From: Matthias Schiffer <mschiffer@universe-factory.net>
Date: Sat, 11 Jan 2014 17:28:18 +0100
Subject: Remove hostapd and mac80211 packages

diff --git a/package/hostapd/Config.in b/package/hostapd/Config.in
deleted file mode 100644
index 810c5a0..0000000
--- a/package/hostapd/Config.in
+++ /dev/null
@@ -1,47 +0,0 @@
-# wpa_supplicant config
-config WPA_SUPPLICANT_NO_TIMESTAMP_CHECK
-	bool "Disable timestamp check"
-	depends PACKAGE_wpa-supplicant || PACKAGE_wpa-supplicant-mini || PACKAGE_wpad || PACKAGE_wpad-mini
-	default n
-	help
-	  This disables the timestamp check for certificates in wpa_supplicant
-	  Useful for devices without RTC that cannot reliably get the real date/time
-
-choice
-	prompt "Choose TLS provider"
-	default WPA_SUPPLICANT_INTERNAL
-	depends PACKAGE_wpa-supplicant || PACKAGE_wpad
-
-config WPA_SUPPLICANT_INTERNAL
-	bool "internal"
-
-config WPA_SUPPLICANT_OPENSSL
-	bool "openssl"
-	select PACKAGE_libopenssl
-
-endchoice
-
-config WPA_RFKILL_SUPPORT
-	bool "Add rfkill support"
-	depends PACKAGE_wpa-supplicant || PACKAGE_wpa-supplicant-mini || PACKAGE_wpad || PACKAGE_wpad-mini
-	default n
-
-config WPA_MSG_MIN_PRIORITY
-	int "Minimum debug message priority"
-	default 3
-	help
-	  Useful values are:
-	    0 = all messages
-		1 = raw message dumps
-		2 = most debugging messages
-		3 = info messages
-		4 = warnings
-		5 = errors
-
-config DRIVER_WEXT_SUPPORT
-	bool
-	default n
-
-config DRIVER_11N_SUPPORT
-	bool
-	default n
diff --git a/package/hostapd/Makefile b/package/hostapd/Makefile
deleted file mode 100644
index 485a8fa..0000000
--- a/package/hostapd/Makefile
+++ /dev/null
@@ -1,346 +0,0 @@
-#
-# Copyright (C) 2006-2012 OpenWrt.org
-#
-# This is free software, licensed under the GNU General Public License v2.
-# See /LICENSE for more information.
-#
-
-include $(TOPDIR)/rules.mk
-
-PKG_NAME:=hostapd
-PKG_VERSION:=20130405
-PKG_RELEASE:=1
-PKG_REV:=f2f66ad7e805218468aa041985dccaf8719c296e
-
-PKG_SOURCE:=$(PKG_NAME)-$(PKG_VERSION).tar.bz2
-PKG_SOURCE_URL:=git://w1.fi/srv/git/hostap.git
-PKG_SOURCE_SUBDIR:=$(PKG_NAME)-$(PKG_VERSION)
-PKG_SOURCE_VERSION:=$(PKG_REV)
-PKG_SOURCE_PROTO:=git
-PKG_MIRROR_MD5SUM:=5dff9bc3b8fbd9ef8a66273d5adee5a3
-
-PKG_MAINTAINER:=Felix Fietkau <nbd@openwrt.org>
-
-PKG_BUILD_PARALLEL:=1
-
-PKG_BUILD_DEPENDS:= \
-	PACKAGE_kmod-madwifi:madwifi \
-
-PKG_CONFIG_DEPENDS:= \
-	CONFIG_WPA_SUPPLICANT_NO_TIMESTAMP_CHECK \
-	CONFIG_PACKAGE_kmod-ath9k \
-	CONFIG_PACKAGE_kmod-mac80211 \
-	CONFIG_PACKAGE_kmod-madwifi \
-	CONFIG_PACKAGE_hostapd \
-	CONFIG_PACKAGE_hostapd-mini \
-	CONFIG_PACKAGE_kmod-hostap \
-	CONFIG_WPA_RFKILL_SUPPORT \
-	CONFIG_DRIVER_WEXT_SUPPORT \
-	CONFIG_DRIVER_11N_SUPPORT
-
-LOCAL_TYPE=$(strip \
-		$(if $(findstring wpad,$(BUILD_VARIANT)),wpad, \
-		$(if $(findstring supplicant,$(BUILD_VARIANT)),supplicant, \
-		hostapd \
-	)))
-LOCAL_VARIANT=$(patsubst wpad-%,%,$(patsubst supplicant-%,%,$(BUILD_VARIANT)))
-
-ifeq ($(LOCAL_TYPE),supplicant)
-  ifeq ($(LOCAL_VARIANT),full)
-    PKG_CONFIG_DEPENDS += \
-		CONFIG_WPA_SUPPLICANT_INTERNAL \
-		CONFIG_WPA_SUPPLICANT_OPENSSL
-  endif
-endif
-
-PKG_BUILD_DIR:=$(BUILD_DIR)/$(PKG_NAME)-$(BUILD_VARIANT)/$(PKG_NAME)-$(PKG_VERSION)
-
-include $(INCLUDE_DIR)/package.mk
-
-STAMP_CONFIGURED:=$(STAMP_CONFIGURED)_$(CONFIG_WPA_MSG_MIN_PRIORITY)
-
-ifneq ($(CONFIG_DRIVER_11N_SUPPORT),)
-  HOSTAPD_IEEE80211N:=y
-endif
-
-DRIVER_MAKEOPTS= \
-	CONFIG_DRIVER_NL80211=$(CONFIG_PACKAGE_kmod-mac80211) \
-	CONFIG_DRIVER_MADWIFI=$(CONFIG_PACKAGE_kmod-madwifi) \
-	CONFIG_DRIVER_HOSTAP=$(CONFIG_PACKAGE_kmod-hostap) \
-	CONFIG_IEEE80211N=$(HOSTAPD_IEEE80211N) \
-	CONFIG_IEEE80211W=$(CONFIG_PACKAGE_kmod-ath9k) \
-	CONFIG_DRIVER_WEXT=$(CONFIG_DRIVER_WEXT_SUPPORT) \
-	$(if $(CONFIG_WPA_RFKILL_SUPPORT),NEED_RFKILL=y)
-
-ifneq ($(LOCAL_TYPE),hostapd)
-  ifdef CONFIG_WPA_SUPPLICANT_OPENSSL
-    ifeq ($(LOCAL_VARIANT),full)
-      DRIVER_MAKEOPTS += CONFIG_TLS=openssl
-      TARGET_LDFLAGS += -lcrypto -lssl
-    endif
-  endif
-  ifdef CONFIG_WPA_SUPPLICANT_NO_TIMESTAMP_CHECK
-    TARGET_CFLAGS += -DNO_TIMESTAMP_CHECK
-  endif
-  DRIVER_MAKEOPTS += \
-	CONFIG_DRIVER_ROBOSWITCH=$(CONFIG_PACKAGE_kmod-switch)
-endif
-
-DRV_DEPENDS:=+PACKAGE_kmod-mac80211:libnl-tiny @(!TARGET_avr32||BROKEN)
-
-define Package/hostapd/Default
-  SECTION:=net
-  CATEGORY:=Network
-  TITLE:=IEEE 802.1x Authenticator
-  URL:=http://hostap.epitest.fi/
-  DEPENDS:=$(DRV_DEPENDS) +libubus
-endef
-
-define Package/hostapd
-$(call Package/hostapd/Default)
-  TITLE+= (full)
-  VARIANT:=full
-endef
-
-define Package/hostapd/description
- This package contains a full featured IEEE 802.1x/WPA/EAP/RADIUS
- Authenticator.
-endef
-
-define Package/hostapd-mini
-$(call Package/hostapd/Default)
-  TITLE+= (WPA-PSK only)
-  VARIANT:=mini
-endef
-
-define Package/hostapd-mini/description
- This package contains a minimal IEEE 802.1x/WPA Authenticator (WPA-PSK only).
-endef
-
-define Package/hostapd-utils
-  $(call Package/hostapd/Default)
-  TITLE+= (utils)
-  DEPENDS:=@PACKAGE_hostapd||PACKAGE_hostapd-mini||PACKAGE_wpad||PACKAGE_wpad-mini
-endef
-
-define Package/hostapd-utils/description
- This package contains a command line utility to control the
- IEEE 802.1x/WPA/EAP/RADIUS Authenticator.
-endef
-
-define Package/wpad/Default
-  SECTION:=net
-  CATEGORY:=Network
-  TITLE:=IEEE 802.1x Authenticator/Supplicant
-  URL:=http://hostap.epitest.fi/
-endef
-
-define Package/wpad
-$(call Package/wpad/Default)
-  TITLE+= (full)
-  DEPENDS:=$(DRV_DEPENDS) +WPA_SUPPLICANT_OPENSSL:libopenssl +libubus
-  VARIANT:=wpad-full
-endef
-
-define Package/wpad/description
- This package contains a full featured IEEE 802.1x/WPA/EAP/RADIUS
- Authenticator and Supplicant
-endef
-
-define Package/wpad-mini
-$(call Package/wpad/Default)
-  TITLE+= (WPA-PSK only)
-  DEPENDS:=$(DRV_DEPENDS) +libubus
-  VARIANT:=wpad-mini
-endef
-
-define Package/wpad-mini/description
- This package contains a minimal IEEE 802.1x/WPA Authenticator and Supplicant (WPA-PSK only).
-endef
-
-define Package/wpa-supplicant
-  SECTION:=net
-  CATEGORY:=Network
-  TITLE:=WPA Supplicant
-  URL:=http://hostap.epitest.fi/wpa_supplicant/
-  DEPENDS:=$(DRV_DEPENDS) +WPA_SUPPLICANT_OPENSSL:libopenssl
-  VARIANT:=supplicant-full
-endef
-
-define Package/wpa-supplicant/Description
-  WPA Supplicant
-endef
-
-define Package/wpa-supplicant/config
-	source "$(SOURCE)/Config.in"
-endef
-
-define Package/wpa-supplicant-mini
-  $(Package/wpa-supplicant)
-  TITLE:=WPA Supplicant (minimal version)
-  DEPENDS:=$(DRV_DEPENDS)
-  VARIANT:=supplicant-mini
-endef
-
-define Package/wpa-supplicant-mini/Description
-  WPA Supplicant (minimal version)
-endef
-
-define Package/wpa-cli
-  SECTION:=net
-  CATEGORY:=Network
-  DEPENDS:=@PACKAGE_wpa-supplicant||PACKAGE_wpad-mini||PACKAGE_wpad
-  TITLE:=WPA Supplicant command line interface
-endef
-
-define Package/wpa-cli/Description
-  WPA Supplicant control utility
-endef
-
-
-ifneq ($(wildcard $(PKG_BUILD_DIR)/.config_*),$(subst .configured_,.config_,$(STAMP_CONFIGURED)))
-  define Build/Configure/rebuild
-	$(FIND) $(PKG_BUILD_DIR) -name \*.o -or -name \*.a | $(XARGS) rm -f
-	rm -f $(PKG_BUILD_DIR)/hostapd/hostapd
-	rm -f $(PKG_BUILD_DIR)/wpa_supplicant/wpa_supplicant
-	rm -f $(PKG_BUILD_DIR)/.config_*
-	touch $(subst .configured_,.config_,$(STAMP_CONFIGURED))
-  endef
-endif
-
-define Build/Configure
-	$(Build/Configure/rebuild)
-	$(CP) ./files/hostapd-$(LOCAL_VARIANT).config $(PKG_BUILD_DIR)/hostapd/.config
-	$(CP) ./files/wpa_supplicant-$(LOCAL_VARIANT).config $(PKG_BUILD_DIR)/wpa_supplicant/.config
-endef
-
-TARGET_CPPFLAGS := \
-	-I$(STAGING_DIR)/usr/include/libnl-tiny \
-	-I$(PKG_BUILD_DIR)/src/crypto \
-	$(TARGET_CPPFLAGS) \
-	-I$(CURDIR)/madwifi \
-	-DCONFIG_LIBNL20 \
-	-D_GNU_SOURCE \
-	$(if $(CONFIG_WPA_MSG_MIN_PRIORITY),-DCONFIG_MSG_MIN_PRIORITY=$(CONFIG_WPA_MSG_MIN_PRIORITY))
-
-TARGET_CFLAGS += -ffunction-sections -fdata-sections
-TARGET_LDFLAGS += -Wl,--gc-sections
-ifeq ($(findstring supplicant,$(BUILD_VARIANT)),)
-  TARGET_LDFLAGS += -lubox -lubus
-endif
-
-ifdef CONFIG_PACKAGE_kmod-mac80211
-  TARGET_LDFLAGS += -lm -lnl-tiny
-endif
-
-define Build/RunMake
-	CFLAGS="$(TARGET_CPPFLAGS) $(TARGET_CFLAGS)" \
-	$(MAKE) $(PKG_JOBS) -C $(PKG_BUILD_DIR)/$(1) \
-		$(TARGET_CONFIGURE_OPTS) \
-		$(DRIVER_MAKEOPTS) \
-		LIBS="$(TARGET_LDFLAGS)" \
-		BCHECK= \
-		$(2)
-endef
-
-define Build/Compile/wpad
-	echo ` \
-		$(call Build/RunMake,hostapd,-s MULTICALL=1 dump_cflags); \
-		$(call Build/RunMake,wpa_supplicant,-s MULTICALL=1 dump_cflags) | \
-		sed -e 's,-n ,,g' -e 's,$(TARGET_CFLAGS),,' \
-	` > $(PKG_BUILD_DIR)/.cflags
-	+$(call Build/RunMake,hostapd, \
-		CFLAGS="$$$$(cat $(PKG_BUILD_DIR)/.cflags)" \
-		MULTICALL=1 \
-		hostapd_cli hostapd_multi.a \
-	)
-	+$(call Build/RunMake,wpa_supplicant, \
-		CFLAGS="$$$$(cat $(PKG_BUILD_DIR)/.cflags)" \
-		MULTICALL=1 \
-		wpa_cli wpa_supplicant_multi.a \
-	)
-	$(TARGET_CC) -o $(PKG_BUILD_DIR)/wpad \
-		$(TARGET_CFLAGS) \
-		./files/multicall.c \
-		$(PKG_BUILD_DIR)/hostapd/hostapd_multi.a \
-		$(PKG_BUILD_DIR)/wpa_supplicant/wpa_supplicant_multi.a \
-		$(TARGET_LDFLAGS)
-endef
-
-define Build/Compile/hostapd
-	$(call Build/RunMake,hostapd, \
-		hostapd hostapd_cli \
-	)
-endef
-
-define Build/Compile/supplicant
-	$(call Build/RunMake,wpa_supplicant, \
-		wpa_cli wpa_supplicant \
-	)
-endef
-
-define Build/Compile
-	$(Build/Compile/$(LOCAL_TYPE))
-endef
-
-define Install/hostapd
-	$(INSTALL_DIR) $(1)/lib/wifi
-	$(INSTALL_DATA) ./files/hostapd.sh $(1)/lib/wifi/hostapd.sh
-	$(INSTALL_DIR) $(1)/usr/sbin
-endef
-
-define Install/supplicant
-	$(INSTALL_DIR) $(1)/lib/wifi
-	$(INSTALL_DATA) ./files/wpa_supplicant.sh $(1)/lib/wifi/wpa_supplicant.sh
-	$(INSTALL_DIR) $(1)/usr/sbin
-endef
-
-define Package/hostapd/install
-	$(call Install/hostapd,$(1))
-	$(INSTALL_BIN) $(PKG_BUILD_DIR)/hostapd/hostapd $(1)/usr/sbin/
-endef
-Package/hostapd-mini/install = $(Package/hostapd/install)
-
-ifneq ($(LOCAL_TYPE),supplicant)
-  define Package/hostapd-utils/install
-	$(INSTALL_DIR) $(1)/usr/sbin $(1)/etc/hotplug.d/button
-	$(INSTALL_BIN) $(PKG_BUILD_DIR)/hostapd/hostapd_cli $(1)/usr/sbin/
-	$(INSTALL_DATA) ./files/wps-hotplug.sh $(1)/etc/hotplug.d/button/50-wps
-	$(if $(CONFIG_PROCD_INIT),
-		$(INSTALL_DIR) $(1)/etc/rc.button/
-		$(INSTALL_BIN) ./files/wps-hotplug.sh $(1)/etc/rc.button/wps,
-		$(INSTALL_DATA) ./files/wps-hotplug.sh $(1)/etc/hotplug.d/button/50-wps
-	)
-  endef
-endif
-
-define Package/wpad/install
-	$(call Install/hostapd,$(1))
-	$(call Install/supplicant,$(1))
-	$(INSTALL_BIN) $(PKG_BUILD_DIR)/wpad $(1)/usr/sbin/
-	ln -sf wpad $(1)/usr/sbin/hostapd
-	ln -sf wpad $(1)/usr/sbin/wpa_supplicant
-endef
-Package/wpad-mini/install = $(Package/wpad/install)
-
-define Package/wpa-supplicant/install
-	$(call Install/supplicant,$(1))
-	$(INSTALL_BIN) $(PKG_BUILD_DIR)/wpa_supplicant/wpa_supplicant $(1)/usr/sbin/
-endef
-Package/wpa-supplicant-mini/install = $(Package/wpa-supplicant/install)
-
-ifneq ($(LOCAL_TYPE),hostapd)
-  define Package/wpa-cli/install
-	$(INSTALL_DIR) $(1)/usr/sbin
-	$(CP) $(PKG_BUILD_DIR)/wpa_supplicant/wpa_cli $(1)/usr/sbin/
-  endef
-endif
-
-$(eval $(call BuildPackage,hostapd))
-$(eval $(call BuildPackage,hostapd-mini))
-$(eval $(call BuildPackage,wpad))
-$(eval $(call BuildPackage,wpad-mini))
-$(eval $(call BuildPackage,wpa-supplicant))
-$(eval $(call BuildPackage,wpa-supplicant-mini))
-$(eval $(call BuildPackage,wpa-cli))
-$(eval $(call BuildPackage,hostapd-utils))
diff --git a/package/hostapd/files/hostapd-full.config b/package/hostapd/files/hostapd-full.config
deleted file mode 100644
index d558736..0000000
--- a/package/hostapd/files/hostapd-full.config
+++ /dev/null
@@ -1,164 +0,0 @@
-# Example hostapd build time configuration
-#
-# This file lists the configuration options that are used when building the
-# hostapd binary. All lines starting with # are ignored. Configuration option
-# lines must be commented out complete, if they are not to be included, i.e.,
-# just setting VARIABLE=n is not disabling that variable.
-#
-# This file is included in Makefile, so variables like CFLAGS and LIBS can also
-# be modified from here. In most cass, these lines should use += in order not
-# to override previous values of the variables.
-
-# Driver interface for Host AP driver
-CONFIG_DRIVER_HOSTAP=y
-
-# Driver interface for wired authenticator
-CONFIG_DRIVER_WIRED=y
-
-# Driver interface for madwifi driver
-CONFIG_DRIVER_MADWIFI=y
-#CFLAGS += -I../../madwifi # change to the madwifi source directory
-
-# Driver interface for Prism54 driver
-#CONFIG_DRIVER_PRISM54=y
-
-# Driver interface for drivers using the nl80211 kernel interface
-CONFIG_DRIVER_NL80211=y
-# driver_nl80211.c requires a rather new libnl (version 1.1) which may not be
-# shipped with your distribution yet. If that is the case, you need to build
-# newer libnl version and point the hostapd build to use it.
-#LIBNL=/usr/src/libnl
-#CFLAGS += -I$(LIBNL)/include
-#LIBS += -L$(LIBNL)/lib
-
-# Driver interface for FreeBSD net80211 layer (e.g., Atheros driver)
-#CONFIG_DRIVER_BSD=y
-#CFLAGS += -I/usr/local/include
-#LIBS += -L/usr/local/lib
-
-# Driver interface for no driver (e.g., RADIUS server only)
-#CONFIG_DRIVER_NONE=y
-
-# IEEE 802.11F/IAPP
-CONFIG_IAPP=y
-
-# WPA2/IEEE 802.11i RSN pre-authentication
-CONFIG_RSN_PREAUTH=y
-
-# PeerKey handshake for Station to Station Link (IEEE 802.11e DLS)
-CONFIG_PEERKEY=y
-
-# IEEE 802.11w (management frame protection)
-# This version is an experimental implementation based on IEEE 802.11w/D1.0
-# draft and is subject to change since the standard has not yet been finalized.
-# Driver support is also needed for IEEE 802.11w.
-#CONFIG_IEEE80211W=y
-
-# Integrated EAP server
-CONFIG_EAP=y
-
-# EAP-MD5 for the integrated EAP server
-CONFIG_EAP_MD5=y
-
-# EAP-TLS for the integrated EAP server
-CONFIG_EAP_TLS=y
-
-# EAP-MSCHAPv2 for the integrated EAP server
-CONFIG_EAP_MSCHAPV2=y
-
-# EAP-PEAP for the integrated EAP server
-CONFIG_EAP_PEAP=y
-
-# EAP-GTC for the integrated EAP server
-CONFIG_EAP_GTC=y
-
-# EAP-TTLS for the integrated EAP server
-CONFIG_EAP_TTLS=y
-
-# EAP-SIM for the integrated EAP server
-#CONFIG_EAP_SIM=y
-
-# EAP-AKA for the integrated EAP server
-#CONFIG_EAP_AKA=y
-
-# EAP-AKA' for the integrated EAP server
-# This requires CONFIG_EAP_AKA to be enabled, too.
-#CONFIG_EAP_AKA_PRIME=y
-
-# EAP-PAX for the integrated EAP server
-#CONFIG_EAP_PAX=y
-
-# EAP-PSK for the integrated EAP server (this is _not_ needed for WPA-PSK)
-#CONFIG_EAP_PSK=y
-
-# EAP-SAKE for the integrated EAP server
-#CONFIG_EAP_SAKE=y
-
-# EAP-GPSK for the integrated EAP server
-#CONFIG_EAP_GPSK=y
-# Include support for optional SHA256 cipher suite in EAP-GPSK
-#CONFIG_EAP_GPSK_SHA256=y
-
-# EAP-FAST for the integrated EAP server
-# Note: Default OpenSSL package does not include support for all the
-# functionality needed for EAP-FAST. If EAP-FAST is enabled with OpenSSL,
-# the OpenSSL library must be patched (openssl-0.9.9-session-ticket.patch)
-# to add the needed functions.
-#CONFIG_EAP_FAST=y
-
-# Wi-Fi Protected Setup (WPS)
-#CONFIG_WPS=y
-# Enable UPnP support for external WPS Registrars
-#CONFIG_WPS_UPNP=y
-
-# EAP-IKEv2
-#CONFIG_EAP_IKEV2=y
-
-# Trusted Network Connect (EAP-TNC)
-#CONFIG_EAP_TNC=y
-
-# PKCS#12 (PFX) support (used to read private key and certificate file from
-# a file that usually has extension .p12 or .pfx)
-CONFIG_PKCS12=y
-
-# RADIUS authentication server. This provides access to the integrated EAP
-# server from external hosts using RADIUS.
-#CONFIG_RADIUS_SERVER=y
-
-# Build IPv6 support for RADIUS operations
-CONFIG_IPV6=y
-
-# IEEE Std 802.11r-2008 (Fast BSS Transition)
-CONFIG_IEEE80211R=y
-
-# Use the hostapd's IEEE 802.11 authentication (ACL), but without
-# the IEEE 802.11 Management capability (e.g., madwifi or FreeBSD/net80211)
-#CONFIG_DRIVER_RADIUS_ACL=y
-
-# IEEE 802.11n (High Throughput) support
-CONFIG_IEEE80211N=y
-
-# Remove debugging code that is printing out debug messages to stdout.
-# This can be used to reduce the size of the hostapd considerably if debugging
-# code is not needed.
-#CONFIG_NO_STDOUT_DEBUG=y
-
-# Remove support for RADIUS accounting
-#CONFIG_NO_ACCOUNTING=y
-
-# Remove support for RADIUS
-#CONFIG_NO_RADIUS=y
-
-# Remove support for VLANs
-#CONFIG_NO_VLAN=y
-
-CONFIG_TLS=internal
-CONFIG_INTERNAL_LIBTOMMATH=y
-CONFIG_INTERNAL_AES=y
-NEED_AES_DEC=y
-
-CONFIG_NO_DUMP_STATE=y
-
-CONFIG_WPS=y
-CONFIG_FULL_DYNAMIC_VLAN=y
-
diff --git a/package/hostapd/files/hostapd-mini.config b/package/hostapd/files/hostapd-mini.config
deleted file mode 100644
index 3e94a64..0000000
--- a/package/hostapd/files/hostapd-mini.config
+++ /dev/null
@@ -1,157 +0,0 @@
-# Example hostapd build time configuration
-#
-# This file lists the configuration options that are used when building the
-# hostapd binary. All lines starting with # are ignored. Configuration option
-# lines must be commented out complete, if they are not to be included, i.e.,
-# just setting VARIABLE=n is not disabling that variable.
-#
-# This file is included in Makefile, so variables like CFLAGS and LIBS can also
-# be modified from here. In most cass, these lines should use += in order not
-# to override previous values of the variables.
-
-# Driver interface for Host AP driver
-CONFIG_DRIVER_HOSTAP=y
-
-# Driver interface for wired authenticator
-CONFIG_DRIVER_WIRED=y
-
-# Driver interface for madwifi driver
-CONFIG_DRIVER_MADWIFI=y
-#CFLAGS += -I../../madwifi # change to the madwifi source directory
-
-# Driver interface for Prism54 driver
-#CONFIG_DRIVER_PRISM54=y
-
-# Driver interface for drivers using the nl80211 kernel interface
-CONFIG_DRIVER_NL80211=y
-# driver_nl80211.c requires a rather new libnl (version 1.1) which may not be
-# shipped with your distribution yet. If that is the case, you need to build
-# newer libnl version and point the hostapd build to use it.
-#LIBNL=/usr/src/libnl
-#CFLAGS += -I$(LIBNL)/include
-#LIBS += -L$(LIBNL)/lib
-
-# Driver interface for FreeBSD net80211 layer (e.g., Atheros driver)
-#CONFIG_DRIVER_BSD=y
-#CFLAGS += -I/usr/local/include
-#LIBS += -L/usr/local/lib
-
-# Driver interface for no driver (e.g., RADIUS server only)
-#CONFIG_DRIVER_NONE=y
-
-# IEEE 802.11F/IAPP
-# CONFIG_IAPP=y
-
-# WPA2/IEEE 802.11i RSN pre-authentication
-CONFIG_RSN_PREAUTH=y
-
-# PeerKey handshake for Station to Station Link (IEEE 802.11e DLS)
-CONFIG_PEERKEY=y
-
-# IEEE 802.11w (management frame protection)
-# This version is an experimental implementation based on IEEE 802.11w/D1.0
-# draft and is subject to change since the standard has not yet been finalized.
-# Driver support is also needed for IEEE 802.11w.
-#CONFIG_IEEE80211W=y
-
-# Integrated EAP server
-#CONFIG_EAP=y
-
-# EAP-MD5 for the integrated EAP server
-#CONFIG_EAP_MD5=y
-
-# EAP-TLS for the integrated EAP server
-#CONFIG_EAP_TLS=y
-
-# EAP-MSCHAPv2 for the integrated EAP server
-#CONFIG_EAP_MSCHAPV2=y
-
-# EAP-PEAP for the integrated EAP server
-#CONFIG_EAP_PEAP=y
-
-# EAP-GTC for the integrated EAP server
-#CONFIG_EAP_GTC=y
-
-# EAP-TTLS for the integrated EAP server
-#CONFIG_EAP_TTLS=y
-
-# EAP-SIM for the integrated EAP server
-#CONFIG_EAP_SIM=y
-
-# EAP-AKA for the integrated EAP server
-#CONFIG_EAP_AKA=y
-
-# EAP-AKA' for the integrated EAP server
-# This requires CONFIG_EAP_AKA to be enabled, too.
-#CONFIG_EAP_AKA_PRIME=y
-
-# EAP-PAX for the integrated EAP server
-#CONFIG_EAP_PAX=y
-
-# EAP-PSK for the integrated EAP server (this is _not_ needed for WPA-PSK)
-#CONFIG_EAP_PSK=y
-
-# EAP-SAKE for the integrated EAP server
-#CONFIG_EAP_SAKE=y
-
-# EAP-GPSK for the integrated EAP server
-#CONFIG_EAP_GPSK=y
-# Include support for optional SHA256 cipher suite in EAP-GPSK
-#CONFIG_EAP_GPSK_SHA256=y
-
-# EAP-FAST for the integrated EAP server
-# Note: Default OpenSSL package does not include support for all the
-# functionality needed for EAP-FAST. If EAP-FAST is enabled with OpenSSL,
-# the OpenSSL library must be patched (openssl-0.9.9-session-ticket.patch)
-# to add the needed functions.
-#CONFIG_EAP_FAST=y
-
-# Wi-Fi Protected Setup (WPS)
-#CONFIG_WPS=y
-# Enable UPnP support for external WPS Registrars
-#CONFIG_WPS_UPNP=y
-
-# EAP-IKEv2
-#CONFIG_EAP_IKEV2=y
-
-# Trusted Network Connect (EAP-TNC)
-#CONFIG_EAP_TNC=y
-
-# PKCS#12 (PFX) support (used to read private key and certificate file from
-# a file that usually has extension .p12 or .pfx)
-#CONFIG_PKCS12=y
-
-# RADIUS authentication server. This provides access to the integrated EAP
-# server from external hosts using RADIUS.
-#CONFIG_RADIUS_SERVER=y
-
-# Build IPv6 support for RADIUS operations
-#CONFIG_IPV6=y
-
-# IEEE Std 802.11r-2008 (Fast BSS Transition)
-#CONFIG_IEEE80211R=y
-
-# Use the hostapd's IEEE 802.11 authentication (ACL), but without
-# the IEEE 802.11 Management capability (e.g., madwifi or FreeBSD/net80211)
-#CONFIG_DRIVER_RADIUS_ACL=y
-
-# IEEE 802.11n (High Throughput) support
-CONFIG_IEEE80211N=y
-
-# Remove debugging code that is printing out debug messages to stdout.
-# This can be used to reduce the size of the hostapd considerably if debugging
-# code is not needed.
-#CONFIG_NO_STDOUT_DEBUG=y
-
-# Remove support for RADIUS accounting
-CONFIG_NO_ACCOUNTING=y
-
-# Remove support for RADIUS
-CONFIG_NO_RADIUS=y
-
-# Remove support for VLANs
-#CONFIG_NO_VLAN=y
-
-CONFIG_TLS=internal
-
-CONFIG_NO_DUMP_STATE=y
diff --git a/package/hostapd/files/hostapd.sh b/package/hostapd/files/hostapd.sh
deleted file mode 100644
index 00c6a09..0000000
--- a/package/hostapd/files/hostapd.sh
+++ /dev/null
@@ -1,301 +0,0 @@
-hostapd_set_bss_options() {
-	local var="$1"
-	local vif="$2"
-	local enc wep_rekey wpa_group_rekey wpa_pair_rekey wpa_master_rekey wps_possible
-
-	config_get enc "$vif" encryption
-	config_get wep_rekey        "$vif" wep_rekey        # 300
-	config_get wpa_group_rekey  "$vif" wpa_group_rekey  # 300
-	config_get wpa_pair_rekey   "$vif" wpa_pair_rekey   # 300
-	config_get wpa_master_rekey "$vif" wpa_master_rekey # 640
-	config_get_bool ap_isolate "$vif" isolate 0
-	config_get_bool disassoc_low_ack "$vif" disassoc_low_ack 1
-	config_get max_num_sta "$vif" max_num_sta 0
-	config_get max_inactivity "$vif" max_inactivity 0
-	config_get_bool preamble "$vif" short_preamble 1
-
-	config_get device "$vif" device
-	config_get hwmode "$device" hwmode
-	config_get phy "$device" phy
-
-	append "$var" "ctrl_interface=/var/run/hostapd-$phy" "$N"
-
-	if [ "$ap_isolate" -gt 0 ]; then
-		append "$var" "ap_isolate=$ap_isolate" "$N"
-	fi
-	if [ "$max_num_sta" -gt 0 ]; then
-		append "$var" "max_num_sta=$max_num_sta" "$N"
-	fi
-	if [ "$max_inactivity" -gt 0 ]; then
-		append "$var" "ap_max_inactivity=$max_inactivity" "$N"
-	fi
-	append "$var" "disassoc_low_ack=$disassoc_low_ack" "$N"
-	if [ "$preamble" -gt 0 ]; then
-		append "$var" "preamble=$preamble" "$N"
-	fi
-
-	# Examples:
-	# psk-mixed/tkip 	=> WPA1+2 PSK, TKIP
-	# wpa-psk2/tkip+aes	=> WPA2 PSK, CCMP+TKIP
-	# wpa2/tkip+aes 	=> WPA2 RADIUS, CCMP+TKIP
-	# ...
-
-	# TODO: move this parsing function somewhere generic, so that
-	# later it can be reused by drivers that don't use hostapd
-
-	# crypto defaults: WPA2 vs WPA1
-	case "$enc" in
-		wpa2*|*psk2*)
-			wpa=2
-			crypto="CCMP"
-		;;
-		*mixed*)
-			wpa=3
-			crypto="CCMP TKIP"
-		;;
-		*)
-			wpa=1
-			crypto="TKIP"
-		;;
-	esac
-
-	# explicit override for crypto setting
-	case "$enc" in
-		*tkip+aes|*tkip+ccmp|*aes+tkip|*ccmp+tkip) crypto="CCMP TKIP";;
-		*aes|*ccmp) crypto="CCMP";;
-		*tkip) crypto="TKIP";;
-	esac
-
-	# enforce CCMP for 11ng and 11na
-	case "$hwmode:$crypto" in
-		*ng:TKIP|*na:TKIP) crypto="CCMP TKIP";;
-	esac
-
-	# use crypto/auth settings for building the hostapd config
-	case "$enc" in
-		*psk*)
-			config_get psk "$vif" key
-			if [ ${#psk} -eq 64 ]; then
-				append "$var" "wpa_psk=$psk" "$N"
-			else
-				append "$var" "wpa_passphrase=$psk" "$N"
-			fi
-			wps_possible=1
-			[ -n "$wpa_group_rekey"  ] && append "$var" "wpa_group_rekey=$wpa_group_rekey" "$N"
-			[ -n "$wpa_pair_rekey"   ] && append "$var" "wpa_ptk_rekey=$wpa_pair_rekey"    "$N"
-			[ -n "$wpa_master_rekey" ] && append "$var" "wpa_gmk_rekey=$wpa_master_rekey"  "$N"
-		;;
-		*wpa*)
-			# required fields? formats?
-			# hostapd is particular, maybe a default configuration for failures
-			config_get auth_server "$vif" auth_server
-			[ -z "$auth_server" ] && config_get auth_server "$vif" server
-			append "$var" "auth_server_addr=$auth_server" "$N"
-			config_get auth_port "$vif" auth_port
-			[ -z "$auth_port" ] && config_get auth_port "$vif" port
-			auth_port=${auth_port:-1812}
-			append "$var" "auth_server_port=$auth_port" "$N"
-			config_get auth_secret "$vif" auth_secret
-			[ -z "$auth_secret" ] && config_get auth_secret "$vif" key
-			append "$var" "auth_server_shared_secret=$auth_secret" "$N"
-			config_get_bool auth_cache "$vif" auth_cache 0
-			[ "$auth_cache" -gt 0 ] || append "$var" "disable_pmksa_caching=1" "$N"
-			[ "$auth_cache" -gt 0 ] || append "$var" "okc=0" "$N"
-			config_get acct_server "$vif" acct_server
-			[ -n "$acct_server" ] && append "$var" "acct_server_addr=$acct_server" "$N"
-			config_get acct_port "$vif" acct_port
-			[ -n "$acct_port" ] && acct_port=${acct_port:-1813}
-			[ -n "$acct_port" ] && append "$var" "acct_server_port=$acct_port" "$N"
-			config_get acct_secret "$vif" acct_secret
-			[ -n "$acct_secret" ] && append "$var" "acct_server_shared_secret=$acct_secret" "$N"
-			config_get nasid "$vif" nasid
-			append "$var" "nas_identifier=$nasid" "$N"
-			append "$var" "eapol_key_index_workaround=1" "$N"
-			append "$var" "ieee8021x=1" "$N"
-			append "$var" "wpa_key_mgmt=WPA-EAP" "$N"
-			[ -n "$wpa_group_rekey"  ] && append "$var" "wpa_group_rekey=$wpa_group_rekey" "$N"
-			[ -n "$wpa_pair_rekey"   ] && append "$var" "wpa_ptk_rekey=$wpa_pair_rekey"    "$N"
-			[ -n "$wpa_master_rekey" ] && append "$var" "wpa_gmk_rekey=$wpa_master_rekey"  "$N"
-		;;
-		*wep*)
-			config_get key "$vif" key
-			key="${key:-1}"
-			case "$key" in
-				[1234])
-					for idx in 1 2 3 4; do
-						local zidx
-						zidx=$(($idx - 1))
-						config_get ckey "$vif" "key${idx}"
-						[ -n "$ckey" ] && \
-							append "$var" "wep_key${zidx}=$(prepare_key_wep "$ckey")" "$N"
-					done
-					append "$var" "wep_default_key=$((key - 1))"  "$N"
-				;;
-				*)
-					append "$var" "wep_key0=$(prepare_key_wep "$key")" "$N"
-					append "$var" "wep_default_key=0" "$N"
-					[ -n "$wep_rekey" ] && append "$var" "wep_rekey_period=$wep_rekey" "$N"
-				;;
-			esac
-			case "$enc" in
-				*shared*)
-					auth_algs=2
-				;;
-				*mixed*)
-					auth_algs=3
-				;;
-			esac
-			wpa=0
-			crypto=
-		;;
-		*)
-			wpa=0
-			crypto=
-		;;
-	esac
-	append "$var" "auth_algs=${auth_algs:-1}" "$N"
-	append "$var" "wpa=$wpa" "$N"
-	[ -n "$crypto" ] && append "$var" "wpa_pairwise=$crypto" "$N"
-	[ -n "$wpa_group_rekey" ] && append "$var" "wpa_group_rekey=$wpa_group_rekey" "$N"
-
-	config_get ssid "$vif" ssid
-	config_get bridge "$vif" bridge
-	config_get ieee80211d "$vif" ieee80211d
-	config_get iapp_interface "$vif" iapp_interface
-
-	config_get_bool wps_pbc "$vif" wps_pushbutton 0
-	config_get_bool wps_label "$vif" wps_label 0
-
-	config_get config_methods "$vif" wps_config
-	[ "$wps_pbc" -gt 0 ] && append config_methods push_button
-
-	[ -n "$wps_possible" -a -n "$config_methods" ] && {
-		config_get device_type "$vif" wps_device_type "6-0050F204-1"
-		config_get device_name "$vif" wps_device_name "OpenWrt AP"
-		config_get manufacturer "$vif" wps_manufacturer "openwrt.org"
-
-		append "$var" "eap_server=1" "$N"
-		append "$var" "wps_state=2" "$N"
-		append "$var" "ap_setup_locked=1" "$N"
-		append "$var" "device_type=$device_type" "$N"
-		append "$var" "device_name=$device_name" "$N"
-		append "$var" "manufacturer=$manufacturer" "$N"
-		append "$var" "config_methods=$config_methods" "$N"
-	}
-
-	append "$var" "ssid=$ssid" "$N"
-	[ -n "$bridge" ] && append "$var" "bridge=$bridge" "$N"
-	[ -n "$ieee80211d" ] && append "$var" "ieee80211d=$ieee80211d" "$N"
-	[ -n "$iapp_interface" ] && append "$var" iapp_interface=$(uci_get_state network "$iapp_interface" ifname "$iapp_interface") "$N"
-
-	if [ "$wpa" -ge "2" ]
-	then
-		# RSN -> allow preauthentication
-		config_get_bool rsn_preauth "$vif" rsn_preauth "$auth_cache"
-		if [ -n "$bridge" -a "$rsn_preauth" = 1 ]
-		then
-			append "$var" "rsn_preauth=1" "$N"
-			append "$var" "rsn_preauth_interfaces=$bridge" "$N"
-		fi
-
-		# RSN -> allow management frame protection
-		config_get ieee80211w "$vif" ieee80211w
-		case "$ieee80211w" in
-			[012])
-				append "$var" "ieee80211w=$ieee80211w" "$N"
-				[ "$ieee80211w" -gt "0" ] && {
-					config_get ieee80211w_max_timeout "$vif" ieee80211w_max_timeout
-					config_get ieee80211w_retry_timeout "$vif" ieee80211w_retry_timeout
-					[ -n "$ieee80211w_max_timeout" ] && \
-						append "$var" "assoc_sa_query_max_timeout=$ieee80211w_max_timeout" "$N"
-					[ -n "$ieee80211w_retry_timeout" ] && \
-						append "$var" "assoc_sa_query_retry_timeout=$ieee80211w_retry_timeout" "$N"
-				}
-			;;
-		esac
-	fi
-
-	config_get macfilter "$vif" macfilter
-	macfile="/var/run/hostapd-$ifname.maclist"
-	[ -e "$macfile" ] && rm -f "$macfile"
-
-	case "$macfilter" in
-		allow)
-			append "$var" "macaddr_acl=1" "$N"
-			append "$var" "accept_mac_file=$macfile" "$N"
-			;;
-		deny)
-			append "$var" "macaddr_acl=0" "$N"
-			append "$var" "deny_mac_file=$macfile" "$N"
-			;;
-	esac
-	config_get maclist "$vif" maclist
-	[ -n "$maclist" ] && {
-		for mac in $maclist; do
-			echo "$mac" >> $macfile
-		done
-	}
-}
-
-hostapd_set_log_options() {
-	local var="$1"
-	local cfg="$2"
-	local log_level log_80211 log_8021x log_radius log_wpa log_driver log_iapp log_mlme
-
-	config_get log_level "$cfg" log_level 2
-
-	config_get_bool log_80211  "$cfg" log_80211  1
-	config_get_bool log_8021x  "$cfg" log_8021x  1
-	config_get_bool log_radius "$cfg" log_radius 1
-	config_get_bool log_wpa    "$cfg" log_wpa    1
-	config_get_bool log_driver "$cfg" log_driver 1
-	config_get_bool log_iapp   "$cfg" log_iapp   1
-	config_get_bool log_mlme   "$cfg" log_mlme   1
-
-	local log_mask=$((       \
-		($log_80211  << 0) | \
-		($log_8021x  << 1) | \
-		($log_radius << 2) | \
-		($log_wpa    << 3) | \
-		($log_driver << 4) | \
-		($log_iapp   << 5) | \
-		($log_mlme   << 6)   \
-	))
-
-	append "$var" "logger_syslog=$log_mask" "$N"
-	append "$var" "logger_syslog_level=$log_level" "$N"
-	append "$var" "logger_stdout=$log_mask" "$N"
-	append "$var" "logger_stdout_level=$log_level" "$N"
-}
-
-hostapd_setup_vif() {
-	local vif="$1"
-	local driver="$2"
-	local ifname device channel hwmode
-
-	hostapd_cfg=
-
-	config_get ifname "$vif" ifname
-	config_get device "$vif" device
-	config_get channel "$device" channel
-	config_get hwmode "$device" hwmode
-
-	hostapd_set_log_options hostapd_cfg "$device"
-	hostapd_set_bss_options hostapd_cfg "$vif"
-
-	case "$hwmode" in
-		*bg|*gdt|*gst|*fh) hwmode=g;;
-		*adt|*ast) hwmode=a;;
-	esac
-	[ "$channel" = auto ] && channel=
-	[ -n "$channel" -a -z "$hwmode" ] && wifi_fixup_hwmode "$device"
-	cat > /var/run/hostapd-$ifname.conf <<EOF
-driver=$driver
-interface=$ifname
-${hwmode:+hw_mode=${hwmode#11}}
-${channel:+channel=$channel}
-$hostapd_cfg
-EOF
-	hostapd -P /var/run/wifi-$ifname.pid -B /var/run/hostapd-$ifname.conf
-}
-
diff --git a/package/hostapd/files/multicall.c b/package/hostapd/files/multicall.c
deleted file mode 100644
index c8e814b..0000000
--- a/package/hostapd/files/multicall.c
+++ /dev/null
@@ -1,28 +0,0 @@
-#include <stdio.h>
-#include <string.h>
-#include <stdbool.h>
-
-extern int hostapd_main(int argc, char **argv);
-extern int wpa_supplicant_main(int argc, char **argv);
-
-int main(int argc, char **argv)
-{
-	bool restart = false;
-	const char *prog = argv[0];
-
-restart:
-	if (strstr(argv[0], "hostapd"))
-		return hostapd_main(argc, argv);
-	else if (strstr(argv[0], "wpa_supplicant"))
-		return wpa_supplicant_main(argc, argv);
-
-	if (!restart && argc > 1) {
-		argv++;
-		argc--;
-		restart = true;
-		goto restart;
-	}
-
-	fprintf(stderr, "Invalid command.\nUsage: %s wpa_supplicant|hostapd [<arguments>]\n", prog);
-	return 255;
-}
diff --git a/package/hostapd/files/wpa_supplicant-full.config b/package/hostapd/files/wpa_supplicant-full.config
deleted file mode 100644
index f5abbad..0000000
--- a/package/hostapd/files/wpa_supplicant-full.config
+++ /dev/null
@@ -1,408 +0,0 @@
-# Example wpa_supplicant build time configuration
-#
-# This file lists the configuration options that are used when building the
-# hostapd binary. All lines starting with # are ignored. Configuration option
-# lines must be commented out complete, if they are not to be included, i.e.,
-# just setting VARIABLE=n is not disabling that variable.
-#
-# This file is included in Makefile, so variables like CFLAGS and LIBS can also
-# be modified from here. In most cases, these lines should use += in order not
-# to override previous values of the variables.
-
-
-# Uncomment following two lines and fix the paths if you have installed OpenSSL
-# or GnuTLS in non-default location
-#CFLAGS += -I/usr/local/openssl/include
-#LIBS += -L/usr/local/openssl/lib
-
-# Some Red Hat versions seem to include kerberos header files from OpenSSL, but
-# the kerberos files are not in the default include path. Following line can be
-# used to fix build issues on such systems (krb5.h not found).
-#CFLAGS += -I/usr/include/kerberos
-
-# Example configuration for various cross-compilation platforms
-
-#### sveasoft (e.g., for Linksys WRT54G) ######################################
-#CC=mipsel-uclibc-gcc
-#CC=/opt/brcm/hndtools-mipsel-uclibc/bin/mipsel-uclibc-gcc
-#CFLAGS += -Os
-#CPPFLAGS += -I../src/include -I../../src/router/openssl/include
-#LIBS += -L/opt/brcm/hndtools-mipsel-uclibc-0.9.19/lib -lssl
-###############################################################################
-
-#### openwrt (e.g., for Linksys WRT54G) #######################################
-#CC=mipsel-uclibc-gcc
-#CC=/opt/brcm/hndtools-mipsel-uclibc/bin/mipsel-uclibc-gcc
-#CFLAGS += -Os
-#CPPFLAGS=-I../src/include -I../openssl-0.9.7d/include \
-#	-I../WRT54GS/release/src/include
-#LIBS = -lssl
-###############################################################################
-
-
-# Driver interface for Host AP driver
-CONFIG_DRIVER_HOSTAP=y
-
-# Driver interface for Agere driver
-#CONFIG_DRIVER_HERMES=y
-# Change include directories to match with the local setup
-#CFLAGS += -I../../hcf -I../../include -I../../include/hcf
-#CFLAGS += -I../../include/wireless
-
-# Driver interface for madwifi driver
-# Deprecated; use CONFIG_DRIVER_WEXT=y instead.
-#CONFIG_DRIVER_MADWIFI=y
-# Set include directory to the madwifi source tree
-#CFLAGS += -I../../madwifi
-
-# Driver interface for ndiswrapper
-# Deprecated; use CONFIG_DRIVER_WEXT=y instead.
-#CONFIG_DRIVER_NDISWRAPPER=y
-
-# Driver interface for Atmel driver
-# CONFIG_DRIVER_ATMEL=y
-
-# Driver interface for old Broadcom driver
-# Please note that the newer Broadcom driver ("hybrid Linux driver") supports
-# Linux wireless extensions and does not need (or even work) with the old
-# driver wrapper. Use CONFIG_DRIVER_WEXT=y with that driver.
-#CONFIG_DRIVER_BROADCOM=y
-# Example path for wlioctl.h; change to match your configuration
-#CFLAGS += -I/opt/WRT54GS/release/src/include
-
-# Driver interface for Intel ipw2100/2200 driver
-# Deprecated; use CONFIG_DRIVER_WEXT=y instead.
-#CONFIG_DRIVER_IPW=y
-
-# Driver interface for Ralink driver
-#CONFIG_DRIVER_RALINK=y
-
-# Driver interface for generic Linux wireless extensions
-CONFIG_DRIVER_WEXT=y
-
-# Driver interface for Linux drivers using the nl80211 kernel interface
-CONFIG_DRIVER_NL80211=y
-
-# Driver interface for FreeBSD net80211 layer (e.g., Atheros driver)
-#CONFIG_DRIVER_BSD=y
-#CFLAGS += -I/usr/local/include
-#LIBS += -L/usr/local/lib
-#LIBS_p += -L/usr/local/lib
-#LIBS_c += -L/usr/local/lib
-
-# Driver interface for Windows NDIS
-#CONFIG_DRIVER_NDIS=y
-#CFLAGS += -I/usr/include/w32api/ddk
-#LIBS += -L/usr/local/lib
-# For native build using mingw
-#CONFIG_NATIVE_WINDOWS=y
-# Additional directories for cross-compilation on Linux host for mingw target
-#CFLAGS += -I/opt/mingw/mingw32/include/ddk
-#LIBS += -L/opt/mingw/mingw32/lib
-#CC=mingw32-gcc
-# By default, driver_ndis uses WinPcap for low-level operations. This can be
-# replaced with the following option which replaces WinPcap calls with NDISUIO.
-# However, this requires that WZC is disabled (net stop wzcsvc) before starting
-# wpa_supplicant.
-# CONFIG_USE_NDISUIO=y
-
-# Driver interface for development testing
-#CONFIG_DRIVER_TEST=y
-
-# Include client MLME (management frame processing) for test driver
-# This can be used to test MLME operations in hostapd with the test interface.
-# space.
-#CONFIG_CLIENT_MLME=y
-
-# Driver interface for wired Ethernet drivers
-CONFIG_DRIVER_WIRED=y
-
-# Driver interface for the Broadcom RoboSwitch family
-#CONFIG_DRIVER_ROBOSWITCH=y
-
-# Driver interface for no driver (e.g., WPS ER only)
-#CONFIG_DRIVER_NONE=y
-
-# Enable IEEE 802.1X Supplicant (automatically included if any EAP method is
-# included)
-CONFIG_IEEE8021X_EAPOL=y
-
-# EAP-MD5
-CONFIG_EAP_MD5=y
-
-# EAP-MSCHAPv2
-CONFIG_EAP_MSCHAPV2=y
-
-# EAP-TLS
-CONFIG_EAP_TLS=y
-
-# EAL-PEAP
-CONFIG_EAP_PEAP=y
-
-# EAP-TTLS
-CONFIG_EAP_TTLS=y
-
-# EAP-FAST
-# Note: Default OpenSSL package does not include support for all the
-# functionality needed for EAP-FAST. If EAP-FAST is enabled with OpenSSL,
-# the OpenSSL library must be patched (openssl-0.9.8d-tls-extensions.patch)
-# to add the needed functions.
-#CONFIG_EAP_FAST=y
-
-# EAP-GTC
-CONFIG_EAP_GTC=y
-
-# EAP-OTP
-CONFIG_EAP_OTP=y
-
-# EAP-SIM (enable CONFIG_PCSC, if EAP-SIM is used)
-#CONFIG_EAP_SIM=y
-
-# EAP-PSK (experimental; this is _not_ needed for WPA-PSK)
-#CONFIG_EAP_PSK=y
-
-# EAP-PAX
-#CONFIG_EAP_PAX=y
-
-# LEAP
-CONFIG_EAP_LEAP=y
-
-# EAP-AKA (enable CONFIG_PCSC, if EAP-AKA is used)
-#CONFIG_EAP_AKA=y
-
-# EAP-AKA' (enable CONFIG_PCSC, if EAP-AKA' is used).
-# This requires CONFIG_EAP_AKA to be enabled, too.
-#CONFIG_EAP_AKA_PRIME=y
-
-# Enable USIM simulator (Milenage) for EAP-AKA
-#CONFIG_USIM_SIMULATOR=y
-
-# EAP-SAKE
-#CONFIG_EAP_SAKE=y
-
-# EAP-GPSK
-#CONFIG_EAP_GPSK=y
-# Include support for optional SHA256 cipher suite in EAP-GPSK
-#CONFIG_EAP_GPSK_SHA256=y
-
-# EAP-TNC and related Trusted Network Connect support (experimental)
-#CONFIG_EAP_TNC=y
-
-# Wi-Fi Protected Setup (WPS)
-CONFIG_WPS=y
-
-# EAP-IKEv2
-#CONFIG_EAP_IKEV2=y
-
-# PKCS#12 (PFX) support (used to read private key and certificate file from
-# a file that usually has extension .p12 or .pfx)
-CONFIG_PKCS12=y
-
-# Smartcard support (i.e., private key on a smartcard), e.g., with openssl
-# engine.
-CONFIG_SMARTCARD=y
-
-# PC/SC interface for smartcards (USIM, GSM SIM)
-# Enable this if EAP-SIM or EAP-AKA is included
-#CONFIG_PCSC=y
-
-# Development testing
-#CONFIG_EAPOL_TEST=y
-
-# Select control interface backend for external programs, e.g, wpa_cli:
-# unix = UNIX domain sockets (default for Linux/*BSD)
-# udp = UDP sockets using localhost (127.0.0.1)
-# named_pipe = Windows Named Pipe (default for Windows)
-# y = use default (backwards compatibility)
-# If this option is commented out, control interface is not included in the
-# build.
-CONFIG_CTRL_IFACE=y
-
-# Include support for GNU Readline and History Libraries in wpa_cli.
-# When building a wpa_cli binary for distribution, please note that these
-# libraries are licensed under GPL and as such, BSD license may not apply for
-# the resulting binary.
-#CONFIG_READLINE=y
-
-# Remove debugging code that is printing out debug message to stdout.
-# This can be used to reduce the size of the wpa_supplicant considerably
-# if debugging code is not needed. The size reduction can be around 35%
-# (e.g., 90 kB).
-#CONFIG_NO_STDOUT_DEBUG=y
-
-# Remove WPA support, e.g., for wired-only IEEE 802.1X supplicant, to save
-# 35-50 kB in code size.
-#CONFIG_NO_WPA=y
-
-# Remove WPA2 support. This allows WPA to be used, but removes WPA2 code to
-# save about 1 kB in code size when building only WPA-Personal (no EAP support)
-# or 6 kB if building for WPA-Enterprise.
-#CONFIG_NO_WPA2=y
-
-# Remove IEEE 802.11i/WPA-Personal ASCII passphrase support
-# This option can be used to reduce code size by removing support for
-# converting ASCII passphrases into PSK. If this functionality is removed, the
-# PSK can only be configured as the 64-octet hexstring (e.g., from
-# wpa_passphrase). This saves about 0.5 kB in code size.
-#CONFIG_NO_WPA_PASSPHRASE=y
-
-# Disable scan result processing (ap_mode=1) to save code size by about 1 kB.
-# This can be used if ap_scan=1 mode is never enabled.
-#CONFIG_NO_SCAN_PROCESSING=y
-
-# Select configuration backend:
-# file = text file (e.g., wpa_supplicant.conf; note: the configuration file
-#	path is given on command line, not here; this option is just used to
-#	select the backend that allows configuration files to be used)
-# winreg = Windows registry (see win_example.reg for an example)
-CONFIG_BACKEND=file
-
-# Remove configuration write functionality (i.e., to allow the configuration
-# file to be updated based on runtime configuration changes). The runtime
-# configuration can still be changed, the changes are just not going to be
-# persistent over restarts. This option can be used to reduce code size by
-# about 3.5 kB.
-#CONFIG_NO_CONFIG_WRITE=y
-
-# Remove support for configuration blobs to reduce code size by about 1.5 kB.
-#CONFIG_NO_CONFIG_BLOBS=y
-
-# Select program entry point implementation:
-# main = UNIX/POSIX like main() function (default)
-# main_winsvc = Windows service (read parameters from registry)
-# main_none = Very basic example (development use only)
-#CONFIG_MAIN=main
-
-# Select wrapper for operatins system and C library specific functions
-# unix = UNIX/POSIX like systems (default)
-# win32 = Windows systems
-# none = Empty template
-#CONFIG_OS=unix
-
-# Select event loop implementation
-# eloop = select() loop (default)
-# eloop_win = Windows events and WaitForMultipleObject() loop
-# eloop_none = Empty template
-#CONFIG_ELOOP=eloop
-
-# Select layer 2 packet implementation
-# linux = Linux packet socket (default)
-# pcap = libpcap/libdnet/WinPcap
-# freebsd = FreeBSD libpcap
-# winpcap = WinPcap with receive thread
-# ndis = Windows NDISUIO (note: requires CONFIG_USE_NDISUIO=y)
-# none = Empty template
-#CONFIG_L2_PACKET=linux
-
-# PeerKey handshake for Station to Station Link (IEEE 802.11e DLS)
-CONFIG_PEERKEY=y
-
-# IEEE 802.11w (management frame protection)
-# This version is an experimental implementation based on IEEE 802.11w/D1.0
-# draft and is subject to change since the standard has not yet been finalized.
-# Driver support is also needed for IEEE 802.11w.
-CONFIG_IEEE80211W=y
-
-# Select TLS implementation
-# openssl = OpenSSL (default)
-# gnutls = GnuTLS (needed for TLS/IA, see also CONFIG_GNUTLS_EXTRA)
-# internal = Internal TLSv1 implementation (experimental)
-# none = Empty template
-CONFIG_TLS=internal
-
-# Whether to enable TLS/IA support, which is required for EAP-TTLSv1.
-# You need CONFIG_TLS=gnutls for this to have any effect. Please note that
-# even though the core GnuTLS library is released under LGPL, this extra
-# library uses GPL and as such, the terms of GPL apply to the combination
-# of wpa_supplicant and GnuTLS if this option is enabled. BSD license may not
-# apply for distribution of the resulting binary.
-#CONFIG_GNUTLS_EXTRA=y
-
-# If CONFIG_TLS=internal is used, additional library and include paths are
-# needed for LibTomMath. Alternatively, an integrated, minimal version of
-# LibTomMath can be used. See beginning of libtommath.c for details on benefits
-# and drawbacks of this option.
-CONFIG_INTERNAL_LIBTOMMATH=y
-#ifndef CONFIG_INTERNAL_LIBTOMMATH
-#LTM_PATH=/usr/src/libtommath-0.39
-#CFLAGS += -I$(LTM_PATH)
-#LIBS += -L$(LTM_PATH)
-#LIBS_p += -L$(LTM_PATH)
-#endif
-# At the cost of about 4 kB of additional binary size, the internal LibTomMath
-# can be configured to include faster routines for exptmod, sqr, and div to
-# speed up DH and RSA calculation considerably
-CONFIG_INTERNAL_LIBTOMMATH_FAST=y
-
-# Include NDIS event processing through WMI into wpa_supplicant/wpasvc.
-# This is only for Windows builds and requires WMI-related header files and
-# WbemUuid.Lib from Platform SDK even when building with MinGW.
-#CONFIG_NDIS_EVENTS_INTEGRATED=y
-#PLATFORMSDKLIB="/opt/Program Files/Microsoft Platform SDK/Lib"
-
-# Add support for old DBus control interface
-# (fi.epitest.hostap.WPASupplicant)
-#CONFIG_CTRL_IFACE_DBUS=y
-
-# Add support for new DBus control interface
-# (fi.w1.hostap.wpa_supplicant1)
-#CONFIG_CTRL_IFACE_DBUS_NEW=y
-
-# Add introspection support for new DBus control interface
-#CONFIG_CTRL_IFACE_DBUS_INTRO=y
-
-# Add support for loading EAP methods dynamically as shared libraries.
-# When this option is enabled, each EAP method can be either included
-# statically (CONFIG_EAP_<method>=y) or dynamically (CONFIG_EAP_<method>=dyn).
-# Dynamic EAP methods are build as shared objects (eap_*.so) and they need to
-# be loaded in the beginning of the wpa_supplicant configuration file
-# (see load_dynamic_eap parameter in the example file) before being used in
-# the network blocks.
-#
-# Note that some shared parts of EAP methods are included in the main program
-# and in order to be able to use dynamic EAP methods using these parts, the
-# main program must have been build with the EAP method enabled (=y or =dyn).
-# This means that EAP-TLS/PEAP/TTLS/FAST cannot be added as dynamic libraries
-# unless at least one of them was included in the main build to force inclusion
-# of the shared code. Similarly, at least one of EAP-SIM/AKA must be included
-# in the main build to be able to load these methods dynamically.
-#
-# Please also note that using dynamic libraries will increase the total binary
-# size. Thus, it may not be the best option for targets that have limited
-# amount of memory/flash.
-#CONFIG_DYNAMIC_EAP_METHODS=y
-
-# IEEE Std 802.11r-2008 (Fast BSS Transition)
-#CONFIG_IEEE80211R=y
-
-# Add support for writing debug log to a file (/tmp/wpa_supplicant-log-#.txt)
-#CONFIG_DEBUG_FILE=y
-
-# Enable privilege separation (see README 'Privilege separation' for details)
-#CONFIG_PRIVSEP=y
-
-# Enable mitigation against certain attacks against TKIP by delaying Michael
-# MIC error reports by a random amount of time between 0 and 60 seconds
-#CONFIG_DELAYED_MIC_ERROR_REPORT=y
-
-# Enable tracing code for developer debugging
-# This tracks use of memory allocations and other registrations and reports
-# incorrect use with a backtrace of call (or allocation) location.
-#CONFIG_WPA_TRACE=y
-# For BSD, comment out these.
-#LIBS += -lexecinfo
-#LIBS_p += -lexecinfo
-#LIBS_c += -lexecinfo
-
-# Use libbfd to get more details for developer debugging
-# This enables use of libbfd to get more detailed symbols for the backtraces
-# generated by CONFIG_WPA_TRACE=y.
-#CONFIG_WPA_TRACE_BFD=y
-# For BSD, comment out these.
-#LIBS += -lbfd -liberty -lz
-#LIBS_p += -lbfd -liberty -lz
-#LIBS_c += -lbfd -liberty -lz
-
-NEED_80211_COMMON=y
-
-CONFIG_IBSS_RSN=y
diff --git a/package/hostapd/files/wpa_supplicant-mini.config b/package/hostapd/files/wpa_supplicant-mini.config
deleted file mode 100644
index 772e1d9..0000000
--- a/package/hostapd/files/wpa_supplicant-mini.config
+++ /dev/null
@@ -1,406 +0,0 @@
-# Example wpa_supplicant build time configuration
-#
-# This file lists the configuration options that are used when building the
-# hostapd binary. All lines starting with # are ignored. Configuration option
-# lines must be commented out complete, if they are not to be included, i.e.,
-# just setting VARIABLE=n is not disabling that variable.
-#
-# This file is included in Makefile, so variables like CFLAGS and LIBS can also
-# be modified from here. In most cases, these lines should use += in order not
-# to override previous values of the variables.
-
-
-# Uncomment following two lines and fix the paths if you have installed OpenSSL
-# or GnuTLS in non-default location
-#CFLAGS += -I/usr/local/openssl/include
-#LIBS += -L/usr/local/openssl/lib
-
-# Some Red Hat versions seem to include kerberos header files from OpenSSL, but
-# the kerberos files are not in the default include path. Following line can be
-# used to fix build issues on such systems (krb5.h not found).
-#CFLAGS += -I/usr/include/kerberos
-
-# Example configuration for various cross-compilation platforms
-
-#### sveasoft (e.g., for Linksys WRT54G) ######################################
-#CC=mipsel-uclibc-gcc
-#CC=/opt/brcm/hndtools-mipsel-uclibc/bin/mipsel-uclibc-gcc
-#CFLAGS += -Os
-#CPPFLAGS += -I../src/include -I../../src/router/openssl/include
-#LIBS += -L/opt/brcm/hndtools-mipsel-uclibc-0.9.19/lib -lssl
-###############################################################################
-
-#### openwrt (e.g., for Linksys WRT54G) #######################################
-#CC=mipsel-uclibc-gcc
-#CC=/opt/brcm/hndtools-mipsel-uclibc/bin/mipsel-uclibc-gcc
-#CFLAGS += -Os
-#CPPFLAGS=-I../src/include -I../openssl-0.9.7d/include \
-#	-I../WRT54GS/release/src/include
-#LIBS = -lssl
-###############################################################################
-
-
-# Driver interface for Host AP driver
-CONFIG_DRIVER_HOSTAP=y
-
-# Driver interface for Agere driver
-#CONFIG_DRIVER_HERMES=y
-# Change include directories to match with the local setup
-#CFLAGS += -I../../hcf -I../../include -I../../include/hcf
-#CFLAGS += -I../../include/wireless
-
-# Driver interface for madwifi driver
-# Deprecated; use CONFIG_DRIVER_WEXT=y instead.
-#CONFIG_DRIVER_MADWIFI=y
-# Set include directory to the madwifi source tree
-#CFLAGS += -I../../madwifi
-
-# Driver interface for ndiswrapper
-# Deprecated; use CONFIG_DRIVER_WEXT=y instead.
-#CONFIG_DRIVER_NDISWRAPPER=y
-
-# Driver interface for Atmel driver
-# CONFIG_DRIVER_ATMEL=y
-
-# Driver interface for old Broadcom driver
-# Please note that the newer Broadcom driver ("hybrid Linux driver") supports
-# Linux wireless extensions and does not need (or even work) with the old
-# driver wrapper. Use CONFIG_DRIVER_WEXT=y with that driver.
-#CONFIG_DRIVER_BROADCOM=y
-# Example path for wlioctl.h; change to match your configuration
-#CFLAGS += -I/opt/WRT54GS/release/src/include
-
-# Driver interface for Intel ipw2100/2200 driver
-# Deprecated; use CONFIG_DRIVER_WEXT=y instead.
-#CONFIG_DRIVER_IPW=y
-
-# Driver interface for Ralink driver
-#CONFIG_DRIVER_RALINK=y
-
-# Driver interface for generic Linux wireless extensions
-CONFIG_DRIVER_WEXT=y
-
-# Driver interface for Linux drivers using the nl80211 kernel interface
-CONFIG_DRIVER_NL80211=y
-
-# Driver interface for FreeBSD net80211 layer (e.g., Atheros driver)
-#CONFIG_DRIVER_BSD=y
-#CFLAGS += -I/usr/local/include
-#LIBS += -L/usr/local/lib
-#LIBS_p += -L/usr/local/lib
-#LIBS_c += -L/usr/local/lib
-
-# Driver interface for Windows NDIS
-#CONFIG_DRIVER_NDIS=y
-#CFLAGS += -I/usr/include/w32api/ddk
-#LIBS += -L/usr/local/lib
-# For native build using mingw
-#CONFIG_NATIVE_WINDOWS=y
-# Additional directories for cross-compilation on Linux host for mingw target
-#CFLAGS += -I/opt/mingw/mingw32/include/ddk
-#LIBS += -L/opt/mingw/mingw32/lib
-#CC=mingw32-gcc
-# By default, driver_ndis uses WinPcap for low-level operations. This can be
-# replaced with the following option which replaces WinPcap calls with NDISUIO.
-# However, this requires that WZC is disabled (net stop wzcsvc) before starting
-# wpa_supplicant.
-# CONFIG_USE_NDISUIO=y
-
-# Driver interface for development testing
-#CONFIG_DRIVER_TEST=y
-
-# Include client MLME (management frame processing) for test driver
-# This can be used to test MLME operations in hostapd with the test interface.
-# space.
-#CONFIG_CLIENT_MLME=y
-
-# Driver interface for wired Ethernet drivers
-CONFIG_DRIVER_WIRED=y
-
-# Driver interface for the Broadcom RoboSwitch family
-#CONFIG_DRIVER_ROBOSWITCH=y
-
-# Driver interface for no driver (e.g., WPS ER only)
-#CONFIG_DRIVER_NONE=y
-
-# Enable IEEE 802.1X Supplicant (automatically included if any EAP method is
-# included)
-# CONFIG_IEEE8021X_EAPOL=y
-
-# EAP-MD5
-# CONFIG_EAP_MD5=y
-
-# EAP-MSCHAPv2
-# CONFIG_EAP_MSCHAPV2=y
-
-# EAP-TLS
-# CONFIG_EAP_TLS=y
-
-# EAL-PEAP
-# CONFIG_EAP_PEAP=y
-
-# EAP-TTLS
-# CONFIG_EAP_TTLS=y
-
-# EAP-FAST
-# Note: Default OpenSSL package does not include support for all the
-# functionality needed for EAP-FAST. If EAP-FAST is enabled with OpenSSL,
-# the OpenSSL library must be patched (openssl-0.9.8d-tls-extensions.patch)
-# to add the needed functions.
-#CONFIG_EAP_FAST=y
-
-# EAP-GTC
-# CONFIG_EAP_GTC=y
-
-# EAP-OTP
-# CONFIG_EAP_OTP=y
-
-# EAP-SIM (enable CONFIG_PCSC, if EAP-SIM is used)
-#CONFIG_EAP_SIM=y
-
-# EAP-PSK (experimental; this is _not_ needed for WPA-PSK)
-#CONFIG_EAP_PSK=y
-
-# EAP-PAX
-#CONFIG_EAP_PAX=y
-
-# LEAP
-# CONFIG_EAP_LEAP=y
-
-# EAP-AKA (enable CONFIG_PCSC, if EAP-AKA is used)
-#CONFIG_EAP_AKA=y
-
-# EAP-AKA' (enable CONFIG_PCSC, if EAP-AKA' is used).
-# This requires CONFIG_EAP_AKA to be enabled, too.
-#CONFIG_EAP_AKA_PRIME=y
-
-# Enable USIM simulator (Milenage) for EAP-AKA
-#CONFIG_USIM_SIMULATOR=y
-
-# EAP-SAKE
-#CONFIG_EAP_SAKE=y
-
-# EAP-GPSK
-#CONFIG_EAP_GPSK=y
-# Include support for optional SHA256 cipher suite in EAP-GPSK
-#CONFIG_EAP_GPSK_SHA256=y
-
-# EAP-TNC and related Trusted Network Connect support (experimental)
-#CONFIG_EAP_TNC=y
-
-# Wi-Fi Protected Setup (WPS)
-#CONFIG_WPS=y
-
-# EAP-IKEv2
-#CONFIG_EAP_IKEV2=y
-
-# PKCS#12 (PFX) support (used to read private key and certificate file from
-# a file that usually has extension .p12 or .pfx)
-# CONFIG_PKCS12=y
-
-# Smartcard support (i.e., private key on a smartcard), e.g., with openssl
-# engine.
-# CONFIG_SMARTCARD=y
-
-# PC/SC interface for smartcards (USIM, GSM SIM)
-# Enable this if EAP-SIM or EAP-AKA is included
-#CONFIG_PCSC=y
-
-# Development testing
-#CONFIG_EAPOL_TEST=y
-
-# Select control interface backend for external programs, e.g, wpa_cli:
-# unix = UNIX domain sockets (default for Linux/*BSD)
-# udp = UDP sockets using localhost (127.0.0.1)
-# named_pipe = Windows Named Pipe (default for Windows)
-# y = use default (backwards compatibility)
-# If this option is commented out, control interface is not included in the
-# build.
-CONFIG_CTRL_IFACE=y
-
-# Include support for GNU Readline and History Libraries in wpa_cli.
-# When building a wpa_cli binary for distribution, please note that these
-# libraries are licensed under GPL and as such, BSD license may not apply for
-# the resulting binary.
-#CONFIG_READLINE=y
-
-# Remove debugging code that is printing out debug message to stdout.
-# This can be used to reduce the size of the wpa_supplicant considerably
-# if debugging code is not needed. The size reduction can be around 35%
-# (e.g., 90 kB).
-#CONFIG_NO_STDOUT_DEBUG=y
-
-# Remove WPA support, e.g., for wired-only IEEE 802.1X supplicant, to save
-# 35-50 kB in code size.
-#CONFIG_NO_WPA=y
-
-# Remove WPA2 support. This allows WPA to be used, but removes WPA2 code to
-# save about 1 kB in code size when building only WPA-Personal (no EAP support)
-# or 6 kB if building for WPA-Enterprise.
-#CONFIG_NO_WPA2=y
-
-# Remove IEEE 802.11i/WPA-Personal ASCII passphrase support
-# This option can be used to reduce code size by removing support for
-# converting ASCII passphrases into PSK. If this functionality is removed, the
-# PSK can only be configured as the 64-octet hexstring (e.g., from
-# wpa_passphrase). This saves about 0.5 kB in code size.
-#CONFIG_NO_WPA_PASSPHRASE=y
-
-# Disable scan result processing (ap_mode=1) to save code size by about 1 kB.
-# This can be used if ap_scan=1 mode is never enabled.
-#CONFIG_NO_SCAN_PROCESSING=y
-
-# Select configuration backend:
-# file = text file (e.g., wpa_supplicant.conf; note: the configuration file
-#	path is given on command line, not here; this option is just used to
-#	select the backend that allows configuration files to be used)
-# winreg = Windows registry (see win_example.reg for an example)
-CONFIG_BACKEND=file
-
-# Remove configuration write functionality (i.e., to allow the configuration
-# file to be updated based on runtime configuration changes). The runtime
-# configuration can still be changed, the changes are just not going to be
-# persistent over restarts. This option can be used to reduce code size by
-# about 3.5 kB.
-#CONFIG_NO_CONFIG_WRITE=y
-
-# Remove support for configuration blobs to reduce code size by about 1.5 kB.
-#CONFIG_NO_CONFIG_BLOBS=y
-
-# Select program entry point implementation:
-# main = UNIX/POSIX like main() function (default)
-# main_winsvc = Windows service (read parameters from registry)
-# main_none = Very basic example (development use only)
-#CONFIG_MAIN=main
-
-# Select wrapper for operatins system and C library specific functions
-# unix = UNIX/POSIX like systems (default)
-# win32 = Windows systems
-# none = Empty template
-#CONFIG_OS=unix
-
-# Select event loop implementation
-# eloop = select() loop (default)
-# eloop_win = Windows events and WaitForMultipleObject() loop
-# eloop_none = Empty template
-#CONFIG_ELOOP=eloop
-
-# Select layer 2 packet implementation
-# linux = Linux packet socket (default)
-# pcap = libpcap/libdnet/WinPcap
-# freebsd = FreeBSD libpcap
-# winpcap = WinPcap with receive thread
-# ndis = Windows NDISUIO (note: requires CONFIG_USE_NDISUIO=y)
-# none = Empty template
-#CONFIG_L2_PACKET=linux
-
-# PeerKey handshake for Station to Station Link (IEEE 802.11e DLS)
-# CONFIG_PEERKEY=y
-
-# IEEE 802.11w (management frame protection)
-# This version is an experimental implementation based on IEEE 802.11w/D1.0
-# draft and is subject to change since the standard has not yet been finalized.
-# Driver support is also needed for IEEE 802.11w.
-#CONFIG_IEEE80211W=y
-
-# Select TLS implementation
-# openssl = OpenSSL (default)
-# gnutls = GnuTLS (needed for TLS/IA, see also CONFIG_GNUTLS_EXTRA)
-# internal = Internal TLSv1 implementation (experimental)
-# none = Empty template
-CONFIG_TLS=internal
-
-# Whether to enable TLS/IA support, which is required for EAP-TTLSv1.
-# You need CONFIG_TLS=gnutls for this to have any effect. Please note that
-# even though the core GnuTLS library is released under LGPL, this extra
-# library uses GPL and as such, the terms of GPL apply to the combination
-# of wpa_supplicant and GnuTLS if this option is enabled. BSD license may not
-# apply for distribution of the resulting binary.
-#CONFIG_GNUTLS_EXTRA=y
-
-# If CONFIG_TLS=internal is used, additional library and include paths are
-# needed for LibTomMath. Alternatively, an integrated, minimal version of
-# LibTomMath can be used. See beginning of libtommath.c for details on benefits
-# and drawbacks of this option.
-#CONFIG_INTERNAL_LIBTOMMATH=y
-#ifndef CONFIG_INTERNAL_LIBTOMMATH
-#LTM_PATH=/usr/src/libtommath-0.39
-#CFLAGS += -I$(LTM_PATH)
-#LIBS += -L$(LTM_PATH)
-#LIBS_p += -L$(LTM_PATH)
-#endif
-# At the cost of about 4 kB of additional binary size, the internal LibTomMath
-# can be configured to include faster routines for exptmod, sqr, and div to
-# speed up DH and RSA calculation considerably
-#CONFIG_INTERNAL_LIBTOMMATH_FAST=y
-
-# Include NDIS event processing through WMI into wpa_supplicant/wpasvc.
-# This is only for Windows builds and requires WMI-related header files and
-# WbemUuid.Lib from Platform SDK even when building with MinGW.
-#CONFIG_NDIS_EVENTS_INTEGRATED=y
-#PLATFORMSDKLIB="/opt/Program Files/Microsoft Platform SDK/Lib"
-
-# Add support for old DBus control interface
-# (fi.epitest.hostap.WPASupplicant)
-#CONFIG_CTRL_IFACE_DBUS=y
-
-# Add support for new DBus control interface
-# (fi.w1.hostap.wpa_supplicant1)
-#CONFIG_CTRL_IFACE_DBUS_NEW=y
-
-# Add introspection support for new DBus control interface
-#CONFIG_CTRL_IFACE_DBUS_INTRO=y
-
-# Add support for loading EAP methods dynamically as shared libraries.
-# When this option is enabled, each EAP method can be either included
-# statically (CONFIG_EAP_<method>=y) or dynamically (CONFIG_EAP_<method>=dyn).
-# Dynamic EAP methods are build as shared objects (eap_*.so) and they need to
-# be loaded in the beginning of the wpa_supplicant configuration file
-# (see load_dynamic_eap parameter in the example file) before being used in
-# the network blocks.
-#
-# Note that some shared parts of EAP methods are included in the main program
-# and in order to be able to use dynamic EAP methods using these parts, the
-# main program must have been build with the EAP method enabled (=y or =dyn).
-# This means that EAP-TLS/PEAP/TTLS/FAST cannot be added as dynamic libraries
-# unless at least one of them was included in the main build to force inclusion
-# of the shared code. Similarly, at least one of EAP-SIM/AKA must be included
-# in the main build to be able to load these methods dynamically.
-#
-# Please also note that using dynamic libraries will increase the total binary
-# size. Thus, it may not be the best option for targets that have limited
-# amount of memory/flash.
-#CONFIG_DYNAMIC_EAP_METHODS=y
-
-# IEEE Std 802.11r-2008 (Fast BSS Transition)
-#CONFIG_IEEE80211R=y
-
-# Add support for writing debug log to a file (/tmp/wpa_supplicant-log-#.txt)
-#CONFIG_DEBUG_FILE=y
-
-# Enable privilege separation (see README 'Privilege separation' for details)
-#CONFIG_PRIVSEP=y
-
-# Enable mitigation against certain attacks against TKIP by delaying Michael
-# MIC error reports by a random amount of time between 0 and 60 seconds
-#CONFIG_DELAYED_MIC_ERROR_REPORT=y
-
-# Enable tracing code for developer debugging
-# This tracks use of memory allocations and other registrations and reports
-# incorrect use with a backtrace of call (or allocation) location.
-#CONFIG_WPA_TRACE=y
-# For BSD, comment out these.
-#LIBS += -lexecinfo
-#LIBS_p += -lexecinfo
-#LIBS_c += -lexecinfo
-
-# Use libbfd to get more details for developer debugging
-# This enables use of libbfd to get more detailed symbols for the backtraces
-# generated by CONFIG_WPA_TRACE=y.
-#CONFIG_WPA_TRACE_BFD=y
-# For BSD, comment out these.
-#LIBS += -lbfd -liberty -lz
-#LIBS_p += -lbfd -liberty -lz
-#LIBS_c += -lbfd -liberty -lz
-
-NEED_80211_COMMON=y
diff --git a/package/hostapd/files/wpa_supplicant.sh b/package/hostapd/files/wpa_supplicant.sh
deleted file mode 100644
index 0b5e1d3..0000000
--- a/package/hostapd/files/wpa_supplicant.sh
+++ /dev/null
@@ -1,194 +0,0 @@
-wpa_supplicant_setup_vif() {
-	local vif="$1"
-	local driver="$2"
-	local key="$key"
-	local options="$3"
-	local freq=""
-	local ht="$5"
-	local ap_scan=""
-	local scan_ssid="1"
-	[ -n "$4" ] && freq="frequency=$4"
-
-	config_get enc "$vif" encryption
-	config_get key "$vif" key
-
-	local net_cfg bridge
-	config_get bridge "$vif" bridge
-	[ -z "$bridge" ] && {
-		net_cfg="$(find_net_config "$vif")"
-		[ -z "$net_cfg" ] || bridge="$(bridge_interface "$net_cfg")"
-		config_set "$vif" bridge "$bridge"
-	}
-
-	local mode ifname wds modestr=""
-	config_get mode "$vif" mode
-	config_get ifname "$vif" ifname
-	config_get_bool wds "$vif" wds 0
-	[ -z "$bridge" ] || [ "$mode" = ap ] || [ "$mode" = sta -a $wds -eq 1 ] || {
-		echo "wpa_supplicant_setup_vif($ifname): Refusing to bridge $mode mode interface"
-		return 1
-	}
-	[ "$mode" = "adhoc" ] && {
-		modestr="mode=1"
-		scan_ssid="0"
-		ap_scan="ap_scan=2"
-	}
-
-	key_mgmt='NONE'
-	case "$enc" in
-		*none*) ;;
-		*wep*)
-			config_get key "$vif" key
-			key="${key:-1}"
-			case "$key" in
-				[1234])
-					for idx in 1 2 3 4; do
-						local zidx
-						zidx=$(($idx - 1))
-						config_get ckey "$vif" "key${idx}"
-						[ -n "$ckey" ] && \
-							append "wep_key${zidx}" "wep_key${zidx}=$(prepare_key_wep "$ckey")"
-					done
-					wep_tx_keyidx="wep_tx_keyidx=$((key - 1))"
-				;;
-				*)
-					wep_key0="wep_key0=$(prepare_key_wep "$key")"
-					wep_tx_keyidx="wep_tx_keyidx=0"
-				;;
-			esac
-		;;
-		*psk*)
-			key_mgmt='WPA-PSK'
-			# if you want to use PSK with a non-nl80211 driver you
-			# have to use WPA-NONE and wext driver for wpa_s
-			[ "$mode" = "adhoc" -a "$driver" != "nl80211" ] && {
-				key_mgmt='WPA-NONE'
-				driver='wext'
-			}
-			if [ ${#key} -eq 64 ]; then
-				passphrase="psk=${key}"
-			else
-				passphrase="psk=\"${key}\""
-			fi
-			case "$enc" in
-				*psk2*)
-					proto='proto=RSN'
-					config_get ieee80211w "$vif" ieee80211w
-				;;
-				*psk*)
-					proto='proto=WPA'
-				;;
-			esac
-		;;
-		*wpa*|*8021x*)
-			proto='proto=WPA2'
-			key_mgmt='WPA-EAP'
-			config_get ieee80211w "$vif" ieee80211w
-			config_get ca_cert "$vif" ca_cert
-			config_get eap_type "$vif" eap_type
-			ca_cert=${ca_cert:+"ca_cert=\"$ca_cert\""}
-			case "$eap_type" in
-				tls)
-					pairwise='pairwise=CCMP'
-					group='group=CCMP'
-					config_get identity "$vif" identity
-					config_get client_cert "$vif" client_cert
-					config_get priv_key "$vif" priv_key
-					config_get priv_key_pwd "$vif" priv_key_pwd
-					identity="identity=\"$identity\""
-					client_cert="client_cert=\"$client_cert\""
-					priv_key="private_key=\"$priv_key\""
-					priv_key_pwd="private_key_passwd=\"$priv_key_pwd\""
-				;;
-				peap|ttls)
-					config_get auth "$vif" auth
-					config_get identity "$vif" identity
-					config_get password "$vif" password
-					phase2="phase2=\"auth=${auth:-MSCHAPV2}\""
-					identity="identity=\"$identity\""
-					password="${password:+password=\"$password\"}"
-				;;
-			esac
-			eap_type="eap=$(echo $eap_type | tr 'a-z' 'A-Z')"
-		;;
-	esac
-
-	case "$ieee80211w" in
-		[012])
-			ieee80211w="ieee80211w=$ieee80211w"
-		;;
-	esac
-
-	local fixed_freq bssid1 beacon_interval brates mrate
-	config_get ifname "$vif" ifname
-	config_get bridge "$vif" bridge
-	config_get ssid "$vif" ssid
-	config_get bssid "$vif" bssid
-	bssid1=${bssid:+"bssid=$bssid"}
-	beacon_interval=${beacon_int:+"beacon_interval=$beacon_int"}
-
-	local br brval brsub brstr
-	[ -n "$basic_rate_list" ] && {
-		for br in $basic_rate_list; do
-			brval="$(($br / 1000))"
-			brsub="$((($br / 100) % 10))"
-			[ "$brsub" -gt 0 ] && brval="$brval.$brsub"
-			[ -n "$brstr" ] && brstr="$brstr,"
-			brstr="$brstr$brval"
-		done
-		brates=${basic_rate_list:+"rates=$brstr"}
-	}
-
-	local mcval=""
-	[ -n "$mcast_rate" ] && {
-		mcval="$(($mcast_rate / 1000))"
-		mcsub="$(( ($mcast_rate / 100) % 10 ))"
-		[ "$mcsub" -gt 0 ] && mcval="$mcval.$mcsub"
-		mrate=${mcast_rate:+"mcast_rate=$mcval"}
-	}
-
-	local ht_str
-	[ -n "$ht" ] && ht_str="htmode=$ht"
-
-	rm -rf /var/run/wpa_supplicant-$ifname
-	cat > /var/run/wpa_supplicant-$ifname.conf <<EOF
-ctrl_interface=/var/run/wpa_supplicant-$ifname
-$ap_scan
-network={
-	$modestr
-	scan_ssid=$scan_ssid
-	ssid="$ssid"
-	$bssid1
-	key_mgmt=$key_mgmt
-	$proto
-	$freq
-	${fixed:+"fixed_freq=1"}
-	$beacon_interval
-	$brates
-	$mrate
-	$ht_str
-	$ieee80211w
-	$passphrase
-	$pairwise
-	$group
-	$eap_type
-	$ca_cert
-	$client_cert
-	$priv_key
-	$priv_key_pwd
-	$phase2
-	$identity
-	$password
-	$wep_key0
-	$wep_key1
-	$wep_key2
-	$wep_key3
-	$wep_tx_keyidx
-}
-EOF
-	if [ -n "$proto" -o "$key_mgmt" == "NONE" ]; then
-		wpa_supplicant ${bridge:+ -b $bridge} -B -P "/var/run/wifi-${ifname}.pid" -D ${driver:-wext} -i "$ifname" -c /var/run/wpa_supplicant-$ifname.conf $options
-	else
-		return 0
-	fi
-}
diff --git a/package/hostapd/files/wps-hotplug.sh b/package/hostapd/files/wps-hotplug.sh
deleted file mode 100644
index ffd3cf9..0000000
--- a/package/hostapd/files/wps-hotplug.sh
+++ /dev/null
@@ -1,8 +0,0 @@
-#!/bin/sh
-
-if [ "$ACTION" = "pressed" -a "$BUTTON" = "wps" ]; then
-	for dir in /var/run/hostapd-*; do
-		[ -d "$dir" ] || continue
-		hostapd_cli -p "$dir" wps_pbc
-	done
-fi
diff --git a/package/hostapd/madwifi/include/compat.h b/package/hostapd/madwifi/include/compat.h
deleted file mode 100644
index 09e6397..0000000
--- a/package/hostapd/madwifi/include/compat.h
+++ /dev/null
@@ -1,209 +0,0 @@
-/*-
- * Copyright (c) 2002-2005 Sam Leffler, Errno Consulting
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer,
- *    without modification.
- * 2. Redistributions in binary form must reproduce at minimum a disclaimer
- *    similar to the "NO WARRANTY" disclaimer below ("Disclaimer") and any
- *    redistribution must be conditioned upon including a substantially
- *    similar Disclaimer requirement for further binary redistribution.
- * 3. Neither the names of the above-listed copyright holders nor the names
- *    of any contributors may be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * Alternatively, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") version 2 as published by the Free
- * Software Foundation.
- *
- * NO WARRANTY
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF NONINFRINGEMENT, MERCHANTIBILITY
- * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
- * THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY,
- * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
- * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGES.
- *
- * $Id: compat.h 3310 2008-01-30 20:23:49Z mentor $
- */
-#ifndef _ATH_COMPAT_H_
-#define _ATH_COMPAT_H_
-
-/* Compatibility with older Linux kernels */
-#ifdef __KERNEL__
-#include <linux/types.h>
-#include <linux/time.h>
-#include <linux/netdevice.h>
-#endif
-
-#if !defined(__KERNEL__) || !defined (__bitwise)
-#define __le16 u_int16_t
-#define __le32 u_int32_t
-#define __le64 u_int64_t
-#define __be16 u_int16_t
-#define __be32 u_int32_t
-#define __be64 u_int64_t
-#define __force
-#endif
-
-#ifndef container_of
-#define container_of(ptr, type, member) ({				\
-	    const typeof( ((type *)0)->member ) *__mptr = (ptr);	\
-	    (type *)( (char *)__mptr - offsetof(type,member) );})
-#endif
-
-#ifndef list_for_each_entry_reverse
-#define list_for_each_entry_reverse(pos, head, member)			\
-	for (pos = list_entry((head)->prev, typeof(*pos), member);	\
-	     prefetch(pos->member.prev), &pos->member != (head); 	\
-	     pos = list_entry(pos->member.prev, typeof(*pos), member))
-#endif
-
-#ifndef NETDEV_TX_OK
-#define NETDEV_TX_OK    0
-#define NETDEV_TX_BUSY  1
-#endif
-
-/*
- * BSD/Linux compatibility shims.  These are used mainly to
- * minimize differences when importing necesary BSD code.
- */
-#define	NBBY	8			/* number of bits/byte */
-
-/* roundup() appears in Linux 2.6.18 */
-#include <linux/kernel.h>
-#ifndef roundup
-#define	roundup(x, y)	((((x)+((y)-1))/(y))*(y))  /* to any y */
-#endif
-
-#define	howmany(x, y)	(((x)+((y)-1))/(y))
-
-/* Bit map related macros. */
-#define	setbit(a,i)	((a)[(i)/NBBY] |= 1<<((i)%NBBY))
-#define	clrbit(a,i)	((a)[(i)/NBBY] &= ~(1<<((i)%NBBY)))
-#define	isset(a,i)	((a)[(i)/NBBY] & (1<<((i)%NBBY)))
-#define	isclr(a,i)	(((a)[(i)/NBBY] & (1<<((i)%NBBY))) == 0)
-
-#ifndef __packed
-#define	__packed	__attribute__((__packed__))
-#endif
-
-#define	__offsetof(t,m)	offsetof(t,m)
-
-#ifndef ALIGNED_POINTER
-/*
- * ALIGNED_POINTER is a boolean macro that checks whether an address
- * is valid to fetch data elements of type t from on this architecture.
- * This does not reflect the optimal alignment, just the possibility
- * (within reasonable limits). 
- *
- */
-#define ALIGNED_POINTER(p,t)	1
-#endif
-
-#ifdef __KERNEL__
-#define	KASSERT(exp, msg) do {			\
-	if (unlikely(!(exp))) {			\
-		printk msg;			\
-		BUG();				\
-	}					\
-} while (0)
-#endif /* __KERNEL__ */
-
-/*
- * NetBSD/FreeBSD defines for file version.
- */
-#define	__FBSDID(_s)
-#define	__KERNEL_RCSID(_n,_s)
-
-/*
- * Fixes for Linux API changes
- */
-#ifdef __KERNEL__
-
-#include <linux/version.h>
-
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,38)
-#define AUTOCONF_INCLUDED 1
-#endif
-
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,21)
-#define ATH_REGISTER_SYSCTL_TABLE(t) register_sysctl_table(t, 1)
-#else
-#define ATH_REGISTER_SYSCTL_TABLE(t) register_sysctl_table(t)
-#endif
-
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,9)
-#define __user
-#define __kernel
-#define __iomem
-#endif
-
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,14)
-typedef int gfp_t;
-#endif
-
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,16)
-static inline int timeval_compare(struct timeval *lhs, struct timeval *rhs)
-{
-	if (lhs->tv_sec < rhs->tv_sec)
-		return -1;
-	if (lhs->tv_sec > rhs->tv_sec)
-		return 1;
-	return lhs->tv_usec - rhs->tv_usec;
-}
-#endif
-
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18)
-#define IRQF_SHARED SA_SHIRQ
-#endif
-
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,27)
-#define netdev_priv(_netdev) ((_netdev)->priv)
-#endif
-
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22)
-#define skb_end_pointer(_skb) ((_skb)->end)
-#define skb_tail_pointer(_skb) ((_skb)->tail)
-#define skb_set_network_header(_skb, _offset) \
-	do { (_skb)->nh.raw = (_skb)->data + (_offset); } while(0)
-#define skb_reset_network_header(_skb) \
-	do { (_skb)->nh.raw = (_skb)->data; } while(0)
-#define skb_mac_header(_skb) ((_skb)->mac.raw)
-#define skb_reset_mac_header(_skb) \
-	do { (_skb)->mac.raw = (_skb)->data; } while(0)
-#endif
-
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24)
-#define CTL_AUTO -2
-#define DEV_ATH 9
-#else
-#define CTL_AUTO CTL_UNNUMBERED
-#define DEV_ATH CTL_UNNUMBERED
-#endif
-
-/* __skb_append got a third parameter in 2.6.14 */
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,14)
-#define __skb_queue_after(_list, _old, _new)	__skb_append(_old, _new)
-#elif LINUX_VERSION_CODE < KERNEL_VERSION(2,6,25)
-#define __skb_queue_after(_list, _old, _new)	__skb_append(_old, _new, _list)
-#endif
-
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,33)
-#define CTLNAME(x)	.ctl_name	= x,
-#else
-#define CTLNAME(x)
-#endif
-
-#endif /* __KERNEL__ */
-
-#endif /* _ATH_COMPAT_H_ */
diff --git a/package/hostapd/madwifi/net80211/_ieee80211.h b/package/hostapd/madwifi/net80211/_ieee80211.h
deleted file mode 100644
index 2d2a06f..0000000
--- a/package/hostapd/madwifi/net80211/_ieee80211.h
+++ /dev/null
@@ -1,325 +0,0 @@
-/*-
- * Copyright (c) 2001 Atsushi Onoe
- * Copyright (c) 2002-2005 Sam Leffler, Errno Consulting
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * Alternatively, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") version 2 as published by the Free
- * Software Foundation.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- *
- * $Id: _ieee80211.h 3207 2008-01-18 21:25:05Z mtaylor $
- */
-#ifndef _NET80211__IEEE80211_H_
-#define _NET80211__IEEE80211_H_
-
-enum ieee80211_phytype {
-	IEEE80211_T_DS,			/* direct sequence spread spectrum */
-	IEEE80211_T_FH,			/* frequency hopping */
-	IEEE80211_T_OFDM,		/* frequency division multiplexing */
-	IEEE80211_T_TURBO,		/* high rate OFDM, aka turbo mode */
-};
-#define	IEEE80211_T_CCK	IEEE80211_T_DS	/* more common nomenclature */
-
-/* XXX: not really a mode; there are really multiple PHYs */
-enum ieee80211_phymode {
-	IEEE80211_MODE_AUTO	= 0,	/* autoselect */
-	IEEE80211_MODE_11A	= 1,	/* 5GHz, OFDM */
-	IEEE80211_MODE_11B	= 2,	/* 2GHz, CCK */
-	IEEE80211_MODE_11G	= 3,	/* 2GHz, OFDM */
-	IEEE80211_MODE_FH	= 4,	/* 2GHz, GFSK */
-	IEEE80211_MODE_TURBO_A	= 5,	/* 5GHz, OFDM, 2x clock dynamic turbo */
-	IEEE80211_MODE_TURBO_G	= 6,	/* 2GHz, OFDM, 2x clock  dynamic turbo*/
-};
-#define	IEEE80211_MODE_MAX	(IEEE80211_MODE_TURBO_G+1)
-
-enum ieee80211_opmode {
-	IEEE80211_M_STA		= 1,	/* infrastructure station */
-	IEEE80211_M_IBSS 	= 0,	/* IBSS (adhoc) station */
-	IEEE80211_M_AHDEMO	= 3,	/* Old lucent compatible adhoc demo */
-	IEEE80211_M_HOSTAP	= 6,	/* Software Access Point */
-	IEEE80211_M_MONITOR	= 8,	/* Monitor mode */
-	IEEE80211_M_WDS		= 2	/* WDS link */
-};
-
-/*
- * True if this mode will send beacon on a regular interval, like AP
- * or IBSS
- */
-#define IEEE80211_IS_MODE_BEACON(_opmode) \
-	((_opmode == IEEE80211_M_IBSS) || \
-	 (_opmode == IEEE80211_M_HOSTAP))
-
-/*
- * True if this mode must behave like a DFS master, ie do Channel
- * Check Availability and In Service Monitoring. We need to make sure
- * that all modes cannot send data without being authorized. Such
- * enforcement is not done in monitor mode however.
- */
-
-#define IEEE80211_IS_MODE_DFS_MASTER(_opmode) \
-	((_opmode == IEEE80211_M_IBSS) || \
-	 (_opmode == IEEE80211_M_AHDEMO) || \
-	 (_opmode == IEEE80211_M_HOSTAP) || \
-	 (_opmode == IEEE80211_M_WDS))
-
-/*
- * 802.11g protection mode.
- */
-enum ieee80211_protmode {
-	IEEE80211_PROT_NONE	= 0,	/* no protection */
-	IEEE80211_PROT_CTSONLY	= 1,	/* CTS to self */
-	IEEE80211_PROT_RTSCTS	= 2,	/* RTS-CTS */
-};
-
-/*
- * Authentication mode.
- */
-enum ieee80211_authmode {
-	IEEE80211_AUTH_NONE	= 0,
-	IEEE80211_AUTH_OPEN	= 1,	/* open */
-	IEEE80211_AUTH_SHARED	= 2,	/* shared-key */
-	IEEE80211_AUTH_8021X	= 3,	/* 802.1x */
-	IEEE80211_AUTH_AUTO	= 4,	/* auto-select/accept */
-	/* NB: these are used only for ioctls */
-	IEEE80211_AUTH_WPA	= 5,	/* WPA/RSN w/ 802.1x/PSK */
-};
-
-/*
- * Roaming mode is effectively who controls the operation
- * of the 802.11 state machine when operating as a station.
- * State transitions are controlled either by the driver
- * (typically when management frames are processed by the
- * hardware/firmware), the host (auto/normal operation of
- * the 802.11 layer), or explicitly through ioctl requests
- * when applications like wpa_supplicant want control.
- */
-enum ieee80211_roamingmode {
-	IEEE80211_ROAMING_DEVICE= 0,	/* driver/hardware control */
-	IEEE80211_ROAMING_AUTO	= 1,	/* 802.11 layer control */
-	IEEE80211_ROAMING_MANUAL= 2,	/* application control */
-};
-
-/*
- * Scanning mode controls station scanning work; this is
- * used only when roaming mode permits the host to select
- * the bss to join/channel to use.
- */
-enum ieee80211_scanmode {
-	IEEE80211_SCAN_DEVICE	= 0,	/* driver/hardware control */
-	IEEE80211_SCAN_BEST	= 1,	/* 802.11 layer selects best */
-	IEEE80211_SCAN_FIRST	= 2,	/* take first suitable candidate */
-};
-
-enum ieee80211_scanflags {
-	IEEE80211_NOSCAN_DEFAULT = (1 << 0),
-	IEEE80211_NOSCAN_SET     = (1 << 1),
-};
-
-/*
- * Channels are specified by frequency and attributes.
- */
-struct ieee80211_channel {
-	u_int16_t ic_freq;	/* setting in MHz */
-	u_int16_t ic_flags;	/* see below */
-	u_int8_t ic_ieee;	/* IEEE channel number */
-	int8_t ic_maxregpower;	/* maximum regulatory tx power in dBm */
-	int8_t ic_maxpower;	/* maximum tx power in dBm */
-	int8_t ic_minpower;	/* minimum tx power in dBm */
-	u_int8_t ic_scanflags;
-	u_int8_t ic_idletime; /* phy idle time in % */
-};
-
-#define	IEEE80211_CHAN_MAX	255
-#define	IEEE80211_CHAN_BYTES	32	/* howmany(IEEE80211_CHAN_MAX, NBBY) */
-#define	IEEE80211_CHAN_ANY	0xffff	/* token for ``any channel'' */
-#define	IEEE80211_CHAN_ANYC 	((struct ieee80211_channel *) IEEE80211_CHAN_ANY)
-
-#define	IEEE80211_RADAR_CHANCHANGE_TBTT_COUNT	0
-#define IEEE80211_DEFAULT_CHANCHANGE_TBTT_COUNT	3
-
-#define	IEEE80211_RADAR_TEST_MUTE_CHAN	36	/* Move to channel 36 for mute test */
-
-/* bits 0-3 are for private use by drivers */
-/* channel attributes */
-#define	IEEE80211_CHAN_TURBO	0x0010	/* Turbo channel */
-#define	IEEE80211_CHAN_CCK	0x0020	/* CCK channel */
-#define	IEEE80211_CHAN_OFDM	0x0040	/* OFDM channel */
-#define	IEEE80211_CHAN_2GHZ	0x0080	/* 2 GHz spectrum channel. */
-#define	IEEE80211_CHAN_5GHZ	0x0100	/* 5 GHz spectrum channel */
-#define	IEEE80211_CHAN_PASSIVE	0x0200	/* Only passive scan allowed */
-#define	IEEE80211_CHAN_DYN	0x0400	/* Dynamic CCK-OFDM channel */
-#define	IEEE80211_CHAN_GFSK	0x0800	/* GFSK channel (FHSS PHY) */
-#define IEEE80211_CHAN_RADAR	0x1000	/* Radar found on channel */
-#define	IEEE80211_CHAN_STURBO	0x2000	/* 11a static turbo channel only */
-#define	IEEE80211_CHAN_HALF	0x4000	/* Half rate channel */
-#define	IEEE80211_CHAN_QUARTER	0x8000	/* Quarter rate channel */
-
-/*
- * Useful combinations of channel characteristics.
- */
-#define	IEEE80211_CHAN_FHSS \
-	(IEEE80211_CHAN_2GHZ | IEEE80211_CHAN_GFSK)
-#define	IEEE80211_CHAN_A \
-	(IEEE80211_CHAN_5GHZ | IEEE80211_CHAN_OFDM)
-#define	IEEE80211_CHAN_B \
-	(IEEE80211_CHAN_2GHZ | IEEE80211_CHAN_CCK)
-#define	IEEE80211_CHAN_PUREG \
-	(IEEE80211_CHAN_2GHZ | IEEE80211_CHAN_OFDM)
-#define	IEEE80211_CHAN_G \
-	(IEEE80211_CHAN_2GHZ | IEEE80211_CHAN_DYN)
-#define IEEE80211_CHAN_108A \
-	(IEEE80211_CHAN_5GHZ | IEEE80211_CHAN_OFDM | IEEE80211_CHAN_TURBO)
-#define	IEEE80211_CHAN_108G \
-	(IEEE80211_CHAN_2GHZ | IEEE80211_CHAN_OFDM | IEEE80211_CHAN_TURBO)
-#define	IEEE80211_CHAN_ST \
-	(IEEE80211_CHAN_108A | IEEE80211_CHAN_STURBO)
-
-#define	IEEE80211_CHAN_ALL \
-	(IEEE80211_CHAN_2GHZ | IEEE80211_CHAN_5GHZ | IEEE80211_CHAN_GFSK | \
-	 IEEE80211_CHAN_CCK | IEEE80211_CHAN_OFDM | IEEE80211_CHAN_DYN)
-#define	IEEE80211_CHAN_ALLTURBO \
-	(IEEE80211_CHAN_ALL | IEEE80211_CHAN_TURBO | IEEE80211_CHAN_STURBO)
-
-#define	IEEE80211_IS_CHAN_FHSS(_c) \
-	(((_c)->ic_flags & IEEE80211_CHAN_FHSS) == IEEE80211_CHAN_FHSS)
-#define	IEEE80211_IS_CHAN_A(_c) \
-	(((_c)->ic_flags & IEEE80211_CHAN_A) == IEEE80211_CHAN_A)
-#define	IEEE80211_IS_CHAN_B(_c) \
-	(((_c)->ic_flags & IEEE80211_CHAN_B) == IEEE80211_CHAN_B)
-#define	IEEE80211_IS_CHAN_PUREG(_c) \
-	(((_c)->ic_flags & IEEE80211_CHAN_PUREG) == IEEE80211_CHAN_PUREG)
-#define	IEEE80211_IS_CHAN_G(_c) \
-	(((_c)->ic_flags & IEEE80211_CHAN_G) == IEEE80211_CHAN_G)
-#define	IEEE80211_IS_CHAN_ANYG(_c) \
-	(IEEE80211_IS_CHAN_PUREG(_c) || IEEE80211_IS_CHAN_G(_c))
-#define	IEEE80211_IS_CHAN_ST(_c) \
-	(((_c)->ic_flags & IEEE80211_CHAN_ST) == IEEE80211_CHAN_ST)
-#define	IEEE80211_IS_CHAN_108A(_c) \
-	(((_c)->ic_flags & IEEE80211_CHAN_108A) == IEEE80211_CHAN_108A)
-#define	IEEE80211_IS_CHAN_108G(_c) \
-	(((_c)->ic_flags & IEEE80211_CHAN_108G) == IEEE80211_CHAN_108G)
-
-#define	IEEE80211_IS_CHAN_2GHZ(_c) \
-	(((_c)->ic_flags & IEEE80211_CHAN_2GHZ) != 0)
-#define	IEEE80211_IS_CHAN_5GHZ(_c) \
-	(((_c)->ic_flags & IEEE80211_CHAN_5GHZ) != 0)
-#define	IEEE80211_IS_CHAN_OFDM(_c) \
-	(((_c)->ic_flags & IEEE80211_CHAN_OFDM) != 0)
-#define	IEEE80211_IS_CHAN_CCK(_c) \
-	(((_c)->ic_flags & IEEE80211_CHAN_CCK) != 0)
-#define	IEEE80211_IS_CHAN_GFSK(_c) \
-	(((_c)->ic_flags & IEEE80211_CHAN_GFSK) != 0)
-#define	IEEE80211_IS_CHAN_TURBO(_c) \
-	(((_c)->ic_flags & IEEE80211_CHAN_TURBO) != 0)
-#define	IEEE80211_IS_CHAN_STURBO(_c) \
-	(((_c)->ic_flags & IEEE80211_CHAN_STURBO) != 0)
-#define	IEEE80211_IS_CHAN_DTURBO(_c) \
-	(((_c)->ic_flags & \
-	(IEEE80211_CHAN_TURBO | IEEE80211_CHAN_STURBO)) == IEEE80211_CHAN_TURBO)
-#define	IEEE80211_IS_CHAN_HALF(_c) \
-	(((_c)->ic_flags & IEEE80211_CHAN_HALF) != 0)
-#define	IEEE80211_IS_CHAN_QUARTER(_c) \
-	(((_c)->ic_flags & IEEE80211_CHAN_QUARTER) != 0)
-
-#define	IEEE80211_IS_CHAN_RADAR(_c) \
-	(((_c)->ic_flags & IEEE80211_CHAN_RADAR) != 0)
-#define	IEEE80211_IS_CHAN_PASSIVE(_c) \
-	(((_c)->ic_flags & IEEE80211_CHAN_PASSIVE) != 0)
-#define	IEEE80211_ARE_CHANS_SAME_MODE(_a, _b) \
-	(((_a)->ic_flags & IEEE80211_CHAN_ALLTURBO) == ((_b)->ic_flags & IEEE80211_CHAN_ALLTURBO))
-
-/* ni_chan encoding for FH phy */
-#define	IEEE80211_FH_CHANMOD		80
-#define	IEEE80211_FH_CHAN(set,pat)	(((set) - 1) * IEEE80211_FH_CHANMOD + (pat))
-#define	IEEE80211_FH_CHANSET(chan)	((chan) / IEEE80211_FH_CHANMOD + 1)
-#define	IEEE80211_FH_CHANPAT(chan)	((chan) % IEEE80211_FH_CHANMOD)
-
-/*
- * Spectrum Management (IEEE 802.11h-2003)
- */
-
-/* algorithm for (re)association based on supported channels
- * (the one mentioned in 11.6.1 as out of scope of .11h) */
-enum ieee80211_sc_algorithm {
-	IEEE80211_SC_NONE,
-	/*
-	 * Do not disallow anyone from associating. When needed, channel will
-	 * be switched to the most suitable channel, no matter client stations
-	 * support it or not.
-	 */
-
-	IEEE80211_SC_LOOSE,
-	/*
-	 * Do not disallow anyone from associating. When needed, channel will
-	 * be switched to a suitable channel, which will be chosen taking
-	 * ni->ni_suppchans and ic->ic_sc_sldg under consideration.
-	 */
-
-	IEEE80211_SC_TIGHT,
-	/*
-	 * Allow to associate if there are at least ic->ic_mincom channels
-	 * common to the associating station and all of the already associated
-	 * stations. If the number of new common channels is less than
-	 * required, consider disassociating some other STAs. Such a
-	 * disassociation will be performed if (and only if) the association we
-	 * are currently considering would be then possible and the count of
-	 * the resultant set of common channels (ic_chan_nodes[i] ==
-	 * ic_cn_total) would increase by some amount. Whether the number of
-	 * the new channels that could be gained is enough to sacrifice a
-	 * number of STAs is determined by the ic->ic_slcg parameter.
-	 */
-
-	IEEE80211_SC_STRICT
-	/*
-	 * Basically the same behavior as IEEE80211_SC_TIGHT, except that if a
-	 * station does not specify Supported Channels, then it is denied to
-	 * associate.
-	 */
-};
-
-/*
- * 802.11 rate set.
- */
-#define	IEEE80211_RATE_SIZE	8		/* 802.11 standard */
-#define	IEEE80211_RATE_MAXSIZE	15		/* max rates we'll handle */
-#define	IEEE80211_SANITISE_RATESIZE(_rsz) \
-	((_rsz > IEEE80211_RATE_MAXSIZE) ? IEEE80211_RATE_MAXSIZE : _rsz)
-
-struct ieee80211_rateset {
-	u_int8_t rs_nrates;
-	u_int8_t rs_rates[IEEE80211_RATE_MAXSIZE];
-};
-
-struct ieee80211_roam {
-	int8_t rssi11a;		/* rssi thresh for 11a bss */
-	int8_t rssi11b;		/* for 11g sta in 11b bss */
-	int8_t rssi11bOnly;	/* for 11b sta */
-	u_int8_t pad1;
-	u_int8_t rate11a;	/* rate thresh for 11a bss */
-	u_int8_t rate11b;	/* for 11g sta in 11b bss */
-	u_int8_t rate11bOnly;	/* for 11b sta */
-	u_int8_t pad2;
-};
-#endif /* _NET80211__IEEE80211_H_ */
diff --git a/package/hostapd/madwifi/net80211/ieee80211.h b/package/hostapd/madwifi/net80211/ieee80211.h
deleted file mode 100644
index a39d4b9..0000000
--- a/package/hostapd/madwifi/net80211/ieee80211.h
+++ /dev/null
@@ -1,997 +0,0 @@
-/*-
- * Copyright (c) 2001 Atsushi Onoe
- * Copyright (c) 2002-2005 Sam Leffler, Errno Consulting
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * Alternatively, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") version 2 as published by the Free
- * Software Foundation.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- *
- * $Id: ieee80211.h 3268 2008-01-26 20:48:11Z mtaylor $
- */
-#ifndef _NET80211_IEEE80211_H_
-#define _NET80211_IEEE80211_H_
-
-/*
- * 802.11 protocol definitions.
- */
-
-#define	IEEE80211_ADDR_LEN		6		/* size of 802.11 address */
-/* is 802.11 address multicast/broadcast? */
-#define	IEEE80211_IS_MULTICAST(_a)	(*(_a) & 0x01)
-
-/* IEEE 802.11 PLCP header */
-struct ieee80211_plcp_hdr {
-	u_int16_t i_sfd;
-	u_int8_t i_signal;
-	u_int8_t i_service;
-	u_int16_t i_length;
-	u_int16_t i_crc;
-} __packed;
-
-#define IEEE80211_PLCP_SFD      0xF3A0
-#define IEEE80211_PLCP_SERVICE  0x00
-
-/*
- * generic definitions for IEEE 802.11 frames
- */
-struct ieee80211_frame {
-	u_int8_t i_fc[2];
-	__le16 i_dur;
-	u_int8_t i_addr1[IEEE80211_ADDR_LEN];
-	u_int8_t i_addr2[IEEE80211_ADDR_LEN];
-	u_int8_t i_addr3[IEEE80211_ADDR_LEN];
-	u_int8_t i_seq[2];
-	/* possibly followed by addr4[IEEE80211_ADDR_LEN]; */
-	/* see below */
-} __packed;
-
-struct ieee80211_qosframe {
-	u_int8_t i_fc[2];
-	__le16 i_dur;
-	u_int8_t i_addr1[IEEE80211_ADDR_LEN];
-	u_int8_t i_addr2[IEEE80211_ADDR_LEN];
-	u_int8_t i_addr3[IEEE80211_ADDR_LEN];
-	u_int8_t i_seq[2];
-	u_int8_t i_qos[2];
-	/* possibly followed by addr4[IEEE80211_ADDR_LEN]; */
-	/* see below */
-} __packed;
-
-struct ieee80211_qoscntl {
-	u_int8_t i_qos[2];
-};
-
-struct ieee80211_frame_addr4 {
-	u_int8_t i_fc[2];
-	__le16 i_dur;
-	u_int8_t i_addr1[IEEE80211_ADDR_LEN];
-	u_int8_t i_addr2[IEEE80211_ADDR_LEN];
-	u_int8_t i_addr3[IEEE80211_ADDR_LEN];
-	u_int8_t i_seq[2];
-	u_int8_t i_addr4[IEEE80211_ADDR_LEN];
-} __packed;
-
-
-struct ieee80211_qosframe_addr4 {
-	u_int8_t i_fc[2];
-	__le16 i_dur;
-	u_int8_t i_addr1[IEEE80211_ADDR_LEN];
-	u_int8_t i_addr2[IEEE80211_ADDR_LEN];
-	u_int8_t i_addr3[IEEE80211_ADDR_LEN];
-	u_int8_t i_seq[2];
-	u_int8_t i_addr4[IEEE80211_ADDR_LEN];
-	u_int8_t i_qos[2];
-} __packed;
-
-struct ieee80211_ctlframe_addr2 {
-	u_int8_t i_fc[2];
-	__le16 i_aidordur; /* AID or duration */
-	u_int8_t i_addr1[IEEE80211_ADDR_LEN];
-	u_int8_t i_addr2[IEEE80211_ADDR_LEN];
-} __packed;
-
-#define	IEEE80211_FC0_VERSION_MASK		0x03
-#define	IEEE80211_FC0_VERSION_SHIFT		0
-#define	IEEE80211_FC0_VERSION_0			0x00
-#define	IEEE80211_FC0_TYPE_MASK			0x0c
-#define	IEEE80211_FC0_TYPE_SHIFT		2
-#define	IEEE80211_FC0_TYPE_MGT			0x00
-#define	IEEE80211_FC0_TYPE_CTL			0x04
-#define	IEEE80211_FC0_TYPE_DATA			0x08
-
-#define	IEEE80211_FC0_SUBTYPE_MASK		0xf0
-#define	IEEE80211_FC0_SUBTYPE_SHIFT		4
-/* for TYPE_MGT */
-#define	IEEE80211_FC0_SUBTYPE_ASSOC_REQ		0x00
-#define	IEEE80211_FC0_SUBTYPE_ASSOC_RESP	0x10
-#define	IEEE80211_FC0_SUBTYPE_REASSOC_REQ	0x20
-#define	IEEE80211_FC0_SUBTYPE_REASSOC_RESP	0x30
-#define	IEEE80211_FC0_SUBTYPE_PROBE_REQ		0x40
-#define	IEEE80211_FC0_SUBTYPE_PROBE_RESP	0x50
-#define	IEEE80211_FC0_SUBTYPE_BEACON		0x80
-#define	IEEE80211_FC0_SUBTYPE_ATIM		0x90
-#define	IEEE80211_FC0_SUBTYPE_DISASSOC		0xa0
-#define	IEEE80211_FC0_SUBTYPE_AUTH		0xb0
-#define	IEEE80211_FC0_SUBTYPE_DEAUTH		0xc0
-#define IEEE80211_FC0_SUBTYPE_ACTION		0xd0
-/* for TYPE_CTL */
-#define	IEEE80211_FC0_SUBTYPE_PS_POLL		0xa0
-#define	IEEE80211_FC0_SUBTYPE_RTS		0xb0
-#define	IEEE80211_FC0_SUBTYPE_CTS		0xc0
-#define	IEEE80211_FC0_SUBTYPE_ACK		0xd0
-#define	IEEE80211_FC0_SUBTYPE_CF_END		0xe0
-#define	IEEE80211_FC0_SUBTYPE_CF_END_ACK	0xf0
-/* for TYPE_DATA (bit combination) */
-#define	IEEE80211_FC0_SUBTYPE_DATA		0x00
-#define	IEEE80211_FC0_SUBTYPE_CF_ACK		0x10
-#define	IEEE80211_FC0_SUBTYPE_CF_POLL		0x20
-#define	IEEE80211_FC0_SUBTYPE_CF_ACPL		0x30
-#define	IEEE80211_FC0_SUBTYPE_NODATA		0x40
-#define	IEEE80211_FC0_SUBTYPE_CFACK		0x50
-#define	IEEE80211_FC0_SUBTYPE_CFPOLL		0x60
-#define	IEEE80211_FC0_SUBTYPE_CF_ACK_CF_ACK	0x70
-#define	IEEE80211_FC0_SUBTYPE_QOS		0x80
-#define	IEEE80211_FC0_SUBTYPE_QOS_NULL		0xc0
-
-#define	IEEE80211_FC1_DIR_MASK			0x03
-#define	IEEE80211_FC1_DIR_NODS			0x00	/* STA->STA */
-#define	IEEE80211_FC1_DIR_TODS			0x01	/* STA->AP  */
-#define	IEEE80211_FC1_DIR_FROMDS		0x02	/* AP ->STA */
-#define	IEEE80211_FC1_DIR_DSTODS		0x03	/* AP ->AP  */
-
-#define	IEEE80211_FC1_MORE_FRAG			0x04
-#define	IEEE80211_FC1_RETRY			0x08
-#define	IEEE80211_FC1_PWR_MGT			0x10
-#define	IEEE80211_FC1_MORE_DATA			0x20
-#define	IEEE80211_FC1_PROT			0x40
-#define	IEEE80211_FC1_ORDER			0x80
-
-#define	IEEE80211_SEQ_FRAG_MASK			0x000f
-#define	IEEE80211_SEQ_FRAG_SHIFT		0
-#define	IEEE80211_SEQ_SEQ_MASK			0xfff0
-#define	IEEE80211_SEQ_SEQ_SHIFT			4
-
-#define	IEEE80211_NWID_LEN			32
-
-#define	IEEE80211_QOS_TXOP			0x00ff
-/* bit 8 is reserved */
-#define	IEEE80211_QOS_ACKPOLICY			0x60
-#define	IEEE80211_QOS_ACKPOLICY_S		5
-#define	IEEE80211_QOS_EOSP			0x10
-#define	IEEE80211_QOS_EOSP_S			4
-#define	IEEE80211_QOS_TID			0x0f
-
-#define IEEE80211_FRM_HAS_BODY(_wh)			\
-	(((_wh)->i_fc[0] & IEEE80211_FC0_TYPE_MASK) !=	\
-			IEEE80211_FC0_TYPE_CTL)
-
-/*
- * Country/Region Codes from MS WINNLS.H
- * Numbering from ISO 3166
- * XXX belongs elsewhere
- */
-enum CountryCode {
-	CTRY_ALBANIA              = 8,       /* Albania */
-	CTRY_ALGERIA              = 12,      /* Algeria */
-	CTRY_ARGENTINA            = 32,      /* Argentina */
-	CTRY_ARMENIA              = 51,      /* Armenia */
-	CTRY_AUSTRALIA            = 36,      /* Australia */
-	CTRY_AUSTRIA              = 40,      /* Austria */
-	CTRY_AZERBAIJAN           = 31,      /* Azerbaijan */
-	CTRY_BAHRAIN              = 48,      /* Bahrain */
-	CTRY_BELARUS              = 112,     /* Belarus */
-	CTRY_BELGIUM              = 56,      /* Belgium */
-	CTRY_BELIZE               = 84,      /* Belize */
-	CTRY_BOLIVIA              = 68,      /* Bolivia */
-	CTRY_BRAZIL               = 76,      /* Brazil */
-	CTRY_BRUNEI_DARUSSALAM    = 96,      /* Brunei Darussalam */
-	CTRY_BULGARIA             = 100,     /* Bulgaria */
-	CTRY_CANADA               = 124,     /* Canada */
-	CTRY_CHILE                = 152,     /* Chile */
-	CTRY_CHINA                = 156,     /* People's Republic of China */
-	CTRY_COLOMBIA             = 170,     /* Colombia */
-	CTRY_COSTA_RICA           = 188,     /* Costa Rica */
-	CTRY_CROATIA              = 191,     /* Croatia */
-	CTRY_CYPRUS               = 196,
-	CTRY_CZECH                = 203,     /* Czech Republic */
-	CTRY_DENMARK              = 208,     /* Denmark */
-	CTRY_DOMINICAN_REPUBLIC   = 214,     /* Dominican Republic */
-	CTRY_ECUADOR              = 218,     /* Ecuador */
-	CTRY_EGYPT                = 818,     /* Egypt */
-	CTRY_EL_SALVADOR          = 222,     /* El Salvador */
-	CTRY_ESTONIA              = 233,     /* Estonia */
-	CTRY_FAEROE_ISLANDS       = 234,     /* Faeroe Islands */
-	CTRY_FINLAND              = 246,     /* Finland */
-	CTRY_FRANCE               = 250,     /* France */
-	CTRY_FRANCE2              = 255,     /* France2 */
-	CTRY_GEORGIA              = 268,     /* Georgia */
-	CTRY_GERMANY              = 276,     /* Germany */
-	CTRY_GREECE               = 300,     /* Greece */
-	CTRY_GUATEMALA            = 320,     /* Guatemala */
-	CTRY_HONDURAS             = 340,     /* Honduras */
-	CTRY_HONG_KONG            = 344,     /* Hong Kong S.A.R., P.R.C. */
-	CTRY_HUNGARY              = 348,     /* Hungary */
-	CTRY_ICELAND              = 352,     /* Iceland */
-	CTRY_INDIA                = 356,     /* India */
-	CTRY_INDONESIA            = 360,     /* Indonesia */
-	CTRY_IRAN                 = 364,     /* Iran */
-	CTRY_IRAQ                 = 368,     /* Iraq */
-	CTRY_IRELAND              = 372,     /* Ireland */
-	CTRY_ISRAEL               = 376,     /* Israel */
-	CTRY_ITALY                = 380,     /* Italy */
-	CTRY_JAMAICA              = 388,     /* Jamaica */
-	CTRY_JAPAN                = 392,     /* Japan */
-	CTRY_JAPAN1               = 393,     /* Japan (JP1) */
-	CTRY_JAPAN2               = 394,     /* Japan (JP0) */
-	CTRY_JAPAN3               = 395,     /* Japan (JP1-1) */
-	CTRY_JAPAN4               = 396,     /* Japan (JE1) */
-	CTRY_JAPAN5               = 397,     /* Japan (JE2) */
-	CTRY_JAPAN6               = 399,	 /* Japan (JP6) */
-	CTRY_JAPAN7               = 900,	 /* Japan */
-	CTRY_JAPAN8               = 901,	 /* Japan */
-	CTRY_JAPAN9               = 902,	 /* Japan */
-	CTRY_JAPAN10	      = 903,	 /* Japan */
-	CTRY_JAPAN11	      = 904,	 /* Japan */
-	CTRY_JAPAN12	      = 905,	 /* Japan */
-	CTRY_JAPAN13	      = 906,	 /* Japan */
-	CTRY_JAPAN14	      = 907,	 /* Japan */
-	CTRY_JAPAN15	      = 908,	 /* Japan */
-	CTRY_JAPAN16	      = 909,	 /* Japan */
-	CTRY_JAPAN17	      = 910,	 /* Japan */
-	CTRY_JAPAN18	      = 911,	 /* Japan */
-	CTRY_JAPAN19	      = 912,	 /* Japan */
-	CTRY_JAPAN20	      = 913,	 /* Japan */
-	CTRY_JAPAN21	      = 914,	 /* Japan */
-	CTRY_JAPAN22	      = 915,	 /* Japan */
-	CTRY_JAPAN23	      = 916,	 /* Japan */
-	CTRY_JAPAN24	      = 917,	 /* Japan */
-	CTRY_JAPAN25	      = 918,	 /* Japan */
-	CTRY_JAPAN26	      = 919,	 /* Japan */
-	CTRY_JAPAN27	      = 920,	 /* Japan */
-	CTRY_JAPAN28	      = 921,	 /* Japan */
-	CTRY_JAPAN29	      = 922,	 /* Japan */
-	CTRY_JAPAN30	      = 923,	 /* Japan */
-	CTRY_JAPAN31	      = 924,	 /* Japan */
-	CTRY_JAPAN32	      = 925,	 /* Japan */
-	CTRY_JAPAN33	      = 926,	 /* Japan */
-	CTRY_JAPAN34	      = 927,	 /* Japan */
-	CTRY_JAPAN35	      = 928,	 /* Japan */
-	CTRY_JAPAN36	      = 929,	 /* Japan */
-	CTRY_JAPAN37	      = 930,	 /* Japan */
-	CTRY_JAPAN38	      = 931,	 /* Japan */
-	CTRY_JAPAN39	      = 932,	 /* Japan */
-	CTRY_JAPAN40	      = 933,	 /* Japan */
-	CTRY_JAPAN41	      = 934,	 /* Japan */
-	CTRY_JAPAN42	      = 935,	 /* Japan */
-	CTRY_JAPAN43	      = 936,	 /* Japan */
-	CTRY_JAPAN44	      = 937,	 /* Japan */
-	CTRY_JAPAN45	      = 938,	 /* Japan */
-	CTRY_JAPAN46	      = 939,	 /* Japan */
-	CTRY_JAPAN47	      = 940,	 /* Japan */
-	CTRY_JAPAN48	      = 941,	 /* Japan */
-	CTRY_JORDAN               = 400,     /* Jordan */
-	CTRY_KAZAKHSTAN           = 398,     /* Kazakhstan */
-	CTRY_KENYA                = 404,     /* Kenya */
-	CTRY_KOREA_NORTH          = 408,     /* North Korea */
-	CTRY_KOREA_ROC            = 410,     /* South Korea */
-	CTRY_KOREA_ROC2           = 411,     /* South Korea */
-	CTRY_KUWAIT               = 414,     /* Kuwait */
-	CTRY_LATVIA               = 428,     /* Latvia */
-	CTRY_LEBANON              = 422,     /* Lebanon */
-	CTRY_LIBYA                = 434,     /* Libya */
-	CTRY_LIECHTENSTEIN        = 438,     /* Liechtenstein */
-	CTRY_LITHUANIA            = 440,     /* Lithuania */
-	CTRY_LUXEMBOURG           = 442,     /* Luxembourg */
-	CTRY_MACAU                = 446,     /* Macau */
-	CTRY_MACEDONIA            = 807,     /* the Former Yugoslav Republic of Macedonia */
-	CTRY_MALAYSIA             = 458,     /* Malaysia */
-	CTRY_MEXICO               = 484,     /* Mexico */
-	CTRY_MONACO               = 492,     /* Principality of Monaco */
-	CTRY_MOROCCO              = 504,     /* Morocco */
-	CTRY_NETHERLANDS          = 528,     /* Netherlands */
-	CTRY_NEW_ZEALAND          = 554,     /* New Zealand */
-	CTRY_NICARAGUA            = 558,     /* Nicaragua */
-	CTRY_NORWAY               = 578,     /* Norway */
-	CTRY_OMAN                 = 512,     /* Oman */
-	CTRY_PAKISTAN             = 586,     /* Islamic Republic of Pakistan */
-	CTRY_PANAMA               = 591,     /* Panama */
-	CTRY_PARAGUAY             = 600,     /* Paraguay */
-	CTRY_PERU                 = 604,     /* Peru */
-	CTRY_PHILIPPINES          = 608,     /* Republic of the Philippines */
-	CTRY_POLAND               = 616,     /* Poland */
-	CTRY_PORTUGAL             = 620,     /* Portugal */
-	CTRY_PUERTO_RICO          = 630,     /* Puerto Rico */
-	CTRY_QATAR                = 634,     /* Qatar */
-	CTRY_ROMANIA              = 642,     /* Romania */
-	CTRY_RUSSIA               = 643,     /* Russia */
-	CTRY_SAUDI_ARABIA         = 682,     /* Saudi Arabia */
-	CTRY_SINGAPORE            = 702,     /* Singapore */
-	CTRY_SLOVAKIA             = 703,     /* Slovak Republic */
-	CTRY_SLOVENIA             = 705,     /* Slovenia */
-	CTRY_SOUTH_AFRICA         = 710,     /* South Africa */
-	CTRY_SPAIN                = 724,     /* Spain */
-	CTRY_SWEDEN               = 752,     /* Sweden */
-	CTRY_SWITZERLAND          = 756,     /* Switzerland */
-	CTRY_SYRIA                = 760,     /* Syria */
-	CTRY_TAIWAN               = 158,     /* Taiwan */
-	CTRY_THAILAND             = 764,     /* Thailand */
-	CTRY_TRINIDAD_Y_TOBAGO    = 780,     /* Trinidad y Tobago */
-	CTRY_TUNISIA              = 788,     /* Tunisia */
-	CTRY_TURKEY               = 792,     /* Turkey */
-	CTRY_UAE                  = 784,     /* U.A.E. */
-	CTRY_UKRAINE              = 804,     /* Ukraine */
-	CTRY_UNITED_KINGDOM       = 826,     /* United Kingdom */
-	CTRY_UNITED_STATES        = 840,     /* United States */
-	CTRY_UNITED_STATES_FCC49  = 842,     /* United States (Public Safety)*/
-	CTRY_URUGUAY              = 858,     /* Uruguay */
-	CTRY_UZBEKISTAN           = 860,     /* Uzbekistan */
-	CTRY_VENEZUELA            = 862,     /* Venezuela */
-	CTRY_VIET_NAM             = 704,     /* Viet Nam */
-	CTRY_YEMEN                = 887,     /* Yemen */
-	CTRY_ZIMBABWE             = 716      /* Zimbabwe */
-};
-
-/* 
- * Generic information element
- */
-struct ieee80211_ie {
-	u_int8_t id;
-	u_int8_t len;
-	u_int8_t info[0];
-} __packed;
-
-/* 
- * Country information element.
- */
-#define IEEE80211_COUNTRY_MAX_TRIPLETS (83)
-struct ieee80211_ie_country {
-	u_int8_t country_id;
-	u_int8_t country_len;
-	u_int8_t country_str[3];
-	u_int8_t country_triplet[IEEE80211_COUNTRY_MAX_TRIPLETS * 3];
-} __packed;
-
-/*
- * Power Constraint information element.
- */
-struct ieee80211_ie_pwrcnstr {
-	u_int8_t pc_id;			/* IEEE80211_ELEMID_PWRCNSTR */
-	u_int8_t pc_len;		/* == 2 */
-	u_int8_t pc_lpc;		/* Local Power Constraint [dB] */
-} __packed;
-
-/*
- * Power Capability information element.
- */
-struct ieee80211_ie_pwrcap {
-	u_int8_t pc_id;			/* IEEE80211_ELEMID_PWRCAP */
-	u_int8_t pc_len;		/* == 2 */
-	int8_t pc_mintxpow;		/* Minimum Transmit Power Capability [dBm] */
-	int8_t pc_maxtxpow;		/* Maximum Transmit Power Capability [dBm] */
-} __packed;
-
-/*
- * Supported Channels information element.
- */
-#define IEEE80211_SUPPCHAN_MAX_PAIRS (127)
-struct ieee80211_ie_sc {
-	u_int8_t sc_id;			/* IEEE80211_ELEMID_SUPPCHAN */
-	u_int8_t sc_len;		/* == 2 * number of sc_subband elements */
-	struct {
-		u_int8_t sc_first;	/* First Channel Number */
-		u_int8_t sc_number;	/* Number of Channels */
-	} __packed sc_subband[IEEE80211_SUPPCHAN_MAX_PAIRS];
-} __packed;
-
-/*
- * Channel Switch Announcement information element.
- */
-struct ieee80211_ie_csa {
-	u_int8_t csa_id;	/* IEEE80211_ELEMID_CHANSWITCHANN */
-	u_int8_t csa_len;	/* == 3 */
-	u_int8_t csa_mode;	/* Channel Switch Mode: 1 == stop transmission until CS */
-	u_int8_t csa_chan;	/* New Channel Number */
-	u_int8_t csa_count;	/* TBTTs until Channel Switch happens */
-} __packed;
-
-/* minimal Channel Switch Count in the initial announcement */
-#define IEEE80211_CSA_PROTECTION_PERIOD 3
-
-/* maximum allowed deviance of measurement of intervals between CSA in Beacons */
-#define IEEE80211_CSA_SANITY_THRESHOLD 100
-
-
-/* does frame have QoS sequence control data */
-#define	IEEE80211_QOS_HAS_SEQ(wh) \
-	(((wh)->i_fc[0] & \
-	  (IEEE80211_FC0_TYPE_MASK | IEEE80211_FC0_SUBTYPE_QOS)) == \
-	  (IEEE80211_FC0_TYPE_DATA | IEEE80211_FC0_SUBTYPE_QOS))
-
-#define WME_QOSINFO_COUNT	0x0f  /* Mask for Param Set Count field */
-/*
- * WME/802.11e information element.
- */
-struct ieee80211_ie_wme {
-	u_int8_t wme_id;		/* IEEE80211_ELEMID_VENDOR */
-	u_int8_t wme_len;	/* length in bytes */
-	u_int8_t wme_oui[3];	/* 0x00, 0x50, 0xf2 */
-	u_int8_t wme_type;	/* OUI type */
-	u_int8_t wme_subtype;	/* OUI subtype */
-	u_int8_t wme_version;	/* spec revision */
-	u_int8_t wme_info;	/* QoS info */
-} __packed;
-
-/*
- * WME/802.11e Tspec Element
- */
-struct ieee80211_wme_tspec {
-	u_int8_t ts_id;
-	u_int8_t ts_len;
-	u_int8_t ts_oui[3];
-	u_int8_t ts_oui_type;
-	u_int8_t ts_oui_subtype;
-	u_int8_t ts_version;
-	u_int8_t ts_tsinfo[3];
-	u_int8_t ts_nom_msdu[2];
-	u_int8_t ts_max_msdu[2];
-	u_int8_t ts_min_svc[4];
-	u_int8_t ts_max_svc[4];
-	u_int8_t ts_inactv_intv[4];
-	u_int8_t ts_susp_intv[4];
-	u_int8_t ts_start_svc[4];
-	u_int8_t ts_min_rate[4];
-	u_int8_t ts_mean_rate[4];
-	u_int8_t ts_max_burst[4];
-	u_int8_t ts_min_phy[4];
-	u_int8_t ts_peak_rate[4];
-	u_int8_t ts_delay[4];
-	u_int8_t ts_surplus[2];
-	u_int8_t ts_medium_time[2];
-} __packed;
-
-/*
- * WME AC parameter field
- */
-
-struct ieee80211_wme_acparams {
-	u_int8_t acp_aci_aifsn;
-	u_int8_t acp_logcwminmax;
-	u_int16_t acp_txop;
-} __packed;
-
-#define IEEE80211_WME_PARAM_LEN 24
-#define WME_NUM_AC		4	/* 4 AC categories */
-
-#define WME_PARAM_ACI		0x60	/* Mask for ACI field */
-#define WME_PARAM_ACI_S		5	/* Shift for ACI field */
-#define WME_PARAM_ACM		0x10	/* Mask for ACM bit */
-#define WME_PARAM_ACM_S		4	/* Shift for ACM bit */
-#define WME_PARAM_AIFSN		0x0f	/* Mask for aifsn field */
-#define WME_PARAM_AIFSN_S	0	/* Shift for aifsn field */
-#define WME_PARAM_LOGCWMIN	0x0f	/* Mask for CwMin field (in log) */
-#define WME_PARAM_LOGCWMIN_S	0	/* Shift for CwMin field */
-#define WME_PARAM_LOGCWMAX	0xf0	/* Mask for CwMax field (in log) */
-#define WME_PARAM_LOGCWMAX_S	4	/* Shift for CwMax field */
-
-#define WME_AC_TO_TID(_ac) (       \
-	((_ac) == WME_AC_VO) ? 6 : \
-	((_ac) == WME_AC_VI) ? 5 : \
-	((_ac) == WME_AC_BK) ? 1 : \
-	0)
-
-#define TID_TO_WME_AC(_tid) (      \
-	((_tid) < 1) ? WME_AC_BE : \
-	((_tid) < 3) ? WME_AC_BK : \
-	((_tid) < 6) ? WME_AC_VI : \
-	WME_AC_VO)
-
-/*
- * WME Parameter Element
- */
-
-struct ieee80211_wme_param {
-	u_int8_t param_id;
-	u_int8_t param_len;
-	u_int8_t param_oui[3];
-	u_int8_t param_oui_type;
-	u_int8_t param_oui_sybtype;
-	u_int8_t param_version;
-	u_int8_t param_qosInfo;
-	u_int8_t param_reserved;
-	struct ieee80211_wme_acparams	params_acParams[WME_NUM_AC];
-} __packed;
-
-/*
- * WME U-APSD qos info field defines
- */
-#define WME_CAPINFO_UAPSD_EN			0x00000080
-#define WME_CAPINFO_UAPSD_VO			0x00000001
-#define WME_CAPINFO_UAPSD_VI			0x00000002
-#define WME_CAPINFO_UAPSD_BK			0x00000004
-#define WME_CAPINFO_UAPSD_BE			0x00000008
-#define WME_CAPINFO_UAPSD_ACFLAGS_SHIFT		0
-#define WME_CAPINFO_UAPSD_ACFLAGS_MASK		0xF
-#define WME_CAPINFO_UAPSD_MAXSP_SHIFT		5
-#define WME_CAPINFO_UAPSD_MAXSP_MASK		0x3
-#define WME_CAPINFO_IE_OFFSET			8
-#define WME_UAPSD_MAXSP(_qosinfo)					\
-		(((_qosinfo) >> WME_CAPINFO_UAPSD_MAXSP_SHIFT) & 	\
-		 WME_CAPINFO_UAPSD_MAXSP_MASK)
-#define WME_UAPSD_AC_ENABLED(_ac, _qosinfo)				\
-		((1 << (3 - (_ac))) & (					\
-		 ((_qosinfo) >> WME_CAPINFO_UAPSD_ACFLAGS_SHIFT) &	\
-		 WME_CAPINFO_UAPSD_ACFLAGS_MASK))
-
-/*
- * Atheros Advanced Capability information element.
- */
-struct ieee80211_ie_athAdvCap {
-	u_int8_t athAdvCap_id;		/* IEEE80211_ELEMID_VENDOR */
-	u_int8_t athAdvCap_len;		/* length in bytes */
-	u_int8_t athAdvCap_oui[3];	/* 0x00, 0x03, 0x7f */
-	u_int8_t athAdvCap_type;	/* OUI type */
-	u_int8_t athAdvCap_subtype;	/* OUI subtype */
-	u_int8_t athAdvCap_version;	/* spec revision */
-	u_int8_t athAdvCap_capability;	/* Capability info */
-	u_int16_t athAdvCap_defKeyIndex;
-} __packed;
-
-/*
- * Atheros XR information element.
- */
-struct ieee80211_xr_param {
-	u_int8_t param_id;
-	u_int8_t param_len;
-	u_int8_t param_oui[3];
-	u_int8_t param_oui_type;
-	u_int8_t param_oui_sybtype;
-	u_int8_t param_version;
-	u_int8_t param_Info;
-	u_int8_t param_base_bssid[IEEE80211_ADDR_LEN];
-	u_int8_t param_xr_bssid[IEEE80211_ADDR_LEN];
-	u_int16_t param_xr_beacon_interval;
-	u_int8_t param_base_ath_capability;
-	u_int8_t param_xr_ath_capability;
-} __packed;
-
-/* Atheros capabilities */
-#define IEEE80211_ATHC_TURBOP	0x0001		/* Turbo Prime */
-#define IEEE80211_ATHC_COMP	0x0002		/* Compression */
-#define IEEE80211_ATHC_FF	0x0004		/* Fast Frames */
-#define IEEE80211_ATHC_XR	0x0008		/* Xtended Range support */
-#define IEEE80211_ATHC_AR	0x0010		/* Advanced Radar support */
-#define IEEE80211_ATHC_BURST	0x0020		/* Bursting - not negotiated */
-#define IEEE80211_ATHC_WME	0x0040		/* CWMin tuning */
-#define IEEE80211_ATHC_BOOST	0x0080		/* Boost */
-
-/*
- * Management Notification Frame
- */
-struct ieee80211_mnf {
-	u_int8_t mnf_category;
-	u_int8_t mnf_action;
-	u_int8_t mnf_dialog;
-	u_int8_t mnf_status;
-} __packed;
-#define	MNF_SETUP_REQ	0
-#define	MNF_SETUP_RESP	1
-#define	MNF_TEARDOWN	2
-
-/*
- * Control frames.
- */
-struct ieee80211_frame_min {
-	u_int8_t i_fc[2];
-	__le16 i_dur;
-	u_int8_t i_addr1[IEEE80211_ADDR_LEN];
-	u_int8_t i_addr2[IEEE80211_ADDR_LEN];
-	/* FCS */
-} __packed;
-
-struct ieee80211_frame_rts {
-	u_int8_t i_fc[2];
-	__le16 i_dur;
-	u_int8_t i_ra[IEEE80211_ADDR_LEN];
-	u_int8_t i_ta[IEEE80211_ADDR_LEN];
-	/* FCS */
-} __packed;
-
-struct ieee80211_frame_cts {
-	u_int8_t i_fc[2];
-	__le16 i_dur;
-	u_int8_t i_ra[IEEE80211_ADDR_LEN];
-	/* FCS */
-} __packed;
-
-struct ieee80211_frame_ack {
-	u_int8_t i_fc[2];
-	__le16 i_dur;
-	u_int8_t i_ra[IEEE80211_ADDR_LEN];
-	/* FCS */
-} __packed;
-
-struct ieee80211_frame_pspoll {
-	u_int8_t i_fc[2];
-	u_int8_t i_aid[2];
-	u_int8_t i_bssid[IEEE80211_ADDR_LEN];
-	u_int8_t i_ta[IEEE80211_ADDR_LEN];
-	/* FCS */
-} __packed;
-
-struct ieee80211_frame_cfend {		/* NB: also CF-End+CF-Ack */
-	u_int8_t i_fc[2];
-	__le16 i_dur;	/* should be zero */
-	u_int8_t i_ra[IEEE80211_ADDR_LEN];
-	u_int8_t i_bssid[IEEE80211_ADDR_LEN];
-	/* FCS */
-} __packed;
-
-/*
- * BEACON management packets
- *
- *	octet timestamp[8]
- *	octet beacon interval[2]
- *	octet capability information[2]
- *	information element
- *		octet elemid
- *		octet length
- *		octet information[length]
- */
-
-typedef u_int8_t *ieee80211_mgt_beacon_t;
-
-#define	IEEE80211_BEACON_INTERVAL(beacon) \
-	((beacon)[8] | ((beacon)[9] << 8))
-#define	IEEE80211_BEACON_CAPABILITY(beacon) \
-	((beacon)[10] | ((beacon)[11] << 8))
-
-#define	IEEE80211_CAPINFO_ESS			0x0001
-#define	IEEE80211_CAPINFO_IBSS			0x0002
-#define	IEEE80211_CAPINFO_CF_POLLABLE		0x0004
-#define	IEEE80211_CAPINFO_CF_POLLREQ		0x0008
-#define	IEEE80211_CAPINFO_PRIVACY		0x0010
-#define	IEEE80211_CAPINFO_SHORT_PREAMBLE	0x0020
-#define	IEEE80211_CAPINFO_PBCC			0x0040
-#define	IEEE80211_CAPINFO_CHNL_AGILITY		0x0080
-/* bits 8-9 are reserved (8 now for spectrum management) */
-#define IEEE80211_CAPINFO_SPECTRUM_MGMT		0x0100
-#define	IEEE80211_CAPINFO_SHORT_SLOTTIME	0x0400
-#define	IEEE80211_CAPINFO_RSN			0x0800
-/* bit 12 is reserved */
-#define	IEEE80211_CAPINFO_DSSSOFDM		0x2000
-/* bits 14-15 are reserved */
-
-/*
- * 802.11i/WPA information element (maximally sized).
- */
-struct ieee80211_ie_wpa {
-	u_int8_t wpa_id;			/* IEEE80211_ELEMID_VENDOR */
-	u_int8_t wpa_len;		/* length in bytes */
-	u_int8_t wpa_oui[3];		/* 0x00, 0x50, 0xf2 */
-	u_int8_t wpa_type;		/* OUI type */
-	u_int16_t wpa_version;		/* spec revision */
-	u_int32_t wpa_mcipher[1];	/* multicast/group key cipher */
-	u_int16_t wpa_uciphercnt;	/* # pairwise key ciphers */
-	u_int32_t wpa_uciphers[8];	/* ciphers */
-	u_int16_t wpa_authselcnt;	/* authentication selector cnt*/
-	u_int32_t wpa_authsels[8];	/* selectors */
-	u_int16_t wpa_caps;		/* 802.11i capabilities */
-	u_int16_t wpa_pmkidcnt;		/* 802.11i pmkid count */
-	u_int16_t wpa_pmkids[8];	/* 802.11i pmkids */
-} __packed;
-
-/*
- * Management information element payloads.
- */
-
-enum {
-	IEEE80211_ELEMID_SSID		= 0,
-	IEEE80211_ELEMID_RATES		= 1,
-	IEEE80211_ELEMID_FHPARMS	= 2,
-	IEEE80211_ELEMID_DSPARMS	= 3,
-	IEEE80211_ELEMID_CFPARMS	= 4,
-	IEEE80211_ELEMID_TIM		= 5,
-	IEEE80211_ELEMID_IBSSPARMS	= 6,
-	IEEE80211_ELEMID_COUNTRY	= 7,
-	IEEE80211_ELEMID_HOPPATRNPARMS  = 8,
-	IEEE80211_ELEMID_HOPPATRNTABLE  = 9,
-	IEEE80211_ELEMID_REQINFO	= 10,
-	IEEE80211_ELEMID_QBSSLOAD       = 11,
-	IEEE80211_ELEMID_EDCAPARAM      = 12,
-	IEEE80211_ELEMID_TSPEC		= 13,
-	IEEE80211_ELEMID_TRAFCLASS      = 14,
-	IEEE80211_ELEMID_SCHEDULE       = 15,
-	IEEE80211_ELEMID_CHALLENGE	= 16,
-	/* 17-31 reserved for challenge text extension */
-	IEEE80211_ELEMID_PWRCNSTR	= 32,
-	IEEE80211_ELEMID_PWRCAP		= 33,
-	IEEE80211_ELEMID_TPCREQ		= 34,
-	IEEE80211_ELEMID_TPCREP		= 35,
-	IEEE80211_ELEMID_SUPPCHAN	= 36,
-	IEEE80211_ELEMID_CHANSWITCHANN	= 37,
-	IEEE80211_ELEMID_MEASREQ	= 38,
-	IEEE80211_ELEMID_MEASREP	= 39,
-	IEEE80211_ELEMID_QUIET		= 40,
-	IEEE80211_ELEMID_IBSSDFS	= 41,
-	IEEE80211_ELEMID_ERP		= 42,
-	IEEE80211_ELEMID_TSDELAY	= 43,
-	IEEE80211_ELEMID_TCLASSPROC     = 44,
-	IEEE80211_ELEMID_QOS		= 46,
-	IEEE80211_ELEMID_RSN		= 48,
-	/* 49 reserved */
-	IEEE80211_ELEMID_XRATES		= 50,
-	/* 128-129 proprietary elements used by Agere chipsets */
-	IEEE80211_ELEMID_AGERE1		= 128,
-	IEEE80211_ELEMID_AGERE2		= 129,
-	IEEE80211_ELEMID_TPC		= 150,
-	IEEE80211_ELEMID_CCKM		= 156,
-	IEEE80211_ELEMID_VENDOR		= 221,	/* vendor private */
-};
-
-#define IEEE80211_CHANSWITCHANN_BYTES 	5
-#define BITCTL_BUFD_MCAST       	1
-#define BITCTL_BUFD_UCAST_AID_MASK 	((u_int8_t)~(BITCTL_BUFD_MCAST))
-#define BITCTL_BUFD_UCAST_AID_SHIFT 	1
-
-struct ieee80211_tim_ie {
-	u_int8_t	tim_ie;			/* IEEE80211_ELEMID_TIM */
-	u_int8_t	tim_len;
-	u_int8_t	tim_count;		/* DTIM count */
-	u_int8_t	tim_period;		/* DTIM period */
-	u_int8_t	tim_bitctl;		/* bitmap control */
-	u_int8_t	tim_bitmap[1];		/* variable-length bitmap */
-} __packed;
-
-struct ieee80211_country_ie {
-	u_int8_t	ie;			/* IEEE80211_ELEMID_COUNTRY */
-	u_int8_t	len;
-	u_int8_t	cc[3];			/* ISO CC+(I)ndoor/(O)utdoor */
-	struct {
-		u_int8_t schan;			/* starting channel */
-		u_int8_t nchan;			/* number channels */
-		u_int8_t maxtxpwr;		/* tx power cap */
-	} __packed band[4];			/* up to 4 sub bands */
-} __packed;
-
-#define IEEE80211_CHALLENGE_LEN		128
-
-#define IEEE80211_SUPPCHAN_LEN		26
-
-#define	IEEE80211_RATE_BASIC		0x80
-#define	IEEE80211_RATE_VAL		0x7f
-
-/* EPR information element flags */
-#define	IEEE80211_ERP_NON_ERP_PRESENT	0x01
-#define	IEEE80211_ERP_USE_PROTECTION	0x02
-#define	IEEE80211_ERP_LONG_PREAMBLE	0x04
-
-/* Atheros private advanced capabilities info */
-#define	ATHEROS_CAP_TURBO_PRIME		0x01
-#define	ATHEROS_CAP_COMPRESSION		0x02
-#define	ATHEROS_CAP_FAST_FRAME		0x04
-/* bits 3-6 reserved */
-#define	ATHEROS_CAP_BOOST		0x80
-
-#define	ATH_OUI			0x7f0300		/* Atheros OUI */
-#define	ATH_OUI_TYPE		0x01
-#define	ATH_OUI_SUBTYPE		0x01
-#define	ATH_OUI_VERSION		0x00
-#define	ATH_OUI_TYPE_XR		0x03
-#define	ATH_OUI_SUBTYPE_XR	0x01
-#define	ATH_OUI_VER_XR		0x00
-
-#define	WPA_OUI			0xf25000
-#define	WPA_OUI_TYPE		0x01
-#define	WPA_VERSION		1		/* current supported version */
-
-#define	WPA_CSE_NULL		0x00
-#define	WPA_CSE_WEP40		0x01
-#define	WPA_CSE_TKIP		0x02
-#define	WPA_CSE_CCMP		0x04
-#define	WPA_CSE_WEP104		0x05
-
-#define	WPA_ASE_NONE		0x00
-#define	WPA_ASE_8021X_UNSPEC	0x01
-#define	WPA_ASE_8021X_PSK	0x02
-
-#define	RSN_OUI			0xac0f00
-#define	RSN_VERSION		1		/* current supported version */
-
-#define	RSN_CSE_NULL		0x00
-#define	RSN_CSE_WEP40		0x01
-#define	RSN_CSE_TKIP		0x02
-#define	RSN_CSE_WRAP		0x03
-#define	RSN_CSE_CCMP		0x04
-#define	RSN_CSE_WEP104		0x05
-
-#define	RSN_ASE_NONE		0x00
-#define	RSN_ASE_8021X_UNSPEC	0x01
-#define	RSN_ASE_8021X_PSK	0x02
-
-#define	RSN_CAP_PREAUTH		0x01
-
-#define	WME_OUI			0xf25000
-#define	WME_OUI_TYPE		0x02
-#define	WME_INFO_OUI_SUBTYPE	0x00
-#define	WME_PARAM_OUI_SUBTYPE	0x01
-#define	WME_VERSION		1
-
-/* WME stream classes */
-#define	WME_AC_BE	0		/* best effort */
-#define	WME_AC_BK	1		/* background */
-#define	WME_AC_VI	2		/* video */
-#define	WME_AC_VO	3		/* voice */
-
-/*
- * AUTH management packets
- *
- *	octet algo[2]
- *	octet seq[2]
- *	octet status[2]
- *	octet chal.id
- *	octet chal.length
- *	octet chal.text[253]
- */
-
-typedef u_int8_t *ieee80211_mgt_auth_t;
-
-#define	IEEE80211_AUTH_ALGORITHM(auth) \
-	((auth)[0] | ((auth)[1] << 8))
-#define	IEEE80211_AUTH_TRANSACTION(auth) \
-	((auth)[2] | ((auth)[3] << 8))
-#define	IEEE80211_AUTH_STATUS(auth) \
-	((auth)[4] | ((auth)[5] << 8))
-
-#define	IEEE80211_AUTH_ALG_OPEN		0x0000
-#define	IEEE80211_AUTH_ALG_SHARED	0x0001
-#define	IEEE80211_AUTH_ALG_LEAP		0x0080
-
-enum {
-	IEEE80211_AUTH_OPEN_REQUEST		= 1,
-	IEEE80211_AUTH_OPEN_RESPONSE		= 2,
-};
-
-enum {
-	IEEE80211_AUTH_SHARED_REQUEST		= 1,
-	IEEE80211_AUTH_SHARED_CHALLENGE		= 2,
-	IEEE80211_AUTH_SHARED_RESPONSE		= 3,
-	IEEE80211_AUTH_SHARED_PASS		= 4,
-};
-
-/*
- * Reason codes
- *
- * Unlisted codes are reserved
- */
-
-enum {
-	IEEE80211_REASON_UNSPECIFIED		= 1,
-	IEEE80211_REASON_AUTH_EXPIRE		= 2,
-	IEEE80211_REASON_AUTH_LEAVE		= 3,
-	IEEE80211_REASON_ASSOC_EXPIRE		= 4,
-	IEEE80211_REASON_ASSOC_TOOMANY		= 5,
-	IEEE80211_REASON_NOT_AUTHED		= 6,
-	IEEE80211_REASON_NOT_ASSOCED		= 7,
-	IEEE80211_REASON_ASSOC_LEAVE		= 8,
-	IEEE80211_REASON_ASSOC_NOT_AUTHED	= 9,
-
-	IEEE80211_REASON_PWRCAP_UNACCEPTABLE	= 10,
-	IEEE80211_REASON_SUPPCHAN_UNACCEPTABLE	= 11,
-	IEEE80211_REASON_RSN_REQUIRED		= 11,
-	IEEE80211_REASON_RSN_INCONSISTENT	= 12,
-	IEEE80211_REASON_IE_INVALID		= 13,
-	IEEE80211_REASON_MIC_FAILURE		= 14,
-
-	IEEE80211_STATUS_SUCCESS		= 0,
-	IEEE80211_STATUS_UNSPECIFIED		= 1,
-	IEEE80211_STATUS_CAPINFO		= 10,
-	IEEE80211_STATUS_NOT_ASSOCED		= 11,
-	IEEE80211_STATUS_OTHER			= 12,
-	IEEE80211_STATUS_ALG			= 13,
-	IEEE80211_STATUS_SEQUENCE		= 14,
-	IEEE80211_STATUS_CHALLENGE		= 15,
-	IEEE80211_STATUS_TIMEOUT		= 16,
-	IEEE80211_STATUS_TOOMANY		= 17,
-	IEEE80211_STATUS_BASIC_RATE		= 18,
-	IEEE80211_STATUS_SP_REQUIRED		= 19,
-	IEEE80211_STATUS_PBCC_REQUIRED		= 20,
-	IEEE80211_STATUS_CA_REQUIRED		= 21,
-	IEEE80211_STATUS_SM_REQUIRED		= 22,
-	IEEE80211_STATUS_PWRCAP_UNACCEPTABLE	= 23,
-	IEEE80211_STATUS_SUPPCHAN_UNACCEPTABLE	= 24,
-	IEEE80211_STATUS_TOO_MANY_STATIONS	= 22,
-	IEEE80211_STATUS_RATES			= 23,
-	IEEE80211_STATUS_SHORTSLOT_REQUIRED	= 25,
-	IEEE80211_STATUS_DSSSOFDM_REQUIRED	= 26,
-};
-
-#define	IEEE80211_WEP_KEYLEN		5	/* 40bit */
-#define	IEEE80211_WEP_IVLEN		3	/* 24bit */
-#define	IEEE80211_WEP_KIDLEN		1	/* 1 octet */
-#define	IEEE80211_WEP_CRCLEN		4	/* CRC-32 */
-#define	IEEE80211_WEP_NKID		4	/* number of key ids */
-
-/*
- * 802.11i defines an extended IV for use with non-WEP ciphers.
- * When the EXTIV bit is set in the key id byte an additional
- * 4 bytes immediately follow the IV for TKIP.  For CCMP the
- * EXTIV bit is likewise set but the 8 bytes represent the
- * CCMP header rather than IV+extended-IV.
- */
-#define	IEEE80211_WEP_EXTIV		0x20
-#define	IEEE80211_WEP_EXTIVLEN		4	/* extended IV length */
-#define	IEEE80211_WEP_MICLEN		8	/* trailing MIC */
-
-#define	IEEE80211_CRC_LEN		4
-
-/*
- * Maximum acceptable MTU is:
- *	IEEE80211_MAX_LEN - WEP overhead - CRC -
- *		QoS overhead - RSN/WPA overhead
- * Min is arbitrarily chosen > IEEE80211_MIN_LEN.  The default
- * mtu is Ethernet-compatible; it's set by ether_ifattach.
- */
-#define	IEEE80211_MTU_MAX		2290
-#define	IEEE80211_MTU_MIN		32
-
-#define	IEEE80211_MAX_LEN		(2300 + IEEE80211_CRC_LEN + \
-	(IEEE80211_WEP_IVLEN + IEEE80211_WEP_KIDLEN + IEEE80211_WEP_CRCLEN))
-#define	IEEE80211_ACK_LEN \
-	(sizeof(struct ieee80211_frame_ack) + IEEE80211_CRC_LEN)
-#define	IEEE80211_MIN_LEN \
-	(sizeof(struct ieee80211_frame_min) + IEEE80211_CRC_LEN)
-
-/*
- * The 802.11 spec says at most 2007 stations may be
- * associated at once.  For most APs this is way more
- * than is feasible so we use a default of 128.  This
- * number may be overridden by the driver and/or by
- * user configuration.
- */
-#define	IEEE80211_AID_MAX		2007
-#define	IEEE80211_AID_DEF		128
-
-#define	IEEE80211_AID(b)	((b) &~ 0xc000)
-
-/* 
- * RTS frame length parameters.  The default is specified in
- * the 802.11 spec.  The max may be wrong for jumbo frames.
- */
-#define	IEEE80211_RTS_DEFAULT		512
-#define	IEEE80211_RTS_MIN		1
-#define	IEEE80211_RTS_MAX		2346
-
-/* 
- * Regulatory extension identifier for country IE.
- */
-#define IEEE80211_REG_EXT_ID		201
-
-/*
- * IEEE 802.11 timer synchronization function (TSF) timestamp length
- */
-#define IEEE80211_TSF_LEN		8
-
-#endif /* _NET80211_IEEE80211_H_ */
diff --git a/package/hostapd/madwifi/net80211/ieee80211_crypto.h b/package/hostapd/madwifi/net80211/ieee80211_crypto.h
deleted file mode 100644
index b34f359..0000000
--- a/package/hostapd/madwifi/net80211/ieee80211_crypto.h
+++ /dev/null
@@ -1,207 +0,0 @@
-/*-
- * Copyright (c) 2001 Atsushi Onoe
- * Copyright (c) 2002-2005 Sam Leffler, Errno Consulting
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * Alternatively, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") version 2 as published by the Free
- * Software Foundation.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- *
- * $Id: ieee80211_crypto.h 3068 2007-12-21 17:46:02Z mentor $
- */
-#ifndef _NET80211_IEEE80211_CRYPTO_H_
-#define _NET80211_IEEE80211_CRYPTO_H_
-
-/*
- * 802.11 protocol crypto-related definitions.
- */
-#define	IEEE80211_KEYBUF_SIZE	16
-#define	IEEE80211_MICBUF_SIZE	(8 + 8)		/* space for both TX & RX keys */
-#define IEEE80211_TID_SIZE	17		/* total number of TIDs */
-
-/*
- * Old WEP-style key.  Deprecated.
- */
-struct ieee80211_wepkey {
-	u_int wk_len;				/* key length in bytes */
-	u_int8_t wk_key[IEEE80211_KEYBUF_SIZE];
-};
-
-struct ieee80211_cipher;
-
-/*
- * Crypto key state.  There is sufficient room for all supported
- * ciphers (see below).  The underlying ciphers are handled
- * separately through loadable cipher modules that register with
- * the generic crypto support.  A key has a reference to an instance
- * of the cipher; any per-key state is hung off wk_private by the
- * cipher when it is attached.  Ciphers are automatically called
- * to detach and cleanup any such state when the key is deleted.
- *
- * The generic crypto support handles encap/decap of cipher-related
- * frame contents for both hardware- and software-based implementations.
- * A key requiring software crypto support is automatically flagged and
- * the cipher is expected to honor this and do the necessary work.
- * Ciphers such as TKIP may also support mixed hardware/software
- * encrypt/decrypt and MIC processing.
- */
-
-typedef u_int16_t ieee80211_keyix_t;
-
-/* XXX pack better? */
-/* XXX 48-bit rsc/tsc */
-struct ieee80211_key {
-	u_int8_t wk_keylen;		/* key length in bytes */
-	u_int8_t wk_flags;
-#define	IEEE80211_KEY_XMIT	0x01	/* key used for xmit */
-#define	IEEE80211_KEY_RECV	0x02	/* key used for recv */
-#define	IEEE80211_KEY_GROUP	0x04	/* key used for WPA group operation */
-#define	IEEE80211_KEY_SWCRYPT	0x10	/* host-based encrypt/decrypt */
-#define	IEEE80211_KEY_SWMIC	0x20	/* host-based enmic/demic */
-	ieee80211_keyix_t wk_keyix;	/* key index */
-	u_int8_t wk_key[IEEE80211_KEYBUF_SIZE+IEEE80211_MICBUF_SIZE];
-#define	wk_txmic	wk_key+IEEE80211_KEYBUF_SIZE+0	/* XXX can't () right */
-#define	wk_rxmic	wk_key+IEEE80211_KEYBUF_SIZE+8	/* XXX can't () right */
-	u_int64_t wk_keyrsc[IEEE80211_TID_SIZE];	/* key receive sequence counter */
-	u_int64_t wk_keytsc;		/* key transmit sequence counter */
-	const struct ieee80211_cipher *wk_cipher;
-	void *wk_private;		/* private cipher state */
-};
-#define	IEEE80211_KEY_COMMON 		/* common flags passed in by apps */\
-	(IEEE80211_KEY_XMIT | IEEE80211_KEY_RECV | IEEE80211_KEY_GROUP)
-
-/*
- * NB: these values are ordered carefully; there are lots of
- * of implications in any reordering.  In particular beware
- * that 4 is not used to avoid conflicting with IEEE80211_F_PRIVACY.
- */
-#define	IEEE80211_CIPHER_WEP		0
-#define	IEEE80211_CIPHER_TKIP		1
-#define	IEEE80211_CIPHER_AES_OCB	2
-#define	IEEE80211_CIPHER_AES_CCM	3
-#define	IEEE80211_CIPHER_CKIP		5
-#define	IEEE80211_CIPHER_NONE		6	/* pseudo value */
-
-#define	IEEE80211_CIPHER_MAX		(IEEE80211_CIPHER_NONE + 1)
-
-#define	IEEE80211_KEYIX_NONE	((ieee80211_keyix_t)-1)
-
-#if defined(__KERNEL__) || defined(_KERNEL)
-
-struct ieee80211com;
-struct ieee80211vap;
-struct ieee80211_node;
-struct sk_buff;
-
-void ieee80211_crypto_attach(struct ieee80211com *);
-void ieee80211_crypto_detach(struct ieee80211com *);
-void ieee80211_crypto_vattach(struct ieee80211vap *);
-void ieee80211_crypto_vdetach(struct ieee80211vap *);
-int ieee80211_crypto_newkey(struct ieee80211vap *, int, int,
-	struct ieee80211_key *);
-int ieee80211_crypto_delkey(struct ieee80211vap *, struct ieee80211_key *,
-	struct ieee80211_node *);
-int ieee80211_crypto_setkey(struct ieee80211vap *, struct ieee80211_key *,
-	const u_int8_t macaddr[IEEE80211_ADDR_LEN], struct ieee80211_node *);
-void ieee80211_crypto_delglobalkeys(struct ieee80211vap *);
-
-/*
- * Template for a supported cipher.  Ciphers register with the
- * crypto code and are typically loaded as separate modules
- * (the null cipher is always present).
- * XXX may need refcnts
- */
-struct ieee80211_cipher {
-	const char *ic_name;		/* printable name */
-	u_int ic_cipher;		/* IEEE80211_CIPHER_* */
-	u_int ic_header;		/* size of privacy header (bytes) */
-	u_int ic_trailer;		/* size of privacy trailer (bytes) */
-	u_int ic_miclen;		/* size of mic trailer (bytes) */
-	void *(*ic_attach)(struct ieee80211vap *, struct ieee80211_key *);
-	void (*ic_detach)(struct ieee80211_key *);
-	int (*ic_setkey)(struct ieee80211_key *);
-	int (*ic_encap)(struct ieee80211_key *, struct sk_buff *, u_int8_t);
-	int (*ic_decap)(struct ieee80211_key *, struct sk_buff *, int);
-	int (*ic_enmic)(struct ieee80211_key *, struct sk_buff *, int);
-	int (*ic_demic)(struct ieee80211_key *, struct sk_buff *, int, int);
-};
-extern const struct ieee80211_cipher ieee80211_cipher_none;
-
-void ieee80211_crypto_register(const struct ieee80211_cipher *);
-void ieee80211_crypto_unregister(const struct ieee80211_cipher *);
-int ieee80211_crypto_available(struct ieee80211vap*, u_int);
-
-struct ieee80211_key *ieee80211_crypto_encap(struct ieee80211_node *,
-	struct sk_buff *);
-struct ieee80211_key *ieee80211_crypto_decap(struct ieee80211_node *,
-	struct sk_buff *, int);
-
-/*
- * Check and remove any MIC.
- */
-static __inline int
-ieee80211_crypto_demic(struct ieee80211vap *vap, struct ieee80211_key *k,
-	struct sk_buff *skb, int hdrlen, int force)
-{
-	const struct ieee80211_cipher *cip = k->wk_cipher;
-	return (cip->ic_miclen > 0 ? cip->ic_demic(k, skb, hdrlen, force) : 1);
-}
-
-/*
- * Add any MIC.
- */
-static __inline int
-ieee80211_crypto_enmic(struct ieee80211vap *vap, struct ieee80211_key *k,
-	struct sk_buff *skb, int force)
-{
-	const struct ieee80211_cipher *cip = k->wk_cipher;
-	return (cip->ic_miclen > 0 ? cip->ic_enmic(k, skb, force) : 1);
-}
-
-/* 
- * Reset key state to an unused state.  The crypto
- * key allocation mechanism ensures other state (e.g.
- * key data) is properly setup before a key is used.
- */
-static __inline void
-ieee80211_crypto_resetkey(struct ieee80211vap *vap, struct ieee80211_key *k,
-	ieee80211_keyix_t ix)
-{
-	k->wk_cipher = &ieee80211_cipher_none;;
-	k->wk_private = k->wk_cipher->ic_attach(vap, k);
-	k->wk_keyix = ix;
-	k->wk_flags = IEEE80211_KEY_XMIT | IEEE80211_KEY_RECV;
-}
-
-/*
- * Crypto-related notification methods.
- */
-void ieee80211_notify_replay_failure(struct ieee80211vap *,
-	const struct ieee80211_frame *, const struct ieee80211_key *,
-	u_int64_t rsc);
-void ieee80211_notify_michael_failure(struct ieee80211vap *,
-	const struct ieee80211_frame *, ieee80211_keyix_t keyix);
-#endif /* defined(__KERNEL__) || defined(_KERNEL) */
-#endif /* _NET80211_IEEE80211_CRYPTO_H_ */
diff --git a/package/hostapd/madwifi/net80211/ieee80211_ioctl.h b/package/hostapd/madwifi/net80211/ieee80211_ioctl.h
deleted file mode 100644
index 204303b..0000000
--- a/package/hostapd/madwifi/net80211/ieee80211_ioctl.h
+++ /dev/null
@@ -1,715 +0,0 @@
-/*-
- * Copyright (c) 2001 Atsushi Onoe
- * Copyright (c) 2002-2005 Sam Leffler, Errno Consulting
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * Alternatively, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") version 2 as published by the Free
- * Software Foundation.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- *
- * $Id: ieee80211_ioctl.h 3314 2008-01-30 23:50:16Z mtaylor $
- */
-#ifndef _NET80211_IEEE80211_IOCTL_H_
-#define _NET80211_IEEE80211_IOCTL_H_
-
-/*
- * IEEE 802.11 ioctls.
- */
-#include <net80211/_ieee80211.h>
-#include <net80211/ieee80211.h>
-#include <net80211/ieee80211_crypto.h>
-
-/*
- * Per/node (station) statistics available when operating as an AP.
- */
-struct ieee80211_nodestats {
-	u_int32_t ns_rx_data;		/* rx data frames */
-	u_int32_t ns_rx_mgmt;		/* rx management frames */
-	u_int32_t ns_rx_ctrl;		/* rx control frames */
-	u_int32_t ns_rx_ucast;		/* rx unicast frames */
-	u_int32_t ns_rx_mcast;		/* rx multi/broadcast frames */
-	u_int64_t ns_rx_bytes;		/* rx data count (bytes) */
-	u_int64_t ns_rx_beacons;		/* rx beacon frames */
-	u_int32_t ns_rx_proberesp;	/* rx probe response frames */
-
-	u_int32_t ns_rx_dup;		/* rx discard because it's a dup */
-	u_int32_t ns_rx_noprivacy;	/* rx w/ wep but privacy off */
-	u_int32_t ns_rx_wepfail;		/* rx wep processing failed */
-	u_int32_t ns_rx_demicfail;	/* rx demic failed */
-	u_int32_t ns_rx_decap;		/* rx decapsulation failed */
-	u_int32_t ns_rx_defrag;		/* rx defragmentation failed */
-	u_int32_t ns_rx_disassoc;	/* rx disassociation */
-	u_int32_t ns_rx_deauth;		/* rx deauthentication */
-	u_int32_t ns_rx_decryptcrc;	/* rx decrypt failed on crc */
-	u_int32_t ns_rx_unauth;		/* rx on unauthorized port */
-	u_int32_t ns_rx_unencrypted;	/* rx unecrypted w/ privacy */
-
-	u_int32_t ns_tx_data;		/* tx data frames */
-	u_int32_t ns_tx_mgmt;		/* tx management frames */
-	u_int32_t ns_tx_ucast;		/* tx unicast frames */
-	u_int32_t ns_tx_mcast;		/* tx multi/broadcast frames */
-	u_int64_t ns_tx_bytes;		/* tx data count (bytes) */
-	u_int32_t ns_tx_probereq;	/* tx probe request frames */
-	u_int32_t ns_tx_uapsd;		/* tx on uapsd queue */
-
-	u_int32_t ns_tx_novlantag;	/* tx discard due to no tag */
-	u_int32_t ns_tx_vlanmismatch;	/* tx discard due to of bad tag */
-
-	u_int32_t ns_tx_eosplost;	/* uapsd EOSP retried out */
-
-	u_int32_t ns_ps_discard;		/* ps discard due to of age */
-
-	u_int32_t ns_uapsd_triggers;	/* uapsd triggers */
-
-	/* MIB-related state */
-	u_int32_t ns_tx_assoc;		/* [re]associations */
-	u_int32_t ns_tx_assoc_fail;	/* [re]association failures */
-	u_int32_t ns_tx_auth;		/* [re]authentications */
-	u_int32_t ns_tx_auth_fail;	/* [re]authentication failures*/
-	u_int32_t ns_tx_deauth;		/* deauthentications */
-	u_int32_t ns_tx_deauth_code;	/* last deauth reason */
-	u_int32_t ns_tx_disassoc;	/* disassociations */
-	u_int32_t ns_tx_disassoc_code;	/* last disassociation reason */
-	u_int32_t ns_psq_drops;		/* power save queue drops */
-};
-
-/*
- * Summary statistics.
- */
-struct ieee80211_stats {
-	u_int32_t is_rx_badversion;	/* rx frame with bad version */
-	u_int32_t is_rx_tooshort;	/* rx frame too short */
-	u_int32_t is_rx_wrongbss;	/* rx from wrong bssid */
-	u_int32_t is_rx_dup;		/* rx discard due to it's a dup */
-	u_int32_t is_rx_wrongdir;	/* rx w/ wrong direction */
-	u_int32_t is_rx_mcastecho;	/* rx discard due to of mcast echo */
-	u_int32_t is_rx_mcastdisabled;	/* rx discard due to of mcast disabled */
-	u_int32_t is_rx_notassoc;	/* rx discard due to sta !assoc */
-	u_int32_t is_rx_noprivacy;	/* rx w/ wep but privacy off */
-	u_int32_t is_rx_unencrypted;	/* rx w/o wep and privacy on */
-	u_int32_t is_rx_wepfail;		/* rx wep processing failed */
-	u_int32_t is_rx_decap;		/* rx decapsulation failed */
-	u_int32_t is_rx_mgtdiscard;	/* rx discard mgt frames */
-	u_int32_t is_rx_ctl;		/* rx discard ctrl frames */
-	u_int32_t is_rx_beacon;		/* rx beacon frames */
-	u_int32_t is_rx_rstoobig;	/* rx rate set truncated */
-	u_int32_t is_rx_elem_missing;	/* rx required element missing*/
-	u_int32_t is_rx_elem_toobig;	/* rx element too big */
-	u_int32_t is_rx_elem_toosmall;	/* rx element too small */
-	u_int32_t is_rx_elem_unknown;	/* rx element unknown */
-	u_int32_t is_rx_badchan;		/* rx frame w/ invalid chan */
-	u_int32_t is_rx_chanmismatch;	/* rx frame chan mismatch */
-	u_int32_t is_rx_nodealloc;	/* rx frame dropped */
-	u_int32_t is_rx_ssidmismatch;	/* rx frame ssid mismatch  */
-	u_int32_t is_rx_auth_unsupported;/* rx w/ unsupported auth alg */
-	u_int32_t is_rx_auth_fail;	/* rx sta auth failure */
-	u_int32_t is_rx_auth_countermeasures;/* rx auth discard due to CM */
-	u_int32_t is_rx_assoc_bss;	/* rx assoc from wrong bssid */
-	u_int32_t is_rx_assoc_notauth;	/* rx assoc w/o auth */
-	u_int32_t is_rx_assoc_capmismatch;/* rx assoc w/ cap mismatch */
-	u_int32_t is_rx_assoc_norate;	/* rx assoc w/ no rate match */
-	u_int32_t is_rx_assoc_badwpaie;	/* rx assoc w/ bad WPA IE */
-	u_int32_t is_rx_assoc_badscie;	/* rx assoc w/ bad SC IE */
-	u_int32_t is_rx_deauth;		/* rx deauthentication */
-	u_int32_t is_rx_disassoc;	/* rx disassociation */
-	u_int32_t is_rx_badsubtype;	/* rx frame w/ unknown subtype*/
-	u_int32_t is_rx_nobuf;		/* rx failed for lack of buf */
-	u_int32_t is_rx_decryptcrc;	/* rx decrypt failed on crc */
-	u_int32_t is_rx_ahdemo_mgt;	/* rx discard ahdemo mgt frame*/
-	u_int32_t is_rx_bad_auth;	/* rx bad auth request */
-	u_int32_t is_rx_unauth;		/* rx on unauthorized port */
-	u_int32_t is_rx_badkeyid;	/* rx w/ incorrect keyid */
-	u_int32_t is_rx_ccmpreplay;	/* rx seq# violation (CCMP) */
-	u_int32_t is_rx_ccmpformat;	/* rx format bad (CCMP) */
-	u_int32_t is_rx_ccmpmic;		/* rx MIC check failed (CCMP) */
-	u_int32_t is_rx_tkipreplay;	/* rx seq# violation (TKIP) */
-	u_int32_t is_rx_tkipformat;	/* rx format bad (TKIP) */
-	u_int32_t is_rx_tkipmic;		/* rx MIC check failed (TKIP) */
-	u_int32_t is_rx_tkipicv;		/* rx ICV check failed (TKIP) */
-	u_int32_t is_rx_badcipher;	/* rx failed due to of key type */
-	u_int32_t is_rx_nocipherctx;	/* rx failed due to key !setup */
-	u_int32_t is_rx_acl;		/* rx discard due to of acl policy */
-	u_int32_t is_rx_ffcnt;		/* rx fast frames */
-	u_int32_t is_rx_badathtnl;   	/* driver key alloc failed */
-	u_int32_t is_tx_nobuf;		/* tx failed for lack of buf */
-	u_int32_t is_tx_nonode;		/* tx failed for no node */
-	u_int32_t is_tx_unknownmgt;	/* tx of unknown mgt frame */
-	u_int32_t is_tx_badcipher;	/* tx failed due to of key type */
-	u_int32_t is_tx_nodefkey;	/* tx failed due to no defkey */
-	u_int32_t is_tx_noheadroom;	/* tx failed due to no space */
-	u_int32_t is_tx_ffokcnt;		/* tx fast frames sent success */
-	u_int32_t is_tx_fferrcnt;	/* tx fast frames sent success */
-	u_int32_t is_scan_active;	/* active scans started */
-	u_int32_t is_scan_passive;	/* passive scans started */
-	u_int32_t is_node_timeout;	/* nodes timed out inactivity */
-	u_int32_t is_node_fdisassoc;	/* forced node disassociation */
-	u_int32_t is_crypto_nomem;	/* no memory for crypto ctx */
-	u_int32_t is_crypto_tkip;	/* tkip crypto done in s/w */
-	u_int32_t is_crypto_tkipenmic;	/* tkip en-MIC done in s/w */
-	u_int32_t is_crypto_tkipdemic;	/* tkip de-MIC done in s/w */
-	u_int32_t is_crypto_tkipcm;	/* tkip counter measures */
-	u_int32_t is_crypto_ccmp;	/* ccmp crypto done in s/w */
-	u_int32_t is_crypto_wep;		/* wep crypto done in s/w */
-	u_int32_t is_crypto_setkey_cipher;/* cipher rejected key */
-	u_int32_t is_crypto_setkey_nokey;/* no key index for setkey */
-	u_int32_t is_crypto_delkey;	/* driver key delete failed */
-	u_int32_t is_crypto_badcipher;	/* unknown cipher */
-	u_int32_t is_crypto_nocipher;	/* cipher not available */
-	u_int32_t is_crypto_attachfail;	/* cipher attach failed */
-	u_int32_t is_crypto_swfallback;	/* cipher fallback to s/w */
-	u_int32_t is_crypto_keyfail;	/* driver key alloc failed */
-	u_int32_t is_crypto_enmicfail;	/* en-MIC failed */
-	u_int32_t is_ibss_capmismatch;	/* merge failed-cap mismatch */
-	u_int32_t is_ibss_norate;	/* merge failed-rate mismatch */
-	u_int32_t is_ps_unassoc;		/* ps-poll for unassoc. sta */
-	u_int32_t is_ps_badaid;		/* ps-poll w/ incorrect aid */
-	u_int32_t is_ps_qempty;		/* ps-poll w/ nothing to send */
-};
-
-/*
- * Max size of optional information elements.  We artificially
- * constrain this; it's limited only by the max frame size (and
- * the max parameter size of the wireless extensions).
- */
-#define	IEEE80211_MAX_OPT_IE	256
-
-/*
- * WPA/RSN get/set key request.  Specify the key/cipher
- * type and whether the key is to be used for sending and/or
- * receiving.  The key index should be set only when working
- * with global keys (use IEEE80211_KEYIX_NONE for ``no index'').
- * Otherwise a unicast/pairwise key is specified by the bssid
- * (on a station) or mac address (on an ap).  They key length
- * must include any MIC key data; otherwise it should be no
- more than IEEE80211_KEYBUF_SIZE.
- */
-struct ieee80211req_key {
-	u_int8_t ik_type;		/* key/cipher type */
-	u_int8_t ik_pad;
-	ieee80211_keyix_t ik_keyix;	/* key index */
-	u_int8_t ik_keylen;		/* key length in bytes */
-	u_int8_t ik_flags;
-/* NB: IEEE80211_KEY_XMIT and IEEE80211_KEY_RECV defined elsewhere */
-#define	IEEE80211_KEY_DEFAULT	0x80	/* default xmit key */
-	u_int8_t ik_macaddr[IEEE80211_ADDR_LEN];
-	u_int64_t ik_keyrsc;		/* key receive sequence counter */
-	u_int64_t ik_keytsc;		/* key transmit sequence counter */
-	u_int8_t ik_keydata[IEEE80211_KEYBUF_SIZE+IEEE80211_MICBUF_SIZE];
-};
-
-/*
- * Delete a key either by index or address.  Set the index
- * to IEEE80211_KEYIX_NONE when deleting a unicast key.
- */
-struct ieee80211req_del_key {
-	/* NB: This is different to ieee80211_keyix_t, but this is OK as 
-	 * values are unique over the low order bits. */
-	u_int8_t idk_keyix;	/* key index */
-	u_int8_t idk_macaddr[IEEE80211_ADDR_LEN];
-};
-
-/*
- * MLME state manipulation request.  IEEE80211_MLME_ASSOC
- * only makes sense when operating as a station.  The other
- * requests can be used when operating as a station or an
- * ap (to effect a station).
- */
-struct ieee80211req_mlme {
-	u_int8_t im_op;			/* operation to perform */
-#define	IEEE80211_MLME_ASSOC		1	/* associate station */
-#define	IEEE80211_MLME_DISASSOC		2	/* disassociate station */
-#define	IEEE80211_MLME_DEAUTH		3	/* deauthenticate station */
-#define	IEEE80211_MLME_AUTHORIZE	4	/* authorize station */
-#define	IEEE80211_MLME_UNAUTHORIZE	5	/* unauthorize station */
-#define IEEE80211_MLME_CLEAR_STATS	6	/* clear station statistic */
-	u_int8_t im_ssid_len;		/* length of optional ssid */
-	u_int16_t im_reason;		/* 802.11 reason code */
-	u_int8_t im_macaddr[IEEE80211_ADDR_LEN];
-	u_int8_t im_ssid[IEEE80211_NWID_LEN];
-};
-
-/* 
- * MAC ACL operations.
- */
-enum {
-	IEEE80211_MACCMD_POLICY_OPEN	= 0,	/* set policy: no ACLs */
-	IEEE80211_MACCMD_POLICY_ALLOW	= 1,	/* set policy: allow traffic */
-	IEEE80211_MACCMD_POLICY_DENY	= 2,	/* set policy: deny traffic */
-	IEEE80211_MACCMD_FLUSH		= 3,	/* flush ACL database */
-	IEEE80211_MACCMD_DETACH		= 4,	/* detach ACL policy */
-};
-
-/*
- * Set the active channel list.  Note this list is
- * intersected with the available channel list in
- * calculating the set of channels actually used in
- * scanning.
- */
-struct ieee80211req_chanlist {
-	u_int8_t ic_channels[IEEE80211_CHAN_BYTES];
-};
-
-/*
- * Get the active channel list info.
- */
-struct ieee80211req_chaninfo {
-	u_int ic_nchans;
-	struct ieee80211_channel ic_chans[IEEE80211_CHAN_MAX];
-};
-
-/*
- * Retrieve the WPA/RSN information element for an associated station.
- */
-struct ieee80211req_wpaie {
-	u_int8_t	wpa_macaddr[IEEE80211_ADDR_LEN];
-	u_int8_t	wpa_ie[IEEE80211_MAX_OPT_IE];
-	u_int8_t	rsn_ie[IEEE80211_MAX_OPT_IE];
-};
-
-/*
- * Retrieve per-node statistics.
- */
-struct ieee80211req_sta_stats {
-	union {
-		/* NB: explicitly force 64-bit alignment */
-		u_int8_t macaddr[IEEE80211_ADDR_LEN];
-		u_int64_t pad;
-	} is_u;
-	struct ieee80211_nodestats is_stats;
-};
-
-/*
- * Station information block; the mac address is used
- * to retrieve other data like stats, unicast key, etc.
- */
-struct ieee80211req_sta_info {
-	u_int16_t isi_len;		/* length (mult of 4) */
-	u_int16_t isi_freq;		/* MHz */
-	u_int16_t isi_flags;		/* channel flags */
-	u_int16_t isi_state;		/* state flags */
-	u_int8_t isi_authmode;		/* authentication algorithm */
-	u_int8_t isi_rssi;
-	int8_t isi_noise;
-	u_int16_t isi_capinfo;		/* capabilities */
-	u_int8_t isi_athflags;		/* Atheros capabilities */
-	u_int8_t isi_erp;		/* ERP element */
-	u_int8_t isi_macaddr[IEEE80211_ADDR_LEN];
-	u_int8_t isi_nrates;		/* negotiated rates */
-	u_int8_t isi_rates[IEEE80211_RATE_MAXSIZE];
-	u_int8_t isi_txrate;		/* index to isi_rates[] */
-	u_int16_t isi_ie_len;		/* IE length */
-	u_int16_t isi_associd;		/* assoc response */
-	u_int16_t isi_txpower;		/* current tx power */
-	u_int16_t isi_vlan;		/* vlan tag */
-	u_int16_t isi_txseqs[17];	/* seq to be transmitted */
-	u_int16_t isi_rxseqs[17];	/* seq previous for qos frames*/
-	u_int16_t isi_inact;		/* inactivity timer */
-	u_int8_t isi_uapsd;		/* UAPSD queues */
-	u_int8_t isi_opmode;		/* sta operating mode */
-
-	/* XXX frag state? */
-	/* variable length IE data */
-};
-
-enum {
-	IEEE80211_STA_OPMODE_NORMAL,
-	IEEE80211_STA_OPMODE_XR
-};
-
-/*
- * Retrieve per-station information; to retrieve all
- * specify a mac address of ff:ff:ff:ff:ff:ff.
- */
-struct ieee80211req_sta_req {
-	union {
-		/* NB: explicitly force 64-bit alignment */
-		u_int8_t macaddr[IEEE80211_ADDR_LEN];
-		u_int64_t pad;
-	} is_u;
-	struct ieee80211req_sta_info info[1];	/* variable length */
-};
-
-/*
- * Get/set per-station tx power cap.
- */
-struct ieee80211req_sta_txpow {
-	u_int8_t	it_macaddr[IEEE80211_ADDR_LEN];
-	u_int8_t	it_txpow;
-};
-
-/*
- * WME parameters are set and return using i_val and i_len.
- * i_val holds the value itself.  i_len specifies the AC
- * and, as appropriate, then high bit specifies whether the
- * operation is to be applied to the BSS or ourself.
- */
-#define	IEEE80211_WMEPARAM_SELF	0x0000		/* parameter applies to self */
-#define	IEEE80211_WMEPARAM_BSS	0x8000		/* parameter applies to BSS */
-#define	IEEE80211_WMEPARAM_VAL	0x7fff		/* parameter value */
-
-/*
- * Scan result data returned for IEEE80211_IOC_SCAN_RESULTS.
- */
-struct ieee80211req_scan_result {
-	u_int16_t isr_len;		/* length (mult of 4) */
-	u_int16_t isr_freq;		/* MHz */
-	u_int16_t isr_flags;		/* channel flags */
-	u_int8_t isr_noise;
-	u_int8_t isr_rssi;
-	u_int8_t isr_intval;		/* beacon interval */
-	u_int16_t isr_capinfo;		/* capabilities */
-	u_int8_t isr_erp;		/* ERP element */
-	u_int8_t isr_bssid[IEEE80211_ADDR_LEN];
-	u_int8_t isr_nrates;
-	u_int8_t isr_rates[IEEE80211_RATE_MAXSIZE];
-	u_int8_t isr_ssid_len;		/* SSID length */
-	u_int8_t isr_ie_len;		/* IE length */
-	u_int8_t isr_pad[5];
-	/* variable length SSID followed by IE data */
-};
-
-#ifdef __FreeBSD__
-/*
- * FreeBSD-style ioctls.
- */
-/* the first member must be matched with struct ifreq */
-struct ieee80211req {
-	char i_name[IFNAMSIZ];	/* if_name, e.g. "wi0" */
-	u_int16_t i_type;	/* req type */
-	int16_t 	i_val;		/* Index or simple value */
-	int16_t 	i_len;		/* Index or simple value */
-	void *i_data;		/* Extra data */
-};
-#define	SIOCS80211		 _IOW('i', 234, struct ieee80211req)
-#define	SIOCG80211		_IOWR('i', 235, struct ieee80211req)
-#define	SIOCG80211STATS		_IOWR('i', 236, struct ifreq)
-#define	SIOC80211IFCREATE	_IOWR('i', 237, struct ifreq)
-#define	SIOC80211IFDESTROY	 _IOW('i', 238, struct ifreq)
-
-#define IEEE80211_IOC_SSID		1
-#define IEEE80211_IOC_NUMSSIDS		2
-#define IEEE80211_IOC_WEP		3
-#define 	IEEE80211_WEP_NOSUP		-1
-#define 	IEEE80211_WEP_OFF		0
-#define 	IEEE80211_WEP_ON		1
-#define 	IEEE80211_WEP_MIXED		2
-#define IEEE80211_IOC_WEPKEY		4
-#define IEEE80211_IOC_NUMWEPKEYS	5
-#define IEEE80211_IOC_WEPTXKEY		6
-#define IEEE80211_IOC_AUTHMODE		7
-#define IEEE80211_IOC_STATIONNAME	8
-#define IEEE80211_IOC_CHANNEL		9
-#define IEEE80211_IOC_POWERSAVE		10
-#define 	IEEE80211_POWERSAVE_NOSUP	-1
-#define 	IEEE80211_POWERSAVE_OFF		0
-#define 	IEEE80211_POWERSAVE_CAM		1
-#define 	IEEE80211_POWERSAVE_PSP		2
-#define 	IEEE80211_POWERSAVE_PSP_CAM	3
-#define 	IEEE80211_POWERSAVE_ON		IEEE80211_POWERSAVE_CAM
-#define IEEE80211_IOC_POWERSAVESLEEP	11
-#define	IEEE80211_IOC_RTSTHRESHOLD	12
-#define IEEE80211_IOC_PROTMODE		13
-#define 	IEEE80211_PROTMODE_OFF		0
-#define 	IEEE80211_PROTMODE_CTS		1
-#define 	IEEE80211_PROTMODE_RTSCTS	2
-#define	IEEE80211_IOC_TXPOWER		14	/* global tx power limit */
-#define	IEEE80211_IOC_BSSID		15
-#define	IEEE80211_IOC_ROAMING		16	/* roaming mode */
-#define	IEEE80211_IOC_PRIVACY		17	/* privacy invoked */
-#define	IEEE80211_IOC_DROPUNENCRYPTED	18	/* discard unencrypted frames */
-#define	IEEE80211_IOC_WPAKEY		19
-#define	IEEE80211_IOC_DELKEY		20
-#define	IEEE80211_IOC_MLME		21
-#define	IEEE80211_IOC_OPTIE		22	/* optional info. element */
-#define	IEEE80211_IOC_SCAN_REQ		23
-#define	IEEE80211_IOC_SCAN_RESULTS	24
-#define	IEEE80211_IOC_COUNTERMEASURES	25	/* WPA/TKIP countermeasures */
-#define	IEEE80211_IOC_WPA		26	/* WPA mode (0,1,2) */
-#define	IEEE80211_IOC_CHANLIST		27	/* channel list */
-#define	IEEE80211_IOC_WME		28	/* WME mode (on, off) */
-#define	IEEE80211_IOC_HIDESSID		29	/* hide SSID mode (on, off) */
-#define IEEE80211_IOC_APBRIDGE		30	/* AP inter-sta bridging */
-#define	IEEE80211_IOC_MCASTCIPHER	31	/* multicast/default cipher */
-#define	IEEE80211_IOC_MCASTKEYLEN	32	/* multicast key length */
-#define	IEEE80211_IOC_UCASTCIPHERS	33	/* unicast cipher suites */
-#define	IEEE80211_IOC_UCASTCIPHER	34	/* unicast cipher */
-#define	IEEE80211_IOC_UCASTKEYLEN	35	/* unicast key length */
-#define	IEEE80211_IOC_DRIVER_CAPS	36	/* driver capabilities */
-#define	IEEE80211_IOC_KEYMGTALGS	37	/* key management algorithms */
-#define	IEEE80211_IOC_RSNCAPS		38	/* RSN capabilities */
-#define	IEEE80211_IOC_WPAIE		39	/* WPA information element */
-#define	IEEE80211_IOC_STA_STATS		40	/* per-station statistics */
-#define	IEEE80211_IOC_MACCMD		41	/* MAC ACL operation */
-#define	IEEE80211_IOC_TXPOWMAX		43	/* max tx power for channel */
-#define	IEEE80211_IOC_STA_TXPOW		44	/* per-station tx power limit */
-#define	IEEE80211_IOC_STA_INFO		45	/* station/neighbor info */
-#define	IEEE80211_IOC_WME_CWMIN		46	/* WME: ECWmin */
-#define	IEEE80211_IOC_WME_CWMAX		47	/* WME: ECWmax */
-#define	IEEE80211_IOC_WME_AIFS		48	/* WME: AIFSN */
-#define	IEEE80211_IOC_WME_TXOPLIMIT	49	/* WME: txops limit */
-#define	IEEE80211_IOC_WME_ACM		50	/* WME: ACM (bss only) */
-#define	IEEE80211_IOC_WME_ACKPOLICY	51	/* WME: ACK policy (!bss only)*/
-#define	IEEE80211_IOC_DTIM_PERIOD	52	/* DTIM period (beacons) */
-#define	IEEE80211_IOC_BEACON_INTERVAL	53	/* beacon interval (ms) */
-#define	IEEE80211_IOC_ADDMAC		54	/* add sta to MAC ACL table */
-#define	IEEE80211_IOC_SETMAC		55	/* set interface wds mac addr */
-#define	IEEE80211_IOC_FF		56	/* ATH fast frames (on, off) */
-#define	IEEE80211_IOC_TURBOP		57	/* ATH turbo' (on, off) */
-#define	IEEE80211_IOC_APPIEBUF		58	/* IE in the management frame */
-#define	IEEE80211_IOC_FILTERFRAME	59	/* management frame filter */
-
-/*
- * Scan result data returned for IEEE80211_IOC_SCAN_RESULTS.
- */
-struct ieee80211req_scan_result {
-	u_int16_t isr_len;		/* length (mult of 4) */
-	u_int16_t isr_freq;		/* MHz */
-	u_int16_t isr_flags;		/* channel flags */
-	u_int8_t isr_noise;
-	u_int8_t isr_rssi;
-	u_int8_t isr_intval;		/* beacon interval */
-	u_int16_t isr_capinfo;		/* capabilities */
-	u_int8_t isr_erp;		/* ERP element */
-	u_int8_t isr_bssid[IEEE80211_ADDR_LEN];
-	u_int8_t isr_nrates;
-	u_int8_t isr_rates[IEEE80211_RATE_MAXSIZE];
-	u_int8_t isr_ssid_len;		/* SSID length */
-	u_int8_t isr_ie_len;		/* IE length */
-	u_int8_t isr_pad[5];
-	/* variable length SSID followed by IE data */
-};
-
-#endif /* __FreeBSD__ */
-
-#ifdef __linux__
-/*
- * Wireless Extensions API, private ioctl interfaces.
- *
- * NB: Even-numbered ioctl numbers have set semantics and are privileged!
- *     (regardless of the incorrect comment in wireless.h!)
- */
-#ifdef __KERNEL__
-#include <linux/if.h>
-#endif
-/* The maximum size of a iwpriv structure is IW_PRIV_SIZE_MASK, which was 
- * exceeded for some time by chaninfo ioctl.  These macros change the size 
- * encoding for anything larger than IW_PRIV_SIZE_MASK from bytes to 4-byte
- * multiples so that the padded size fits under IW_PRIV_SIZE_MASK. */
-#define IW_PRIV_BLOB_LENGTH_ENCODING(_SIZE) \
-	(((_SIZE) == ((_SIZE) & IW_PRIV_SIZE_MASK)) ? \
-		(_SIZE) : \
-		(((_SIZE) / sizeof(uint32_t)) + \
-			(((_SIZE) == (((_SIZE) / sizeof(uint32_t)) * sizeof(int))) ? \
-				0 : 1)))
-#define IW_PRIV_BLOB_TYPE_ENCODING(_SIZE) \
-	(((_SIZE) == ((_SIZE) & IW_PRIV_SIZE_MASK)) ? \
-		(IW_PRIV_TYPE_BYTE | (_SIZE)) : \
-		(IW_PRIV_TYPE_INT  | IW_PRIV_BLOB_LENGTH_ENCODING((_SIZE))))
-
-#define	IEEE80211_IOCTL_SETPARAM	(SIOCIWFIRSTPRIV+0)
-#define	IEEE80211_IOCTL_GETPARAM	(SIOCIWFIRSTPRIV+1)
-#define	IEEE80211_IOCTL_SETMODE		(SIOCIWFIRSTPRIV+2)
-#define	IEEE80211_IOCTL_GETMODE		(SIOCIWFIRSTPRIV+3)
-#define	IEEE80211_IOCTL_SETWMMPARAMS	(SIOCIWFIRSTPRIV+4)
-#define	IEEE80211_IOCTL_GETWMMPARAMS	(SIOCIWFIRSTPRIV+5)
-#define	IEEE80211_IOCTL_SETCHANLIST	(SIOCIWFIRSTPRIV+6)
-#define	IEEE80211_IOCTL_GETCHANLIST	(SIOCIWFIRSTPRIV+7)
-#define	IEEE80211_IOCTL_CHANSWITCH	(SIOCIWFIRSTPRIV+8)
-#define	IEEE80211_IOCTL_GET_APPIEBUF	(SIOCIWFIRSTPRIV+9)
-#define	IEEE80211_IOCTL_SET_APPIEBUF	(SIOCIWFIRSTPRIV+10)
-#define	IEEE80211_IOCTL_READREG		(SIOCIWFIRSTPRIV+11)
-#define	IEEE80211_IOCTL_FILTERFRAME	(SIOCIWFIRSTPRIV+12)
-#define	IEEE80211_IOCTL_GETCHANINFO	(SIOCIWFIRSTPRIV+13)
-#define	IEEE80211_IOCTL_SETOPTIE	(SIOCIWFIRSTPRIV+14)
-#define	IEEE80211_IOCTL_GETOPTIE	(SIOCIWFIRSTPRIV+15)
-#define	IEEE80211_IOCTL_SETMLME		(SIOCIWFIRSTPRIV+16)
-#define	IEEE80211_IOCTL_RADAR		(SIOCIWFIRSTPRIV+17)
-#define	IEEE80211_IOCTL_SETKEY		(SIOCIWFIRSTPRIV+18)
-#define	IEEE80211_IOCTL_WRITEREG	(SIOCIWFIRSTPRIV+19)
-#define	IEEE80211_IOCTL_DELKEY		(SIOCIWFIRSTPRIV+20)
-#define	IEEE80211_IOCTL_HALMAP		(SIOCIWFIRSTPRIV+21)
-#define	IEEE80211_IOCTL_ADDMAC		(SIOCIWFIRSTPRIV+22)
-#define	IEEE80211_IOCTL_DELMAC		(SIOCIWFIRSTPRIV+24)
-#define	IEEE80211_IOCTL_WDSADDMAC	(SIOCIWFIRSTPRIV+25)
-#define	IEEE80211_IOCTL_WDSSETMAC	(SIOCIWFIRSTPRIV+26)
-#define	IEEE80211_IOCTL_KICKMAC		(SIOCIWFIRSTPRIV+30)
-#define	IEEE80211_IOCTL_SETSCANLIST	(SIOCIWFIRSTPRIV+31)
-
-enum {
-	IEEE80211_WMMPARAMS_CWMIN       = 1,
-	IEEE80211_WMMPARAMS_CWMAX       = 2,
-	IEEE80211_WMMPARAMS_AIFS       	= 3,
-	IEEE80211_WMMPARAMS_TXOPLIMIT	= 4,
-	IEEE80211_WMMPARAMS_ACM		= 5,
-	IEEE80211_WMMPARAMS_NOACKPOLICY	= 6,
-};
-enum {
-	IEEE80211_PARAM_TURBO			= 1,	/* turbo mode */
-	IEEE80211_PARAM_MODE			= 2,	/* phy mode (11a, 11b, etc.) */
-	IEEE80211_PARAM_AUTHMODE		= 3,	/* authentication mode */
-	IEEE80211_PARAM_PROTMODE		= 4,	/* 802.11g protection */
-	IEEE80211_PARAM_MCASTCIPHER		= 5,	/* multicast/default cipher */
-	IEEE80211_PARAM_MCASTKEYLEN		= 6,	/* multicast key length */
-	IEEE80211_PARAM_UCASTCIPHERS		= 7,	/* unicast cipher suites */
-	IEEE80211_PARAM_UCASTCIPHER		= 8,	/* unicast cipher */
-	IEEE80211_PARAM_UCASTKEYLEN		= 9,	/* unicast key length */
-	IEEE80211_PARAM_WPA			= 10,	/* WPA mode (0,1,2) */
-	IEEE80211_PARAM_ROAMING			= 12,	/* roaming mode */
-	IEEE80211_PARAM_PRIVACY			= 13,	/* privacy invoked */
-	IEEE80211_PARAM_COUNTERMEASURES		= 14,	/* WPA/TKIP countermeasures */
-	IEEE80211_PARAM_DROPUNENCRYPTED		= 15,	/* discard unencrypted frames */
-	IEEE80211_PARAM_DRIVER_CAPS		= 16,	/* driver capabilities */
-	IEEE80211_PARAM_MACCMD			= 17,	/* MAC ACL operation */
-	IEEE80211_PARAM_WMM			= 18,	/* WMM mode (on, off) */
-	IEEE80211_PARAM_HIDESSID		= 19,	/* hide SSID mode (on, off) */
-	IEEE80211_PARAM_APBRIDGE    		= 20,   /* AP inter-sta bridging */
-	IEEE80211_PARAM_KEYMGTALGS		= 21,	/* key management algorithms */
-	IEEE80211_PARAM_RSNCAPS			= 22,	/* RSN capabilities */
-	IEEE80211_PARAM_INACT			= 23,	/* station inactivity timeout */
-	IEEE80211_PARAM_INACT_AUTH		= 24,	/* station auth inact timeout */
-	IEEE80211_PARAM_INACT_INIT		= 25,	/* station init inact timeout */
-	IEEE80211_PARAM_ABOLT			= 26,	/* Atheros Adv. Capabilities */
-	IEEE80211_PARAM_INACT_TICK		= 27,	/* station inactivity timer tick (seconds) */
-	IEEE80211_PARAM_DTIM_PERIOD		= 28,	/* DTIM period (beacons) */
-	IEEE80211_PARAM_BEACON_INTERVAL		= 29,	/* beacon interval (ms) */
-	IEEE80211_PARAM_DOTH			= 30,	/* 11.h is on/off */
-	IEEE80211_PARAM_PWRTARGET		= 31,	/* Current Channel Pwr Constraint */
-	IEEE80211_PARAM_GENREASSOC		= 32,	/* Generate a reassociation request */
-	IEEE80211_PARAM_COMPRESSION		= 33,	/* compression */
-	IEEE80211_PARAM_FF			= 34,	/* fast frames support  */
-	IEEE80211_PARAM_XR			= 35,	/* XR support */
-	IEEE80211_PARAM_BURST			= 36,	/* burst mode */
-	IEEE80211_PARAM_PUREG			= 37,	/* pure 11g (no 11b stations) */
-	IEEE80211_PARAM_AR			= 38,	/* AR support */
-	IEEE80211_PARAM_WDS			= 39,	/* Enable 4 address processing */
-	IEEE80211_PARAM_BGSCAN			= 40,	/* bg scanning (on, off) */
-	IEEE80211_PARAM_BGSCAN_IDLE		= 41,	/* bg scan idle threshold */
-	IEEE80211_PARAM_BGSCAN_INTERVAL		= 42,	/* bg scan interval */
-	IEEE80211_PARAM_MCAST_RATE		= 43,	/* Multicast Tx Rate */
-	IEEE80211_PARAM_COVERAGE_CLASS		= 44,	/* coverage class */
-	IEEE80211_PARAM_COUNTRY_IE		= 45,	/* enable country IE */
-	IEEE80211_PARAM_SCANVALID		= 46,	/* scan cache valid threshold */
-	IEEE80211_PARAM_ROAM_RSSI_11A		= 47,	/* rssi threshold in 11a */
-	IEEE80211_PARAM_ROAM_RSSI_11B		= 48,	/* rssi threshold in 11b */
-	IEEE80211_PARAM_ROAM_RSSI_11G		= 49,	/* rssi threshold in 11g */
-	IEEE80211_PARAM_ROAM_RATE_11A		= 50,	/* tx rate threshold in 11a */
-	IEEE80211_PARAM_ROAM_RATE_11B		= 51,	/* tx rate threshold in 11b */
-	IEEE80211_PARAM_ROAM_RATE_11G		= 52,	/* tx rate threshold in 11g */
-	IEEE80211_PARAM_UAPSDINFO		= 53,	/* value for qos info field */
-	IEEE80211_PARAM_SLEEP			= 54,	/* force sleep/wake */
-	IEEE80211_PARAM_QOSNULL			= 55,	/* force sleep/wake */
-	IEEE80211_PARAM_PSPOLL			= 56,	/* force ps-poll generation (sta only) */
-	IEEE80211_PARAM_EOSPDROP		= 57,	/* force uapsd EOSP drop (ap only) */
-	IEEE80211_PARAM_MARKDFS			= 58,	/* mark a dfs interference channel when found */
-	IEEE80211_PARAM_REGCLASS		= 59,	/* enable regclass ids in country IE */
-	IEEE80211_PARAM_DROPUNENC_EAPOL		= 60,	/* drop unencrypted eapol frames */
-	IEEE80211_PARAM_SHPREAMBLE		= 61,	/* Short Preamble */
-	IEEE80211_PARAM_DUMPREGS		= 62,	/* Pretty printed dump of Atheros hardware registers */
-	IEEE80211_PARAM_DOTH_ALGORITHM		= 63,	/* spectrum management algorithm */
-	IEEE80211_PARAM_DOTH_MINCOM   		= 64,	/* minimum number of common channels */
-	IEEE80211_PARAM_DOTH_SLCG		= 65,	/* permil of Stations Lost per Channel Gained */
-	IEEE80211_PARAM_DOTH_SLDG		= 66,	/* permil of Stations Lost per rssi Db Gained */
-	IEEE80211_PARAM_TXCONT			= 67,	/* continuous transmit mode (boolean) */
-	IEEE80211_PARAM_TXCONT_RATE		= 68,	/* continuous transmit mode data rate (in mbit/sec) - will use closest match from current rate table */
-	IEEE80211_PARAM_TXCONT_POWER		= 69,	/* power level in units of 0.5dBm */
-	IEEE80211_PARAM_DFS_TESTMODE		= 70,	/* do not perform DFS actions (i.e. markng DFS and channel change on interference), just report them via debug. */
-	IEEE80211_PARAM_DFS_CACTIME		= 71,	/* how long do we wait for chan availability
-							   scans ?
-							   FCC requires 60s, so that is the default. */
-	IEEE80211_PARAM_DFS_EXCLPERIOD		= 72,	/* DFS no-occupancy limit - how long do we stay
-							   off a channel once radar is detected?
-							   FCC requires 30m, so that is the default. */
-	IEEE80211_PARAM_BEACON_MISS_THRESH	= 73,	/* Beacon miss threshold (in beacons) */
-	IEEE80211_PARAM_BEACON_MISS_THRESH_MS	= 74,	/* Beacon miss threshold (in ms) */
-	IEEE80211_PARAM_MAXRATE			= 75,	/* Maximum rate (by table index) */
-	IEEE80211_PARAM_MINRATE			= 76,	/* Minimum rate (by table index) */
-	IEEE80211_PARAM_PROTMODE_RSSI		= 77,	/* RSSI Threshold for enabling protection mode */
-	IEEE80211_PARAM_PROTMODE_TIMEOUT	= 78,	/* Timeout for expiring protection mode */
-	IEEE80211_PARAM_BGSCAN_THRESH		= 79,	/* bg scan rssi threshold */
-	IEEE80211_PARAM_RSSI_DIS_THR	= 80,	/* rssi threshold for disconnection */
-	IEEE80211_PARAM_RSSI_DIS_COUNT	= 81,	/* counter for rssi threshold */
-	IEEE80211_PARAM_WDS_SEP			= 82,	/* move wds stations into separate interfaces */
-	IEEE80211_PARAM_MAXASSOC		= 83,	/* maximum associated stations */
-	IEEE80211_PARAM_PROBEREQ		= 84,	/* enable handling of probe requests */
-	IEEE80211_PARAM_BEACON_TXP		= 85,	/* set beacon tx power */
-};
-
-#define	SIOCG80211STATS			(SIOCDEVPRIVATE+2)
-/* NB: require in+out parameters so cannot use wireless extensions, yech */
-#define	IEEE80211_IOCTL_GETKEY		(SIOCDEVPRIVATE+3)
-#define	IEEE80211_IOCTL_GETWPAIE	(SIOCDEVPRIVATE+4)
-#define	IEEE80211_IOCTL_STA_STATS	(SIOCDEVPRIVATE+5)
-#define	IEEE80211_IOCTL_STA_INFO	(SIOCDEVPRIVATE+6)
-#define	SIOC80211IFCREATE		(SIOCDEVPRIVATE+7)
-#define	SIOC80211IFDESTROY	 	(SIOCDEVPRIVATE+8)
-#define	IEEE80211_IOCTL_SCAN_RESULTS	(SIOCDEVPRIVATE+9)
-
-struct ieee80211_clone_params {
-	char icp_name[IFNAMSIZ];		/* device name */
-	u_int16_t icp_opmode;			/* operating mode */
-	u_int16_t icp_flags;			/* see below */
-#define	IEEE80211_CLONE_BSSID	0x0001		/* allocate unique mac/bssid */
-#define	IEEE80211_NO_STABEACONS	0x0002		/* Do not setup the station beacon timers */
-};
-
-/* APPIEBUF related definitions */
-
-/* Management frame type to which application IE is added */
-enum {
-	IEEE80211_APPIE_FRAME_BEACON		= 0,
-	IEEE80211_APPIE_FRAME_PROBE_REQ		= 1,
-	IEEE80211_APPIE_FRAME_PROBE_RESP	= 2,
-	IEEE80211_APPIE_FRAME_ASSOC_REQ		= 3,
-	IEEE80211_APPIE_FRAME_ASSOC_RESP	= 4,
-	IEEE80211_APPIE_NUM_OF_FRAME		= 5
-};
-
-struct ieee80211req_getset_appiebuf {
-	u_int32_t	app_frmtype;		/* management frame type for which buffer is added */
-	u_int32_t	app_buflen;		/* application-supplied buffer length */
-	u_int8_t	app_buf[0];		/* application-supplied IE(s) */
-};
-
-/* Flags ORed by application to set filter for receiving management frames */
-enum {
-	IEEE80211_FILTER_TYPE_BEACON		= 1<<0,
-	IEEE80211_FILTER_TYPE_PROBE_REQ		= 1<<1,
-	IEEE80211_FILTER_TYPE_PROBE_RESP	= 1<<2,
-	IEEE80211_FILTER_TYPE_ASSOC_REQ		= 1<<3,
-	IEEE80211_FILTER_TYPE_ASSOC_RESP	= 1<<4,
-	IEEE80211_FILTER_TYPE_AUTH		= 1<<5,
-	IEEE80211_FILTER_TYPE_DEAUTH		= 1<<6,
-	IEEE80211_FILTER_TYPE_DISASSOC		= 1<<7,
-	IEEE80211_FILTER_TYPE_ALL		= 0xFF	/* used to check the valid filter bits */
-};
-
-struct ieee80211req_set_filter {
-	u_int32_t app_filterype;		/* management frame filter type */
-};
-
-
-#endif /* __linux__ */
-
-#endif /* _NET80211_IEEE80211_IOCTL_H_ */
diff --git a/package/hostapd/patches/300-nl80211_multicall_fixes.patch b/package/hostapd/patches/300-nl80211_multicall_fixes.patch
deleted file mode 100644
index be68ed1..0000000
--- a/package/hostapd/patches/300-nl80211_multicall_fixes.patch
+++ /dev/null
@@ -1,60 +0,0 @@
---- a/src/drivers/driver_nl80211.c
-+++ b/src/drivers/driver_nl80211.c
-@@ -3290,6 +3290,7 @@ static void * wpa_driver_nl80211_init(vo
- 	drv->monitor_sock = -1;
- 	drv->eapol_tx_sock = -1;
- 	drv->ap_scan_as_station = NL80211_IFTYPE_UNSPECIFIED;
-+	drv->nlmode = NL80211_IFTYPE_STATION;
- 
- 	if (wpa_driver_nl80211_init_nl(drv)) {
- 		os_free(drv);
-@@ -3607,17 +3608,12 @@ static void wpa_driver_nl80211_send_rfki
- 	wpa_supplicant_event(timeout_ctx, EVENT_INTERFACE_DISABLED, NULL);
- }
- 
--
- static int
--wpa_driver_nl80211_finish_drv_init(struct wpa_driver_nl80211_data *drv)
-+wpa_driver_nl80211_finish_drv_init_sta(struct wpa_driver_nl80211_data *drv,
-+				       int *send_rfkill_event)
- {
- 	struct i802_bss *bss = &drv->first_bss;
--	int send_rfkill_event = 0;
- 
--	drv->ifindex = if_nametoindex(bss->ifname);
--	drv->first_bss.ifindex = drv->ifindex;
--
--#ifndef HOSTAPD
- 	/*
- 	 * Make sure the interface starts up in station mode unless this is a
- 	 * dynamically added interface (e.g., P2P) that was already configured
-@@ -3636,7 +3632,7 @@ wpa_driver_nl80211_finish_drv_init(struc
- 				   "interface '%s' due to rfkill",
- 				   bss->ifname);
- 			drv->if_disabled = 1;
--			send_rfkill_event = 1;
-+			*send_rfkill_event = 1;
- 		} else {
- 			wpa_printf(MSG_ERROR, "nl80211: Could not set "
- 				   "interface '%s' UP", bss->ifname);
-@@ -3646,7 +3642,19 @@ wpa_driver_nl80211_finish_drv_init(struc
- 
- 	netlink_send_oper_ifla(drv->global->netlink, drv->ifindex,
- 			       1, IF_OPER_DORMANT);
--#endif /* HOSTAPD */
-+}
-+
-+static int
-+wpa_driver_nl80211_finish_drv_init(struct wpa_driver_nl80211_data *drv)
-+{
-+	struct i802_bss *bss = &drv->first_bss;
-+	int send_rfkill_event = 0;
-+
-+	drv->ifindex = if_nametoindex(bss->ifname);
-+	drv->first_bss.ifindex = drv->ifindex;
-+
-+	if (drv->nlmode == NL80211_IFTYPE_STATION)
-+		wpa_driver_nl80211_finish_drv_init_sta(drv, &send_rfkill_event);
- 
- 	if (wpa_driver_nl80211_capa(drv))
- 		return -1;
diff --git a/package/hostapd/patches/310-multicall_bridge_fix.patch b/package/hostapd/patches/310-multicall_bridge_fix.patch
deleted file mode 100644
index a80c041..0000000
--- a/package/hostapd/patches/310-multicall_bridge_fix.patch
+++ /dev/null
@@ -1,45 +0,0 @@
---- a/src/drivers/driver_nl80211.c
-+++ b/src/drivers/driver_nl80211.c
-@@ -899,6 +899,10 @@ static void wpa_driver_nl80211_event_rtm
- 		return;
- 	}
- 
-+	if (ifi->ifi_family == AF_BRIDGE &&
-+	    drv->nlmode != NL80211_IFTYPE_AP)
-+		return;
-+
- 	wpa_printf(MSG_DEBUG, "RTM_NEWLINK: operstate=%d ifi_flags=0x%x "
- 		   "(%s%s%s%s)",
- 		   drv->operstate, ifi->ifi_flags,
-@@ -1006,6 +1010,10 @@ static void wpa_driver_nl80211_event_rtm
- 	attrlen = len;
- 	attr = (struct rtattr *) buf;
- 
-+	if (ifi->ifi_family == AF_BRIDGE &&
-+	    drv->nlmode != NL80211_IFTYPE_AP)
-+		return;
-+
- 	rta_len = RTA_ALIGN(sizeof(struct rtattr));
- 	while (RTA_OK(attr, attrlen)) {
- 		if (attr->rta_type == IFLA_IFNAME) {
-@@ -3292,6 +3300,11 @@ static void * wpa_driver_nl80211_init(vo
- 	drv->ap_scan_as_station = NL80211_IFTYPE_UNSPECIFIED;
- 	drv->nlmode = NL80211_IFTYPE_STATION;
- 
-+#ifdef HOSTAPD
-+	drv->num_if_indices = sizeof(drv->default_if_indices) / sizeof(int);
-+	drv->if_indices = drv->default_if_indices;
-+#endif
-+
- 	if (wpa_driver_nl80211_init_nl(drv)) {
- 		os_free(drv);
- 		return NULL;
-@@ -8296,8 +8309,6 @@ static void *i802_init(struct hostapd_da
- 		br_ifindex = 0;
- 	}
- 
--	drv->num_if_indices = sizeof(drv->default_if_indices) / sizeof(int);
--	drv->if_indices = drv->default_if_indices;
- 	for (i = 0; i < params->num_bridge; i++) {
- 		if (params->bridge[i]) {
- 			ifindex = if_nametoindex(params->bridge[i]);
diff --git a/package/hostapd/patches/320-madwifi_key_fixes.patch b/package/hostapd/patches/320-madwifi_key_fixes.patch
deleted file mode 100644
index 45a7ac6..0000000
--- a/package/hostapd/patches/320-madwifi_key_fixes.patch
+++ /dev/null
@@ -1,34 +0,0 @@
---- a/src/drivers/driver_madwifi.c
-+++ b/src/drivers/driver_madwifi.c
-@@ -453,7 +453,9 @@ wpa_driver_madwifi_set_key(const char *i
- 
- 	memset(&wk, 0, sizeof(wk));
- 	wk.ik_type = cipher;
--	wk.ik_flags = IEEE80211_KEY_RECV | IEEE80211_KEY_XMIT;
-+	wk.ik_flags = IEEE80211_KEY_RECV;
-+	if (set_tx)
-+		wk.ik_flags |= IEEE80211_KEY_XMIT;
- 	if (addr == NULL || is_broadcast_ether_addr(addr)) {
- 		memset(wk.ik_macaddr, 0xff, IEEE80211_ADDR_LEN);
- 		wk.ik_keyix = key_idx;
-@@ -465,6 +467,20 @@ wpa_driver_madwifi_set_key(const char *i
- 	wk.ik_keylen = key_len;
- 	memcpy(wk.ik_keydata, key, key_len);
- 
-+#ifdef WORDS_BIGENDIAN
-+#define WPA_KEY_RSC_LEN 8
-+	{
-+		size_t i;
-+		u8 tmp[WPA_KEY_RSC_LEN];
-+		os_memset(tmp, 0, sizeof(tmp));
-+		for (i = 0; i < seq_len; i++)
-+			tmp[WPA_KEY_RSC_LEN - i - 1] = seq[i];
-+		os_memcpy(&wk.ik_keyrsc, tmp, WPA_KEY_RSC_LEN);
-+	}
-+#else /* WORDS_BIGENDIAN */
-+	os_memcpy(&wk.ik_keyrsc, seq, seq_len);
-+#endif /* WORDS_BIGENDIAN */
-+
- 	ret = set80211priv(drv, IEEE80211_IOCTL_SETKEY, &wk, sizeof(wk));
- 	if (ret < 0) {
- 		wpa_printf(MSG_DEBUG, "%s: Failed to set key (addr %s"
diff --git a/package/hostapd/patches/400-noscan.patch b/package/hostapd/patches/400-noscan.patch
deleted file mode 100644
index 18a218c..0000000
--- a/package/hostapd/patches/400-noscan.patch
+++ /dev/null
@@ -1,32 +0,0 @@
---- a/hostapd/config_file.c
-+++ b/hostapd/config_file.c
-@@ -2464,6 +2464,8 @@ static int hostapd_config_fill(struct ho
- 			}
- #endif /* CONFIG_IEEE80211W */
- #ifdef CONFIG_IEEE80211N
-+		} else if (os_strcmp(buf, "noscan") == 0) {
-+			conf->noscan = atoi(pos);
- 		} else if (os_strcmp(buf, "ieee80211n") == 0) {
- 			conf->ieee80211n = atoi(pos);
- 		} else if (os_strcmp(buf, "ht_capab") == 0) {
---- a/src/ap/ap_config.h
-+++ b/src/ap/ap_config.h
-@@ -511,6 +511,7 @@ struct hostapd_config {
- 
- 	int ht_op_mode_fixed;
- 	u16 ht_capab;
-+	int noscan;
- 	int ieee80211n;
- 	int secondary_channel;
- 	int require_ht;
---- a/src/ap/hw_features.c
-+++ b/src/ap/hw_features.c
-@@ -494,7 +494,7 @@ static int ieee80211n_check_40mhz(struct
- {
- 	struct wpa_driver_scan_params params;
- 
--	if (!iface->conf->secondary_channel)
-+	if (!iface->conf->secondary_channel || iface->conf->noscan)
- 		return 0; /* HT40 not used */
- 
- 	wpa_printf(MSG_DEBUG, "Scan for neighboring BSSes prior to enabling "
diff --git a/package/hostapd/patches/410-multicall.patch b/package/hostapd/patches/410-multicall.patch
deleted file mode 100644
index 723f5f6..0000000
--- a/package/hostapd/patches/410-multicall.patch
+++ /dev/null
@@ -1,246 +0,0 @@
---- a/hostapd/Makefile
-+++ b/hostapd/Makefile
-@@ -14,6 +14,7 @@ CFLAGS += -I../src/utils
- # CFLAGS += -DUSE_KERNEL_HEADERS -I/usr/src/linux/include
- 
- -include .config
-+-include $(if $(MULTICALL), ../wpa_supplicant/.config)
- 
- ifndef CONFIG_OS
- ifdef CONFIG_NATIVE_WINDOWS
-@@ -192,10 +193,14 @@ ifdef CONFIG_IEEE80211AC
- CFLAGS += -DCONFIG_IEEE80211AC
- endif
- 
-+ifndef MULTICALL
-+CFLAGS += -DNO_SUPPLICANT
-+endif
-+
- include ../src/drivers/drivers.mak
--OBJS += $(DRV_AP_OBJS)
--CFLAGS += $(DRV_AP_CFLAGS)
--LDFLAGS += $(DRV_AP_LDFLAGS)
-+OBJS += $(sort $(DRV_AP_OBJS) $(if $(MULTICALL),$(DRV_WPA_OBJS)))
-+CFLAGS += $(DRV_AP_CFLAGS) $(if $(MULTICALL),$(DRV_WPA_CFLAGS))
-+LDFLAGS += $(DRV_AP_LDFLAGS) $(if $(MULTICALL),$(DRV_WPA_LDFLAGS))
- LIBS += $(DRV_AP_LIBS)
- 
- ifdef CONFIG_L2_PACKET
-@@ -860,6 +865,12 @@ install: all
- 
- BCHECK=../src/drivers/build.hostapd
- 
-+hostapd_multi.a: $(BCHECK) $(OBJS)
-+	$(Q)$(CC) -c -o hostapd_multi.o -Dmain=hostapd_main $(CFLAGS) main.c
-+	@$(E) "  CC " $<
-+	@rm -f $@
-+	@$(AR) cr $@ hostapd_multi.o $(OBJS)
-+
- hostapd: $(BCHECK) $(OBJS)
- 	$(Q)$(CC) $(LDFLAGS) -o hostapd $(OBJS) $(LIBS)
- 	@$(E) "  LD " $@
-@@ -898,6 +909,12 @@ HOBJS += ../src/crypto/aes-internal.o
- HOBJS += ../src/crypto/aes-internal-enc.o
- endif
- 
-+dump_cflags:
-+	@echo -n $(CFLAGS) " "
-+
-+dump_ldflags:
-+	@echo -n $(LDFLAGS) $(LIBS) $(EXTRALIBS) " "
-+
- nt_password_hash: $(NOBJS)
- 	$(Q)$(CC) $(LDFLAGS) -o nt_password_hash $(NOBJS) $(LIBS_n)
- 	@$(E) "  LD " $@
---- a/wpa_supplicant/Makefile
-+++ b/wpa_supplicant/Makefile
-@@ -14,6 +14,7 @@ CFLAGS += -I../src
- CFLAGS += -I../src/utils
- 
- -include .config
-+-include $(if $(MULTICALL),../hostapd/.config)
- 
- BINALL=wpa_supplicant wpa_cli
- 
-@@ -708,6 +709,10 @@ ifdef CONFIG_DYNAMIC_EAP_METHODS
- CFLAGS += -DCONFIG_DYNAMIC_EAP_METHODS
- LIBS += -ldl -rdynamic
- endif
-+else
-+  ifdef MULTICALL
-+    OBJS += ../src/eap_common/eap_common.o
-+  endif
- endif
- 
- ifdef CONFIG_AP
-@@ -716,9 +721,11 @@ NEED_EAP_COMMON=y
- NEED_RSN_AUTHENTICATOR=y
- CFLAGS += -DCONFIG_AP
- OBJS += ap.o
-+ifndef MULTICALL
- CFLAGS += -DCONFIG_NO_RADIUS
- CFLAGS += -DCONFIG_NO_ACCOUNTING
- CFLAGS += -DCONFIG_NO_VLAN
-+endif
- OBJS += ../src/ap/hostapd.o
- OBJS += ../src/ap/wpa_auth_glue.o
- OBJS += ../src/ap/utils.o
-@@ -773,10 +780,18 @@ endif
- ifdef CONFIG_HS20
- OBJS += ../src/ap/hs20.o
- endif
-+else
-+  ifdef MULTICALL
-+    OBJS += ../src/eap_server/eap_server.o
-+    OBJS += ../src/eap_server/eap_server_identity.o
-+    OBJS += ../src/eap_server/eap_server_methods.o
-+  endif
- endif
- 
- ifdef NEED_RSN_AUTHENTICATOR
-+ifndef MULTICALL
- CFLAGS += -DCONFIG_NO_RADIUS
-+endif
- NEED_AES_WRAP=y
- OBJS += ../src/ap/wpa_auth.o
- OBJS += ../src/ap/wpa_auth_ie.o
-@@ -1525,6 +1540,12 @@ wpa_priv: $(BCHECK) $(OBJS_priv)
- 
- $(OBJS_c) $(OBJS_t) $(OBJS_t2) $(OBJS) $(BCHECK) $(EXTRA_progs): .config
- 
-+wpa_supplicant_multi.a: .config $(BCHECK) $(OBJS) $(EXTRA_progs)
-+	$(Q)$(CC) -c -o wpa_supplicant_multi.o -Dmain=wpa_supplicant_main $(CFLAGS) main.c
-+	@$(E) "  CC " $<
-+	@rm -f $@
-+	@$(AR) cr $@ wpa_supplicant_multi.o $(OBJS)
-+
- wpa_supplicant: $(BCHECK) $(OBJS) $(EXTRA_progs)
- 	$(Q)$(LDO) $(LDFLAGS) -o wpa_supplicant $(OBJS) $(LIBS) $(EXTRALIBS)
- 	@$(E) "  LD " $@
-@@ -1595,6 +1616,12 @@ eap_ikev2.so: ../src/eap_peer/eap_ikev2.
- %@.service: %.service.arg.in
- 	sed -e 's|\@BINDIR\@|$(BINDIR)|g' $< >$@
- 
-+dump_cflags:
-+	@echo -n $(CFLAGS) " "
-+
-+dump_ldflags:
-+	@echo -n $(LDFLAGS) $(LIBS) $(EXTRALIBS) " "
-+
- wpa_supplicant.exe: wpa_supplicant
- 	mv -f $< $@
- wpa_cli.exe: wpa_cli
---- a/src/drivers/driver.h
-+++ b/src/drivers/driver.h
-@@ -3750,8 +3750,8 @@ union wpa_event_data {
-  * Driver wrapper code should call this function whenever an event is received
-  * from the driver.
-  */
--void wpa_supplicant_event(void *ctx, enum wpa_event_type event,
--			  union wpa_event_data *data);
-+extern void (*wpa_supplicant_event)(void *ctx, enum wpa_event_type event,
-+				    union wpa_event_data *data);
- 
- 
- /*
---- a/src/ap/drv_callbacks.c
-+++ b/src/ap/drv_callbacks.c
-@@ -714,8 +714,8 @@ static void hostapd_event_eapol_rx(struc
- }
- 
- 
--void wpa_supplicant_event(void *ctx, enum wpa_event_type event,
--			  union wpa_event_data *data)
-+void hostapd_wpa_event(void *ctx, enum wpa_event_type event,
-+		       union wpa_event_data *data)
- {
- 	struct hostapd_data *hapd = ctx;
- #ifndef CONFIG_NO_STDOUT_DEBUG
---- a/wpa_supplicant/wpa_priv.c
-+++ b/wpa_supplicant/wpa_priv.c
-@@ -819,8 +819,8 @@ static void wpa_priv_send_ft_response(st
- }
- 
- 
--void wpa_supplicant_event(void *ctx, enum wpa_event_type event,
--			  union wpa_event_data *data)
-+static void supplicant_event(void *ctx, enum wpa_event_type event,
-+			     union wpa_event_data *data)
- {
- 	struct wpa_priv_interface *iface = ctx;
- 
-@@ -962,6 +962,7 @@ int main(int argc, char *argv[])
- 	if (os_program_init())
- 		return -1;
- 
-+	wpa_supplicant_event = supplicant_event;
- 	wpa_priv_fd_workaround();
- 
- 	for (;;) {
---- a/wpa_supplicant/events.c
-+++ b/wpa_supplicant/events.c
-@@ -2354,8 +2354,8 @@ static void wpa_supplicant_event_unprot_
- }
- 
- 
--void wpa_supplicant_event(void *ctx, enum wpa_event_type event,
--			  union wpa_event_data *data)
-+void supplicant_event(void *ctx, enum wpa_event_type event,
-+		      union wpa_event_data *data)
- {
- 	struct wpa_supplicant *wpa_s = ctx;
- 	u16 reason_code = 0;
---- a/wpa_supplicant/wpa_supplicant.c
-+++ b/wpa_supplicant/wpa_supplicant.c
-@@ -3050,6 +3050,9 @@ static void wpa_supplicant_deinit_iface(
- 	}
- }
- 
-+extern void supplicant_event(void *ctx, enum wpa_event_type event,
-+			     union wpa_event_data *data);
-+
- 
- /**
-  * wpa_supplicant_add_iface - Add a new network interface
-@@ -3244,6 +3247,7 @@ struct wpa_global * wpa_supplicant_init(
- 	wpa_msg_register_ifname_cb(wpa_supplicant_msg_ifname_cb);
- #endif /* CONFIG_NO_WPA_MSG */
- 
-+	wpa_supplicant_event = supplicant_event;
- 	wpa_debug_open_file(params->wpa_debug_file_path);
- 	if (params->wpa_debug_syslog)
- 		wpa_debug_open_syslog();
---- a/hostapd/main.c
-+++ b/hostapd/main.c
-@@ -554,6 +554,9 @@ static int hostapd_get_ctrl_iface_group(
- 	return 0;
- }
- 
-+void hostapd_wpa_event(void *ctx, enum wpa_event_type event,
-+                       union wpa_event_data *data);
-+
- 
- int main(int argc, char *argv[])
- {
-@@ -579,6 +582,7 @@ int main(int argc, char *argv[])
- 	interfaces.global_iface_name = NULL;
- 	interfaces.global_ctrl_sock = -1;
- 
-+	wpa_supplicant_event = hostapd_wpa_event;
- 	for (;;) {
- 		c = getopt(argc, argv, "Bde:f:hKP:tvg:G:");
- 		if (c < 0)
---- a/src/drivers/drivers.c
-+++ b/src/drivers/drivers.c
-@@ -7,7 +7,11 @@
-  */
- 
- #include "includes.h"
-+#include "common.h"
-+#include "driver.h"
- 
-+void (*wpa_supplicant_event)(void *ctx, enum wpa_event_type event,
-+			     union wpa_event_data *data);
- 
- #ifdef CONFIG_DRIVER_WEXT
- extern struct wpa_driver_ops wpa_driver_wext_ops; /* driver_wext.c */
diff --git a/package/hostapd/patches/420-timestamp_check.patch b/package/hostapd/patches/420-timestamp_check.patch
deleted file mode 100644
index b2d4a05..0000000
--- a/package/hostapd/patches/420-timestamp_check.patch
+++ /dev/null
@@ -1,12 +0,0 @@
---- a/src/tls/x509v3.c
-+++ b/src/tls/x509v3.c
-@@ -1848,6 +1848,9 @@ int x509_certificate_chain_validate(stru
- 		if (chain_trusted)
- 			continue;
- 
-+#ifdef NO_TIMESTAMP_CHECK
-+		disable_time_checks = 1;
-+#endif
- 		if (!disable_time_checks &&
- 		    ((unsigned long) now.sec <
- 		     (unsigned long) cert->not_before ||
diff --git a/package/hostapd/patches/430-rescan_immediately.patch b/package/hostapd/patches/430-rescan_immediately.patch
deleted file mode 100644
index 9d5fd32..0000000
--- a/package/hostapd/patches/430-rescan_immediately.patch
+++ /dev/null
@@ -1,11 +0,0 @@
---- a/wpa_supplicant/wpa_supplicant.c
-+++ b/wpa_supplicant/wpa_supplicant.c
-@@ -2443,7 +2443,7 @@ static struct wpa_supplicant * wpa_suppl
- 	if (wpa_s == NULL)
- 		return NULL;
- 	wpa_s->scan_req = INITIAL_SCAN_REQ;
--	wpa_s->scan_interval = 5;
-+	wpa_s->scan_interval = 1;
- 	wpa_s->new_connection = 1;
- 	wpa_s->parent = wpa_s;
- 	wpa_s->sched_scanning = 0;
diff --git a/package/hostapd/patches/440-optional_rfkill.patch b/package/hostapd/patches/440-optional_rfkill.patch
deleted file mode 100644
index 8a006df..0000000
--- a/package/hostapd/patches/440-optional_rfkill.patch
+++ /dev/null
@@ -1,261 +0,0 @@
---- a/src/drivers/driver_nl80211.c
-+++ b/src/drivers/driver_nl80211.c
-@@ -218,7 +218,9 @@ struct wpa_driver_nl80211_data {
- 	int if_removed;
- 	int if_disabled;
- 	int ignore_if_down_event;
-+#ifdef CONFIG_RFKILL
- 	struct rfkill_data *rfkill;
-+#endif
- 	struct wpa_driver_capa capa;
- 	u8 *extended_capa, *extended_capa_mask;
- 	unsigned int extended_capa_len;
-@@ -3128,7 +3130,7 @@ static int wpa_driver_nl80211_init_nl(st
- 	return 0;
- }
- 
--
-+#ifdef CONFIG_RFKILL
- static void wpa_driver_nl80211_rfkill_blocked(void *ctx)
- {
- 	wpa_printf(MSG_DEBUG, "nl80211: RFKILL blocked");
-@@ -3151,6 +3153,7 @@ static void wpa_driver_nl80211_rfkill_un
- 	}
- 	/* rtnetlink ifup handler will report interface as enabled */
- }
-+#endif /* CONFIG_RFKILL */
- 
- 
- static void nl80211_get_phy_name(struct wpa_driver_nl80211_data *drv)
-@@ -3279,7 +3282,9 @@ static void * wpa_driver_nl80211_init(vo
- 				      void *global_priv)
- {
- 	struct wpa_driver_nl80211_data *drv;
-+#ifdef CONFIG_RFKILL
- 	struct rfkill_config *rcfg;
-+#endif
- 	struct i802_bss *bss;
- 
- 	if (global_priv == NULL)
-@@ -3315,6 +3320,7 @@ static void * wpa_driver_nl80211_init(vo
- 
- 	nl80211_get_phy_name(drv);
- 
-+#ifdef CONFIG_RFKILL
- 	rcfg = os_zalloc(sizeof(*rcfg));
- 	if (rcfg == NULL)
- 		goto failed;
-@@ -3327,6 +3333,7 @@ static void * wpa_driver_nl80211_init(vo
- 		wpa_printf(MSG_DEBUG, "nl80211: RFKILL status not available");
- 		os_free(rcfg);
- 	}
-+#endif /* CONFIG_RFKILL */
- 
- 	if (wpa_driver_nl80211_finish_drv_init(drv))
- 		goto failed;
-@@ -3616,10 +3623,12 @@ static void nl80211_mgmt_unsubscribe(str
- }
- 
- 
-+#ifdef CONFIG_RFKILL
- static void wpa_driver_nl80211_send_rfkill(void *eloop_ctx, void *timeout_ctx)
- {
- 	wpa_supplicant_event(timeout_ctx, EVENT_INTERFACE_DISABLED, NULL);
- }
-+#endif /* CONFIG_RFKILL */
- 
- static int
- wpa_driver_nl80211_finish_drv_init_sta(struct wpa_driver_nl80211_data *drv,
-@@ -3640,13 +3649,16 @@ wpa_driver_nl80211_finish_drv_init_sta(s
- 	}
- 
- 	if (linux_set_iface_flags(drv->global->ioctl_sock, bss->ifname, 1)) {
-+#ifdef CONFIG_RFKILL
- 		if (rfkill_is_blocked(drv->rfkill)) {
- 			wpa_printf(MSG_DEBUG, "nl80211: Could not yet enable "
- 				   "interface '%s' due to rfkill",
- 				   bss->ifname);
- 			drv->if_disabled = 1;
- 			*send_rfkill_event = 1;
--		} else {
-+		} else
-+#endif
-+		{
- 			wpa_printf(MSG_ERROR, "nl80211: Could not set "
- 				   "interface '%s' UP", bss->ifname);
- 			return -1;
-@@ -3677,8 +3689,10 @@ wpa_driver_nl80211_finish_drv_init(struc
- 		return -1;
- 
- 	if (send_rfkill_event) {
-+#ifdef CONFIG_RFKILL
- 		eloop_register_timeout(0, 0, wpa_driver_nl80211_send_rfkill,
- 				       drv, drv->ctx);
-+#endif
- 	}
- 
- 	return 0;
-@@ -3764,7 +3778,9 @@ static void wpa_driver_nl80211_deinit(st
- 
- 	netlink_send_oper_ifla(drv->global->netlink, drv->ifindex, 0,
- 			       IF_OPER_UP);
-+#ifdef CONFIG_RFKILL
- 	rfkill_deinit(drv->rfkill);
-+#endif
- 
- 	eloop_cancel_timeout(wpa_driver_nl80211_scan_timeout, drv, drv->ctx);
- 
---- a/src/drivers/driver_wext.c
-+++ b/src/drivers/driver_wext.c
-@@ -742,7 +742,7 @@ static void wpa_driver_wext_event_rtm_de
- 	}
- }
- 
--
-+#ifdef CONFIG_RFKILL
- static void wpa_driver_wext_rfkill_blocked(void *ctx)
- {
- 	wpa_printf(MSG_DEBUG, "WEXT: RFKILL blocked");
-@@ -764,7 +764,7 @@ static void wpa_driver_wext_rfkill_unblo
- 	}
- 	/* rtnetlink ifup handler will report interface as enabled */
- }
--
-+#endif /* CONFIG_RFKILL */
- 
- static void wext_get_phy_name(struct wpa_driver_wext_data *drv)
- {
-@@ -810,7 +810,9 @@ void * wpa_driver_wext_init(void *ctx, c
- {
- 	struct wpa_driver_wext_data *drv;
- 	struct netlink_config *cfg;
-+#ifdef CONFIG_RFKILL
- 	struct rfkill_config *rcfg;
-+#endif
- 	char path[128];
- 	struct stat buf;
- 
-@@ -845,6 +847,7 @@ void * wpa_driver_wext_init(void *ctx, c
- 		goto err2;
- 	}
- 
-+#ifdef CONFIG_RFKILL
- 	rcfg = os_zalloc(sizeof(*rcfg));
- 	if (rcfg == NULL)
- 		goto err3;
-@@ -857,6 +860,7 @@ void * wpa_driver_wext_init(void *ctx, c
- 		wpa_printf(MSG_DEBUG, "WEXT: RFKILL status not available");
- 		os_free(rcfg);
- 	}
-+#endif /* CONFIG_RFKILL */
- 
- 	drv->mlme_sock = -1;
- 
-@@ -874,7 +878,9 @@ void * wpa_driver_wext_init(void *ctx, c
- 	return drv;
- 
- err3:
-+#ifdef CONFIG_RFKILL
- 	rfkill_deinit(drv->rfkill);
-+#endif
- 	netlink_deinit(drv->netlink);
- err2:
- 	close(drv->ioctl_sock);
-@@ -884,10 +890,12 @@ err1:
- }
- 
- 
-+#ifdef CONFIG_RFKILL
- static void wpa_driver_wext_send_rfkill(void *eloop_ctx, void *timeout_ctx)
- {
- 	wpa_supplicant_event(timeout_ctx, EVENT_INTERFACE_DISABLED, NULL);
- }
-+#endif /* CONFIG_RFKILL */
- 
- 
- static int wpa_driver_wext_finish_drv_init(struct wpa_driver_wext_data *drv)
-@@ -895,13 +903,16 @@ static int wpa_driver_wext_finish_drv_in
- 	int send_rfkill_event = 0;
- 
- 	if (linux_set_iface_flags(drv->ioctl_sock, drv->ifname, 1) < 0) {
-+#ifdef CONFIG_RFKILL
- 		if (rfkill_is_blocked(drv->rfkill)) {
- 			wpa_printf(MSG_DEBUG, "WEXT: Could not yet enable "
- 				   "interface '%s' due to rfkill",
- 				   drv->ifname);
- 			drv->if_disabled = 1;
- 			send_rfkill_event = 1;
--		} else {
-+		} else
-+#endif
-+		{
- 			wpa_printf(MSG_ERROR, "WEXT: Could not set "
- 				   "interface '%s' UP", drv->ifname);
- 			return -1;
-@@ -949,8 +960,10 @@ static int wpa_driver_wext_finish_drv_in
- 			       1, IF_OPER_DORMANT);
- 
- 	if (send_rfkill_event) {
-+#ifdef CONFIG_RFKILL
- 		eloop_register_timeout(0, 0, wpa_driver_wext_send_rfkill,
- 				       drv, drv->ctx);
-+#endif
- 	}
- 
- 	return 0;
-@@ -980,7 +993,9 @@ void wpa_driver_wext_deinit(void *priv)
- 
- 	netlink_send_oper_ifla(drv->netlink, drv->ifindex, 0, IF_OPER_UP);
- 	netlink_deinit(drv->netlink);
-+#ifdef CONFIG_RFKILL
- 	rfkill_deinit(drv->rfkill);
-+#endif
- 
- 	if (drv->mlme_sock >= 0)
- 		eloop_unregister_read_sock(drv->mlme_sock);
---- a/src/drivers/drivers.mak
-+++ b/src/drivers/drivers.mak
-@@ -25,7 +25,6 @@ NEED_SME=y
- NEED_AP_MLME=y
- NEED_NETLINK=y
- NEED_LINUX_IOCTL=y
--NEED_RFKILL=y
- 
- ifdef CONFIG_LIBNL32
-   DRV_LIBS += -lnl-3
-@@ -109,7 +108,6 @@ DRV_WPA_CFLAGS += -DCONFIG_DRIVER_WEXT
- CONFIG_WIRELESS_EXTENSION=y
- NEED_NETLINK=y
- NEED_LINUX_IOCTL=y
--NEED_RFKILL=y
- endif
- 
- ifdef CONFIG_DRIVER_NDIS
-@@ -135,7 +133,6 @@ endif
- ifdef CONFIG_WIRELESS_EXTENSION
- DRV_WPA_CFLAGS += -DCONFIG_WIRELESS_EXTENSION
- DRV_WPA_OBJS += ../src/drivers/driver_wext.o
--NEED_RFKILL=y
- endif
- 
- ifdef NEED_NETLINK
-@@ -148,6 +145,7 @@ endif
- 
- ifdef NEED_RFKILL
- DRV_OBJS += ../src/drivers/rfkill.o
-+DRV_WPA_CFLAGS += -DCONFIG_RFKILL
- endif
- 
- ifdef CONFIG_VLAN_NETLINK
---- a/src/drivers/driver_wext.h
-+++ b/src/drivers/driver_wext.h
-@@ -22,7 +22,9 @@ struct wpa_driver_wext_data {
- 	int ifindex2;
- 	int if_removed;
- 	int if_disabled;
-+#ifdef CONFIG_RFKILL
- 	struct rfkill_data *rfkill;
-+#endif
- 	u8 *assoc_req_ies;
- 	size_t assoc_req_ies_len;
- 	u8 *assoc_resp_ies;
diff --git a/package/hostapd/patches/450-reload_freq_change.patch b/package/hostapd/patches/450-reload_freq_change.patch
deleted file mode 100644
index ffa757e..0000000
--- a/package/hostapd/patches/450-reload_freq_change.patch
+++ /dev/null
@@ -1,27 +0,0 @@
---- a/src/ap/hostapd.c
-+++ b/src/ap/hostapd.c
-@@ -156,6 +156,24 @@ int hostapd_reload_config(struct hostapd
- 	oldconf = hapd->iconf;
- 	iface->conf = newconf;
- 
-+	hostapd_select_hw_mode(iface);
-+	iface->freq = hostapd_hw_get_freq(hapd, newconf->channel);
-+
-+	if (hostapd_set_freq(hapd, newconf->hw_mode, iface->freq,
-+			     newconf->channel,
-+			     newconf->ieee80211n,
-+			     newconf->ieee80211ac,
-+			     newconf->secondary_channel,
-+			     newconf->vht_oper_chwidth,
-+			     newconf->vht_oper_centr_freq_seg0_idx,
-+			     newconf->vht_oper_centr_freq_seg1_idx)) {
-+		wpa_printf(MSG_ERROR, "Could not set channel for "
-+			   "kernel driver");
-+	}
-+
-+	if (iface->current_mode)
-+		hostapd_prepare_rates(iface, iface->current_mode);
-+
- 	for (j = 0; j < iface->num_bss; j++) {
- 		hapd = iface->bss[j];
- 		hapd->iconf = newconf;
diff --git a/package/hostapd/patches/451-nl80211_del_beacon_bss.patch b/package/hostapd/patches/451-nl80211_del_beacon_bss.patch
deleted file mode 100644
index fdff9e7..0000000
--- a/package/hostapd/patches/451-nl80211_del_beacon_bss.patch
+++ /dev/null
@@ -1,63 +0,0 @@
---- a/src/drivers/driver_nl80211.c
-+++ b/src/drivers/driver_nl80211.c
-@@ -3699,16 +3699,18 @@ wpa_driver_nl80211_finish_drv_init(struc
- }
- 
- 
--static int wpa_driver_nl80211_del_beacon(struct wpa_driver_nl80211_data *drv)
-+static int wpa_driver_nl80211_del_bss_beacon(struct i802_bss *bss)
- {
-+	struct wpa_driver_nl80211_data *drv = bss->drv;
- 	struct nl_msg *msg;
- 
-+	bss->beacon_set = 0;
- 	msg = nlmsg_alloc();
- 	if (!msg)
- 		return -ENOMEM;
- 
- 	nl80211_cmd(drv, msg, 0, NL80211_CMD_DEL_BEACON);
--	NLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, drv->ifindex);
-+	NLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, bss->ifindex);
- 
- 	return send_and_recv_msgs(drv, msg, NULL, NULL);
-  nla_put_failure:
-@@ -3716,6 +3718,21 @@ static int wpa_driver_nl80211_del_beacon
- 	return -ENOBUFS;
- }
- 
-+static int wpa_driver_nl80211_del_beacon(struct wpa_driver_nl80211_data *drv)
-+{
-+	struct i802_bss *bss;
-+
-+	for (bss = &drv->first_bss; bss; bss = bss->next)
-+		wpa_driver_nl80211_del_bss_beacon(bss);
-+
-+	return 0;
-+}
-+
-+static int wpa_driver_nl80211_stop_ap(void *priv)
-+{
-+	struct i802_bss *bss = priv;
-+	return wpa_driver_nl80211_del_beacon(bss->drv);
-+}
- 
- /**
-  * wpa_driver_nl80211_deinit - Deinitialize nl80211 driver interface
-@@ -9855,4 +9872,5 @@ const struct wpa_driver_ops wpa_driver_n
- 	.tdls_oper = nl80211_tdls_oper,
- #endif /* CONFIG_TDLS */
- 	.update_ft_ies = wpa_driver_nl80211_update_ft_ies,
-+	.stop_ap = wpa_driver_nl80211_stop_ap,
- };
---- a/src/drivers/driver.h
-+++ b/src/drivers/driver.h
-@@ -2095,6 +2095,9 @@ struct wpa_driver_ops {
- 	 */
- 	int (*probe_req_report)(void *priv, int report);
- 
-+
-+	int (*stop_ap)(void *priv);
-+
- 	/**
- 	 * deinit_ap - Deinitialize AP mode
- 	 * @priv: Private driver interface data
diff --git a/package/hostapd/patches/452-ctrl_iface_reload.patch b/package/hostapd/patches/452-ctrl_iface_reload.patch
deleted file mode 100644
index 85e871f..0000000
--- a/package/hostapd/patches/452-ctrl_iface_reload.patch
+++ /dev/null
@@ -1,98 +0,0 @@
---- a/hostapd/ctrl_iface.c
-+++ b/hostapd/ctrl_iface.c
-@@ -33,6 +33,7 @@
- #include "wps/wps.h"
- #include "config_file.h"
- #include "ctrl_iface.h"
-+#include "config_file.h"
- 
- 
- struct wpa_ctrl_dst {
-@@ -43,6 +44,7 @@ struct wpa_ctrl_dst {
- 	int errors;
- };
- 
-+static char *reload_opts = NULL;
- 
- static void hostapd_ctrl_iface_send(struct hostapd_data *hapd, int level,
- 				    const char *buf, size_t len);
-@@ -152,6 +154,68 @@ static int hostapd_ctrl_iface_new_sta(st
- 	return 0;
- }
- 
-+static int hostapd_ctrl_iface_set_down(struct hostapd_data *hapd)
-+{
-+	if (hapd->driver->stop_ap)
-+		hapd->driver->stop_ap(hapd->drv_priv);
-+	return 0;
-+}
-+
-+static char *get_option(char *opt, char *str)
-+{
-+	int len = strlen(str);
-+
-+	if (!strncmp(opt, str, len))
-+		return opt + len;
-+	else
-+		return NULL;
-+}
-+
-+static struct hostapd_config *hostapd_ctrl_iface_config_read(const char *fname)
-+{
-+	struct hostapd_config *conf;
-+	char *opt, *val;
-+
-+	conf = hostapd_config_read(fname);
-+	if (!conf)
-+		return NULL;
-+
-+	for (opt = strtok(reload_opts, " ");
-+	     opt;
-+		 opt = strtok(NULL, " ")) {
-+
-+		if ((val = get_option(opt, "channel=")))
-+			conf->channel = atoi(val);
-+		else if ((val = get_option(opt, "ht_capab=")))
-+			conf->ht_capab = atoi(val);
-+		else if ((val = get_option(opt, "ht_capab_mask=")))
-+			conf->ht_capab &= atoi(val);
-+		else if ((val = get_option(opt, "sec_chan=")))
-+			conf->secondary_channel = atoi(val);
-+		else if ((val = get_option(opt, "hw_mode=")))
-+			conf->hw_mode = atoi(val);
-+		else if ((val = get_option(opt, "ieee80211n=")))
-+			conf->ieee80211n = atoi(val);
-+		else
-+			break;
-+	}
-+
-+	return conf;
-+}
-+
-+static int hostapd_ctrl_iface_update(struct hostapd_data *hapd, char *txt)
-+{
-+	struct hostapd_config * (*config_read_cb)(const char *config_fname);
-+	struct hostapd_iface *iface = hapd->iface;
-+
-+	config_read_cb = iface->interfaces->config_read_cb;
-+	iface->interfaces->config_read_cb = hostapd_ctrl_iface_config_read;
-+	reload_opts = txt;
-+
-+	hostapd_reload_config(iface);
-+
-+	iface->interfaces->config_read_cb = config_read_cb;
-+}
- 
- #ifdef CONFIG_IEEE80211W
- #ifdef NEED_AP_MLME
-@@ -902,6 +966,10 @@ static void hostapd_ctrl_iface_receive(i
- 				reply_len += res;
- 		}
- #endif /* CONFIG_NO_RADIUS */
-+	} else if (os_strcmp(buf, "DOWN") == 0) {
-+		hostapd_ctrl_iface_set_down(hapd);
-+	} else if (os_strncmp(buf, "UPDATE ", 7) == 0) {
-+		hostapd_ctrl_iface_update(hapd, buf + 7);
- 	} else if (os_strcmp(buf, "STA-FIRST") == 0) {
- 		reply_len = hostapd_ctrl_iface_sta_first(hapd, reply,
- 							 reply_size);
diff --git a/package/hostapd/patches/453-ap_sta_support.patch b/package/hostapd/patches/453-ap_sta_support.patch
deleted file mode 100644
index a3dff04..0000000
--- a/package/hostapd/patches/453-ap_sta_support.patch
+++ /dev/null
@@ -1,223 +0,0 @@
---- a/wpa_supplicant/wpa_supplicant_i.h
-+++ b/wpa_supplicant/wpa_supplicant_i.h
-@@ -96,6 +96,8 @@ struct wpa_interface {
- 	 * receiving of EAPOL frames from an additional interface.
- 	 */
- 	const char *bridge_ifname;
-+
-+	const char *hostapd_ctrl;
- };
- 
- /**
-@@ -306,6 +308,8 @@ struct wpa_supplicant {
- #endif /* CONFIG_CTRL_IFACE_DBUS_NEW */
- 	char bridge_ifname[16];
- 
-+	struct wpa_ctrl *hostapd;
-+
- 	char *confname;
- 	struct wpa_config *conf;
- 	int countermeasures;
---- a/wpa_supplicant/Makefile
-+++ b/wpa_supplicant/Makefile
-@@ -13,6 +13,10 @@ PKG_CONFIG ?= pkg-config
- CFLAGS += -I../src
- CFLAGS += -I../src/utils
- 
-+ifdef MULTICALL
-+CFLAGS += -DMULTICALL
-+endif
-+
- -include .config
- -include $(if $(MULTICALL),../hostapd/.config)
- 
-@@ -76,6 +80,10 @@ OBJS_c = wpa_cli.o ../src/common/wpa_ctr
- OBJS_c += ../src/utils/wpa_debug.o
- OBJS_c += ../src/utils/common.o
- 
-+ifdef MULTICALL
-+OBJS += ../src/common/wpa_ctrl.o
-+endif
-+
- ifndef CONFIG_OS
- ifdef CONFIG_NATIVE_WINDOWS
- CONFIG_OS=win32
---- a/wpa_supplicant/wpa_supplicant.c
-+++ b/wpa_supplicant/wpa_supplicant.c
-@@ -107,6 +107,55 @@ extern int wpa_debug_show_keys;
- extern int wpa_debug_timestamp;
- extern struct wpa_driver_ops *wpa_drivers[];
- 
-+#ifdef MULTICALL
-+static int hostapd_stop(struct wpa_supplicant *wpa_s)
-+{
-+	const char *cmd = "DOWN";
-+	char buf[256];
-+	int len = sizeof(buf);
-+
-+	if (wpa_ctrl_request(wpa_s->hostapd, cmd, os_strlen(cmd), buf, &len, NULL) < 0) {
-+		wpa_printf(MSG_ERROR, "\nFailed to stop hostapd AP interfaces\n");
-+		return -1;
-+	}
-+	return 0;
-+}
-+
-+static int hostapd_reload(struct wpa_supplicant *wpa_s, struct wpa_bss *bss)
-+{
-+	char *cmd = NULL;
-+	char buf[256];
-+	int len = sizeof(buf);
-+	int channel, hw_mode;
-+	int ret;
-+
-+	if (!bss)
-+		return;
-+
-+	if (bss->freq < 4000) {
-+		hw_mode = HOSTAPD_MODE_IEEE80211G;
-+		channel = (bss->freq - 2407) / 5;
-+	} else {
-+		hw_mode = HOSTAPD_MODE_IEEE80211A;
-+		channel = (bss->freq - 5000) / 5;
-+	}
-+
-+	if (asprintf(&cmd, "UPDATE channel=%d sec_chan=0 hw_mode=%d ieee80211n=%d",
-+		     channel, hw_mode, !!bss->ht_capab) < 0) {
-+		return -1;
-+	}
-+
-+	ret = wpa_ctrl_request(wpa_s->hostapd, cmd, os_strlen(cmd), buf, &len, NULL);
-+	free(cmd);
-+
-+	if (ret < 0) {
-+		wpa_printf(MSG_ERROR, "\nFailed to reload hostapd AP interfaces\n");
-+		return -1;
-+	}
-+	return 0;
-+}
-+#endif
-+
- /* Configure default/group WEP keys for static WEP */
- int wpa_set_wep_keys(struct wpa_supplicant *wpa_s, struct wpa_ssid *ssid)
- {
-@@ -667,8 +716,16 @@ void wpa_supplicant_set_state(struct wpa
- #endif /* CONFIG_P2P */
- 
- 		sme_sched_obss_scan(wpa_s, 1);
-+#ifdef MULTICALL
-+		if (wpa_s->hostapd)
-+			hostapd_reload(wpa_s, wpa_s->current_bss);
-+#endif
- 	} else if (state == WPA_DISCONNECTED || state == WPA_ASSOCIATING ||
- 		   state == WPA_ASSOCIATED) {
-+#ifdef MULTICALL
-+		if (wpa_s->hostapd)
-+			hostapd_stop(wpa_s);
-+#endif
- 		wpa_s->new_connection = 1;
- 		wpa_drv_set_operstate(wpa_s, 0);
- #ifndef IEEE8021X_EAPOL
-@@ -2853,6 +2910,21 @@ static int wpa_supplicant_init_iface(str
- 		os_strlcpy(wpa_s->bridge_ifname, iface->bridge_ifname,
- 			   sizeof(wpa_s->bridge_ifname));
- 	}
-+#ifdef MULTICALL
-+	if (iface->hostapd_ctrl) {
-+		char *cmd = "DOWN";
-+		char buf[256];
-+		int len = sizeof(buf);
-+
-+		wpa_s->hostapd = wpa_ctrl_open(iface->hostapd_ctrl);
-+		if (!wpa_s->hostapd) {
-+			wpa_printf(MSG_ERROR, "\nFailed to connect to hostapd\n");
-+			return -1;
-+		}
-+		if (hostapd_stop(wpa_s) < 0)
-+			return -1;
-+	}
-+#endif
- 
- 	/* RSNA Supplicant Key Management - INITIALIZE */
- 	eapol_sm_notify_portEnabled(wpa_s->eapol, FALSE);
---- a/wpa_supplicant/bss.c
-+++ b/wpa_supplicant/bss.c
-@@ -11,6 +11,7 @@
- #include "utils/common.h"
- #include "utils/eloop.h"
- #include "common/ieee802_11_defs.h"
-+#include "common/ieee802_11_common.h"
- #include "drivers/driver.h"
- #include "wpa_supplicant_i.h"
- #include "config.h"
-@@ -245,6 +246,9 @@ static void calculate_update_time(const 
- static void wpa_bss_copy_res(struct wpa_bss *dst, struct wpa_scan_res *src,
- 			     struct os_time *fetch_time)
- {
-+	struct ieee80211_ht_capabilities *capab;
-+	struct ieee802_11_elems elems;
-+
- 	dst->flags = src->flags;
- 	os_memcpy(dst->bssid, src->bssid, ETH_ALEN);
- 	dst->freq = src->freq;
-@@ -255,6 +259,12 @@ static void wpa_bss_copy_res(struct wpa_
- 	dst->level = src->level;
- 	dst->tsf = src->tsf;
- 
-+	memset(&elems, 0, sizeof(elems));
-+	ieee802_11_parse_elems((u8 *) (src + 1), src->ie_len, &elems, 0);
-+	capab = (struct ieee80211_ht_capabilities *) elems.ht_capabilities;
-+	if (capab)
-+		dst->ht_capab = le_to_host16(capab->ht_capabilities_info);
-+
- 	calculate_update_time(fetch_time, src->age, &dst->last_update);
- }
- 
---- a/wpa_supplicant/main.c
-+++ b/wpa_supplicant/main.c
-@@ -25,7 +25,7 @@ static void usage(void)
- 	       "usage:\n"
- 	       "  wpa_supplicant [-BddhKLqqstuvW] [-P<pid file>] "
- 	       "[-g<global ctrl>] \\\n"
--	       "        -i<ifname> -c<config file> [-C<ctrl>] [-D<driver>] "
-+	       "        -i<ifname> -c<config file> [-C<ctrl>] [-D<driver>] [-H<hostapd path>]"
- 	       "[-p<driver_param>] \\\n"
- 	       "        [-b<br_ifname>] [-f<debug file>] [-e<entropy file>] "
- 	       "\\\n"
-@@ -67,6 +67,7 @@ static void usage(void)
- #endif /* CONFIG_DEBUG_LINUX_TRACING */
- 	printf("  -t = include timestamp in debug messages\n"
- 	       "  -h = show this help text\n"
-+		   "  -H = connect to a hostapd instance to manage state changes\n"
- 	       "  -L = show license (BSD)\n"
- 	       "  -o = override driver parameter for new interfaces\n"
- 	       "  -O = override ctrl_interface parameter for new interfaces\n"
-@@ -155,7 +156,7 @@ int main(int argc, char *argv[])
- 
- 	for (;;) {
- 		c = getopt(argc, argv,
--			   "b:Bc:C:D:de:f:g:hi:KLNo:O:p:P:qsTtuvW");
-+			   "b:Bc:C:D:de:f:g:hH:i:KLNo:O:p:P:qsTtuvW");
- 		if (c < 0)
- 			break;
- 		switch (c) {
-@@ -199,6 +200,9 @@ int main(int argc, char *argv[])
- 			usage();
- 			exitcode = 0;
- 			goto out;
-+		case 'H':
-+			iface->hostapd_ctrl = optarg;
-+			break;
- 		case 'i':
- 			iface->ifname = optarg;
- 			break;
---- a/wpa_supplicant/bss.h
-+++ b/wpa_supplicant/bss.h
-@@ -69,6 +69,8 @@ struct wpa_bss {
- 	u8 ssid[32];
- 	/** Length of SSID */
- 	size_t ssid_len;
-+	/** HT caapbilities */
-+	u16 ht_capab;
- 	/** Frequency of the channel in MHz (e.g., 2412 = channel 1) */
- 	int freq;
- 	/** Beacon interval in TUs (host byte order) */
diff --git a/package/hostapd/patches/460-disable_ctrl_iface_mib.patch b/package/hostapd/patches/460-disable_ctrl_iface_mib.patch
deleted file mode 100644
index a51ade8..0000000
--- a/package/hostapd/patches/460-disable_ctrl_iface_mib.patch
+++ /dev/null
@@ -1,168 +0,0 @@
---- a/hostapd/Makefile
-+++ b/hostapd/Makefile
-@@ -136,6 +136,9 @@ endif
- ifdef CONFIG_NO_CTRL_IFACE
- CFLAGS += -DCONFIG_NO_CTRL_IFACE
- else
-+ifdef CONFIG_CTRL_IFACE_MIB
-+CFLAGS += -DCONFIG_CTRL_IFACE_MIB
-+endif
- OBJS += ctrl_iface.o
- OBJS += ../src/ap/ctrl_iface_ap.o
- endif
---- a/hostapd/ctrl_iface.c
-+++ b/hostapd/ctrl_iface.c
-@@ -937,6 +937,7 @@ static void hostapd_ctrl_iface_receive(i
- 	} else if (os_strncmp(buf, "RELOG", 5) == 0) {
- 		if (wpa_debug_reopen_file() < 0)
- 			reply_len = -1;
-+#ifdef CONFIG_CTRL_IFACE_MIB
- 	} else if (os_strcmp(buf, "MIB") == 0) {
- 		reply_len = ieee802_11_get_mib(hapd, reply, reply_size);
- 		if (reply_len >= 0) {
-@@ -966,10 +967,12 @@ static void hostapd_ctrl_iface_receive(i
- 				reply_len += res;
- 		}
- #endif /* CONFIG_NO_RADIUS */
-+#endif
- 	} else if (os_strcmp(buf, "DOWN") == 0) {
- 		hostapd_ctrl_iface_set_down(hapd);
- 	} else if (os_strncmp(buf, "UPDATE ", 7) == 0) {
- 		hostapd_ctrl_iface_update(hapd, buf + 7);
-+#ifdef CONFIG_CTRL_IFACE_MIB
- 	} else if (os_strcmp(buf, "STA-FIRST") == 0) {
- 		reply_len = hostapd_ctrl_iface_sta_first(hapd, reply,
- 							 reply_size);
-@@ -979,6 +982,7 @@ static void hostapd_ctrl_iface_receive(i
- 	} else if (os_strncmp(buf, "STA-NEXT ", 9) == 0) {
- 		reply_len = hostapd_ctrl_iface_sta_next(hapd, buf + 9, reply,
- 							reply_size);
-+#endif
- 	} else if (os_strcmp(buf, "ATTACH") == 0) {
- 		if (hostapd_ctrl_iface_attach(hapd, &from, fromlen))
- 			reply_len = -1;
---- a/wpa_supplicant/Makefile
-+++ b/wpa_supplicant/Makefile
-@@ -758,6 +758,9 @@ ifdef CONFIG_WNM
- OBJS += ../src/ap/wnm_ap.o
- endif
- ifdef CONFIG_CTRL_IFACE
-+ifdef CONFIG_CTRL_IFACE_MIB
-+CFLAGS += -DCONFIG_CTRL_IFACE_MIB
-+endif
- OBJS += ../src/ap/ctrl_iface_ap.o
- endif
- 
---- a/wpa_supplicant/ctrl_iface.c
-+++ b/wpa_supplicant/ctrl_iface.c
-@@ -5051,6 +5051,7 @@ char * wpa_supplicant_ctrl_iface_process
- 			reply_len = -1;
- 	} else if (os_strncmp(buf, "NOTE ", 5) == 0) {
- 		wpa_printf(MSG_INFO, "NOTE: %s", buf + 5);
-+#ifdef CONFIG_CTRL_IFACE_MIB
- 	} else if (os_strcmp(buf, "MIB") == 0) {
- 		reply_len = wpa_sm_get_mib(wpa_s->wpa, reply, reply_size);
- 		if (reply_len >= 0) {
-@@ -5062,6 +5063,7 @@ char * wpa_supplicant_ctrl_iface_process
- 			else
- 				reply_len += res;
- 		}
-+#endif
- 	} else if (os_strncmp(buf, "STATUS", 6) == 0) {
- 		reply_len = wpa_supplicant_ctrl_iface_status(
- 			wpa_s, buf + 6, reply, reply_size);
-@@ -5465,6 +5467,7 @@ char * wpa_supplicant_ctrl_iface_process
- 		reply_len = wpa_supplicant_ctrl_iface_bss(
- 			wpa_s, buf + 4, reply, reply_size);
- #ifdef CONFIG_AP
-+#ifdef CONFIG_CTRL_IFACE_MIB
- 	} else if (os_strcmp(buf, "STA-FIRST") == 0) {
- 		reply_len = ap_ctrl_iface_sta_first(wpa_s, reply, reply_size);
- 	} else if (os_strncmp(buf, "STA ", 4) == 0) {
-@@ -5473,6 +5476,7 @@ char * wpa_supplicant_ctrl_iface_process
- 	} else if (os_strncmp(buf, "STA-NEXT ", 9) == 0) {
- 		reply_len = ap_ctrl_iface_sta_next(wpa_s, buf + 9, reply,
- 						   reply_size);
-+#endif
- 	} else if (os_strncmp(buf, "DEAUTHENTICATE ", 15) == 0) {
- 		if (ap_ctrl_iface_sta_deauthenticate(wpa_s, buf + 15))
- 			reply_len = -1;
---- a/src/ap/ctrl_iface_ap.c
-+++ b/src/ap/ctrl_iface_ap.c
-@@ -20,6 +20,7 @@
- #include "ctrl_iface_ap.h"
- #include "ap_drv_ops.h"
- 
-+#ifdef CONFIG_CTRL_IFACE_MIB
- 
- static int hostapd_get_sta_conn_time(struct sta_info *sta,
- 				     char *buf, size_t buflen)
-@@ -129,6 +130,7 @@ int hostapd_ctrl_iface_sta_next(struct h
- 	return hostapd_ctrl_iface_sta_mib(hapd, sta->next, buf, buflen);
- }
- 
-+#endif
- 
- #ifdef CONFIG_P2P_MANAGER
- static int p2p_manager_disconnect(struct hostapd_data *hapd, u16 stype,
-@@ -303,3 +305,4 @@ int hostapd_ctrl_iface_disassociate(stru
- 
- 	return 0;
- }
-+
---- a/src/ap/ieee802_1x.c
-+++ b/src/ap/ieee802_1x.c
-@@ -2048,6 +2048,7 @@ static const char * bool_txt(Boolean boo
- 	return bool ? "TRUE" : "FALSE";
- }
- 
-+#ifdef CONFIG_CTRL_IFACE_MIB
- 
- int ieee802_1x_get_mib(struct hostapd_data *hapd, char *buf, size_t buflen)
- {
-@@ -2200,6 +2201,7 @@ int ieee802_1x_get_mib_sta(struct hostap
- 	return len;
- }
- 
-+#endif
- 
- static void ieee802_1x_finished(struct hostapd_data *hapd,
- 				struct sta_info *sta, int success)
---- a/src/ap/wpa_auth.c
-+++ b/src/ap/wpa_auth.c
-@@ -2687,6 +2687,7 @@ static const char * wpa_bool_txt(int boo
- 	return bool ? "TRUE" : "FALSE";
- }
- 
-+#ifdef CONFIG_CTRL_IFACE_MIB
- 
- #define RSN_SUITE "%02x-%02x-%02x-%d"
- #define RSN_SUITE_ARG(s) \
-@@ -2831,7 +2832,7 @@ int wpa_get_mib_sta(struct wpa_state_mac
- 
- 	return len;
- }
--
-+#endif
- 
- void wpa_auth_countermeasures_start(struct wpa_authenticator *wpa_auth)
- {
---- a/src/rsn_supp/wpa.c
-+++ b/src/rsn_supp/wpa.c
-@@ -1848,6 +1848,8 @@ static u32 wpa_key_mgmt_suite(struct wpa
- }
- 
- 
-+#ifdef CONFIG_CTRL_IFACE_MIB
-+
- #define RSN_SUITE "%02x-%02x-%02x-%d"
- #define RSN_SUITE_ARG(s) \
- ((s) >> 24) & 0xff, ((s) >> 16) & 0xff, ((s) >> 8) & 0xff, (s) & 0xff
-@@ -1931,6 +1933,7 @@ int wpa_sm_get_mib(struct wpa_sm *sm, ch
- 
- 	return (int) len;
- }
-+#endif
- #endif /* CONFIG_CTRL_IFACE */
- 
- 
diff --git a/package/hostapd/patches/470-wpa_ie_cap_workaround.patch b/package/hostapd/patches/470-wpa_ie_cap_workaround.patch
deleted file mode 100644
index 974ec3d..0000000
--- a/package/hostapd/patches/470-wpa_ie_cap_workaround.patch
+++ /dev/null
@@ -1,56 +0,0 @@
---- a/src/common/wpa_common.c
-+++ b/src/common/wpa_common.c
-@@ -965,6 +965,31 @@ const char * wpa_key_mgmt_txt(int key_mg
- }
- 
- 
-+static void wpa_fixup_wpa_ie_rsn(u8 *assoc_ie, const u8 *wpa_msg_ie,
-+				 size_t rsn_ie_len)
-+{
-+	int pos, count;
-+
-+	pos = sizeof(struct rsn_ie_hdr) + RSN_SELECTOR_LEN;
-+	if (rsn_ie_len < pos + 2)
-+		return;
-+
-+	count = WPA_GET_LE16(wpa_msg_ie + pos);
-+	pos += 2 + count * RSN_SELECTOR_LEN;
-+	if (rsn_ie_len < pos + 2)
-+		return;
-+
-+	count = WPA_GET_LE16(wpa_msg_ie + pos);
-+	pos += 2 + count * RSN_SELECTOR_LEN;
-+	if (rsn_ie_len < pos + 2)
-+		return;
-+
-+	if (!assoc_ie[pos] && !assoc_ie[pos + 1] &&
-+	    (wpa_msg_ie[pos] || wpa_msg_ie[pos + 1]))
-+		memcpy(&assoc_ie[pos], &wpa_msg_ie[pos], 2);
-+}
-+
-+
- int wpa_compare_rsn_ie(int ft_initial_assoc,
- 		       const u8 *ie1, size_t ie1len,
- 		       const u8 *ie2, size_t ie2len)
-@@ -972,8 +997,19 @@ int wpa_compare_rsn_ie(int ft_initial_as
- 	if (ie1 == NULL || ie2 == NULL)
- 		return -1;
- 
--	if (ie1len == ie2len && os_memcmp(ie1, ie2, ie1len) == 0)
--		return 0; /* identical IEs */
-+	if (ie1len == ie2len) {
-+		u8 *ie_tmp;
-+
-+		if (os_memcmp(ie1, ie2, ie1len) == 0)
-+			return 0; /* identical IEs */
-+
-+		ie_tmp = alloca(ie1len);
-+		memcpy(ie_tmp, ie1, ie1len);
-+		wpa_fixup_wpa_ie_rsn(ie_tmp, ie2, ie1len);
-+
-+		if (os_memcmp(ie_tmp, ie2, ie1len) == 0)
-+			return 0; /* only mismatch in RSN capabilties */
-+	}
- 
- #ifdef CONFIG_IEEE80211R
- 	if (ft_initial_assoc) {
diff --git a/package/hostapd/patches/480-terminate_on_setup_failure.patch b/package/hostapd/patches/480-terminate_on_setup_failure.patch
deleted file mode 100644
index 3f8a778..0000000
--- a/package/hostapd/patches/480-terminate_on_setup_failure.patch
+++ /dev/null
@@ -1,81 +0,0 @@
---- a/src/ap/hostapd.c
-+++ b/src/ap/hostapd.c
-@@ -911,11 +911,8 @@ int hostapd_setup_interface_complete(str
- 	size_t j;
- 	u8 *prev_addr;
- 
--	if (err) {
--		wpa_printf(MSG_ERROR, "Interface initialization failed");
--		eloop_terminate();
--		return -1;
--	}
-+	if (err)
-+		goto error;
- 
- 	wpa_printf(MSG_DEBUG, "Completing interface initialization");
- 	if (hapd->iconf->channel) {
-@@ -935,7 +932,7 @@ int hostapd_setup_interface_complete(str
- 				     hapd->iconf->vht_oper_centr_freq_seg1_idx)) {
- 			wpa_printf(MSG_ERROR, "Could not set channel for "
- 				   "kernel driver");
--			return -1;
-+			goto error;
- 		}
- 	}
- 
-@@ -946,7 +943,7 @@ int hostapd_setup_interface_complete(str
- 			hostapd_logger(hapd, NULL, HOSTAPD_MODULE_IEEE80211,
- 				       HOSTAPD_LEVEL_WARNING,
- 				       "Failed to prepare rates table.");
--			return -1;
-+			goto error;
- 		}
- 	}
- 
-@@ -954,14 +951,14 @@ int hostapd_setup_interface_complete(str
- 	    hostapd_set_rts(hapd, hapd->iconf->rts_threshold)) {
- 		wpa_printf(MSG_ERROR, "Could not set RTS threshold for "
- 			   "kernel driver");
--		return -1;
-+		goto error;
- 	}
- 
- 	if (hapd->iconf->fragm_threshold > -1 &&
- 	    hostapd_set_frag(hapd, hapd->iconf->fragm_threshold)) {
- 		wpa_printf(MSG_ERROR, "Could not set fragmentation threshold "
- 			   "for kernel driver");
--		return -1;
-+		goto error;
- 	}
- 
- 	prev_addr = hapd->own_addr;
-@@ -971,7 +968,7 @@ int hostapd_setup_interface_complete(str
- 		if (j)
- 			os_memcpy(hapd->own_addr, prev_addr, ETH_ALEN);
- 		if (hostapd_setup_bss(hapd, j == 0))
--			return -1;
-+			goto error;
- 		if (hostapd_mac_comp_empty(hapd->conf->bssid) == 0)
- 			prev_addr = hapd->own_addr;
- 	}
-@@ -983,7 +980,7 @@ int hostapd_setup_interface_complete(str
- 	if (hostapd_driver_commit(hapd) < 0) {
- 		wpa_printf(MSG_ERROR, "%s: Failed to commit driver "
- 			   "configuration", __func__);
--		return -1;
-+		goto error;
- 	}
- 
- 	/*
-@@ -1004,6 +1001,11 @@ int hostapd_setup_interface_complete(str
- 		   iface->bss[0]->conf->iface);
- 
- 	return 0;
-+
-+error:
-+	wpa_printf(MSG_ERROR, "Interface initialization failed");
-+	eloop_terminate();
-+	return -1;
- }
- 
- 
diff --git a/package/hostapd/patches/500-random_pool_add_kernel.patch b/package/hostapd/patches/500-random_pool_add_kernel.patch
deleted file mode 100644
index ccecb22..0000000
--- a/package/hostapd/patches/500-random_pool_add_kernel.patch
+++ /dev/null
@@ -1,177 +0,0 @@
---- a/src/crypto/random.c
-+++ b/src/crypto/random.c
-@@ -25,6 +25,7 @@
- #include "utils/includes.h"
- #ifdef __linux__
- #include <fcntl.h>
-+#include <sys/stat.h>
- #endif /* __linux__ */
- 
- #include "utils/common.h"
-@@ -33,6 +34,8 @@
- #include "sha1.h"
- #include "random.h"
- 
-+#define RANDOM_STAMPFILE "/var/run/.random_available"
-+
- #define POOL_WORDS 32
- #define POOL_WORDS_MASK (POOL_WORDS - 1)
- #define POOL_TAP1 26
-@@ -43,6 +46,8 @@
- #define EXTRACT_LEN 16
- #define MIN_READY_MARK 2
- 
-+#ifndef CONFIG_NO_RANDOM_POOL
-+
- static u32 pool[POOL_WORDS];
- static unsigned int input_rotate = 0;
- static unsigned int pool_pos = 0;
-@@ -123,7 +128,7 @@ static void random_extract(u8 *out)
- }
- 
- 
--void random_add_randomness(const void *buf, size_t len)
-+static void random_pool_add_randomness(const void *buf, size_t len)
- {
- 	struct os_time t;
- 	static unsigned int count = 0;
-@@ -213,16 +218,22 @@ int random_get_bytes(void *buf, size_t l
- int random_pool_ready(void)
- {
- #ifdef __linux__
-+	struct stat st;
- 	int fd;
- 	ssize_t res;
- 
-+	if (stat(RANDOM_STAMPFILE, &st) == 0)
-+		return 1;
-+
- 	/*
- 	 * Make sure that there is reasonable entropy available before allowing
- 	 * some key derivation operations to proceed.
- 	 */
- 
--	if (dummy_key_avail == sizeof(dummy_key))
-+	if (dummy_key_avail == sizeof(dummy_key)) {
-+		random_mark_pool_ready();
- 		return 1; /* Already initialized - good to continue */
-+	}
- 
- 	/*
- 	 * Try to fetch some more data from the kernel high quality
-@@ -257,6 +268,7 @@ int random_pool_ready(void)
- 	if (dummy_key_avail == sizeof(dummy_key)) {
- 		if (own_pool_ready < MIN_READY_MARK)
- 			own_pool_ready = MIN_READY_MARK;
-+		random_mark_pool_ready();
- 		random_write_entropy();
- 		return 1;
- 	}
-@@ -269,6 +281,7 @@ int random_pool_ready(void)
- 	    total_collected + 10 * own_pool_ready > MIN_COLLECT_ENTROPY) {
- 		wpa_printf(MSG_INFO, "random: Allow operation to proceed "
- 			   "based on internal entropy");
-+		random_mark_pool_ready();
- 		return 1;
- 	}
- 
-@@ -284,10 +297,16 @@ int random_pool_ready(void)
- 
- void random_mark_pool_ready(void)
- {
-+	int fd;
-+
- 	own_pool_ready++;
- 	wpa_printf(MSG_DEBUG, "random: Mark internal entropy pool to be "
- 		   "ready (count=%u/%u)", own_pool_ready, MIN_READY_MARK);
- 	random_write_entropy();
-+
-+	fd = open(RANDOM_STAMPFILE, O_CREAT | O_WRONLY | O_EXCL | O_NOFOLLOW, 0600);
-+	if (fd >= 0)
-+		close(fd);
- }
- 
- 
-@@ -444,3 +463,22 @@ void random_deinit(void)
- 	os_free(random_entropy_file);
- 	random_entropy_file = NULL;
- }
-+
-+#endif /* CONFIG_NO_RANDOM_POOL */
-+
-+
-+void random_add_randomness(const void *buf, size_t len)
-+{
-+#ifdef __linux__
-+	int fd;
-+
-+	fd = open("/dev/random", O_RDWR);
-+	if (fd >= 0) {
-+		write(fd, buf, len);
-+		close(fd);
-+	}
-+#endif
-+#ifndef CONFIG_NO_RANDOM_POOL
-+	random_pool_add_randomness(buf, len);
-+#endif
-+}
---- a/wpa_supplicant/Makefile
-+++ b/wpa_supplicant/Makefile
-@@ -1226,9 +1226,8 @@ endif
- 
- ifdef CONFIG_NO_RANDOM_POOL
- CFLAGS += -DCONFIG_NO_RANDOM_POOL
--else
--OBJS += ../src/crypto/random.o
- endif
-+OBJS += ../src/crypto/random.o
- 
- ifdef CONFIG_CTRL_IFACE
- ifeq ($(CONFIG_CTRL_IFACE), y)
---- a/wpa_supplicant/Android.mk
-+++ b/wpa_supplicant/Android.mk
-@@ -1191,9 +1191,8 @@ endif
- 
- ifdef CONFIG_NO_RANDOM_POOL
- L_CFLAGS += -DCONFIG_NO_RANDOM_POOL
--else
--OBJS += src/crypto/random.c
- endif
-+OBJS += src/crypto/random.c
- 
- ifdef CONFIG_CTRL_IFACE
- ifeq ($(CONFIG_CTRL_IFACE), y)
---- a/hostapd/Android.mk
-+++ b/hostapd/Android.mk
-@@ -775,12 +775,12 @@ endif
- ifdef CONFIG_NO_RANDOM_POOL
- L_CFLAGS += -DCONFIG_NO_RANDOM_POOL
- else
--OBJS += src/crypto/random.c
--HOBJS += src/crypto/random.c
- HOBJS += src/utils/eloop.c
- HOBJS += $(SHA1OBJS)
- HOBJS += src/crypto/md5.c
- endif
-+OBJS += src/crypto/random.c
-+HOBJS += src/crypto/random.c
- 
- ifdef CONFIG_RADIUS_SERVER
- L_CFLAGS += -DRADIUS_SERVER
---- a/hostapd/Makefile
-+++ b/hostapd/Makefile
-@@ -748,12 +748,12 @@ endif
- ifdef CONFIG_NO_RANDOM_POOL
- CFLAGS += -DCONFIG_NO_RANDOM_POOL
- else
--OBJS += ../src/crypto/random.o
--HOBJS += ../src/crypto/random.o
- HOBJS += ../src/utils/eloop.o
- HOBJS += $(SHA1OBJS)
- HOBJS += ../src/crypto/md5.o
- endif
-+OBJS += ../src/crypto/random.o
-+HOBJS += ../src/crypto/random.o
- 
- ifdef CONFIG_RADIUS_SERVER
- CFLAGS += -DRADIUS_SERVER
diff --git a/package/hostapd/patches/510-bring_down_interface.patch b/package/hostapd/patches/510-bring_down_interface.patch
deleted file mode 100644
index e92c122..0000000
--- a/package/hostapd/patches/510-bring_down_interface.patch
+++ /dev/null
@@ -1,19 +0,0 @@
---- a/src/drivers/driver_nl80211.c
-+++ b/src/drivers/driver_nl80211.c
-@@ -7616,8 +7616,6 @@ static int wpa_driver_nl80211_set_mode(s
- 			ret = nl80211_set_mode(drv, drv->ifindex, nlmode);
- 			if (ret == -EACCES)
- 				break;
--			res = linux_set_iface_flags(drv->global->ioctl_sock,
--						    bss->ifname, 1);
- 			if (res && !ret)
- 				ret = -1;
- 			else if (ret != -EBUSY)
-@@ -7633,6 +7631,7 @@ static int wpa_driver_nl80211_set_mode(s
- 			   "interface is down");
- 		drv->nlmode = nlmode;
- 		drv->ignore_if_down_event = 1;
-+		linux_set_iface_flags(drv->global->ioctl_sock, bss->ifname, 1);
- 	}
- 
- done:
diff --git a/package/hostapd/patches/520-fix_wps_pin_crash.patch b/package/hostapd/patches/520-fix_wps_pin_crash.patch
deleted file mode 100644
index 80d562c..0000000
--- a/package/hostapd/patches/520-fix_wps_pin_crash.patch
+++ /dev/null
@@ -1,12 +0,0 @@
---- a/hostapd/ctrl_iface.c
-+++ b/hostapd/ctrl_iface.c
-@@ -479,6 +479,9 @@ static int hostapd_ctrl_iface_wps_ap_pin
- 	char *pos;
- 	const char *pin_txt;
- 
-+	if (!hapd->wps)
-+		return -1;
-+
- 	pos = os_strchr(txt, ' ');
- 	if (pos)
- 		*pos++ = '\0';
diff --git a/package/hostapd/patches/530-wps_single_auth_enc_type.patch b/package/hostapd/patches/530-wps_single_auth_enc_type.patch
deleted file mode 100644
index 6f4a655..0000000
--- a/package/hostapd/patches/530-wps_single_auth_enc_type.patch
+++ /dev/null
@@ -1,25 +0,0 @@
---- a/src/ap/wps_hostapd.c
-+++ b/src/ap/wps_hostapd.c
-@@ -989,11 +989,9 @@ int hostapd_init_wps(struct hostapd_data
- 
- 		if (conf->rsn_pairwise & WPA_CIPHER_CCMP)
- 			wps->encr_types |= WPS_ENCR_AES;
--		if (conf->rsn_pairwise & WPA_CIPHER_TKIP)
-+		else if (conf->rsn_pairwise & WPA_CIPHER_TKIP)
- 			wps->encr_types |= WPS_ENCR_TKIP;
--	}
--
--	if (conf->wpa & WPA_PROTO_WPA) {
-+	} else if (conf->wpa & WPA_PROTO_WPA) {
- 		if (conf->wpa_key_mgmt & WPA_KEY_MGMT_PSK)
- 			wps->auth_types |= WPS_AUTH_WPAPSK;
- 		if (conf->wpa_key_mgmt & WPA_KEY_MGMT_IEEE8021X)
-@@ -1001,7 +999,7 @@ int hostapd_init_wps(struct hostapd_data
- 
- 		if (conf->wpa_pairwise & WPA_CIPHER_CCMP)
- 			wps->encr_types |= WPS_ENCR_AES;
--		if (conf->wpa_pairwise & WPA_CIPHER_TKIP)
-+		else if (conf->wpa_pairwise & WPA_CIPHER_TKIP)
- 			wps->encr_types |= WPS_ENCR_TKIP;
- 	}
- 
diff --git a/package/hostapd/patches/540-dynamic_20_40_mhz.patch b/package/hostapd/patches/540-dynamic_20_40_mhz.patch
deleted file mode 100644
index a7b39db..0000000
--- a/package/hostapd/patches/540-dynamic_20_40_mhz.patch
+++ /dev/null
@@ -1,206 +0,0 @@
---- a/hostapd/config_file.c
-+++ b/hostapd/config_file.c
-@@ -2474,6 +2474,10 @@ static int hostapd_config_fill(struct ho
- 					   "ht_capab", line);
- 				errors++;
- 			}
-+		} else if (os_strcmp(buf, "dynamic_ht40") == 0) {
-+			conf->dynamic_ht40 = atoi(pos);
-+			if (conf->dynamic_ht40 == 1)
-+				conf->dynamic_ht40 = 1500;
- 		} else if (os_strcmp(buf, "require_ht") == 0) {
- 			conf->require_ht = atoi(pos);
- #endif /* CONFIG_IEEE80211N */
---- a/src/ap/ap_config.h
-+++ b/src/ap/ap_config.h
-@@ -515,6 +515,7 @@ struct hostapd_config {
- 	int ieee80211n;
- 	int secondary_channel;
- 	int require_ht;
-+	int dynamic_ht40;
- 	u32 vht_capab;
- 	int ieee80211ac;
- 	int require_vht;
---- a/src/ap/hostapd.c
-+++ b/src/ap/hostapd.c
-@@ -22,6 +22,7 @@
- #include "beacon.h"
- #include "iapp.h"
- #include "ieee802_1x.h"
-+#include "ieee802_11.h"
- #include "ieee802_11_auth.h"
- #include "vlan_init.h"
- #include "wpa_auth.h"
-@@ -348,6 +349,7 @@ static void hostapd_cleanup_iface_pre(st
- 
- static void hostapd_cleanup_iface_partial(struct hostapd_iface *iface)
- {
-+	hostapd_deinit_ht(iface);
- 	hostapd_free_hw_features(iface->hw_features, iface->num_hw_features);
- 	iface->hw_features = NULL;
- 	os_free(iface->current_rates);
---- a/src/ap/hostapd.h
-+++ b/src/ap/hostapd.h
-@@ -269,6 +269,9 @@ struct hostapd_iface {
- 	/* Overlapping BSS information */
- 	int olbc_ht;
- 
-+	int force_20mhz;
-+	struct os_time last_20mhz_trigger;
-+
- 	u16 ht_op_mode;
- 	void (*scan_cb)(struct hostapd_iface *iface);
- };
---- a/src/ap/ieee802_11.c
-+++ b/src/ap/ieee802_11.c
-@@ -1484,6 +1484,9 @@ static void handle_beacon(struct hostapd
- 					     sizeof(mgmt->u.beacon)), &elems,
- 				      0);
- 
-+	if (!elems.ht_capabilities)
-+		hostapd_trigger_20mhz(hapd->iface);
-+
- 	ap_list_process_beacon(hapd->iface, mgmt, &elems, fi);
- }
- 
---- a/src/ap/ieee802_11.h
-+++ b/src/ap/ieee802_11.h
-@@ -81,4 +81,17 @@ int hostapd_update_time_adv(struct hosta
- void hostapd_client_poll_ok(struct hostapd_data *hapd, const u8 *addr);
- u8 * hostapd_eid_bss_max_idle_period(struct hostapd_data *hapd, u8 *eid);
- 
-+#ifdef CONFIG_IEEE80211N
-+void hostapd_trigger_20mhz(struct hostapd_iface *iface);
-+void hostapd_deinit_ht(struct hostapd_iface *iface);
-+
-+#else
-+static inline void hostapd_deinit_ht(struct hostapd_iface *iface)
-+{
-+}
-+static inline void hostapd_trigger_20mhz(struct hostapd_iface *iface)
-+{
-+}
-+#endif /* CONFIG_IEEE80211N */
-+
- #endif /* IEEE802_11_H */
---- a/src/ap/ieee802_11_ht.c
-+++ b/src/ap/ieee802_11_ht.c
-@@ -20,9 +20,11 @@
- #include "drivers/driver.h"
- #include "hostapd.h"
- #include "ap_config.h"
-+#include "ap_drv_ops.h"
- #include "sta_info.h"
- #include "beacon.h"
- #include "ieee802_11.h"
-+#include "utils/eloop.h"
- 
- 
- u8 * hostapd_eid_ht_capabilities(struct hostapd_data *hapd, u8 *eid)
-@@ -70,12 +72,15 @@ u8 * hostapd_eid_ht_operation(struct hos
- 
- 	oper->control_chan = hapd->iconf->channel;
- 	oper->operation_mode = host_to_le16(hapd->iface->ht_op_mode);
--	if (hapd->iconf->secondary_channel == 1)
--		oper->ht_param |= HT_INFO_HT_PARAM_SECONDARY_CHNL_ABOVE |
--			HT_INFO_HT_PARAM_REC_TRANS_CHNL_WIDTH;
--	if (hapd->iconf->secondary_channel == -1)
--		oper->ht_param |= HT_INFO_HT_PARAM_SECONDARY_CHNL_BELOW |
--			HT_INFO_HT_PARAM_REC_TRANS_CHNL_WIDTH;
-+
-+	if (!hapd->iface->force_20mhz) {
-+		if (hapd->iconf->secondary_channel == 1)
-+			oper->ht_param |= HT_INFO_HT_PARAM_SECONDARY_CHNL_ABOVE |
-+				HT_INFO_HT_PARAM_REC_TRANS_CHNL_WIDTH;
-+		if (hapd->iconf->secondary_channel == -1)
-+			oper->ht_param |= HT_INFO_HT_PARAM_SECONDARY_CHNL_BELOW |
-+				HT_INFO_HT_PARAM_REC_TRANS_CHNL_WIDTH;
-+	}
- 
- 	pos += sizeof(*oper);
- 
-@@ -270,3 +275,84 @@ void hostapd_get_ht_capab(struct hostapd
- 
- 	neg_ht_cap->ht_capabilities_info = host_to_le16(cap);
- }
-+
-+static void hostapd_set_force_20mhz(struct hostapd_iface *iface);
-+
-+static void hostapd_restore_40mhz(void *eloop_data, void *user_ctx)
-+{
-+	struct hostapd_iface *iface = eloop_data;
-+	struct os_time time;
-+	int timeout;
-+
-+	if (!iface->last_20mhz_trigger.sec)
-+	    return;
-+
-+	os_get_time(&time);
-+	timeout = iface->last_20mhz_trigger.sec + iface->conf->dynamic_ht40 -
-+		  time.sec;
-+
-+	if (timeout > 0) {
-+		eloop_register_timeout(timeout, 0, hostapd_restore_40mhz,
-+				       iface, NULL);
-+		return;
-+	}
-+
-+	iface->last_20mhz_trigger.sec = 0;
-+	iface->last_20mhz_trigger.usec = 0;
-+
-+	iface->force_20mhz = 0;
-+	hostapd_set_force_20mhz(iface);
-+}
-+
-+static void hostapd_set_force_20mhz(struct hostapd_iface *iface)
-+{
-+	int secondary_channel;
-+	int i;
-+
-+	ieee802_11_set_beacons(iface);
-+
-+	for (i = 0; i < iface->num_bss; i++) {
-+		struct hostapd_data *hapd = iface->bss[i];
-+
-+		if (iface->force_20mhz)
-+			secondary_channel = 0;
-+		else
-+			secondary_channel = hapd->iconf->secondary_channel;
-+
-+		if (hostapd_set_freq(hapd, hapd->iconf->hw_mode, iface->freq,
-+				     hapd->iconf->channel,
-+				     hapd->iconf->ieee80211n,
-+				     hapd->iconf->ieee80211ac,
-+				     secondary_channel,
-+				     hapd->iconf->vht_oper_chwidth,
-+				     hapd->iconf->vht_oper_centr_freq_seg0_idx,
-+				     hapd->iconf->vht_oper_centr_freq_seg1_idx)) {
-+			wpa_printf(MSG_ERROR, "Could not set channel for "
-+				   "kernel driver");
-+		}
-+	}
-+}
-+
-+void hostapd_deinit_ht(struct hostapd_iface *iface)
-+{
-+	eloop_cancel_timeout(hostapd_restore_40mhz, iface, NULL);
-+}
-+
-+void hostapd_trigger_20mhz(struct hostapd_iface *iface)
-+{
-+	if (!iface->conf->dynamic_ht40)
-+		return;
-+
-+	if (!iface->force_20mhz) {
-+		iface->force_20mhz = 1;
-+		hostapd_set_force_20mhz(iface);
-+	}
-+
-+	if (!iface->last_20mhz_trigger.sec) {
-+		eloop_cancel_timeout(hostapd_restore_40mhz, iface, NULL);
-+		eloop_register_timeout(iface->conf->dynamic_ht40, 0,
-+				       hostapd_restore_40mhz, iface, NULL);
-+	}
-+
-+	os_get_time(&iface->last_20mhz_trigger);
-+}
diff --git a/package/hostapd/patches/550-limit_debug_messages.patch b/package/hostapd/patches/550-limit_debug_messages.patch
deleted file mode 100644
index 659e980..0000000
--- a/package/hostapd/patches/550-limit_debug_messages.patch
+++ /dev/null
@@ -1,213 +0,0 @@
---- a/src/utils/wpa_debug.c
-+++ b/src/utils/wpa_debug.c
-@@ -201,7 +201,7 @@ void wpa_debug_close_linux_tracing(void)
-  *
-  * Note: New line '\n' is added to the end of the text when printing to stdout.
-  */
--void wpa_printf(int level, const char *fmt, ...)
-+void _wpa_printf(int level, const char *fmt, ...)
- {
- 	va_list ap;
- 
-@@ -248,8 +248,8 @@ void wpa_printf(int level, const char *f
- }
- 
- 
--static void _wpa_hexdump(int level, const char *title, const u8 *buf,
--			 size_t len, int show)
-+void _wpa_hexdump(int level, const char *title, const u8 *buf,
-+		  size_t len, int show)
- {
- 	size_t i;
- 
-@@ -375,20 +375,9 @@ static void _wpa_hexdump(int level, cons
- #endif /* CONFIG_ANDROID_LOG */
- }
- 
--void wpa_hexdump(int level, const char *title, const u8 *buf, size_t len)
--{
--	_wpa_hexdump(level, title, buf, len, 1);
--}
--
--
--void wpa_hexdump_key(int level, const char *title, const u8 *buf, size_t len)
--{
--	_wpa_hexdump(level, title, buf, len, wpa_debug_show_keys);
--}
- 
--
--static void _wpa_hexdump_ascii(int level, const char *title, const u8 *buf,
--			       size_t len, int show)
-+void _wpa_hexdump_ascii(int level, const char *title, const u8 *buf,
-+			size_t len, int show)
- {
- 	size_t i, llen;
- 	const u8 *pos = buf;
-@@ -495,19 +484,6 @@ static void _wpa_hexdump_ascii(int level
- }
- 
- 
--void wpa_hexdump_ascii(int level, const char *title, const u8 *buf, size_t len)
--{
--	_wpa_hexdump_ascii(level, title, buf, len, 1);
--}
--
--
--void wpa_hexdump_ascii_key(int level, const char *title, const u8 *buf,
--			   size_t len)
--{
--	_wpa_hexdump_ascii(level, title, buf, len, wpa_debug_show_keys);
--}
--
--
- #ifdef CONFIG_DEBUG_FILE
- static char *last_path = NULL;
- #endif /* CONFIG_DEBUG_FILE */
-@@ -591,7 +567,7 @@ void wpa_msg_register_ifname_cb(wpa_msg_
- }
- 
- 
--void wpa_msg(void *ctx, int level, const char *fmt, ...)
-+void _wpa_msg(void *ctx, int level, const char *fmt, ...)
- {
- 	va_list ap;
- 	char *buf;
-@@ -625,7 +601,7 @@ void wpa_msg(void *ctx, int level, const
- }
- 
- 
--void wpa_msg_ctrl(void *ctx, int level, const char *fmt, ...)
-+void _wpa_msg_ctrl(void *ctx, int level, const char *fmt, ...)
- {
- 	va_list ap;
- 	char *buf;
---- a/src/utils/wpa_debug.h
-+++ b/src/utils/wpa_debug.h
-@@ -43,6 +43,17 @@ int wpa_debug_open_file(const char *path
- int wpa_debug_reopen_file(void);
- void wpa_debug_close_file(void);
- 
-+/* internal */
-+void _wpa_hexdump(int level, const char *title, const u8 *buf,
-+		  size_t len, int show);
-+void _wpa_hexdump_ascii(int level, const char *title, const u8 *buf,
-+			size_t len, int show);
-+extern int wpa_debug_show_keys;
-+
-+#ifndef CONFIG_MSG_MIN_PRIORITY
-+#define CONFIG_MSG_MIN_PRIORITY 0
-+#endif
-+
- /**
-  * wpa_debug_printf_timestamp - Print timestamp for debug output
-  *
-@@ -63,9 +74,15 @@ void wpa_debug_print_timestamp(void);
-  *
-  * Note: New line '\n' is added to the end of the text when printing to stdout.
-  */
--void wpa_printf(int level, const char *fmt, ...)
-+void _wpa_printf(int level, const char *fmt, ...)
- PRINTF_FORMAT(2, 3);
- 
-+#define wpa_printf(level, ...)						\
-+	do {								\
-+		if (level >= CONFIG_MSG_MIN_PRIORITY)			\
-+			_wpa_printf(level, __VA_ARGS__);		\
-+	} while(0)
-+
- /**
-  * wpa_hexdump - conditional hex dump
-  * @level: priority level (MSG_*) of the message
-@@ -77,7 +94,13 @@ PRINTF_FORMAT(2, 3);
-  * output may be directed to stdout, stderr, and/or syslog based on
-  * configuration. The contents of buf is printed out has hex dump.
-  */
--void wpa_hexdump(int level, const char *title, const u8 *buf, size_t len);
-+static inline void wpa_hexdump(int level, const char *title, const u8 *buf, size_t len)
-+{
-+	if (level < CONFIG_MSG_MIN_PRIORITY)
-+		return;
-+
-+	_wpa_hexdump(level, title, buf, len, 1);
-+}
- 
- static inline void wpa_hexdump_buf(int level, const char *title,
- 				   const struct wpabuf *buf)
-@@ -99,7 +122,13 @@ static inline void wpa_hexdump_buf(int l
-  * like wpa_hexdump(), but by default, does not include secret keys (passwords,
-  * etc.) in debug output.
-  */
--void wpa_hexdump_key(int level, const char *title, const u8 *buf, size_t len);
-+static inline void wpa_hexdump_key(int level, const char *title, const u8 *buf, size_t len)
-+{
-+	if (level < CONFIG_MSG_MIN_PRIORITY)
-+		return;
-+
-+	_wpa_hexdump(level, title, buf, len, wpa_debug_show_keys);
-+}
- 
- static inline void wpa_hexdump_buf_key(int level, const char *title,
- 				       const struct wpabuf *buf)
-@@ -121,8 +150,14 @@ static inline void wpa_hexdump_buf_key(i
-  * the hex numbers and ASCII characters (for printable range) are shown. 16
-  * bytes per line will be shown.
-  */
--void wpa_hexdump_ascii(int level, const char *title, const u8 *buf,
--		       size_t len);
-+static inline void wpa_hexdump_ascii(int level, const char *title,
-+				     const u8 *buf, size_t len)
-+{
-+	if (level < CONFIG_MSG_MIN_PRIORITY)
-+		return;
-+
-+	_wpa_hexdump_ascii(level, title, buf, len, 1);
-+}
- 
- /**
-  * wpa_hexdump_ascii_key - conditional hex dump, hide keys
-@@ -138,8 +173,14 @@ void wpa_hexdump_ascii(int level, const 
-  * bytes per line will be shown. This works like wpa_hexdump_ascii(), but by
-  * default, does not include secret keys (passwords, etc.) in debug output.
-  */
--void wpa_hexdump_ascii_key(int level, const char *title, const u8 *buf,
--			   size_t len);
-+static inline void wpa_hexdump_ascii_key(int level, const char *title,
-+					 const u8 *buf, size_t len)
-+{
-+	if (level < CONFIG_MSG_MIN_PRIORITY)
-+		return;
-+
-+	_wpa_hexdump_ascii(level, title, buf, len, wpa_debug_show_keys);
-+}
- 
- /*
-  * wpa_dbg() behaves like wpa_msg(), but it can be removed from build to reduce
-@@ -172,7 +213,12 @@ void wpa_hexdump_ascii_key(int level, co
-  *
-  * Note: New line '\n' is added to the end of the text when printing to stdout.
-  */
--void wpa_msg(void *ctx, int level, const char *fmt, ...) PRINTF_FORMAT(3, 4);
-+void _wpa_msg(void *ctx, int level, const char *fmt, ...) PRINTF_FORMAT(3, 4);
-+#define wpa_msg(ctx, level, ...)					\
-+	do {								\
-+		if (level >= CONFIG_MSG_MIN_PRIORITY)			\
-+			_wpa_msg(ctx, level, __VA_ARGS__);		\
-+	} while(0)
- 
- /**
-  * wpa_msg_ctrl - Conditional printf for ctrl_iface monitors
-@@ -186,8 +232,13 @@ void wpa_msg(void *ctx, int level, const
-  * attached ctrl_iface monitors. In other words, it can be used for frequent
-  * events that do not need to be sent to syslog.
-  */
--void wpa_msg_ctrl(void *ctx, int level, const char *fmt, ...)
-+void _wpa_msg_ctrl(void *ctx, int level, const char *fmt, ...)
- PRINTF_FORMAT(3, 4);
-+#define wpa_msg_ctrl(ctx, level, ...)					\
-+	do {								\
-+		if (level >= CONFIG_MSG_MIN_PRIORITY)			\
-+			_wpa_msg_ctrl(ctx, level, __VA_ARGS__);		\
-+	} while(0)
- 
- typedef void (*wpa_msg_cb_func)(void *ctx, int level, const char *txt,
- 				size_t len);
diff --git a/package/hostapd/patches/560-indicate-features.patch b/package/hostapd/patches/560-indicate-features.patch
deleted file mode 100644
index 9073bd43..0000000
--- a/package/hostapd/patches/560-indicate-features.patch
+++ /dev/null
@@ -1,82 +0,0 @@
---- a/hostapd/main.c
-+++ b/hostapd/main.c
-@@ -14,6 +14,7 @@
- 
- #include "utils/common.h"
- #include "utils/eloop.h"
-+#include "utils/build_features.h"
- #include "crypto/random.h"
- #include "crypto/tls.h"
- #include "common/version.h"
-@@ -584,7 +585,7 @@ int main(int argc, char *argv[])
- 
- 	wpa_supplicant_event = hostapd_wpa_event;
- 	for (;;) {
--		c = getopt(argc, argv, "Bde:f:hKP:tvg:G:");
-+		c = getopt(argc, argv, "Bde:f:hKP:tg:G:v::");
- 		if (c < 0)
- 			break;
- 		switch (c) {
-@@ -616,6 +617,8 @@ int main(int argc, char *argv[])
- 			wpa_debug_timestamp++;
- 			break;
- 		case 'v':
-+			if (optarg)
-+				exit(!has_feature(optarg));
- 			show_version();
- 			exit(1);
- 			break;
---- a/wpa_supplicant/main.c
-+++ b/wpa_supplicant/main.c
-@@ -12,6 +12,7 @@
- #endif /* __linux__ */
- 
- #include "common.h"
-+#include "build_features.h"
- #include "wpa_supplicant_i.h"
- #include "driver_i.h"
- 
-@@ -156,7 +157,7 @@ int main(int argc, char *argv[])
- 
- 	for (;;) {
- 		c = getopt(argc, argv,
--			   "b:Bc:C:D:de:f:g:hH:i:KLNo:O:p:P:qsTtuvW");
-+			   "b:Bc:C:D:de:f:g:hH:i:KLNo:O:p:P:qsTtuv::W");
- 		if (c < 0)
- 			break;
- 		switch (c) {
-@@ -248,8 +249,12 @@ int main(int argc, char *argv[])
- 			break;
- #endif /* CONFIG_DBUS */
- 		case 'v':
--			printf("%s\n", wpa_supplicant_version);
--			exitcode = 0;
-+			if (optarg) {
-+				exitcode = !has_feature(optarg);
-+			} else {
-+				printf("%s\n", wpa_supplicant_version);
-+				exitcode = 0;
-+			}
- 			goto out;
- 		case 'W':
- 			params.wait_for_monitor++;
---- /dev/null
-+++ b/src/utils/build_features.h
-@@ -0,0 +1,17 @@
-+#ifndef BUILD_FEATURES_H
-+#define BUILD_FEATURES_H
-+
-+static inline int has_feature(const char *feat)
-+{
-+#ifdef IEEE8021X_EAPOL
-+	if (!strcmp(feat, "eap"))
-+		return 1;
-+#endif
-+#ifdef IEEE80211N
-+	if (!strcmp(feat, "11n"))
-+		return 1;
-+#endif
-+	return 0;
-+}
-+
-+#endif /* BUILD_FEATURES_H */
diff --git a/package/hostapd/patches/570-genl_connect_debug.patch b/package/hostapd/patches/570-genl_connect_debug.patch
deleted file mode 100644
index 5f14048..0000000
--- a/package/hostapd/patches/570-genl_connect_debug.patch
+++ /dev/null
@@ -1,11 +0,0 @@
---- a/src/drivers/driver_nl80211.c
-+++ b/src/drivers/driver_nl80211.c
-@@ -127,7 +127,7 @@ static struct nl_handle * nl_create_hand
- 	}
- 
- 	if (genl_connect(handle)) {
--		wpa_printf(MSG_ERROR, "nl80211: Failed to connect to generic "
-+		wpa_printf(MSG_DEBUG, "nl80211: Failed to connect to generic "
- 			   "netlink (%s)", dbg);
- 		nl80211_handle_destroy(handle);
- 		return NULL;
diff --git a/package/hostapd/patches/590-hostapd_cli_ifdef.patch b/package/hostapd/patches/590-hostapd_cli_ifdef.patch
deleted file mode 100644
index cbf1e48..0000000
--- a/package/hostapd/patches/590-hostapd_cli_ifdef.patch
+++ /dev/null
@@ -1,50 +0,0 @@
---- a/hostapd/hostapd_cli.c
-+++ b/hostapd/hostapd_cli.c
-@@ -67,7 +67,6 @@ static const char *commands_help =
- #ifdef CONFIG_IEEE80211W
- "   sa_query <addr>      send SA Query to a station\n"
- #endif /* CONFIG_IEEE80211W */
--#ifdef CONFIG_WPS
- "   wps_pin <uuid> <pin> [timeout] [addr]  add WPS Enrollee PIN\n"
- "   wps_check_pin <PIN>  verify PIN checksum\n"
- "   wps_pbc              indicate button pushed to initiate PBC\n"
-@@ -79,7 +78,6 @@ static const char *commands_help =
- #endif /* CONFIG_WPS_NFC */
- "   wps_ap_pin <cmd> [params..]  enable/disable AP PIN\n"
- "   wps_config <SSID> <auth> <encr> <key>  configure AP\n"
--#endif /* CONFIG_WPS */
- "   get_config           show current configuration\n"
- "   help                 show this usage help\n"
- "   interface [ifname]   show interfaces/select interface\n"
-@@ -340,7 +338,6 @@ static int hostapd_cli_cmd_sa_query(stru
- #endif /* CONFIG_IEEE80211W */
- 
- 
--#ifdef CONFIG_WPS
- static int hostapd_cli_cmd_wps_pin(struct wpa_ctrl *ctrl, int argc,
- 				   char *argv[])
- {
-@@ -559,7 +556,6 @@ static int hostapd_cli_cmd_wps_config(st
- 			 ssid_hex, argv[1]);
- 	return wpa_ctrl_command(ctrl, buf);
- }
--#endif /* CONFIG_WPS */
- 
- 
- static int hostapd_cli_cmd_disassoc_imminent(struct wpa_ctrl *ctrl, int argc,
-@@ -805,7 +801,6 @@ static struct hostapd_cli_cmd hostapd_cl
- #ifdef CONFIG_IEEE80211W
- 	{ "sa_query", hostapd_cli_cmd_sa_query },
- #endif /* CONFIG_IEEE80211W */
--#ifdef CONFIG_WPS
- 	{ "wps_pin", hostapd_cli_cmd_wps_pin },
- 	{ "wps_check_pin", hostapd_cli_cmd_wps_check_pin },
- 	{ "wps_pbc", hostapd_cli_cmd_wps_pbc },
-@@ -818,7 +813,6 @@ static struct hostapd_cli_cmd hostapd_cl
- #endif /* CONFIG_WPS_NFC */
- 	{ "wps_ap_pin", hostapd_cli_cmd_wps_ap_pin },
- 	{ "wps_config", hostapd_cli_cmd_wps_config },
--#endif /* CONFIG_WPS */
- 	{ "disassoc_imminent", hostapd_cli_cmd_disassoc_imminent },
- 	{ "ess_disassoc", hostapd_cli_cmd_ess_disassoc },
- 	{ "get_config", hostapd_cli_cmd_get_config },
diff --git a/package/hostapd/patches/601-wpa_supplicant-add-new-config-params-to-be-used-with.patch b/package/hostapd/patches/601-wpa_supplicant-add-new-config-params-to-be-used-with.patch
deleted file mode 100644
index 3345e55..0000000
--- a/package/hostapd/patches/601-wpa_supplicant-add-new-config-params-to-be-used-with.patch
+++ /dev/null
@@ -1,209 +0,0 @@
-From 4bb69d15477e0f2b00e166845341dc933de47c58 Mon Sep 17 00:00:00 2001
-From: Antonio Quartulli <ordex@autistici.org>
-Date: Sun, 3 Jun 2012 18:22:56 +0200
-Subject: [PATCHv2 601/602] wpa_supplicant: add new config params to be used
- with the ibss join command
-
-Signed-hostap: Antonio Quartulli <ordex@autistici.org>
----
- src/drivers/driver.h            |    6 +++
- wpa_supplicant/config.c         |   96 +++++++++++++++++++++++++++++++++++++++
- wpa_supplicant/config_ssid.h    |    6 +++
- wpa_supplicant/wpa_supplicant.c |   23 +++++++---
- 4 files changed, 124 insertions(+), 7 deletions(-)
-
---- a/src/drivers/driver.h
-+++ b/src/drivers/driver.h
-@@ -19,6 +19,7 @@
- 
- #define WPA_SUPPLICANT_DRIVER_VERSION 4
- 
-+#include "drivers/nl80211_copy.h"
- #include "common/defs.h"
- 
- #define HOSTAPD_CHAN_DISABLED 0x00000001
-@@ -363,6 +364,11 @@ struct wpa_driver_associate_params {
- 	 */
- 	int freq;
- 
-+	int beacon_interval;
-+	int fixed_freq;
-+	unsigned char rates[NL80211_MAX_SUPP_RATES];
-+	int mcast_rate;
-+
- 	/**
- 	 * bg_scan_period - Background scan period in seconds, 0 to disable
- 	 * background scan, or -1 to indicate no change to default driver
---- a/wpa_supplicant/config.c
-+++ b/wpa_supplicant/config.c
-@@ -14,6 +14,7 @@
- #include "rsn_supp/wpa.h"
- #include "eap_peer/eap.h"
- #include "p2p/p2p.h"
-+#include "drivers/nl80211_copy.h"
- #include "config.h"
- 
- 
-@@ -1376,6 +1377,97 @@ static char * wpa_config_write_p2p_clien
- 
- #endif /* CONFIG_P2P */
- 
-+static int wpa_config_parse_mcast_rate(const struct parse_data *data,
-+				       struct wpa_ssid *ssid, int line,
-+				       const char *value)
-+{
-+	ssid->mcast_rate = (int)(strtod(value, NULL) * 10);
-+
-+	return 0;
-+}
-+
-+#ifndef NO_CONFIG_WRITE
-+static char * wpa_config_write_mcast_rate(const struct parse_data *data,
-+					  struct wpa_ssid *ssid)
-+{
-+	char *value;
-+	int res;
-+
-+	if (!ssid->mcast_rate == 0)
-+		return NULL;
-+
-+	value = os_malloc(6); /* longest: 300.0 */
-+	if (value == NULL)
-+		return NULL;
-+	res = os_snprintf(value, 5, "%.1f", (double)ssid->mcast_rate / 10);
-+	if (res < 0) {
-+		os_free(value);
-+		return NULL;
-+	}
-+	return value;
-+}
-+#endif /* NO_CONFIG_WRITE */
-+
-+static int wpa_config_parse_rates(const struct parse_data *data,
-+				  struct wpa_ssid *ssid, int line,
-+				  const char *value)
-+{
-+	int i;
-+	char *pos, *r, *sptr, *end;
-+	double rate;
-+
-+	pos = (char *)value;
-+	r = strtok_r(pos, ",", &sptr);
-+	i = 0;
-+	while (pos && i < NL80211_MAX_SUPP_RATES) {
-+		rate = 0.0;
-+		if (r)
-+			rate = strtod(r, &end);
-+		ssid->rates[i] = rate * 2;
-+		if (*end != '\0' || rate * 2 != ssid->rates[i])
-+			return 1;
-+
-+		i++;
-+		r = strtok_r(NULL, ",", &sptr);
-+	}
-+
-+	return 0;
-+}
-+
-+#ifndef NO_CONFIG_WRITE
-+static char * wpa_config_write_rates(const struct parse_data *data,
-+				     struct wpa_ssid *ssid)
-+{
-+	char *value, *pos;
-+	int res, i;
-+
-+	if (ssid->rates[0] <= 0)
-+		return NULL;
-+
-+	value = os_malloc(6 * NL80211_MAX_SUPP_RATES + 1);
-+	if (value == NULL)
-+		return NULL;
-+	pos = value;
-+	for (i = 0; i < NL80211_MAX_SUPP_RATES - 1; i++) {
-+		res = os_snprintf(pos, 6, "%.1f,", (double)ssid->rates[i] / 2);
-+		if (res < 0) {
-+			os_free(value);
-+			return NULL;
-+		}
-+		pos += res;
-+	}
-+	res = os_snprintf(pos, 6, "%.1f",
-+			  (double)ssid->rates[NL80211_MAX_SUPP_RATES - 1] / 2);
-+	if (res < 0) {
-+		os_free(value);
-+		return NULL;
-+	}
-+
-+	value[6 * NL80211_MAX_SUPP_RATES] = '\0';
-+	return value;
-+}
-+#endif /* NO_CONFIG_WRITE */
-+
- /* Helper macros for network block parser */
- 
- #ifdef OFFSET
-@@ -1574,6 +1666,9 @@ static const struct parse_data ssid_fiel
- 	{ INT(ap_max_inactivity) },
- 	{ INT(dtim_period) },
- 	{ INT(beacon_int) },
-+	{ INT_RANGE(fixed_freq, 0, 1) },
-+	{ FUNC(rates) },
-+	{ FUNC(mcast_rate) },
- };
- 
- #undef OFFSET
---- a/wpa_supplicant/config_ssid.h
-+++ b/wpa_supplicant/config_ssid.h
-@@ -11,6 +11,7 @@
- 
- #include "common/defs.h"
- #include "eap_peer/eap_config.h"
-+#include "drivers/nl80211_copy.h"
- 
- #define MAX_SSID_LEN 32
- 
-@@ -600,6 +601,10 @@ struct wpa_ssid {
- 	 * dereferences since it may not be updated in all cases.
- 	 */
- 	void *parent_cred;
-+
-+	int fixed_freq;
-+	unsigned char rates[NL80211_MAX_SUPP_RATES];
-+	double mcast_rate;
- };
- 
- #endif /* CONFIG_SSID_H */
---- a/wpa_supplicant/wpa_supplicant.c
-+++ b/wpa_supplicant/wpa_supplicant.c
-@@ -1597,15 +1597,24 @@ void wpa_supplicant_associate(struct wpa
- 		params.ssid_len = ssid->ssid_len;
- 	}
- 
--	if (ssid->mode == WPAS_MODE_IBSS && ssid->bssid_set &&
--	    wpa_s->conf->ap_scan == 2) {
--		params.bssid = ssid->bssid;
--		params.fixed_bssid = 1;
-+	if (ssid->mode == WPAS_MODE_IBSS) {
-+		if (ssid->bssid_set && wpa_s->conf->ap_scan == 2) {
-+			params.bssid = ssid->bssid;
-+			params.fixed_bssid = 1;
-+		}
-+		if (ssid->frequency > 0 && params.freq == 0)
-+			/* Initial channel for IBSS */
-+			params.freq = ssid->frequency;
-+		params.fixed_freq = ssid->fixed_freq;
-+		params.beacon_interval = ssid->beacon_int;
-+		i = 0;
-+		while (i < NL80211_MAX_SUPP_RATES) {
-+			params.rates[i] = ssid->rates[i];
-+			i++;
-+		}
-+		params.mcast_rate = ssid->mcast_rate;
- 	}
- 
--	if (ssid->mode == WPAS_MODE_IBSS && ssid->frequency > 0 &&
--	    params.freq == 0)
--		params.freq = ssid->frequency; /* Initial channel for IBSS */
- 	params.wpa_ie = wpa_ie;
- 	params.wpa_ie_len = wpa_ie_len;
- 	params.pairwise_suite = cipher_pairwise;
diff --git a/package/hostapd/patches/602-driver_nl80211-use-new-parameters-during-ibss-join.patch b/package/hostapd/patches/602-driver_nl80211-use-new-parameters-during-ibss-join.patch
deleted file mode 100644
index 5a6eb5e..0000000
--- a/package/hostapd/patches/602-driver_nl80211-use-new-parameters-during-ibss-join.patch
+++ /dev/null
@@ -1,59 +0,0 @@
-From ffc4445958a3ed4064f2e1bf73fa478a61c5cf7b Mon Sep 17 00:00:00 2001
-From: Antonio Quartulli <ordex@autistici.org>
-Date: Sun, 3 Jun 2012 18:42:25 +0200
-Subject: [PATCHv2 602/602] driver_nl80211: use new parameters during ibss join
-
-Signed-hostap: Antonio Quartulli <ordex@autistici.org>
----
- src/drivers/driver_nl80211.c |   33 ++++++++++++++++++++++++++++++++-
- 1 file changed, 32 insertions(+), 1 deletion(-)
-
---- a/src/drivers/driver_nl80211.c
-+++ b/src/drivers/driver_nl80211.c
-@@ -7040,7 +7040,7 @@ static int wpa_driver_nl80211_ibss(struc
- 				   struct wpa_driver_associate_params *params)
- {
- 	struct nl_msg *msg;
--	int ret = -1;
-+	int ret = -1, i;
- 	int count = 0;
- 
- 	wpa_printf(MSG_DEBUG, "nl80211: Join IBSS (ifindex=%d)", drv->ifindex);
-@@ -7073,6 +7073,37 @@ retry:
- 	wpa_printf(MSG_DEBUG, "  * freq=%d", params->freq);
- 	NLA_PUT_U32(msg, NL80211_ATTR_WIPHY_FREQ, params->freq);
- 
-+	if (params->fixed_freq) {
-+		wpa_printf(MSG_DEBUG, "  * fixed_freq");
-+		NLA_PUT_FLAG(msg, NL80211_ATTR_FREQ_FIXED);
-+	}
-+
-+	if (params->beacon_interval > 0) {
-+		wpa_printf(MSG_DEBUG, "  * beacon_interval=%d",
-+			   params->beacon_interval);
-+		NLA_PUT_U32(msg, NL80211_ATTR_BEACON_INTERVAL,
-+			    params->beacon_interval);
-+	}
-+
-+	if (params->rates[0] > 0) {
-+		wpa_printf(MSG_DEBUG, "  * basic_rates:");
-+		i = 0;
-+		while (i < NL80211_MAX_SUPP_RATES &&
-+		       params->rates[i] > 0) {
-+			wpa_printf(MSG_DEBUG, "    %.1f",
-+				   (double)params->rates[i] / 2);
-+			i++;
-+		}
-+		NLA_PUT(msg, NL80211_ATTR_BSS_BASIC_RATES, i,
-+			params->rates);
-+	}
-+
-+	if (params->mcast_rate > 0) {
-+		wpa_printf(MSG_DEBUG, "  * mcast_rates=%.1f",
-+			   (double)params->mcast_rate / 10);
-+		NLA_PUT_U32(msg, NL80211_ATTR_MCAST_RATE, params->mcast_rate);
-+	}
-+
- 	ret = nl80211_set_conn_keys(params, msg);
- 	if (ret)
- 		goto nla_put_failure;
diff --git a/package/hostapd/patches/604-wpa_s-support-htmode-param.patch b/package/hostapd/patches/604-wpa_s-support-htmode-param.patch
deleted file mode 100644
index 267bde8..0000000
--- a/package/hostapd/patches/604-wpa_s-support-htmode-param.patch
+++ /dev/null
@@ -1,156 +0,0 @@
-From b9329c5dfeed7d5c55d2117d8dfe326fc40c8fb1 Mon Sep 17 00:00:00 2001
-From: Antonio Quartulli <ordex@autistici.org>
-Date: Tue, 3 Jul 2012 00:36:24 +0200
-Subject: [PATCH] wpa_s: support htmode param
-
-possible values are HT20, HT40-, HT40+ and NOHT
-
-Signed-off-by: Antonio Quartulli <ordex@autistici.org>
----
- src/drivers/driver.h            |    2 ++
- src/drivers/driver_nl80211.c    |   16 ++++++++++
- wpa_supplicant/config.c         |   66 +++++++++++++++++++++++++++++++++++++++
- wpa_supplicant/config_ssid.h    |    2 ++
- wpa_supplicant/wpa_supplicant.c |    2 ++
- 5 files changed, 88 insertions(+)
-
---- a/src/drivers/driver.h
-+++ b/src/drivers/driver.h
-@@ -368,6 +368,8 @@ struct wpa_driver_associate_params {
- 	int fixed_freq;
- 	unsigned char rates[NL80211_MAX_SUPP_RATES];
- 	int mcast_rate;
-+	int ht_set;
-+	unsigned int htmode;
- 
- 	/**
- 	 * bg_scan_period - Background scan period in seconds, 0 to disable
---- a/src/drivers/driver_nl80211.c
-+++ b/src/drivers/driver_nl80211.c
-@@ -7104,6 +7104,22 @@ retry:
- 		NLA_PUT_U32(msg, NL80211_ATTR_MCAST_RATE, params->mcast_rate);
- 	}
- 
-+	if (params->ht_set) {
-+		switch(params->htmode) {
-+			case NL80211_CHAN_HT20:
-+				wpa_printf(MSG_DEBUG, "  * ht=HT20");
-+				break;
-+			case NL80211_CHAN_HT40PLUS:
-+				wpa_printf(MSG_DEBUG, "  * ht=HT40+");
-+				break;
-+			case NL80211_CHAN_HT40MINUS:
-+				wpa_printf(MSG_DEBUG, "  * ht=HT40-");
-+				break;
-+		}
-+		NLA_PUT_U32(msg, NL80211_ATTR_WIPHY_CHANNEL_TYPE,
-+			    params->htmode);
-+	}
-+
- 	ret = nl80211_set_conn_keys(params, msg);
- 	if (ret)
- 		goto nla_put_failure;
---- a/wpa_supplicant/config.c
-+++ b/wpa_supplicant/config.c
-@@ -1408,6 +1408,71 @@ static char * wpa_config_write_mcast_rat
- }
- #endif /* NO_CONFIG_WRITE */
- 
-+static int wpa_config_parse_htmode(const struct parse_data *data,
-+				   struct wpa_ssid *ssid, int line,
-+				   const char *value)
-+{
-+	int i;
-+	static const struct {
-+		const char *name;
-+		unsigned int val;
-+	} htmap[] = {
-+		{ .name = "HT20", .val = NL80211_CHAN_HT20, },
-+		{ .name = "HT40+", .val = NL80211_CHAN_HT40PLUS, },
-+		{ .name = "HT40-", .val = NL80211_CHAN_HT40MINUS, },
-+		{ .name = "NOHT", .val = NL80211_CHAN_NO_HT, },
-+	};
-+	ssid->ht_set = 0;;
-+	for (i = 0; i < 4; i++) {
-+		if (strcasecmp(htmap[i].name, value) == 0) {
-+			ssid->htmode = htmap[i].val;
-+			ssid->ht_set = 1;
-+			break;
-+		}
-+	}
-+
-+	return 0;
-+}
-+
-+#ifndef NO_CONFIG_WRITE
-+static char * wpa_config_write_htmode(const struct parse_data *data,
-+				      struct wpa_ssid *ssid)
-+{
-+	char *value;
-+	int res;
-+
-+	value = os_malloc(6); /* longest: HT40+ */
-+	if (value == NULL)
-+		return NULL;
-+
-+	switch(ssid->htmode) {
-+		case NL80211_CHAN_HT20:
-+			res = os_snprintf(value, 4, "HT20");
-+			break;
-+		case NL80211_CHAN_HT40PLUS:
-+			res = os_snprintf(value, 5, "HT40+");
-+			break;
-+		case NL80211_CHAN_HT40MINUS:
-+			res = os_snprintf(value, 5, "HT40-");
-+			break;
-+		case NL80211_CHAN_NO_HT:
-+			res = os_snprintf(value, 4, "NOHT");
-+			break;
-+		default:
-+			os_free(value);
-+			return NULL;
-+	}
-+
-+	if (res < 0) {
-+		os_free(value);
-+		return NULL;
-+	}
-+
-+	return value;
-+}
-+#endif /* NO_CONFIG_WRITE */
-+
-+
- static int wpa_config_parse_rates(const struct parse_data *data,
- 				  struct wpa_ssid *ssid, int line,
- 				  const char *value)
-@@ -1669,6 +1734,7 @@ static const struct parse_data ssid_fiel
- 	{ INT_RANGE(fixed_freq, 0, 1) },
- 	{ FUNC(rates) },
- 	{ FUNC(mcast_rate) },
-+	{ FUNC(htmode) },
- };
- 
- #undef OFFSET
---- a/wpa_supplicant/config_ssid.h
-+++ b/wpa_supplicant/config_ssid.h
-@@ -605,6 +605,8 @@ struct wpa_ssid {
- 	int fixed_freq;
- 	unsigned char rates[NL80211_MAX_SUPP_RATES];
- 	double mcast_rate;
-+	int ht_set;
-+	unsigned int htmode;
- };
- 
- #endif /* CONFIG_SSID_H */
---- a/wpa_supplicant/wpa_supplicant.c
-+++ b/wpa_supplicant/wpa_supplicant.c
-@@ -1613,6 +1613,8 @@ void wpa_supplicant_associate(struct wpa
- 			i++;
- 		}
- 		params.mcast_rate = ssid->mcast_rate;
-+		params.ht_set = ssid->ht_set;
-+		params.htmode = ssid->htmode;
- 	}
- 
- 	params.wpa_ie = wpa_ie;
diff --git a/package/hostapd/patches/610-max_num_sta_probe.patch b/package/hostapd/patches/610-max_num_sta_probe.patch
deleted file mode 100644
index 141eb5b..0000000
--- a/package/hostapd/patches/610-max_num_sta_probe.patch
+++ /dev/null
@@ -1,13 +0,0 @@
---- a/src/ap/beacon.c
-+++ b/src/ap/beacon.c
-@@ -455,6 +455,10 @@ void handle_probe_req(struct hostapd_dat
- 		return;
- 	}
- 
-+	if (!sta && hapd->num_sta >= hapd->conf->max_num_sta)
-+		wpa_printf(MSG_MSGDUMP, "Probe Request from " MACSTR " ignored,"
-+			   " too many connected stations.", MAC2STR(mgmt->sa));
-+
- #ifdef CONFIG_INTERWORKING
- 	if (elems.interworking && elems.interworking_len >= 1) {
- 		u8 ant = elems.interworking[0] & 0x0f;
diff --git a/package/hostapd/patches/620-scan_wait.patch b/package/hostapd/patches/620-scan_wait.patch
deleted file mode 100644
index ac2d445..0000000
--- a/package/hostapd/patches/620-scan_wait.patch
+++ /dev/null
@@ -1,65 +0,0 @@
---- a/hostapd/main.c
-+++ b/hostapd/main.c
-@@ -33,6 +33,8 @@
- extern int wpa_debug_level;
- extern int wpa_debug_show_keys;
- extern int wpa_debug_timestamp;
-+static int daemonize = 0;
-+static char *pid_file = NULL;
- 
- extern struct wpa_driver_ops *wpa_drivers[];
- 
-@@ -147,6 +149,14 @@ static void hostapd_logger_cb(void *ctx,
- }
- #endif /* CONFIG_NO_HOSTAPD_LOGGER */
- 
-+static void hostapd_setup_complete_cb(void *ctx)
-+{
-+	if (daemonize && os_daemonize(pid_file)) {
-+		perror("daemon");
-+		return;
-+	}
-+	daemonize = 0;
-+}
- 
- /**
-  * hostapd_init - Allocate and initialize per-interface data
-@@ -190,6 +200,7 @@ static struct hostapd_iface * hostapd_in
- 		if (hapd == NULL)
- 			goto fail;
- 		hapd->msg_ctx = hapd;
-+		hapd->setup_complete_cb = hostapd_setup_complete_cb;
- 	}
- 
- 	return hapd_iface;
-@@ -429,8 +440,6 @@ static void hostapd_global_deinit(const 
- #endif /* CONFIG_NATIVE_WINDOWS */
- 
- 	eap_server_unregister_methods();
--
--	os_daemonize_terminate(pid_file);
- }
- 
- 
-@@ -456,11 +465,6 @@ static int hostapd_global_run(struct hap
- 	}
- #endif /* EAP_SERVER_TNC */
- 
--	if (daemonize && os_daemonize(pid_file)) {
--		perror("daemon");
--		return -1;
--	}
--
- 	eloop_run();
- 
- 	return 0;
-@@ -564,8 +568,7 @@ int main(int argc, char *argv[])
- 	struct hapd_interfaces interfaces;
- 	int ret = 1;
- 	size_t i;
--	int c, debug = 0, daemonize = 0;
--	char *pid_file = NULL;
-+	int c, debug = 0;
- 	const char *log_file = NULL;
- 	const char *entropy_file = NULL;
- 
diff --git a/package/hostapd/patches/630-bool_fix.patch b/package/hostapd/patches/630-bool_fix.patch
deleted file mode 100644
index 510b000..0000000
--- a/package/hostapd/patches/630-bool_fix.patch
+++ /dev/null
@@ -1,14 +0,0 @@
---- a/src/ap/ieee802_1x.c
-+++ b/src/ap/ieee802_1x.c
-@@ -2043,9 +2043,9 @@ void ieee802_1x_notify_pre_auth(struct e
- }
- 
- 
--static const char * bool_txt(Boolean bool)
-+static const char * bool_txt(Boolean bool_val)
- {
--	return bool ? "TRUE" : "FALSE";
-+	return bool_val ? "TRUE" : "FALSE";
- }
- 
- #ifdef CONFIG_CTRL_IFACE_MIB
diff --git a/package/mac80211/Makefile b/package/mac80211/Makefile
deleted file mode 100644
index e4fa925..0000000
--- a/package/mac80211/Makefile
+++ /dev/null
@@ -1,1630 +0,0 @@
-#
-# Copyright (C) 2007-2012 OpenWrt.org
-#
-# This is free software, licensed under the GNU General Public License v2.
-# See /LICENSE for more information.
-#
-
-include $(TOPDIR)/rules.mk
-include $(INCLUDE_DIR)/kernel.mk
-
-PKG_NAME:=mac80211
-
-PKG_VERSION:=2013-06-27
-PKG_RELEASE:=1
-PKG_SOURCE_URL:=http://mirror2.openwrt.org/sources
-PKG_BACKPORT_VERSION:=.1
-PKG_MD5SUM:=73bd220c64c5c6fdc22b3bb7f180644f
-
-PKG_SOURCE:=compat-wireless-$(PKG_VERSION)$(PKG_BACKPORT_VERSION).tar.bz2
-PKG_BUILD_DIR:=$(KERNEL_BUILD_DIR)/compat-wireless-$(PKG_VERSION)
-PKG_BUILD_PARALLEL:=1
-
-PKG_MAINTAINER:=Felix Fietkau <nbd@openwrt.org>
-
-PKG_DRIVERS = \
-	adm8211 ath5k libertas-usb libertas-sd p54-common p54-pci p54-usb p54-spi \
-	rt2x00-lib rt2x00-pci rt2x00-usb rt2x00-soc rt2800-lib rt2400-pci \
-	rt2500-pci rt2500-usb rt61-pci rt73-usb rt2800-pci rt2800-usb \
-	rtl8180 rtl8187 zd1211rw mac80211-hwsim carl9170 b43 b43legacy \
-	ath9k-common ath9k ath9k-htc ath net-libipw net-ipw2100 net-ipw2200 \
-	mwl8k net-hermes net-hermes-pci net-hermes-plx net-hermes-pcmcia \
-	iwl-legacy iwl3945 iwl4965 iwlagn wl12xx lib80211
-
-PKG_CONFIG_DEPENDS:= \
-	CONFIG_PACKAGE_kmod-mac80211 \
-	$(patsubst %,CONFIG_PACKAGE_kmod-%,$(PKG_DRIVERS)) \
-	CONFIG_PACKAGE_MAC80211_DEBUGFS \
-	CONFIG_PACKAGE_MAC80211_MESH \
-	CONFIG_PACKAGE_ATH_DEBUG \
-	CONFIG_PACKAGE_B43_DEBUG \
-	CONFIG_PACKAGE_B43_PIO \
-	CONFIG_PACKAGE_B43_N_PHY \
-	CONFIG_ATH_USER_REGD \
-
-CARL9170_FW_VERSION:=1.9.6
-
-include $(INCLUDE_DIR)/package.mk
-
-WMENU:=Wireless Drivers
-
-define KernelPackage/mac80211/Default
-  SUBMENU:=$(WMENU)
-  URL:=http://linuxwireless.org/
-  MAINTAINER:=Felix Fietkau <nbd@openwrt.org>
-  DEPENDS:=@(!(TARGET_avr32||TARGET_ps3||TARGET_pxcab)||BROKEN)
-endef
-
-define KernelPackage/cfg80211
-  $(call KernelPackage/mac80211/Default)
-  TITLE:=cfg80211 - wireless configuration API
-  DEPENDS+= +iw
-  FILES:= \
-	$(PKG_BUILD_DIR)/compat/compat.ko \
-	$(PKG_BUILD_DIR)/net/wireless/cfg80211.ko
-  AUTOLOAD:=$(call AutoLoad,20,compat cfg80211)
-endef
-
-define KernelPackage/cfg80211/description
-cfg80211 is the Linux wireless LAN (802.11) configuration API.
-endef
-
-define KernelPackage/mac80211
-  $(call KernelPackage/mac80211/Default)
-  TITLE:=Linux 802.11 Wireless Networking Stack
-  DEPENDS+= +kmod-crypto-core +kmod-crypto-arc4 +kmod-crypto-aes +kmod-cfg80211
-  KCONFIG:=\
-	CONFIG_AVERAGE=y
-  FILES:= $(PKG_BUILD_DIR)/net/mac80211/mac80211.ko
-  AUTOLOAD:=$(call AutoLoad,21,mac80211)
-  MENU:=1
-endef
-
-define KernelPackage/mac80211/config
-  if PACKAGE_kmod-mac80211
-
-	config PACKAGE_MAC80211_DEBUGFS
-		bool "Export mac80211 internals in DebugFS"
-		select KERNEL_DEBUG_FS
-		select KERNEL_RELAY if PACKAGE_kmod-ath9k-common
-		default y
-		help
-		  Select this to see extensive information about
-		  the internal state of mac80211 in debugfs.
-
-	config PACKAGE_MAC80211_MESH
-		bool "Enable 802.11s mesh support"
-		default y
-
-  endif
-endef
-
-define KernelPackage/mac80211/description
-Generic IEEE 802.11 Networking Stack (mac80211)
-endef
-
-PKG_LINUX_FIRMWARE_NAME:=linux-firmware
-PKG_LINUX_FIRMWARE_VERSION:=6942dba419d2ebf8c15514972e89734fd7a8cebc
-PKG_LINUX_FIRMWARE_SOURCE:=$(PKG_LINUX_FIRMWARE_NAME)-$(PKG_LINUX_FIRMWARE_VERSION).tar.bz2
-PKG_LINUX_FIRMWARE_PROTO:=git
-PKG_LINUX_FIRMWARE_SOURCE_URL:=git://git.kernel.org/pub/scm/linux/kernel/git/firmware/linux-firmware.git
-PKG_LINUX_FIRMWARE_SUBDIR:=$(PKG_LINUX_FIRMWARE_NAME)-$(PKG_LINUX_FIRMWARE_VERSION)
-PKG_LINUX_FIRMWARE_MIRROR_MD5SUM:=a5f8c27af9e43f0ad24d7f821c5a781e
-
-define Download/linux-firmware
-  FILE:=$(PKG_LINUX_FIRMWARE_SOURCE)
-  URL:=$(PKG_LINUX_FIRMWARE_SOURCE_URL)
-  MD5SUM:=$(PKG_LINUX_FIRMWARE_MD5SUM)
-  PROTO:=$(PKG_LINUX_FIRMWARE_PROTO)
-  VERSION:=$(PKG_LINUX_FIRMWARE_VERSION)
-  SUBDIR:=$(PKG_LINUX_FIRMWARE_SUBDIR)
-  MIRROR_MD5SUM:=$(PKG_LINUX_FIRMWARE_MIRROR_MD5SUM)
-endef
-$(eval $(call Download,linux-firmware))
-
-# Prism54 drivers
-P54PCIFW:=2.13.12.0.arm
-P54USBFW:=2.13.24.0.lm87.arm
-P54SPIFW:=2.13.0.0.a.13.14.arm
-CARL9170_FW:=carl9170-1.fw
-
-define Download/p54usb
-  FILE:=$(P54USBFW)
-  URL:=http://daemonizer.de/prism54/prism54-fw/fw-usb
-  MD5SUM:=8e8ab005a4f8f0123bcdc51bc25b47f6
-endef
-$(eval $(call Download,p54usb))
-
-define Download/p54pci
-  FILE:=$(P54PCIFW)
-  URL:=http://daemonizer.de/prism54/prism54-fw/fw-softmac
-  MD5SUM:=ff7536af2092b1c4b21315bd103ef4c4
-endef
-$(eval $(call Download,p54pci))
-
-define Download/p54spi
-  FILE:=$(P54SPIFW)
-  URL:=http://daemonizer.de/prism54/prism54-fw/stlc4560
-  MD5SUM:=42661f8ecbadd88012807493f596081d
-endef
-$(eval $(call Download,p54spi))
-
-define Download/carl9170
-  FILE:=$(CARL9170_FW)-$(CARL9170_FW_VERSION)
-  URL:=http://downloads.openwrt.org/sources/
-  MD5SUM:=2fa6ed98d53d0b5fbcc136d1cf5e9609
-endef
-$(eval $(call Download,carl9170))
-
-define KernelPackage/p54/Default
-  $(call KernelPackage/mac80211/Default)
-  TITLE:=Prism54 Drivers
-endef
-
-define KernelPackage/p54/description
-  Kernel module for Prism54 chipsets (mac80211)
-endef
-
-define KernelPackage/p54-common
-  $(call KernelPackage/p54/Default)
-  DEPENDS+= @PCI_SUPPORT||@USB_SUPPORT||@TARGET_omap24xx +kmod-mac80211 +kmod-lib-crc-ccitt
-  TITLE+= (COMMON)
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/p54/p54common.ko
-  AUTOLOAD:=$(call AutoLoad,30,p54common)
-endef
-
-define KernelPackage/p54-pci
-  $(call KernelPackage/p54/Default)
-  TITLE+= (PCI)
-  DEPENDS+= @PCI_SUPPORT +kmod-p54-common
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/p54/p54pci.ko
-  AUTOLOAD:=$(call AutoLoad,31,p54pci)
-endef
-
-define KernelPackage/p54-usb
-  $(call KernelPackage/p54/Default)
-  TITLE+= (USB)
-  DEPENDS+= @USB_SUPPORT +kmod-usb-core +kmod-p54-common
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/p54/p54usb.ko
-  AUTOLOAD:=$(call AutoLoad,31,p54usb)
-endef
-
-define KernelPackage/p54-spi
-  $(call KernelPackage/p54/Default)
-  TITLE+= (SPI)
-  DEPENDS+= @TARGET_omap24xx +kmod-p54-common
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/p54/p54spi.ko
-  AUTOLOAD:=$(call AutoLoad,31,p54spi)
-endef
-
-define KernelPackage/rt2x00/Default
-  $(call KernelPackage/mac80211/Default)
-  TITLE:=Ralink Drivers for RT2x00 cards
-endef
-
-define KernelPackage/rt2x00-lib
-$(call KernelPackage/rt2x00/Default)
-  DEPENDS+= @(PCI_SUPPORT||USB_SUPPORT||TARGET_ramips) +kmod-mac80211 +kmod-lib-crc-itu-t
-  TITLE+= (LIB)
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/rt2x00/rt2x00lib.ko
-  AUTOLOAD:=$(call AutoLoad,24,rt2x00lib)
-  MENU:=1
-endef
-
-define KernelPackage/rt2x00-lib/config
-  if PACKAGE_kmod-rt2x00-lib
-
-	config PACKAGE_RT2X00_LIB_DEBUGFS
-		bool "Enable rt2x00 debugfs support"
-		depends on PACKAGE_MAC80211_DEBUGFS
-		help
-		  Enable creation of debugfs files for the rt2x00 drivers.
-		  These debugfs files support both reading and writing of the
-		  most important register types of the rt2x00 hardware.
-
-	config PACKAGE_RT2X00_DEBUG
-		bool "Enable rt2x00 debug output"
-		help
-		  Enable debugging output for all rt2x00 modules
-
-  endif
-endef
-
-define KernelPackage/rt2x00-mmio
-$(call KernelPackage/rt2x00/Default)
-  DEPENDS+= @(PCI_SUPPORT||TARGET_ramips) +kmod-rt2x00-lib +kmod-eeprom-93cx6
-  TITLE+= (MMIO)
-  FILES:= $(PKG_BUILD_DIR)/drivers/net/wireless/rt2x00/rt2x00mmio.ko
-  AUTOLOAD:=$(call AutoLoad,25,rt2x00mmio)
-endef
-
-define KernelPackage/rt2x00-pci
-$(call KernelPackage/rt2x00/Default)
-  DEPENDS+= @PCI_SUPPORT +kmod-rt2x00-mmio +kmod-rt2x00-lib
-  TITLE+= (PCI)
-  FILES:= $(PKG_BUILD_DIR)/drivers/net/wireless/rt2x00/rt2x00pci.ko
-  AUTOLOAD:=$(call AutoLoad,26,rt2x00pci)
-endef
-
-define KernelPackage/rt2x00-usb
-$(call KernelPackage/rt2x00/Default)
-  DEPENDS+= @USB_SUPPORT +kmod-rt2x00-lib +kmod-usb-core
-  TITLE+= (USB)
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/rt2x00/rt2x00usb.ko
-  AUTOLOAD:=$(call AutoLoad,26,rt2x00usb)
-endef
-
-define KernelPackage/rt2x00-soc
-$(call KernelPackage/rt2x00/Default)
-  DEPENDS+= @TARGET_ramips @!TARGET_ramips_mt7620a @!TARGET_ramips_rt3883 +kmod-rt2x00-mmio +kmod-rt2x00-lib
-  TITLE+= (SoC)
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/rt2x00/rt2x00soc.ko
-  AUTOLOAD:=$(call AutoLoad,26,rt2x00soc)
-endef
-
-define KernelPackage/rt2800-lib
-$(call KernelPackage/rt2x00/Default)
-  DEPENDS+= @(PCI_SUPPORT||USB_SUPPORT||TARGET_ramips) +kmod-rt2x00-lib +TARGET_ramips:kmod-rt2x00-soc +@DRIVER_11N_SUPPORT
-  TITLE+= (rt2800 LIB)
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/rt2x00/rt2800lib.ko
-  AUTOLOAD:=$(call AutoLoad,27,rt2800lib)
-endef
-
-define KernelPackage/rt2400-pci
-$(call KernelPackage/rt2x00/Default)
-  DEPENDS+= @PCI_SUPPORT +kmod-rt2x00-pci
-  TITLE+= (RT2400 PCI)
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/rt2x00/rt2400pci.ko
-  AUTOLOAD:=$(call AutoLoad,27,rt2400pci)
-endef
-
-define KernelPackage/rt2500-pci
-$(call KernelPackage/rt2x00/Default)
-  DEPENDS+= @PCI_SUPPORT +kmod-rt2x00-pci
-  TITLE+= (RT2500 PCI)
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/rt2x00/rt2500pci.ko
-  AUTOLOAD:=$(call AutoLoad,27,rt2500pci)
-endef
-
-define KernelPackage/rt2500-usb
-$(call KernelPackage/rt2x00/Default)
-  DEPENDS+= @USB_SUPPORT +kmod-rt2x00-usb
-  TITLE+= (RT2500 USB)
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/rt2x00/rt2500usb.ko
-  AUTOLOAD:=$(call AutoLoad,27,rt2500usb)
-endef
-
-define KernelPackage/rt61-pci
-$(call KernelPackage/rt2x00/Default)
-  DEPENDS+= @PCI_SUPPORT +kmod-rt2x00-pci
-  TITLE+= (RT2x61 PCI)
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/rt2x00/rt61pci.ko
-  AUTOLOAD:=$(call AutoLoad,27,rt61pci)
-endef
-
-define KernelPackage/rt73-usb
-  $(call KernelPackage/rt2x00/Default)
-  DEPENDS+= @USB_SUPPORT +kmod-rt2x00-usb
-  TITLE+= (RT73 USB)
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/rt2x00/rt73usb.ko
-  AUTOLOAD:=$(call AutoLoad,27,rt73usb)
-endef
-
-define KernelPackage/rt2800-pci
-$(call KernelPackage/rt2x00/Default)
-  DEPENDS+= @(PCI_SUPPORT||TARGET_ramips) +PCI_SUPPORT:kmod-rt2x00-pci +kmod-rt2800-lib +kmod-lib-crc-ccitt +TARGET_ramips:kmod-rt2x00-soc
-  TITLE+= (RT2860 PCI)
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/rt2x00/rt2800pci.ko
-  AUTOLOAD:=$(call AutoLoad,28,rt2800pci)
-endef
-
-define KernelPackage/rt2800-usb
-$(call KernelPackage/rt2x00/Default)
-  DEPENDS+= @USB_SUPPORT +kmod-rt2x00-usb +kmod-rt2800-lib +kmod-lib-crc-ccitt
-  TITLE+= (RT2870 USB)
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/rt2x00/rt2800usb.ko
-  AUTOLOAD:=$(call AutoLoad,28,rt2800usb)
-endef
-
-define KernelPackage/rtl818x/Default
-  $(call KernelPackage/mac80211/Default)
-  TITLE:=Realtek Drivers for RTL818x devices
-  URL:=http://wireless.kernel.org/en/users/Drivers/rtl8187
-  DEPENDS+= +kmod-eeprom-93cx6 +kmod-mac80211
-endef
-
-define KernelPackage/rtl8180
-  $(call KernelPackage/rtl818x/Default)
-  DEPENDS+= @PCI_SUPPORT
-  TITLE+= (RTL8180 PCI)
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/rtl818x/rtl8180/rtl8180.ko
-  AUTOLOAD:=$(call AutoLoad,27,rtl8180)
-endef
-
-define KernelPackage/rtl8187
-$(call KernelPackage/rtl818x/Default)
-  DEPENDS+= @USB_SUPPORT +kmod-usb-core
-  TITLE+= (RTL8187 USB)
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/rtl818x/rtl8187/rtl8187.ko
-  AUTOLOAD:=$(call AutoLoad,27,rtl8187)
-endef
-
-ZD1211FW_NAME:=zd1211-firmware
-ZD1211FW_VERSION:=1.4
-define Download/zd1211rw
-  FILE:=$(ZD1211FW_NAME)-$(ZD1211FW_VERSION).tar.bz2
-  URL:=@SF/zd1211/
-  MD5SUM:=19f28781d76569af8551c9d11294c870
-endef
-$(eval $(call Download,zd1211rw))
-
-define KernelPackage/zd1211rw
-  $(call KernelPackage/mac80211/Default)
-  TITLE:=Zydas ZD1211 support
-  DEPENDS+= @USB_SUPPORT +kmod-usb-core +kmod-mac80211
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/zd1211rw/zd1211rw.ko
-  AUTOLOAD:=$(call AutoLoad,60,zd1211rw)
-endef
-
-define KernelPackage/adm8211
-  $(call KernelPackage/mac80211/Default)
-  TITLE:=ADMTek 8211 support
-  DEPENDS+=@PCI_SUPPORT +kmod-mac80211 +kmod-eeprom-93cx6
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/adm8211.ko
-  AUTOLOAD:=$(call AutoLoad,60,adm8211)
-endef
-
-define KernelPackage/ath/config
-  if PACKAGE_kmod-ath
-	config ATH_USER_REGD
-		bool "Force Atheros drivers to respect the user's regdomain settings"
-		help
-		  Atheros' idea of regulatory handling is that the EEPROM of the card defines
-		  the regulatory limits and the user is only allowed to restrict the settings
-		  even further, even if the country allows frequencies or power levels that
-		  are forbidden by the EEPROM settings.
-
-		  Select this option if you want the driver to respect the user's decision about
-		  regulatory settings.
-
-	config PACKAGE_ATH_DEBUG
-		bool "Atheros wireless debugging"
-		help
-		  Say Y, if you want to debug atheros wireless drivers.
-		  Right now only ath9k makes use of this.
-  endif
-endef
-
-define KernelPackage/ath
-  $(call KernelPackage/mac80211/Default)
-  TITLE:=Atheros common driver part
-  DEPENDS+= @PCI_SUPPORT||USB_SUPPORT||TARGET_ar71xx||TARGET_atheros +kmod-mac80211
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/ath/ath.ko
-  AUTOLOAD:=$(call AutoLoad,26,ath)
-  MENU:=1
-endef
-
-define KernelPackage/ath/description
- This module contains some common parts needed by Atheros Wireless drivers.
-endef
-
-define KernelPackage/ath5k
-  $(call KernelPackage/mac80211/Default)
-  TITLE:=Atheros 5xxx wireless cards support
-  URL:=http://linuxwireless.org/en/users/Drivers/ath5k
-  DEPENDS+= @PCI_SUPPORT||@TARGET_atheros +kmod-ath
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/ath/ath5k/ath5k.ko
-  AUTOLOAD:=$(call AutoLoad,27,ath5k)
-endef
-
-define KernelPackage/ath5k/description
- This module adds support for wireless adapters based on
- Atheros 5xxx chipset.
-endef
-
-define KernelPackage/ath9k-common
-  $(call KernelPackage/mac80211/Default)
-  TITLE:=Atheros 802.11n wireless devices (common code for ath9k and ath9k_htc)
-  URL:=http://linuxwireless.org/en/users/Drivers/ath9k
-  DEPENDS+= @PCI_SUPPORT||USB_SUPPORT||TARGET_ar71xx +kmod-ath +@DRIVER_11N_SUPPORT
-  FILES:= \
-	$(PKG_BUILD_DIR)/drivers/net/wireless/ath/ath9k/ath9k_common.ko \
-	$(PKG_BUILD_DIR)/drivers/net/wireless/ath/ath9k/ath9k_hw.ko
-  AUTOLOAD:=$(call AutoLoad,27,ath9k_hw ath9k_common)
-endef
-
-define KernelPackage/ath9k
-  $(call KernelPackage/mac80211/Default)
-  TITLE:=Atheros 802.11n PCI wireless cards support
-  URL:=http://linuxwireless.org/en/users/Drivers/ath9k
-  DEPENDS+= @PCI_SUPPORT||TARGET_ar71xx +kmod-ath9k-common
-  FILES:= \
-	$(PKG_BUILD_DIR)/drivers/net/wireless/ath/ath9k/ath9k.ko
-  AUTOLOAD:=$(call AutoLoad,28,ath9k)
-endef
-
-define KernelPackage/ath9k/description
-This module adds support for wireless adapters based on
-Atheros IEEE 802.11n AR5008 and AR9001 family of chipsets.
-endef
-
-define KernelPackage/ath9k-htc
-  $(call KernelPackage/mac80211/Default)
-  TITLE:=Atheros 802.11n USB device support
-  URL:=http://linuxwireless.org/en/users/Drivers/ath9k
-  DEPENDS+= @USB_SUPPORT +kmod-ath9k-common +kmod-usb-core
-  FILES:= \
-	$(PKG_BUILD_DIR)/drivers/net/wireless/ath/ath9k/ath9k_htc.ko
-  AUTOLOAD:=$(call AutoLoad,55,ath9k_htc)
-endef
-
-define KernelPackage/ath9k-htc/description
-This module adds support for wireless adapters based on
-Atheros USB AR9271 and AR7010 family of chipsets.
-endef
-
-define KernelPackage/carl9170
-  $(call KernelPackage/mac80211/Default)
-  TITLE:=Driver for Atheros AR9170 USB sticks
-  DEPENDS:=@USB_SUPPORT +kmod-mac80211 +kmod-ath +kmod-usb-core +kmod-input-core +@DRIVER_11N_SUPPORT
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/ath/carl9170/carl9170.ko
-  AUTOLOAD:=$(call AutoLoad,60,carl9170)
-endef
-
-define KernelPackage/carl9170/install
-	$(INSTALL_DIR) $(1)/lib/firmware
-	$(INSTALL_DATA) $(DL_DIR)/$(CARL9170_FW)-$(CARL9170_FW_VERSION) $(1)/lib/firmware/$(CARL9170_FW)
-endef
-
-define KernelPackage/lib80211
-  $(call KernelPackage/mac80211/Default)
-  TITLE:=802.11 Networking stack
-  FILES:= \
-	$(PKG_BUILD_DIR)/net/wireless/lib80211.ko \
-	$(PKG_BUILD_DIR)/net/wireless/lib80211_crypt_wep.ko \
-	$(PKG_BUILD_DIR)/net/wireless/lib80211_crypt_ccmp.ko \
-	$(PKG_BUILD_DIR)/net/wireless/lib80211_crypt_tkip.ko
-  AUTOLOAD:=$(call AutoLoad,21, \
-	lib80211 \
-	lib80211_crypt_wep \
-	lib80211_crypt_ccmp \
-	lib80211_crypt_tkip \
-  )
-endef
-
-define KernelPackage/lib80211/description
- Kernel modules for 802.11 Networking stack
- Includes:
- - lib80211
- - lib80211_crypt_wep
- - lib80211_crypt_tkip
- - lib80211_crytp_ccmp
-endef
-
-define KernelPackage/libertas-usb
-  $(call KernelPackage/mac80211/Default)
-  DEPENDS+= @USB_SUPPORT +kmod-cfg80211 +kmod-usb-core +kmod-lib80211 +@DRIVER_WEXT_SUPPORT
-  TITLE:=Marvell 88W8015 Wireless Driver
-  FILES:= \
-	$(PKG_BUILD_DIR)/drivers/net/wireless/libertas/libertas.ko \
-	$(PKG_BUILD_DIR)/drivers/net/wireless/libertas/usb8xxx.ko
-  AUTOLOAD:=$(call AutoLoad,27,libertas usb8xxx)
-endef
-
-define KernelPackage/libertas-sd
-  $(call KernelPackage/mac80211/Default)
-  DEPENDS+= +kmod-cfg80211 +kmod-lib80211 +kmod-mmc +@DRIVER_WEXT_SUPPORT
-  TITLE:=Marvell 88W8686 Wireless Driver
-  FILES:= \
-	$(PKG_BUILD_DIR)/drivers/net/wireless/libertas/libertas.ko \
-	$(PKG_BUILD_DIR)/drivers/net/wireless/libertas/libertas_sdio.ko
-  AUTOLOAD:=$(call AutoLoad,91,libertas libertas_sdio)
-endef
-
-define KernelPackage/mac80211-hwsim
-  $(call KernelPackage/mac80211/Default)
-  TITLE:=mac80211 HW simulation device
-  DEPENDS+= +kmod-mac80211
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/mac80211_hwsim.ko
-  AUTOLOAD:=$(call AutoLoad,60,mac80211_hwsim)
-endef
-
-define KernelPackage/net-libipw
-  $(call KernelPackage/mac80211/Default)
-  TITLE:=libipw for ipw2100 and ipw2200
-  DEPENDS:=@PCI_SUPPORT +kmod-crypto-core +kmod-crypto-arc4 +kmod-crypto-aes +kmod-crypto-michael-mic +kmod-lib80211 +kmod-cfg80211 +@DRIVER_WEXT_SUPPORT
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/ipw2x00/libipw.ko
-  AUTOLOAD:=$(call AutoLoad,49,libipw)
-endef
-
-define KernelPackage/net-libipw/description
- Hardware independent IEEE 802.11 networking stack for ipw2100 and ipw2200.
-endef
-
-IPW2100_NAME:=ipw2100-fw
-IPW2100_VERSION:=1.3
-
-define Download/net-ipw2100
-  URL:=http://bughost.org/firmware/
-  FILE:=$(IPW2100_NAME)-$(IPW2100_VERSION).tgz
-  MD5SUM=46aa75bcda1a00efa841f9707bbbd113
-endef
-$(eval $(call Download,net-ipw2100))
-
-define KernelPackage/net-ipw2100
-  $(call KernelPackage/mac80211/Default)
-  TITLE:=Intel IPW2100 driver
-  DEPENDS:=@PCI_SUPPORT +kmod-net-libipw
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/ipw2x00/ipw2100.ko
-  AUTOLOAD:=$(call AutoLoad,50,ipw2100)
-endef
-
-define KernelPackage/net-ipw2100/description
- Kernel support for Intel IPW2100
- Includes:
- - ipw2100
-endef
-
-IPW2200_NAME:=ipw2200-fw
-IPW2200_VERSION:=3.1
-
-define Download/net-ipw2200
-  URL:=http://bughost.org/firmware/
-  FILE:=$(IPW2200_NAME)-$(IPW2200_VERSION).tgz
-  MD5SUM=eaba788643c7cc7483dd67ace70f6e99
-endef
-$(eval $(call Download,net-ipw2200))
-
-define KernelPackage/net-ipw2200
-  $(call KernelPackage/mac80211/Default)
-  TITLE:=Intel IPW2200 driver
-  DEPENDS:=@PCI_SUPPORT +kmod-net-libipw
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/ipw2x00/ipw2200.ko
-  AUTOLOAD:=$(call AutoLoad,50,ipw2200)
-endef
-
-define KernelPackage/net-ipw2200/description
- Kernel support for Intel IPW2200
- Includes:
- - ipw2200
-endef
-
-
-define KernelPackage/net-hermes
-  $(call KernelPackage/mac80211/Default)
-  TITLE:=Hermes 802.11b chipset support
-  DEPENDS:=@PCI_SUPPORT||PCMCIA_SUPPORT +kmod-cfg80211 +@DRIVER_WEXT_SUPPORT
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/orinoco/orinoco.ko
-  AUTOLOAD:=$(call AutoLoad,50,orinoco)
-endef
-
-define KernelPackage/net-hermes/description
- Kernel support for Hermes 802.11b chipsets
-endef
-
-define KernelPackage/net-hermes-pci
-  $(call KernelPackage/mac80211/Default)
-  TITLE:=Intersil Prism 2.5 PCI support
-  DEPENDS:=@PCI_SUPPORT +kmod-net-hermes
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/orinoco/orinoco_pci.ko
-  AUTOLOAD:=$(call AutoLoad,55,orinoco_pci)
-endef
-
-define KernelPackage/net-hermes-pci/description
- Kernel modules for Intersil Prism 2.5 PCI support
-endef
-
-define KernelPackage/net-hermes-plx
-  $(call KernelPackage/mac80211/Default)
-  TITLE:=PLX9052 based PCI adaptor
-  DEPENDS:=@PCI_SUPPORT +kmod-net-hermes
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/orinoco/orinoco_plx.ko
-  AUTOLOAD:=$(call AutoLoad,55,orinoco_plx)
-endef
-
-define KernelPackage/net-hermes-plx/description
- Kernel modules for Hermes in PLX9052 based PCI adaptors
-endef
-
-define KernelPackage/net-hermes-pcmcia
-  $(call KernelPackage/mac80211/Default)
-  TITLE:=Hermes based PCMCIA adaptors
-  DEPENDS:=@PCMCIA_SUPPORT +kmod-net-hermes @BROKEN
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/orinoco/orinoco_cs.ko
-  AUTOLOAD:=$(call AutoLoad,55,orinoco_cs)
-endef
-
-define KernelPackage/net-hermes-pcmcia/description
- Kernel modules for Hermes based PCMCIA adaptors
-endef
-
-define KernelPackage/iwlagn
-  $(call KernelPackage/mac80211/Default)
-  DEPENDS:= +kmod-mac80211 @PCI_SUPPORT +@DRIVER_11N_SUPPORT
-  TITLE:=Intel AGN Wireless support
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/iwlwifi/iwlwifi.ko
-  AUTOLOAD:=$(call AutoLoad,60,iwlwifi)
-  MENU:=1
-endef
-
-define KernelPackage/iwlagn/description
- iwlagn kernel module for Intel 5000/5150/1000/6000/6050/6005/6030/100 support
-endef
-
-define KernelPackage/iwlagn/config
-  if PACKAGE_kmod-iwlagn
-
-	config IWL5000_FW
-		bool "Intel 5000 Firmware"
-		default y
-		help
-		  Download and install firmware for:
-		    Intel Wireless WiFi 5100AGN, 5300AGN, and 5350AGN
-
-	config IWL5150_FW
-		bool "Intel 5150 Firmware"
-		default y
-		help
-		  Download and install firmware for:
-		    Intel Wireless WiFi 5150AGN
-
-	config IWL1000_FW
-		bool "Intel 1000 Firmware"
-		default y
-		help
-		  Download and install firmware for:
-		    Intel Centrino Wireless-N 1000
-
-	config IWL6000_FW
-		bool "Intel 6000 Firmware"
-		default y
-		help
-		  Download and install firmware for:
-		    Intel Centrino Ultimate-N 6300 and Advanced-N 6200
-
-	config IWL6050_FW
-		bool "Intel 6050 Firmware"
-		default y
-		help
-		  Download and install firmware for:
-		    Intel Centrino Advanced-N + WiMAX 6250 and Wireless-N + WiMAX 6150
-
-	config IWL6005_FW
-		bool "Intel 6005 Firmware"
-		default y
-		help
-		  Download and install firmware for:
-		    Intel Centrino Advanced-N 6205
-
-	config IWL6030_FW
-		bool "Intel 6030 Firmware"
-		default y
-		help
-		  Download and install firmware for:
-		    Intel Centrino Advanced-N 6230, Wireless-N 1030, Wireless-N 130 and Advanced-N 6235
-
-	config IWL100_FW
-		bool "Intel 100 Firmware"
-		default y
-		help
-		  Download and install firmware for:
-		    Intel Centrino Wireless-N 100
-
-	config IWL2000_FW
-		bool "Intel 2000 Firmware"
-		default y
-		help
-		  Download and install firmware for:
-		    Intel Centrino Wireless-N 2200
-
-	config IWL2030_FW
-		bool "Intel 2030 Firmware"
-		default y
-		help
-		  Download and install firmware for:
-		    Intel Centrino Wireless-N 2230
-
-	config IWL105_FW
-		bool "Intel 105 Firmware"
-		default y
-		help
-		  Download and install firmware for:
-		    Intel Centrino Wireless-N 105
-
-	config IWL135_FW
-		bool "Intel 135 Firmware"
-		default y
-		help
-		  Download and install firmware for:
-		    Intel Centrino Wireless-N 135
-  endif
-endef
-
-define KernelPackage/iwl-legacy
-  $(call KernelPackage/mac80211/Default)
-  DEPENDS:= +kmod-mac80211 @PCI_SUPPORT
-  TITLE:=Intel legacy Wireless support
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/iwlegacy/iwlegacy.ko
-  AUTOLOAD:=$(call AutoLoad,60,iwlegacy)
-endef
-
-define KernelPackage/iwl-legacy/description
- iwl-legacy kernel module for legacy Intel wireless support
-endef
-
-define KernelPackage/iwl3945
-  $(call KernelPackage/mac80211/Default)
-  DEPENDS:= +kmod-mac80211 +kmod-iwl-legacy
-  TITLE:=Intel iwl3945 Wireless support
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/iwlegacy/iwl3945.ko
-  AUTOLOAD:=$(call AutoLoad,61,iwl3945)
-endef
-
-define KernelPackage/iwl3945/description
- iwl3945 kernel module for Intel 3945 support
-endef
-
-define KernelPackage/iwl4965
-  $(call KernelPackage/mac80211/Default)
-  DEPENDS:= +kmod-mac80211 +kmod-iwl-legacy +@DRIVER_11N_SUPPORT
-  TITLE:=Intel iwl4965 Wireless support
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/iwlegacy/iwl4965.ko
-  AUTOLOAD:=$(call AutoLoad,61,iwl4965)
-endef
-
-define KernelPackage/iwl4965/description
- iwl4965 kernel module for Intel 4965 support
-endef
-
-
-define KernelPackage/mwl8k
-  $(call KernelPackage/mac80211/Default)
-  TITLE:=Driver for Marvell TOPDOG 802.11 Wireless cards
-  URL:=http://wireless.kernel.org/en/users/Drivers/mwl8k
-  DEPENDS+= @PCI_SUPPORT +kmod-mac80211 +@DRIVER_11N_SUPPORT
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/mwl8k.ko
-  AUTOLOAD:=$(call AutoLoad,27,mwl8k)
-endef
-
-define KernelPackage/mwl8k/description
- Kernel modules for Marvell TOPDOG 802.11 Wireless cards
-endef
-
-
-define KernelPackage/wl12xx
-  $(call KernelPackage/mac80211/Default)
-  TITLE:=Driver for TI WL12xx
-  URL:=http://wireless.kernel.org/en/users/Drivers/wl12xx
-  DEPENDS+= @TARGET_omap4 +kmod-mac80211
-  FILES:= \
-	$(PKG_BUILD_DIR)/drivers/net/wireless/ti/wl12xx/wl12xx.ko \
-	$(PKG_BUILD_DIR)/drivers/net/wireless/ti/wlcore/wlcore.ko \
-	$(PKG_BUILD_DIR)/drivers/net/wireless/ti/wlcore/wlcore_sdio.ko
-  AUTOLOAD:=$(call AutoLoad,61,wlcore wlcore_sdio wl12xx)
-endef
-
-define KernelPackage/wl12xx/description
- Kernel modules for TI WL12xx
-endef
-
-#Broadcom firmware
-ifneq ($(CONFIG_B43_FW_5_10),)
-  PKG_B43_FWV4_NAME:=broadcom-wl
-  PKG_B43_FWV4_VERSION:=5.10.56.27.3
-  PKG_B43_FWV4_OBJECT:=$(PKG_B43_FWV4_NAME)-$(PKG_B43_FWV4_VERSION)/driver/wl_apsta/wl_prebuilt.o
-  PKG_B43_FWV4_SOURCE:=$(PKG_B43_FWV4_NAME)-$(PKG_B43_FWV4_VERSION)_mipsel.tar.bz2
-  PKG_B43_FWV4_SOURCE_URL:=http://mirror2.openwrt.org/sources/
-  PKG_B43_FWV4_MD5SUM:=3363e3a6b3d9d73c49dea870c7834eac
-else
-ifneq ($(CONFIG_B43_FW_4_178),)
-  PKG_B43_FWV4_NAME:=broadcom-wl
-  PKG_B43_FWV4_VERSION:=4.178.10.4
-  PKG_B43_FWV4_OBJECT:=$(PKG_B43_FWV4_NAME)-$(PKG_B43_FWV4_VERSION)/linux/wl_apsta.o
-  PKG_B43_FWV4_SOURCE:=$(PKG_B43_FWV4_NAME)-$(PKG_B43_FWV4_VERSION).tar.bz2
-  PKG_B43_FWV4_SOURCE_URL:=http://mirror2.openwrt.org/sources/
-  PKG_B43_FWV4_MD5SUM:=14477e8cbbb91b11896affac9b219fdb
-else
-ifneq ($(CONFIG_B43_FW_5_100_138),)
-  PKG_B43_FWV4_NAME:=broadcom-wl
-  PKG_B43_FWV4_VERSION:=5.100.138
-  PKG_B43_FWV4_OBJECT:=$(PKG_B43_FWV4_NAME)-$(PKG_B43_FWV4_VERSION)/linux/wl_apsta.o
-  PKG_B43_FWV4_SOURCE:=$(PKG_B43_FWV4_NAME)-$(PKG_B43_FWV4_VERSION).tar.bz2
-  PKG_B43_FWV4_SOURCE_URL:=http://www.lwfinger.com/b43-firmware/
-  PKG_B43_FWV4_MD5SUM:=f4e357b09eaf5d8b1f1920cf3493a555
-else
-  PKG_B43_FWV4_NAME:=broadcom-wl
-  PKG_B43_FWV4_VERSION:=4.150.10.5
-  PKG_B43_FWV4_OBJECT:=$(PKG_B43_FWV4_NAME)-$(PKG_B43_FWV4_VERSION)/driver/wl_apsta_mimo.o
-  PKG_B43_FWV4_SOURCE:=$(PKG_B43_FWV4_NAME)-$(PKG_B43_FWV4_VERSION).tar.bz2
-  PKG_B43_FWV4_SOURCE_URL:=http://mirror2.openwrt.org/sources/
-  PKG_B43_FWV4_MD5SUM:=0c6ba9687114c6b598e8019e262d9a60
-endif
-endif
-endif
-ifneq ($(CONFIG_B43_OPENFIRMWARE),)
-  PKG_B43_FWV4_NAME:=broadcom-wl
-  PKG_B43_FWV4_VERSION:=5.2
-  PKG_B43_FWV4_OBJECT:=openfwwf-$(PKG_B43_FWV4_VERSION)
-  PKG_B43_FWV4_SOURCE:=openfwwf-$(PKG_B43_FWV4_VERSION).tar.gz
-  PKG_B43_FWV4_SOURCE_URL:=http://www.ing.unibs.it/openfwwf/firmware/
-  PKG_B43_FWV4_MD5SUM:=e045a135453274e439ae183f8498b0fa
-endif
-
-
-PKG_B43_FWV3_NAME:=wl_apsta
-PKG_B43_FWV3_VERSION:=3.130.20.0
-PKG_B43_FWV3_SOURCE:=$(PKG_B43_FWV3_NAME)-$(PKG_B43_FWV3_VERSION).o
-PKG_B43_FWV3_SOURCE_URL:=http://downloads.openwrt.org/sources/
-PKG_B43_FWV3_MD5SUM:=e08665c5c5b66beb9c3b2dd54aa80cb3
-
-define Download/b43
-  FILE:=$(PKG_B43_FWV4_SOURCE)
-  URL:=$(PKG_B43_FWV4_SOURCE_URL)
-  MD5SUM:=$(PKG_B43_FWV4_MD5SUM)
-endef
-$(eval $(call Download,b43))
-
-define Download/b43legacy
-  FILE:=$(PKG_B43_FWV3_SOURCE)
-  URL:=$(PKG_B43_FWV3_SOURCE_URL)
-  MD5SUM:=$(PKG_B43_FWV3_MD5SUM)
-endef
-$(eval $(call Download,b43legacy))
-
-
-define KernelPackage/b43
-  $(call KernelPackage/mac80211/Default)
-  TITLE:=Broadcom 43xx wireless support
-  URL:=http://linuxwireless.org/en/users/Drivers/b43
-  KCONFIG:= \
-  	CONFIG_HW_RANDOM=y
-  DEPENDS+= +kmod-mac80211 +!TARGET_brcm47xx:kmod-bcma +!(TARGET_brcm47xx||TARGET_brcm63xx):kmod-ssb
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/b43/b43.ko
-  AUTOLOAD:=$(call AutoLoad,30,b43)
-  MENU:=1
-endef
-
-define KernelPackage/b43/config
-  if PACKAGE_kmod-b43
-
-	choice
-		prompt "b43 firmware version"
-		default B43_FW_5_100_138
-		help
-		  This option allows you to select the version of the b43 firmware.
-
-	config B43_FW_4_150
-		bool "Firmware 410.2160 from driver 4.150.10.5 (old stable)"
-		help
-		  Stable firmware for BCM43xx devices.
-
-		  If unsure, select this.
-
-	config B43_FW_4_178
-		bool "Firmware 478.104 from driver 4.178.10.4"
-		help
-		  Experimental firmware for BCM43xx devices.
-
-		  This firmware is not tested as much as the "stable" firmware.
-
-		  If unsure, select the "stable" firmware.
-
-	config B43_FW_5_10
-		bool "Firmware 508.1084 from driver 5.10.56.27"
-		help
-		  Newer experimental firmware for BCM43xx devices.
-
-		  This firmware is mostly untested. It is needed for some N-PHY devices.
-
-		  If unsure, select the "stable" firmware.
-
-	config B43_FW_5_100_138
-		bool "Firmware 666.2 from driver 5.100.138 (stable)"
-		help
-		  Newer experimental firmware for BCM43xx devices.
-
-		  This firmware is mostly untested. It is needed for some N-PHY devices.
-
-		  If unsure, select the "stable" firmware.
-
-	config B43_OPENFIRMWARE
-		bool "Open FirmWare for WiFi networks"
-		help
-		  Opensource firmware for BCM43xx devices.
-
-		  Do _not_ select this, unless you know what you are doing.
-		  The Opensource firmware is not suitable for embedded devices, yet.
-		  It does not support QoS, which is bad for AccessPoints.
-		  It does not support hardware crypto acceleration, which is a showstopper
-		  for embedded devices with low CPU resources.
-
-		  If unsure, select the "stable" firmware.
-
-	endchoice
-
-	config B43_FW_SQUASH
-		bool "Remove unnecessary firmware files"
-		depends on !B43_OPENFIRMWARE
-		default y
-		help
-		  This options allows you to remove unnecessary b43 firmware files
-		  from the final rootfs image. This can reduce the rootfs size by
-		  up to 200k.
-
-		  If unsure, say Y.
-
-	config B43_FW_SQUASH_COREREVS
-		string "Core revisions to include"
-		depends on B43_FW_SQUASH
-		default "5,6,7,8,9,10,11,13,15,16,29"
-		help
-		  This is a comma seperated list of core revision numbers.
-
-		  Example (keep files for rev5 only):
-		    5
-
-		  Example (keep files for rev5 and rev11):
-		    5,11
-
-	config B43_FW_SQUASH_PHYTYPES
-		string "PHY types to include"
-		depends on B43_FW_SQUASH
-		default "G,LP,N,HT"
-		help
-		  This is a comma seperated list of PHY types:
-		    A  => A-PHY
-		    AG => Dual A-PHY G-PHY
-		    G  => G-PHY
-		    LP => LP-PHY
-		    N  => N-PHY
-		    HT  => HT-PHY
-		    LCN  => LCN-PHY
-
-		  Example (keep files for G-PHY only):
-		    G
-
-		  Example (keep files for G-PHY and N-PHY):
-		    G,N
-
-	config PACKAGE_B43_DEBUG
-		bool "Enable debug output and debugfs for b43"
-		default n
-		help
-		  Enable additional debug output and runtime sanity checks for b43
-		  and enables the debugfs interface.
-
-		  If unsure, say N.
-
-	config PACKAGE_B43_PIO
-		bool "Enable support for PIO transfer mode"
-		default n
-		help
-		  Enable support for using PIO instead of DMA. Unless you have DMA
-		  transfer problems you don't need this.
-
-		  If unsure, say N.
-
-	config PACKAGE_B43_PHY_N
-		bool "Enable support for N-PHYs"
-		default y
-		help
-		  Enable support for N-PHY. This includes support for the following devices:
-		  PCI: BCM4321, BCM4322, BCM43222, BCM43224, BCM43225
-		  SoC: BCM4716, BCM4717, BCM4718
-
-		  Currently only 11g speed is available.
-
-		  If unsure, say Y.
-
-	config PACKAGE_B43_PHY_HT
-		bool "Enable support for HT-PHYs"
-		default y
-		help
-		  Enable support for HT-PHY. This includes support for the following devices:
-		  PCI: BCM4331
-
-		  Currently only 11g speed is available.
-
-		  If unsure, say Y.
-
-	config PACKAGE_B43_PHY_LCN
-		bool "Enable support for LCN-PHYs"
-		depends on BROKEN
-		default n
-		help
-		  Currently broken.
-
-		  If unsure, say N.
-
-  endif
-endef
-
-define KernelPackage/b43/description
-Kernel module for Broadcom 43xx wireless support (mac80211 stack) new
-endef
-
-define KernelPackage/b43legacy
-  $(call KernelPackage/mac80211/Default)
-  TITLE:=Broadcom 43xx-legacy wireless support
-  URL:=http://linuxwireless.org/en/users/Drivers/b43
-  KCONFIG:= \
-  	CONFIG_HW_RANDOM=y
-  DEPENDS+= +kmod-mac80211 +!(TARGET_brcm47xx||TARGET_brcm63xx):kmod-ssb
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/b43legacy/b43legacy.ko
-  AUTOLOAD:=$(call AutoLoad,30,b43legacy)
-  MENU:=1
-endef
-
-define KernelPackage/b43legacy/config
-  if PACKAGE_kmod-b43legacy
-
-	config B43LEGACY_FW_SQUASH
-		bool "Remove unnecessary firmware files"
-		default y
-		help
-		  This options allows you to remove unnecessary b43legacy firmware files
-		  from the final rootfs image. This can reduce the rootfs size by
-		  up to 50k.
-
-		  If unsure, say Y.
-
-	config B43LEGACY_FW_SQUASH_COREREVS
-		string "Core revisions to include"
-		depends on B43LEGACY_FW_SQUASH
-		default "1,2,3,4"
-		help
-		  This is a comma seperated list of core revision numbers.
-
-		  Example (keep files for rev4 only):
-		    4
-
-		  Example (keep files for rev2 and rev4):
-		    2,4
-
-  endif
-endef
-
-define KernelPackage/b43legacy/description
-Kernel module for Broadcom 43xx-legacy wireless support (mac80211 stack) new
-endef
-
-
-define KernelPackage/brcmutil
-  $(call KernelPackage/mac80211/Default)
-  TITLE:=Broadcom IEEE802.11n common driver parts
-  URL:=http://linuxwireless.org/en/users/Drivers/brcm80211
-  DEPENDS+=@PCI_SUPPORT||USB_SUPPORT
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/brcm80211/brcmutil/brcmutil.ko
-  AUTOLOAD:=$(call AutoLoad,30,brcmutil)
-  MENU:=1
-endef
-
-define KernelPackage/brcmutil/description
- This module contains some common parts needed by Broadcom Wireless drivers brcmsmac and brcmfmac.
-endef
-
-define KernelPackage/brcmutil/config
-  if PACKAGE_kmod-brcmutil
-
-	config PACKAGE_BRCM80211_DEBUG
-		bool "Broadcom wireless driver debugging"
-		help
-		  Say Y, if you want to debug brcmsmac and brcmfmac wireless driver.
-
-  endif
-endef
-
-PKG_BRCMSMAC_FW_NAME:=broadcom-wl
-PKG_BRCMSMAC_FW_VERSION:=5.100.138
-PKG_BRCMSMAC_FW_OBJECT:=$(PKG_BRCMSMAC_FW_NAME)-$(PKG_BRCMSMAC_FW_VERSION)/linux/wl_apsta.o
-PKG_BRCMSMAC_FW_SOURCE:=$(PKG_BRCMSMAC_FW_NAME)-$(PKG_BRCMSMAC_FW_VERSION).tar.bz2
-PKG_BRCMSMAC_FW_SOURCE_URL:=http://www.lwfinger.com/b43-firmware/
-PKG_BRCMSMAC_FW_MD5SUM:=f4e357b09eaf5d8b1f1920cf3493a555
-
-define Download/brcmsmac
-  FILE:=$(PKG_BRCMSMAC_FW_SOURCE)
-  URL:=$(PKG_BRCMSMAC_FW_SOURCE_URL)
-  MD5SUM:=$(PKG_BRCMSMAC_FW_MD5SUM)
-endef
-$(eval $(call Download,brcmsmac))
-
-define KernelPackage/brcmsmac
-  $(call KernelPackage/mac80211/Default)
-  TITLE:=Broadcom IEEE802.11n PCIe SoftMAC WLAN driver
-  URL:=http://linuxwireless.org/en/users/Drivers/brcm80211
-  DEPENDS+= +kmod-mac80211 +@DRIVER_11N_SUPPORT +!TARGET_brcm47xx:kmod-bcma +kmod-lib-cordic +kmod-lib-crc8 +kmod-brcmutil
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/brcm80211/brcmsmac/brcmsmac.ko
-  AUTOLOAD:=$(call AutoLoad,31,brcmsmac)
-  MENU:=1
-endef
-
-define KernelPackage/brcmsmac/description
- Kernel module for Broadcom IEEE802.11n PCIe Wireless cards
-endef
-
-define KernelPackage/brcmsmac/config
-  if PACKAGE_kmod-brcmsmac
-
-	config BRCMSMAC_USE_FW_FROM_WL
-		bool "Use firmware extracted from broadcom proprietary driver"
-		default y
-		help
-		  Instead of using the official brcmsmac firmware a firmware
-		  version 666.2 extracted from the proprietary Broadcom driver
-		  is used. This is needed to get core rev 17 used in bcm4716
-		  to work.
-
-		  If unsure, say Y.
-
-  endif
-endef
-
-
-define KernelPackage/brcmfmac
-  $(call KernelPackage/mac80211/Default)
-  TITLE:=Broadcom IEEE802.11n USB FullMAC WLAN driver
-  URL:=http://linuxwireless.org/en/users/Drivers/brcm80211
-  DEPENDS+= @USB_SUPPORT +kmod-usb-core +kmod-cfg80211 +@DRIVER_11N_SUPPORT +kmod-brcmutil
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/brcm80211/brcmfmac/brcmfmac.ko
-  AUTOLOAD:=$(call AutoLoad,60,brcmfmac)
-endef
-
-define KernelPackage/brcmfmac/description
- Kernel module for Broadcom IEEE802.11n USB Wireless cards
-endef
-
-config_package=$(if $(CONFIG_PACKAGE_kmod-$(1)),m)
-
-config-y:= \
-	WLAN \
-	NL80211_TESTMODE \
-	CFG80211_WEXT \
-	CFG80211_INTERNAL_REGDB \
-	MAC80211_RC_MINSTREL \
-	MAC80211_RC_MINSTREL_HT \
-	MAC80211_RC_DEFAULT_MINSTREL \
-
-config-$(call config_package,cfg80211) += CFG80211
-
-config-$(call config_package,mac80211) += MAC80211
-config-$(CONFIG_PACKAGE_MAC80211_MESH) += MAC80211_MESH
-ifdef CONFIG_PACKAGE_MAC80211_DEBUGFS
-  config-y += \
-	CFG80211_DEBUGFS \
-	MAC80211_DEBUGFS \
-	ATH9K_DEBUGFS \
-	ATH9K_HTC_DEBUGFS \
-	CARL9170_DEBUGFS \
-	ATH5K_DEBUG
-endif
-
-config-$(call config_package,lib80211) += LIB80211 LIB80211_CRYPT_WEP LIB80211_CRYPT_CCMP LIB80211_CRYPT_TKIP
-
-config-$(call config_package,ath) += ATH_CARDS ATH_COMMON
-config-$(CONFIG_PACKAGE_ATH_DEBUG) += ATH_DEBUG
-
-config-$(call config_package,ath9k) += ATH9K
-config-$(call config_package,ath9k-common) += ATH9K_COMMON
-config-$(CONFIG_TARGET_ar71xx) += ATH9K_AHB
-config-$(CONFIG_PCI) += ATH9K_PCI
-config-$(CONFIG_ATH_USER_REGD) += ATH_USER_REGD
-
-config-$(call config_package,ath9k-htc) += ATH9K_HTC
-
-config-$(call config_package,ath5k) += ATH5K
-ifdef CONFIG_TARGET_atheros
-  config-y += ATH5K_AHB
-else
-  config-y += ATH5K_PCI
-endif
-
-config-$(call config_package,carl9170) += CARL9170
-
-config-$(call config_package,b43) += B43
-config-y += B43_SSB B43_BCMA B43_PHY_LP
-config-$(CONFIG_PACKAGE_B43_PHY_N) += B43_PHY_N
-config-$(CONFIG_PACKAGE_B43_PHY_HT) += B43_PHY_HT
-config-$(CONFIG_PACKAGE_B43_PIO) += B43_PIO
-config-$(CONFIG_PACKAGE_B43_DEBUG) += B43_DEBUG
-
-config-$(call config_package,b43legacy) += B43LEGACY
-config-y += B43LEGACY_DMA_MODE
-
-config-$(call config_package,brcmutil) += BRCMUTIL
-config-$(call config_package,brcmsmac) += BRCMSMAC
-config-$(call config_package,brcmfmac) += BRCMFMAC BRCMFMAC_USB
-config-$(CONFIG_PACKAGE_BRCM80211_DEBUG) += BRCMDBG
-
-config-$(call config_package,mac80211-hwsim) += MAC80211_HWSIM
-
-config-$(call config_package,rt2x00-lib) += RT2X00 RT2X00_LIB
-config-$(call config_package,rt2x00-pci) += RT2X00_LIB_PCI
-config-$(call config_package,rt2x00-mmio) += RT2X00_LIB_MMIO
-config-$(call config_package,rt2x00-usb) += RT2X00_LIB_USB
-config-$(call config_package,rt2x00-soc) += RT2X00_LIB_SOC
-config-$(CONFIG_PACKAGE_RT2X00_LIB_DEBUGFS) += RT2X00_LIB_DEBUGFS
-config-$(CONFIG_PACKAGE_RT2X00_DEBUG) += RT2X00_DEBUG
-
-config-$(call config_package,rt2400-pci) += RT2400PCI
-config-$(call config_package,rt2500-pci) += RT2500PCI
-config-$(call config_package,rt2500-usb) += RT2500USB
-config-$(call config_package,rt61-pci) += RT61PCI
-config-$(call config_package,rt73-usb) += RT73USB
-
-config-$(call config_package,rt2800-lib) += RT2800_LIB
-config-y += RT2800PCI_RT33XX RT2800PCI_RT35XX RT2800PCI_RT53XX RT2800PCI_RT3290
-
-config-$(call config_package,rt2800-pci) += RT2800PCI
-config-$(call config_package,rt2800-usb) += RT2800USB
-
-config-$(call config_package,iwl-legacy) += IWLEGACY
-config-$(call config_package,iwl3945) += IWL3945
-config-$(call config_package,iwl4965) += IWL4965
-config-$(call config_package,iwlagn) += IWLWIFI
-
-config-$(call config_package,net-libipw) += LIBIPW
-config-$(call config_package,net-ipw2100) += IPW2100
-config-$(call config_package,net-ipw2200) += IPW2200
-
-config-$(call config_package,p54-common) += P54_COMMON
-config-$(call config_package,p54-pci) += P54_PCI
-config-$(call config_package,p54-usb) += P54_USB
-config-$(call config_package,p54-spi) += P54_SPI
-
-config-$(call config_package,net-hermes) += HERMES
-config-$(call config_package,net-hermes-pci) += PCI_HERMES
-config-$(call config_package,net-hermes-plx) += PLX_HERMES
-config-$(call config_package,net-hermes-pcmcia) += PCMCIA_HERMES
-config-y += HERMES_PRISM
-
-config-$(call config_package,adm8211) += ADM8211
-config-$(call config_package,libertas-sd) += LIBERTAS LIBERTAS_SDIO
-config-$(call config_package,libertas-usb) += LIBERTAS LIBERTAS_USB
-config-$(call config_package,mwl8k) += MWL8K
-config-$(call config_package,rtl8180) += RTL8180
-config-$(call config_package,rtl8187) += RTL8187
-config-$(call config_package,wl12xx) += WL_TI WLCORE WLCORE_SDIO WL12XX
-config-$(call config_package,zd1211rw) += ZD1211RW
-
-config-$(CONFIG_LEDS_TRIGGERS) += MAC80211_LEDS B43_LEDS B43LEGACY_LEDS
-
-MAKE_OPTS:= -C "$(PKG_BUILD_DIR)" \
-	CROSS_COMPILE="$(KERNEL_CROSS)" \
-	ARCH="$(LINUX_KARCH)" \
-	EXTRA_CFLAGS="-I$(PKG_BUILD_DIR)/include" \
-	KLIB_BUILD="$(LINUX_DIR)" \
-	MODPROBE=true \
-	KLIB=$(TARGET_MODULES_DIR) \
-	KERNEL_SUBLEVEL=$(lastword $(subst ., ,$(KERNEL_PATCHVER))) \
-	KBUILD_LDFLAGS_MODULE_PREREQ=
-
-define ConfigVars
-$(subst $(space),,$(foreach opt,$(config-$(1)),CPTCFG_$(opt)=$(1)
-))
-endef
-
-define mac80211_config
-$(call ConfigVars,m)$(call ConfigVars,y)
-endef
-$(eval $(call shexport,mac80211_config))
-
-define Build/Prepare
-	rm -rf $(PKG_BUILD_DIR)
-	mkdir -p $(PKG_BUILD_DIR)
-	$(PKG_UNPACK)
-	$(Build/Patch)
-	$(TAR) -C $(PKG_BUILD_DIR) -xzf $(DL_DIR)/$(IPW2100_NAME)-$(IPW2100_VERSION).tgz
-	$(TAR) -C $(PKG_BUILD_DIR) -xzf $(DL_DIR)/$(IPW2200_NAME)-$(IPW2200_VERSION).tgz
-	$(TAR) -C $(PKG_BUILD_DIR) -xjf $(DL_DIR)/$(ZD1211FW_NAME)-$(ZD1211FW_VERSION).tar.bz2
-	$(TAR) -C $(PKG_BUILD_DIR) -xjf $(DL_DIR)/$(PKG_LINUX_FIRMWARE_SOURCE)
-	rm -rf \
-		$(PKG_BUILD_DIR)/include/linux/ssb \
-		$(PKG_BUILD_DIR)/include/linux/bcma \
-		$(PKG_BUILD_DIR)/include/net/bluetooth
-
-	rm -f \
-		$(PKG_BUILD_DIR)/include/linux/cordic.h \
-		$(PKG_BUILD_DIR)/include/linux/crc8.h \
-		$(PKG_BUILD_DIR)/include/linux/eeprom_93cx6.h \
-		$(PKG_BUILD_DIR)/include/linux/wl12xx.h \
-		$(PKG_BUILD_DIR)/include/linux/spi/libertas_spi.h \
-		$(PKG_BUILD_DIR)/include/net/ieee80211.h
-
-	echo 'compat-wireless-$(PKG_VERSION)-$(PKG_RELEASE)-$(REVISION)' > $(PKG_BUILD_DIR)/compat_version
-	$(CP) ./files/regdb.txt $(PKG_BUILD_DIR)/net/wireless/db.txt
-endef
-
-ifneq ($(CONFIG_PACKAGE_kmod-cfg80211)$(CONFIG_PACKAGE_kmod-lib80211),)
- define Build/Compile/kmod
-	rm -rf $(PKG_BUILD_DIR)/modules
-	+$(MAKE) $(PKG_JOBS) $(MAKE_OPTS) modules
- endef
-endif
-
-define Build/Configure
-	cmp $(PKG_BUILD_DIR)/include/linux/ath9k_platform.h $(LINUX_DIR)/include/linux/ath9k_platform.h
-	cmp $(PKG_BUILD_DIR)/include/linux/ath5k_platform.h $(LINUX_DIR)/include/linux/ath5k_platform.h
-	cmp $(PKG_BUILD_DIR)/include/linux/rt2x00_platform.h $(LINUX_DIR)/include/linux/rt2x00_platform.h
-endef
-
-define Build/Compile
-	$(SH_FUNC) var2file "$(call shvar,mac80211_config)" $(PKG_BUILD_DIR)/.config
-	$(MAKE) $(MAKE_OPTS) allnoconfig
-	$(call Build/Compile/kmod)
-endef
-
-define Build/InstallDev
-	mkdir -p \
-		$(1)/usr/include/mac80211 \
-		$(1)/usr/include/mac80211-backport \
-		$(1)/usr/include/mac80211/ath \
-		$(1)/usr/include/net/mac80211
-	$(CP) $(PKG_BUILD_DIR)/net/mac80211/*.h $(PKG_BUILD_DIR)/include/* $(1)/usr/include/mac80211/
-	$(CP) $(PKG_BUILD_DIR)/backport-include/* $(1)/usr/include/mac80211-backport/
-	$(CP) $(PKG_BUILD_DIR)/net/mac80211/rate.h $(1)/usr/include/net/mac80211/
-	$(CP) $(PKG_BUILD_DIR)/drivers/net/wireless/ath/*.h $(1)/usr/include/mac80211/ath/
-endef
-
-define KernelPackage/libertas-usb/install
-	$(INSTALL_DIR) $(1)/lib/firmware/libertas
-	$(INSTALL_DATA) \
-		$(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/libertas/usb8388_v9.bin \
-		$(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/libertas/usb8682.bin \
-		$(1)/lib/firmware/libertas/
-endef
-
-define KernelPackage/libertas-sd/install
-	$(INSTALL_DIR) $(1)/lib/firmware/libertas
-	$(INSTALL_DATA) \
-		$(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/libertas/sd8385_helper.bin \
-		$(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/libertas/sd8385.bin \
-		$(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/libertas/sd8686_v9_helper.bin \
-		$(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/libertas/sd8686_v9.bin \
-		$(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/libertas/sd8688_helper.bin \
-		$(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/libertas/sd8688.bin \
-		$(1)/lib/firmware/libertas
-endef
-
-define KernelPackage/cfg80211/install
-	$(INSTALL_DIR) $(1)/lib/wifi
-	$(INSTALL_DATA) ./files/lib/wifi/mac80211.sh $(1)/lib/wifi
-endef
-
-define KernelPackage/p54-pci/install
-	$(INSTALL_DIR) $(1)/lib/firmware
-	$(INSTALL_DATA) $(DL_DIR)/$(P54PCIFW) $(1)/lib/firmware/isl3886pci
-endef
-
-define KernelPackage/p54-usb/install
-	$(INSTALL_DIR) $(1)/lib/firmware
-	$(INSTALL_DATA) $(DL_DIR)/$(P54USBFW) $(1)/lib/firmware/isl3887usb
-endef
-
-define KernelPackage/p54-spi/install
-	$(INSTALL_DIR) $(1)/lib/firmware
-	$(INSTALL_DATA) $(DL_DIR)/$(P54SPIFW) $(1)/lib/firmware/3826.arm
-endef
-
-define KernelPackage/rt61-pci/install
-	$(INSTALL_DIR) $(1)/lib/firmware
-	$(INSTALL_DATA) \
-		$(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/rt2561.bin \
-		$(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/rt2561s.bin \
-		$(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/rt2661.bin \
-		$(1)/lib/firmware/
-endef
-
-define KernelPackage/rt73-usb/install
-	$(INSTALL_DIR) $(1)/lib/firmware
-	$(INSTALL_DATA) $(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/rt73.bin $(1)/lib/firmware/
-endef
-
-define KernelPackage/rt2800-pci/install
-	$(INSTALL_DIR) $(1)/lib/firmware
-	$(INSTALL_DATA) \
-		$(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/rt2860.bin \
-		$(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/rt3290.bin \
-		$(1)/lib/firmware
-endef
-
-define KernelPackage/rt2800-usb/install
-	$(INSTALL_DIR) $(1)/lib/firmware
-	$(INSTALL_DATA) $(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/rt2870.bin $(1)/lib/firmware/
-endef
-
-define KernelPackage/wl12xx/install
-	$(INSTALL_DIR) $(1)/lib/firmware/ti-connectivity
-	$(INSTALL_DATA) \
-		$(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/ti-connectivity/wl127x-fw-5-mr.bin \
-		$(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/ti-connectivity/wl127x-fw-5-plt.bin \
-		$(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/ti-connectivity/wl127x-fw-5-sr.bin \
-		$(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/ti-connectivity/wl1271-nvs.bin \
-		$(1)/lib/firmware/ti-connectivity
-endef
-
-
-define KernelPackage/zd1211rw/install
-	$(INSTALL_DIR) $(1)/lib/firmware/zd1211
-	$(INSTALL_DATA) $(PKG_BUILD_DIR)/$(ZD1211FW_NAME)/zd1211* $(1)/lib/firmware/zd1211
-endef
-
-define KernelPackage/ath9k-htc/install
-	$(INSTALL_DIR) $(1)/lib/firmware
-	$(INSTALL_DATA) \
-		$(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/htc_9271.fw \
-		$(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/htc_7010.fw \
-		$(1)/lib/firmware/
-endef
-
-define KernelPackage/mwl8k/install
-	$(INSTALL_DIR) $(1)/lib/firmware/mwl8k
-	$(INSTALL_DATA) \
-		$(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/mwl8k/fmimage_8366_ap-3.fw \
-		$(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/mwl8k/fmimage_8366.fw \
-		$(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/mwl8k/helper_8366.fw \
-		$(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/mwl8k/fmimage_8687.fw \
-		$(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/mwl8k/helper_8687.fw \
-		$(1)/lib/firmware/mwl8k/
-endef
-
-define KernelPackage/net-ipw2100/install
-	$(INSTALL_DIR) $(1)/lib/firmware
-	$(INSTALL_DATA) $(PKG_BUILD_DIR)/ipw2100-$(IPW2100_VERSION)*.fw $(1)/lib/firmware
-endef
-
-define KernelPackage/net-ipw2200/install
-	$(INSTALL_DIR) $(1)/lib/firmware
-	$(INSTALL_DATA) $(PKG_BUILD_DIR)/$(IPW2200_NAME)-$(IPW2200_VERSION)/ipw2200*.fw $(1)/lib/firmware
-endef
-
-define KernelPackage/iwlagn/install
-	$(INSTALL_DIR) $(1)/lib/firmware
-ifneq ($(CONFIG_IWL5000_FW),)
-	$(INSTALL_DATA) $(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/iwlwifi-5000-5.ucode $(1)/lib/firmware
-endif
-ifneq ($(CONFIG_IWL5150_FW),)
-	$(INSTALL_DATA) $(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/iwlwifi-5150-2.ucode $(1)/lib/firmware
-endif
-ifneq ($(CONFIG_IWL1000_FW),)
-	$(INSTALL_DATA) $(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/iwlwifi-1000-5.ucode $(1)/lib/firmware
-endif
-ifneq ($(CONFIG_IWL6000_FW),)
-	$(INSTALL_DATA) $(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/iwlwifi-6000-4.ucode $(1)/lib/firmware
-endif
-ifneq ($(CONFIG_IWL6050_FW),)
-	$(INSTALL_DATA) $(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/iwlwifi-6050-5.ucode $(1)/lib/firmware
-endif
-ifneq ($(CONFIG_IWL6005_FW),)
-	$(INSTALL_DATA) $(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/iwlwifi-6000g2a-6.ucode $(1)/lib/firmware
-endif
-ifneq ($(CONFIG_IWL6030_FW),)
-	$(INSTALL_DATA) $(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/iwlwifi-6000g2b-6.ucode $(1)/lib/firmware
-endif
-ifneq ($(CONFIG_IWL100_FW),)
-	$(INSTALL_DATA) $(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/iwlwifi-100-5.ucode $(1)/lib/firmware
-endif
-ifneq ($(CONFIG_IWL2000_FW),)
-	$(INSTALL_DATA) $(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/iwlwifi-2000-6.ucode $(1)/lib/firmware
-endif
-ifneq ($(CONFIG_IWL2030_FW),)
-	$(INSTALL_DATA) $(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/iwlwifi-2030-6.ucode $(1)/lib/firmware
-endif
-ifneq ($(CONFIG_IWL105_FW),)
-	$(INSTALL_DATA) $(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/iwlwifi-105-6.ucode $(1)/lib/firmware
-endif
-ifneq ($(CONFIG_IWL135_FW),)
-	$(INSTALL_DATA) $(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/iwlwifi-135-6.ucode $(1)/lib/firmware
-endif
-endef
-
-define KernelPackage/iwl3945/install
-	$(INSTALL_DIR) $(1)/lib/firmware
-	$(INSTALL_DATA) $(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/iwlwifi-3945-2.ucode $(1)/lib/firmware
-endef
-
-define KernelPackage/iwl4965/install
-	$(INSTALL_DIR) $(1)/lib/firmware
-	$(INSTALL_DATA) $(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/iwlwifi-4965-2.ucode $(1)/lib/firmware
-endef
-
-define KernelPackage/b43/install
-	rm -rf $(1)/lib/firmware/
-ifeq ($(CONFIG_B43_OPENFIRMWARE),y)
-	tar xzf "$(DL_DIR)/$(PKG_B43_FWV4_SOURCE)" -C "$(PKG_BUILD_DIR)"
-else
-	tar xjf "$(DL_DIR)/$(PKG_B43_FWV4_SOURCE)" -C "$(PKG_BUILD_DIR)"
-endif
-	$(INSTALL_DIR) $(1)/lib/firmware/
-ifeq ($(CONFIG_B43_OPENFIRMWARE),y)
-	$(MAKE) -C "$(PKG_BUILD_DIR)/$(PKG_B43_FWV4_OBJECT)/"
-	$(INSTALL_DIR) $(1)/lib/firmware/b43-open/
-	$(INSTALL_DATA) $(PKG_BUILD_DIR)/$(PKG_B43_FWV4_OBJECT)/ucode5.fw $(1)/lib/firmware/b43-open/ucode5.fw
-	$(INSTALL_DATA) $(PKG_BUILD_DIR)/$(PKG_B43_FWV4_OBJECT)/b0g0bsinitvals5.fw $(1)/lib/firmware/b43-open/b0g0bsinitvals5.fw
-	$(INSTALL_DATA) $(PKG_BUILD_DIR)/$(PKG_B43_FWV4_OBJECT)/b0g0initvals5.fw $(1)/lib/firmware/b43-open/b0g0initvals5.fw
-else
-	b43-fwcutter -w $(1)/lib/firmware/ $(PKG_BUILD_DIR)/$(PKG_B43_FWV4_OBJECT)
-endif
-ifneq ($(CONFIG_B43_FW_SQUASH),)
-	b43-fwsquash.py "$(CONFIG_B43_FW_SQUASH_PHYTYPES)" "$(CONFIG_B43_FW_SQUASH_COREREVS)" "$(1)/lib/firmware/b43"
-endif
-endef
-
-define KernelPackage/b43legacy/install
-	$(INSTALL_DIR) $(1)/lib/firmware/
-	b43-fwcutter --unsupported -w $(1)/lib/firmware/ $(DL_DIR)/$(PKG_B43_FWV3_SOURCE)
-ifneq ($(CONFIG_B43LEGACY_FW_SQUASH),)
-	b43-fwsquash.py "G" "$(CONFIG_B43LEGACY_FW_SQUASH_COREREVS)" "$(1)/lib/firmware/b43legacy"
-endif
-endef
-
-define KernelPackage/brcmsmac/install
-	$(INSTALL_DIR) $(1)/lib/firmware/brcm
-ifeq ($(CONFIG_BRCMSMAC_USE_FW_FROM_WL),y)
-	tar xjf "$(DL_DIR)/$(PKG_BRCMSMAC_FW_SOURCE)" -C "$(PKG_BUILD_DIR)"
-	b43-fwcutter --brcmsmac -w $(1)/lib/firmware/ $(PKG_BUILD_DIR)/$(PKG_BRCMSMAC_FW_OBJECT)
-else
-	$(INSTALL_DATA) \
-		$(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/brcm/bcm43xx-0.fw \
-		$(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/brcm/bcm43xx_hdr-0.fw \
-		$(1)/lib/firmware/brcm/
-endif
-endef
-
-define KernelPackage/brcmfmac/install
-	$(INSTALL_DIR) $(1)/lib/firmware/brcm
-	$(INSTALL_DATA) \
-		$(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/brcm/brcmfmac43236b.bin \
-		$(1)/lib/firmware/brcm/
-endef
-
-$(eval $(call KernelPackage,adm8211))
-$(eval $(call KernelPackage,ath5k))
-$(eval $(call KernelPackage,lib80211))
-$(eval $(call KernelPackage,libertas-usb))
-$(eval $(call KernelPackage,libertas-sd))
-$(eval $(call KernelPackage,cfg80211))
-$(eval $(call KernelPackage,mac80211))
-$(eval $(call KernelPackage,p54-common))
-$(eval $(call KernelPackage,p54-pci))
-$(eval $(call KernelPackage,p54-usb))
-$(eval $(call KernelPackage,p54-spi))
-$(eval $(call KernelPackage,rt2x00-lib))
-$(eval $(call KernelPackage,rt2x00-mmio))
-$(eval $(call KernelPackage,rt2x00-pci))
-$(eval $(call KernelPackage,rt2x00-usb))
-$(eval $(call KernelPackage,rt2x00-soc))
-$(eval $(call KernelPackage,rt2800-lib))
-$(eval $(call KernelPackage,rt2400-pci))
-$(eval $(call KernelPackage,rt2500-pci))
-$(eval $(call KernelPackage,rt2500-usb))
-$(eval $(call KernelPackage,rt61-pci))
-$(eval $(call KernelPackage,rt73-usb))
-$(eval $(call KernelPackage,rt2800-pci))
-$(eval $(call KernelPackage,rt2800-usb))
-$(eval $(call KernelPackage,rtl8180))
-$(eval $(call KernelPackage,rtl8187))
-$(eval $(call KernelPackage,zd1211rw))
-$(eval $(call KernelPackage,mac80211-hwsim))
-$(eval $(call KernelPackage,ath9k-common))
-$(eval $(call KernelPackage,ath9k))
-$(eval $(call KernelPackage,ath9k-htc))
-$(eval $(call KernelPackage,ath))
-$(eval $(call KernelPackage,carl9170))
-$(eval $(call KernelPackage,b43))
-$(eval $(call KernelPackage,b43legacy))
-$(eval $(call KernelPackage,brcmutil))
-$(eval $(call KernelPackage,brcmsmac))
-$(eval $(call KernelPackage,brcmfmac))
-$(eval $(call KernelPackage,net-libipw))
-$(eval $(call KernelPackage,net-ipw2100))
-$(eval $(call KernelPackage,net-ipw2200))
-$(eval $(call KernelPackage,iwlagn))
-$(eval $(call KernelPackage,iwl-legacy))
-$(eval $(call KernelPackage,iwl4965))
-$(eval $(call KernelPackage,iwl3945))
-$(eval $(call KernelPackage,mwl8k))
-$(eval $(call KernelPackage,net-hermes))
-$(eval $(call KernelPackage,net-hermes-pci))
-$(eval $(call KernelPackage,net-hermes-plx))
-$(eval $(call KernelPackage,net-hermes-pcmcia))
-$(eval $(call KernelPackage,wl12xx))
diff --git a/package/mac80211/files/lib/wifi/mac80211.sh b/package/mac80211/files/lib/wifi/mac80211.sh
deleted file mode 100644
index 20f6bfa..0000000
--- a/package/mac80211/files/lib/wifi/mac80211.sh
+++ /dev/null
@@ -1,641 +0,0 @@
-#!/bin/sh
-append DRIVERS "mac80211"
-
-mac80211_hostapd_setup_base() {
-	local phy="$1"
-	local ifname="$2"
-
-	cfgfile="/var/run/hostapd-$phy.conf"
-
-	config_get device "$vif" device
-	config_get country "$device" country
-	config_get hwmode "$device" hwmode
-	config_get channel "$device" channel
-	config_get beacon_int "$device" beacon_int
-	config_get basic_rate_list "$device" basic_rate
-	config_get_bool noscan "$device" noscan
-
-	hostapd_set_log_options base_cfg "$device"
-
-	[ -n "$channel" -a -z "$hwmode" ] && wifi_fixup_hwmode "$device"
-
-	[ "$channel" = auto ] && {
-		channel=$(iw phy "$phy" info | \
-			sed -ne '/MHz/ { /disabled\|passive\|radar/d; s/.*\[//; s/\].*//; p; q }')
-		config_set "$device" channel "$channel"
-	}
-
-	[ -n "$hwmode" ] && {
-		config_get hwmode_11n "$device" hwmode_11n
-		[ -n "$hwmode_11n" ] && {
-			hwmode="$hwmode_11n"
-			append base_cfg "ieee80211n=1" "$N"
-			config_get htmode "$device" htmode
-			config_get ht_capab_list "$device" ht_capab
-			case "$htmode" in
-				HT20|HT40+|HT40-) ht_capab="[$htmode]";;
-				*)ht_capab=;;
-			esac
-			for cap in $ht_capab_list; do
-				ht_capab="$ht_capab[$cap]"
-			done
-			[ -n "$ht_capab" ] && append base_cfg "ht_capab=$ht_capab" "$N"
-		}
-	}
-
-	local country_ie=0
-	[ -n "$country" ] && country_ie=1
-	config_get_bool country_ie "$device" country_ie "$country_ie"
-	[ "$country_ie" -gt 0 ] && append base_cfg "ieee80211d=1" "$N"
-
-	local br brval brstr
-	[ -n "$basic_rate_list" ] && {
-		for br in $basic_rate_list; do
-			brval="$(($br / 100))"
-			[ -n "$brstr" ] && brstr="$brstr "
-			brstr="$brstr$brval"
-		done
-	}
-
-	cat >> "$cfgfile" <<EOF
-ctrl_interface=/var/run/hostapd-$phy
-driver=nl80211
-wmm_ac_bk_cwmin=4
-wmm_ac_bk_cwmax=10
-wmm_ac_bk_aifs=7
-wmm_ac_bk_txop_limit=0
-wmm_ac_bk_acm=0
-wmm_ac_be_aifs=3
-wmm_ac_be_cwmin=4
-wmm_ac_be_cwmax=10
-wmm_ac_be_txop_limit=0
-wmm_ac_be_acm=0
-wmm_ac_vi_aifs=2
-wmm_ac_vi_cwmin=3
-wmm_ac_vi_cwmax=4
-wmm_ac_vi_txop_limit=94
-wmm_ac_vi_acm=0
-wmm_ac_vo_aifs=2
-wmm_ac_vo_cwmin=2
-wmm_ac_vo_cwmax=3
-wmm_ac_vo_txop_limit=47
-wmm_ac_vo_acm=0
-tx_queue_data3_aifs=7
-tx_queue_data3_cwmin=15
-tx_queue_data3_cwmax=1023
-tx_queue_data3_burst=0
-tx_queue_data2_aifs=3
-tx_queue_data2_cwmin=15
-tx_queue_data2_cwmax=63
-tx_queue_data2_burst=0
-tx_queue_data1_aifs=1
-tx_queue_data1_cwmin=7
-tx_queue_data1_cwmax=15
-tx_queue_data1_burst=3.0
-tx_queue_data0_aifs=1
-tx_queue_data0_cwmin=3
-tx_queue_data0_cwmax=7
-tx_queue_data0_burst=1.5
-${hwmode:+hw_mode=$hwmode}
-${channel:+channel=$channel}
-${beacon_int:+beacon_int=$beacon_int}
-${country:+country_code=$country}
-${noscan:+noscan=$noscan}
-${brstr:+basic_rates=$brstr}
-$base_cfg
-
-EOF
-}
-
-mac80211_hostapd_setup_bss() {
-	local phy="$1"
-	local vif="$2"
-
-	hostapd_cfg=
-	cfgfile="/var/run/hostapd-$phy.conf"
-	config_get ifname "$vif" ifname
-
-	if [ -f "$cfgfile" ]; then
-		append hostapd_cfg "bss=$ifname" "$N"
-	else
-		mac80211_hostapd_setup_base "$phy" "$ifname"
-		append hostapd_cfg "interface=$ifname" "$N"
-	fi
-
-	local net_cfg bridge
-	net_cfg="$(find_net_config "$vif")"
-	[ -z "$net_cfg" ] || bridge="$(bridge_interface "$net_cfg")"
-	config_set "$vif" bridge "$bridge"
-
-	hostapd_set_bss_options hostapd_cfg "$vif"
-
-	config_get_bool wds "$vif" wds 0
-	[ "$wds" -gt 0 ] && append hostapd_cfg "wds_sta=1" "$N"
-
-	local macaddr hidden maxassoc wmm
-	config_get macaddr "$vif" macaddr
-	config_get maxassoc "$vif" maxassoc
-	config_get dtim_period "$vif" dtim_period
-	config_get max_listen_int "$vif" max_listen_int
-	config_get_bool hidden "$vif" hidden 0
-	config_get_bool wmm "$vif" wmm 1
-	cat >> /var/run/hostapd-$phy.conf <<EOF
-$hostapd_cfg
-wmm_enabled=$wmm
-bssid=$macaddr
-ignore_broadcast_ssid=$hidden
-${dtim_period:+dtim_period=$dtim_period}
-${max_listen_int:+max_listen_interval=$max_listen_int}
-${maxassoc:+max_num_sta=$maxassoc}
-EOF
-}
-
-mac80211_start_vif() {
-	local vif="$1"
-	local ifname="$2"
-
-	local net_cfg
-	net_cfg="$(find_net_config "$vif")"
-	[ -z "$net_cfg" ] || start_net "$ifname" "$net_cfg"
-
-	set_wifi_up "$vif" "$ifname"
-}
-
-lookup_phy() {
-	[ -n "$phy" ] && {
-		[ -d /sys/class/ieee80211/$phy ] && return
-	}
-
-	local devpath
-	config_get devpath "$device" path
-	[ -n "$devpath" -a -d "/sys/devices/$devpath/ieee80211" ] && {
-		phy="$(ls /sys/devices/$devpath/ieee80211 | grep -m 1 phy)"
-		[ -n "$phy" ] && return
-	}
-
-	local macaddr="$(config_get "$device" macaddr | tr 'A-Z' 'a-z')"
-	[ -n "$macaddr" ] && {
-		for _phy in $(ls /sys/class/ieee80211 2>/dev/null); do
-			[ "$macaddr" = "$(cat /sys/class/ieee80211/${_phy}/macaddress)" ] || continue
-			phy="$_phy"
-			return
-		done
-	}
-	phy=
-	return
-}
-
-find_mac80211_phy() {
-	local device="$1"
-
-	config_get phy "$device" phy
-	lookup_phy
-	[ -n "$phy" -a -d "/sys/class/ieee80211/$phy" ] || {
-		echo "PHY for wifi device $1 not found"
-		return 1
-	}
-	config_set "$device" phy "$phy"
-
-	config_get macaddr "$device" macaddr
-	[ -z "$macaddr" ] && {
-		config_set "$device" macaddr "$(cat /sys/class/ieee80211/${phy}/macaddress)"
-	}
-
-	return 0
-}
-
-scan_mac80211() {
-	local device="$1"
-	local adhoc sta ap monitor mesh disabled
-
-	config_get vifs "$device" vifs
-	for vif in $vifs; do
-		config_get_bool disabled "$vif" disabled 0
-		[ $disabled = 0 ] || continue
-
-		config_get mode "$vif" mode
-		case "$mode" in
-			adhoc|sta|ap|monitor|mesh)
-				append $mode "$vif"
-			;;
-			*) echo "$device($vif): Invalid mode, ignored."; continue;;
-		esac
-	done
-
-	config_set "$device" vifs "${ap:+$ap }${adhoc:+$adhoc }${sta:+$sta }${monitor:+$monitor }${mesh:+$mesh}"
-}
-
-list_phy_interfaces() {
-	local phy="$1"
-	if [ -d "/sys/class/ieee80211/${phy}/device/net" ]; then
-		ls "/sys/class/ieee80211/${phy}/device/net" 2>/dev/null;
-	else
-		ls "/sys/class/ieee80211/${phy}/device" 2>/dev/null | grep net: | sed -e 's,net:,,g'
-	fi
-}
-
-disable_mac80211() (
-	local device="$1"
-
-	find_mac80211_phy "$device" || return 0
-	config_get phy "$device" phy
-
-	set_wifi_down "$device"
-	# kill all running hostapd and wpa_supplicant processes that
-	# are running on atheros/mac80211 vifs
-	for pid in `pidof hostapd`; do
-		grep -E "$phy" /proc/$pid/cmdline >/dev/null && \
-			kill $pid
-	done
-
-	include /lib/network
-	for wdev in $(list_phy_interfaces "$phy"); do
-		[ -f "/var/run/$wdev.pid" ] && kill $(cat /var/run/$wdev.pid) >&/dev/null 2>&1
-		for pid in `pidof wpa_supplicant`; do
-			grep "$wdev" /proc/$pid/cmdline >/dev/null && \
-				kill $pid
-		done
-		ifconfig "$wdev" down 2>/dev/null
-		unbridge "$dev"
-		iw dev "$wdev" del
-	done
-
-	return 0
-)
-
-get_freq() {
-	local phy="$1"
-	local chan="$2"
-	iw "$phy" info | grep -E -m1 "(\* ${chan:-....} MHz${chan:+|\\[$chan\\]})" | grep MHz | awk '{print $2}'
-}
-
-mac80211_generate_mac() {
-	local id="$1"
-	local ref="$2"
-	local mask="$3"
-
-	[ "$mask" = "00:00:00:00:00:00" ] && mask="ff:ff:ff:ff:ff:ff";
-	local oIFS="$IFS"; IFS=":"; set -- $mask; IFS="$oIFS"
-
-	local mask1=$1
-	local mask6=$6
-
-	local oIFS="$IFS"; IFS=":"; set -- $ref; IFS="$oIFS"
-	[ "$((0x$mask1))" -gt 0 ] && {
-		b1="0x$1"
-		[ "$id" -gt 0 ] && \
-			b1=$(($b1 ^ ((($id - 1) << 2) | 0x2)))
-		printf "%02x:%s:%s:%s:%s:%s" $b1 $2 $3 $4 $5 $6
-		return
-	}
-
-	[ "$((0x$mask6))" -lt 255 ] && {
-		printf "%s:%s:%s:%s:%s:%02x" $1 $2 $3 $4 $5 $(( 0x$6 ^ $id ))
-		return
-	}
-
-	off2=$(( (0x$6 + $id) / 0x100 ))
-	printf "%s:%s:%s:%s:%02x:%02x" \
-		$1 $2 $3 $4 \
-		$(( (0x$5 + $off2) % 0x100 )) \
-		$(( (0x$6 + $id) % 0x100 ))
-}
-
-enable_mac80211() {
-	local device="$1"
-	config_get channel "$device" channel
-	config_get vifs "$device" vifs
-	config_get txpower "$device" txpower
-	config_get country "$device" country
-	config_get distance "$device" distance
-	config_get txantenna "$device" txantenna all
-	config_get rxantenna "$device" rxantenna all
-	config_get antenna_gain "$device" antenna_gain 0
-	config_get frag "$device" frag
-	config_get rts "$device" rts
-	find_mac80211_phy "$device" || return 0
-	config_get phy "$device" phy
-	local i=0
-	local macidx=0
-	local apidx=0
-	fixed=""
-	local hostapd_ctrl=""
-
-	[ -n "$country" ] && {
-		iw reg get | grep -q "^country $country:" || {
-			iw reg set "$country"
-			sleep 1
-		}
-	}
-
-	config_get chanbw "$device" chanbw
-	[ -n "$chanbw" -a -d /sys/kernel/debug/ieee80211/$phy/ath9k ] && echo "$chanbw" > /sys/kernel/debug/ieee80211/$phy/ath9k/chanbw
-	[ -n "$chanbw" -a -d /sys/kernel/debug/ieee80211/$phy/ath5k ] && echo "$chanbw" > /sys/kernel/debug/ieee80211/$phy/ath5k/bwmode
-
-	[ "$channel" = "auto" -o "$channel" = "0" ] || {
-		fixed=1
-	}
-
-	iw phy "$phy" set antenna $txantenna $rxantenna >/dev/null 2>&1
-	iw phy "$phy" set antenna_gain $antenna_gain
-
-	[ -n "$distance" ] && iw phy "$phy" set distance "$distance"
-	[ -n "$frag" ] && iw phy "$phy" set frag "${frag%%.*}"
-	[ -n "$rts" ] && iw phy "$phy" set rts "${rts%%.*}"
-
-	export channel fixed
-	# convert channel to frequency
-	local freq="$(get_freq "$phy" "${fixed:+$channel}")"
-
-	wifi_fixup_hwmode "$device" "g"
-	for vif in $vifs; do
-		config_get ifname "$vif" ifname
-		[ -n "$ifname" ] || {
-			[ $i -gt 0 ] && ifname="wlan${phy#phy}-$i" || ifname="wlan${phy#phy}"
-		}
-		config_set "$vif" ifname "$ifname"
-
-		config_get mode "$vif" mode
-		config_get ssid "$vif" ssid
-
-		# It is far easier to delete and create the desired interface
-		case "$mode" in
-			adhoc)
-				iw phy "$phy" interface add "$ifname" type adhoc
-			;;
-			ap)
-				# Hostapd will handle recreating the interface and
-				# it's accompanying monitor
-				apidx="$(($apidx + 1))"
-				[ "$apidx" -gt 1 ] || iw phy "$phy" interface add "$ifname" type managed
-			;;
-			mesh)
-				config_get mesh_id "$vif" mesh_id
-				iw phy "$phy" interface add "$ifname" type mp mesh_id "$mesh_id"
-			;;
-			monitor)
-				iw phy "$phy" interface add "$ifname" type monitor
-			;;
-			sta)
-				local wdsflag
-				config_get_bool wds "$vif" wds 0
-				[ "$wds" -gt 0 ] && wdsflag="4addr on"
-				iw phy "$phy" interface add "$ifname" type managed $wdsflag
-				config_get_bool powersave "$vif" powersave 0
-				[ "$powersave" -gt 0 ] && powersave="on" || powersave="off"
-				iw "$ifname" set power_save "$powersave"
-			;;
-		esac
-
-		# All interfaces must have unique mac addresses
-		# which can either be explicitly set in the device
-		# section, or automatically generated
-		config_get macaddr "$device" macaddr
-		config_get vif_mac "$vif" macaddr
-		[ -n "$vif_mac" ] || {
-			vif_mac="$(mac80211_generate_mac $macidx $macaddr $(cat /sys/class/ieee80211/${phy}/address_mask))"
-			macidx="$(($macidx + 1))"
-		}
-		[ "$mode" = "ap" ] || ifconfig "$ifname" hw ether "$vif_mac"
-		config_set "$vif" macaddr "$vif_mac"
-
-		# !! ap !!
-		#
-		# ALL ap functionality will be passed to hostapd
-		#
-		# !! station !!
-		#
-		# ALL station functionality will be passed to wpa_supplicant
-		#
-		if [ ! "$mode" = "ap" ]; then
-			# We attempt to set the channel for all interfaces, although
-			# mac80211 may not support it or the driver might not yet
-			# for ap mode this is handled by hostapd
-			config_get htmode "$device" htmode
-			case "$htmode" in
-				HT20|HT40+|HT40-) ;;
-				*) htmode= ;;
-			esac
-			[ -n "$fixed" -a -n "$channel" ] && iw dev "$ifname" set channel "$channel" $htmode
-		fi
-
-		i=$(($i + 1))
-	done
-
-	local start_hostapd=
-	rm -f /var/run/hostapd-$phy.conf
-	for vif in $vifs; do
-		config_get mode "$vif" mode
-		[ "$mode" = "ap" ] || continue
-		mac80211_hostapd_setup_bss "$phy" "$vif"
-		start_hostapd=1
-	done
-
-	[ -n "$start_hostapd" ] && {
-		hostapd -P /var/run/wifi-$phy.pid -B /var/run/hostapd-$phy.conf || {
-			echo "Failed to start hostapd for $phy"
-			return
-		}
-		sleep 2
-
-		for vif in $vifs; do
-			config_get mode "$vif" mode
-			config_get ifname "$vif" ifname
-			[ "$mode" = "ap" ] || continue
-			hostapd_ctrl="${hostapd_ctrl:-/var/run/hostapd-$phy/$ifname}"
-			mac80211_start_vif "$vif" "$ifname"
-		done
-	}
-
-	for vif in $vifs; do
-		config_get mode "$vif" mode
-		config_get ifname "$vif" ifname
-		[ "$mode" = "ap" ] || ifconfig "$ifname" up
-
-		config_get vif_txpower "$vif" txpower
-		# use vif_txpower (from wifi-iface) to override txpower (from
-		# wifi-device) if the latter doesn't exist
-		txpower="${txpower:-$vif_txpower}"
-		[ -z "$txpower" ] || iw dev "$ifname" set txpower fixed "${txpower%%.*}00"
-
-		case "$mode" in
-			adhoc)
-				config_get bssid "$vif" bssid
-				config_get ssid "$vif" ssid
-				config_get beacon_int "$device" beacon_int
-				config_get basic_rate_list "$device" basic_rate
-				config_get encryption "$vif" encryption
-				config_get key "$vif" key 1
-				config_get mcast_rate "$vif" mcast_rate
-				config_get htmode "$device" htmode
-				case "$htmode" in
-					HT20|HT40+|HT40-) ;;
-					*) htmode= ;;
-				esac
-
-
-				local keyspec=""
-				[ "$encryption" == "psk" -o "$encryption" == "psk2" ] && {
-					if eval "type wpa_supplicant_setup_vif" 2>/dev/null >/dev/null; then
-						wpa_supplicant_setup_vif "$vif" nl80211 "${hostapd_ctrl:+-H $hostapd_ctrl}" $freq $htmode || {
-							echo "enable_mac80211($device): Failed to set up wpa_supplicant for interface $ifname" >&2
-							# make sure this wifi interface won't accidentally stay open without encryption
-							ifconfig "$ifname" down
-						}
-						mac80211_start_vif "$vif" "$ifname"
-						continue
-					fi
-				}
-
-				[ "$encryption" == "wep" ] && {
-					case "$key" in
-						[1234])
-							local idx
-							for idx in 1 2 3 4; do
-								local ikey
-								config_get ikey "$vif" "key$idx"
-
-								[ -n "$ikey" ] && {
-									ikey="$(($idx - 1)):$(prepare_key_wep "$ikey")"
-									[ $idx -eq $key ] && ikey="d:$ikey"
-									append keyspec "$ikey"
-								}
-							done
-						;;
-						*) append keyspec "d:0:$(prepare_key_wep "$key")" ;;
-					esac
-				}
-
-				local br brval brsub brstr
-				[ -n "$basic_rate_list" ] && {
-					for br in $basic_rate_list; do
-						brval="$(($br / 1000))"
-						brsub="$((($br / 100) % 10))"
-						[ "$brsub" -gt 0 ] && brval="$brval.$brsub"
-						[ -n "$brstr" ] && brstr="$brstr,"
-						brstr="$brstr$brval"
-					done
-				}
-
-				local mcval=""
-				[ -n "$mcast_rate" ] && {
-					mcval="$(($mcast_rate / 1000))"
-					mcsub="$(( ($mcast_rate / 100) % 10 ))"
-					[ "$mcsub" -gt 0 ] && mcval="$mcval.$mcsub"
-				}
-
-				iw dev "$ifname" ibss join "$ssid" $freq $htmode \
-					${fixed:+fixed-freq} $bssid \
-					${beacon_int:+beacon-interval $beacon_int} \
-					${brstr:+basic-rates $brstr} \
-					${mcval:+mcast-rate $mcval} \
-					${keyspec:+keys $keyspec}
-			;;
-			mesh)
-				mp_list="mesh_retry_timeout mesh_confirm_timeout mesh_holding_timeout mesh_max_peer_links
-					mesh_max_retries mesh_ttl mesh_element_ttl mesh_auto_open_plinks mesh_hwmp_max_preq_retries
-					mesh_path_refresh_time mesh_min_discovery_timeout mesh_hwmp_active_path_timeout
-					mesh_hwmp_preq_min_interval mesh_hwmp_net_diameter_traversal_time mesh_hwmp_rootmode
-					mesh_hwmp_rann_interval mesh_gate_announcements mesh_fwding mesh_sync_offset_max_neighor
-					mesh_rssi_threshold mesh_hwmp_active_path_to_root_timeout mesh_hwmp_root_interval
-					mesh_hwmp_confirmation_interval mesh_power_mode mesh_awake_window"
-				for mp in $mp_list
-				do
-					config_get mp_val "$vif" "$mp" ""
-					[ -n "$mp_val" ] && iw dev "$ifname" set mesh_param "$mp" "$mp_val"
-				done
-			;;
-			sta)
-				if eval "type wpa_supplicant_setup_vif" 2>/dev/null >/dev/null; then
-					wpa_supplicant_setup_vif "$vif" nl80211 "${hostapd_ctrl:+-H $hostapd_ctrl}" || {
-						echo "enable_mac80211($device): Failed to set up wpa_supplicant for interface $ifname" >&2
-						# make sure this wifi interface won't accidentally stay open without encryption
-						ifconfig "$ifname" down
-						continue
-					}
-				fi
-			;;
-		esac
-		[ "$mode" = "ap" ] || mac80211_start_vif "$vif" "$ifname"
-	done
-
-}
-
-
-check_mac80211_device() {
-	config_get phy "$1" phy
-	[ -z "$phy" ] && {
-		find_mac80211_phy "$1" >/dev/null || return 0
-		config_get phy "$1" phy
-	}
-	[ "$phy" = "$dev" ] && found=1
-}
-
-detect_mac80211() {
-	devidx=0
-	config_load wireless
-	while :; do
-		config_get type "radio$devidx" type
-		[ -n "$type" ] || break
-		devidx=$(($devidx + 1))
-	done
-	for dev in $(ls /sys/class/ieee80211); do
-		found=0
-		config_foreach check_mac80211_device wifi-device
-		[ "$found" -gt 0 ] && continue
-
-		mode_11n=""
-		mode_band="g"
-		channel="11"
-		ht_cap=0
-		for cap in $(iw phy "$dev" info | grep 'Capabilities:' | cut -d: -f2); do
-			ht_cap="$(($ht_cap | $cap))"
-		done
-		ht_capab="";
-		[ "$ht_cap" -gt 0 ] && {
-			mode_11n="n"
-			append ht_capab "	option htmode	HT20" "$N"
-
-			list="	list ht_capab"
-			[ "$(($ht_cap & 1))" -eq 1 ] && append ht_capab "$list	LDPC" "$N"
-			[ "$(($ht_cap & 16))" -eq 16 ] && append ht_capab "$list	GF" "$N"
-			[ "$(($ht_cap & 32))" -eq 32 ] && append ht_capab "$list	SHORT-GI-20" "$N"
-			[ "$(($ht_cap & 64))" -eq 64 ] && append ht_capab "$list	SHORT-GI-40" "$N"
-			[ "$(($ht_cap & 128))" -eq 128 ] && append ht_capab "$list	TX-STBC" "$N"
-			[ "$(($ht_cap & 768))" -eq 256 ] && append ht_capab "$list	RX-STBC1" "$N"
-			[ "$(($ht_cap & 768))" -eq 512 ] && append ht_capab "$list	RX-STBC12" "$N"
-			[ "$(($ht_cap & 768))" -eq 768 ] && append ht_capab "$list	RX-STBC123" "$N"
-			[ "$(($ht_cap & 4096))" -eq 4096 ] && append ht_capab "$list	DSSS_CCK-40" "$N"
-		}
-		iw phy "$dev" info | grep -q '2412 MHz' || { mode_band="a"; channel="36"; }
-
-		if [ -x /usr/bin/readlink ]; then
-			path="$(readlink -f /sys/class/ieee80211/${dev}/device)"
-			path="${path##/sys/devices/}"
-			dev_id="	option path	'$path'"
-		else
-			dev_id="	option macaddr	$(cat /sys/class/ieee80211/${dev}/macaddress)"
-		fi
-
-		cat <<EOF
-config wifi-device  radio$devidx
-	option type     mac80211
-	option channel  ${channel}
-	option hwmode	11${mode_11n}${mode_band}
-$dev_id
-$ht_capab
-	# REMOVE THIS LINE TO ENABLE WIFI:
-	option disabled 1
-
-config wifi-iface
-	option device   radio$devidx
-	option network  lan
-	option mode     ap
-	option ssid     OpenWrt
-	option encryption none
-
-EOF
-	devidx=$(($devidx + 1))
-	done
-}
-
diff --git a/package/mac80211/files/regdb.txt b/package/mac80211/files/regdb.txt
deleted file mode 100644
index b250e69..0000000
--- a/package/mac80211/files/regdb.txt
+++ /dev/null
@@ -1,697 +0,0 @@
-# This is the world regulatory domain
-country 00:
-	(2402 - 2472 @ 40), (3, 20)
-        # Channel 12 - 13. No HT40 channel fits here
-        (2457 - 2482 @ 20), (3, 20), PASSIVE-SCAN, NO-IBSS
-        # Channel 14. Only JP enables this and for 802.11b only
-        (2474 - 2494 @ 20), (3, 20), PASSIVE-SCAN, NO-IBSS, NO-OFDM
-        # Channel 36 - 48
-        (5170 - 5250 @ 40), (3, 20)
-        # NB: 5260 MHz - 5700 MHz requies DFS
-        # Channel 149 - 165
-        (5735 - 5835 @ 40), (3, 20), PASSIVE-SCAN, NO-IBSS
-
-
-country AE:
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 40), (N/A, 20)
-	(5250 - 5330 @ 40), (N/A, 20), DFS
-	(5490 - 5710 @ 40), (N/A, 27), DFS
-
-country AL:
-	(2402 - 2482 @ 20), (N/A, 20)
-
-country AM:
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 20), (N/A, 18)
-	(5250 - 5330 @ 20), (N/A, 18), DFS
-
-country AN:
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 40), (N/A, 20)
-	(5250 - 5330 @ 40), (N/A, 20), DFS
-	(5490 - 5710 @ 40), (N/A, 27), DFS
-
-country AR:
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 40), (3, 17)
-	(5250 - 5330 @ 40), (3, 20), DFS
-	(5490 - 5710 @ 40), (3, 20), DFS
-	(5735 - 5835 @ 40), (3, 30)
-
-country AT: DFS-ETSI
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 40), (N/A, 20)
-	(5250 - 5330 @ 40), (N/A, 20), DFS
-	(5490 - 5710 @ 40), (N/A, 27), DFS
-
-country AU:
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 40), (3, 23)
-	(5250 - 5330 @ 40), (3, 23), DFS
-	(5735 - 5835 @ 40), (3, 30)
-
-country AW:
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 40), (N/A, 20)
-	(5250 - 5330 @ 40), (N/A, 20), DFS
-	(5490 - 5710 @ 40), (N/A, 27), DFS
-
-country AZ:
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 40), (N/A, 18)
-	(5250 - 5330 @ 40), (N/A, 18), DFS
-
-country BA: DFS-ETSI
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 40), (N/A, 20)
-	(5250 - 5330 @ 40), (N/A, 20), DFS
-	(5490 - 5710 @ 40), (N/A, 27), DFS
-
-country BB:
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 40), (3, 23)
-	(5250 - 5330 @ 40), (3, 23), DFS
-	(5735 - 5835 @ 40), (3, 30)
-
-country BD:
-	(2402 - 2482 @ 40), (N/A, 20)
-
-country BE: DFS-ETSI
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 40), (N/A, 20)
-	(5250 - 5330 @ 40), (N/A, 20), DFS
-	(5490 - 5710 @ 40), (N/A, 27), DFS
-
-country BG: DFS-ETSI
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 40), (N/A, 23)
-	(5250 - 5290 @ 40), (N/A, 23), DFS
-	(5490 - 5710 @ 40), (N/A, 30), DFS
-
-country BH:
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 20), (N/A, 20)
-	(5250 - 5330 @ 20), (N/A, 20), DFS
-	(5735 - 5835 @ 20), (N/A, 20)
-
-country BL:
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 40), (N/A, 18)
-	(5250 - 5330 @ 40), (N/A, 18), DFS
-
-country BN:
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 40), (N/A, 20)
-	(5250 - 5330 @ 40), (N/A, 20), DFS
-	(5735 - 5835 @ 40), (N/A, 30)
-
-country BO:
-	(2402 - 2482 @ 40), (N/A, 30)
-	(5735 - 5835 @ 40), (N/A, 30)
-
-country BR:
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 40), (3, 17)
-	(5250 - 5330 @ 40), (3, 20), DFS
-	(5490 - 5710 @ 40), (3, 20), DFS
-	(5735 - 5835 @ 40), (3, 30)
-
-country BY:
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 40), (N/A, 20)
-	(5250 - 5330 @ 40), (N/A, 20), DFS
-	(5490 - 5710 @ 40), (N/A, 27), DFS
-
-country BZ:
-	(2402 - 2482 @ 40), (N/A, 30)
-	(5735 - 5835 @ 40), (N/A, 30)
-
-country CA:
-	(2402 - 2472 @ 40), (3, 27)
-	(5170 - 5250 @ 40), (3, 17)
-	(5250 - 5330 @ 40), (3, 20), DFS
-	(5490 - 5710 @ 40), (3, 20), DFS
-	(5735 - 5835 @ 40), (3, 30)
-
-country CH: DFS-ETSI
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 40), (N/A, 20)
-	(5250 - 5330 @ 40), (N/A, 20), DFS
-	(5490 - 5710 @ 40), (N/A, 27), DFS
-
-country CL:
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 40), (N/A, 20)
-	(5250 - 5330 @ 40), (N/A, 20), DFS
-	(5735 - 5835 @ 40), (N/A, 20)
-
-country CN:
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5735 - 5835 @ 40), (N/A, 30)
-
-country CO:
-	(2402 - 2472 @ 40), (3, 27)
-	(5170 - 5250 @ 40), (3, 17)
-	(5250 - 5330 @ 40), (3, 23), DFS
-	(5735 - 5835 @ 40), (3, 30)
-
-country CR:
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 20), (3, 17)
-	(5250 - 5330 @ 20), (3, 23), DFS
-	(5735 - 5835 @ 20), (3, 30)
-
-country CS:
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 40), (N/A, 20)
-	(5250 - 5330 @ 40), (N/A, 20), DFS
-	(5490 - 5710 @ 40), (N/A, 27), DFS
-
-country CY: DFS-ETSI
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 40), (N/A, 20)
-	(5250 - 5330 @ 40), (N/A, 20), DFS
-	(5490 - 5710 @ 40), (N/A, 27), DFS
-
-# Data from http://www.ctu.eu/164/download/VOR/VOR-12-08-2005-34.pdf
-# and http://www.ctu.eu/164/download/VOR/VOR-12-05-2007-6-AN.pdf
-# Power at 5250 - 5350 MHz and 5470 - 5725 MHz can be doubled if TPC is
-# implemented.
-country CZ: DFS-ETSI
-	(2400 - 2483.5 @ 40), (N/A, 100 mW)
-	(5150 - 5250 @ 40), (N/A, 200 mW), NO-OUTDOOR
-	(5250 - 5350 @ 40), (N/A, 100 mW), NO-OUTDOOR, DFS
-	(5470 - 5725 @ 40), (N/A, 500 mW), DFS
-
-# Data from "Frequenznutzungsplan" (as published in April 2008), downloaded from
-# http://www.bundesnetzagentur.de/cae/servlet/contentblob/38448/publicationFile/2659/Frequenznutzungsplan2008_Id17448pdf.pdf
-# For the 5GHz range also see
-# http://www.bundesnetzagentur.de/cae/servlet/contentblob/38216/publicationFile/6579/WLAN5GHzVfg7_2010_28042010pdf.pdf
-# The values have been reduced by a factor of 2 (3db) for non TPC devices
-# (in other words: devices with TPC can use twice the tx power of this table).
-# Note that the docs do not require TPC for 5150--5250; the reduction to
-# 100mW thus is not strictly required -- however the conservative 100mW
-# limit is used here as the non-interference with radar and satellite
-# apps relies on the attenuation by the building walls only in the
-# absence of DFS; the neighbour countries have 100mW limit here as well.
-
-country DE: DFS-ETSI
-	# entries 279004 and 280006
-	(2400 - 2483.5 @ 40), (N/A, 100 mW)
-	# entry 303005
-	(5150 - 5250 @ 40), (N/A, 100 mW), NO-OUTDOOR
-	# entries 304002 and 305002
-	(5250 - 5350 @ 40), (N/A, 100 mW), NO-OUTDOOR, DFS
-	# entries 308002, 309001 and 310003
-	(5470 - 5725 @ 40), (N/A, 500 mW), DFS
-
-country DK: DFS-ETSI
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 40), (N/A, 20)
-	(5250 - 5330 @ 40), (N/A, 20), DFS
-	(5490 - 5710 @ 40), (N/A, 27), DFS
-
-country DO:
-	(2402 - 2472 @ 40), (3, 27)
-	(5170 - 5250 @ 40), (3, 17)
-	(5250 - 5330 @ 40), (3, 23), DFS
-	(5735 - 5835 @ 40), (3, 30)
-
-country DZ:
-	(2402 - 2482 @ 40), (N/A, 20)
-
-country EC:
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 20), (3, 17)
-	(5250 - 5330 @ 20), (3, 23), DFS
-	(5735 - 5835 @ 20), (3, 30)
-
-country EE: DFS-ETSI
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 40), (N/A, 20)
-	(5250 - 5330 @ 40), (N/A, 20), DFS
-	(5490 - 5710 @ 40), (N/A, 27), DFS
-
-country EG:
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 20), (N/A, 20)
-	(5250 - 5330 @ 20), (N/A, 20), DFS
-
-country ES: DFS-ETSI
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 40), (N/A, 20)
-	(5250 - 5330 @ 40), (N/A, 20), DFS
-	(5490 - 5710 @ 40), (N/A, 27), DFS
-
-country FI: DFS-ETSI
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 40), (N/A, 20)
-	(5250 - 5330 @ 40), (N/A, 20), DFS
-	(5490 - 5710 @ 40), (N/A, 27), DFS
-
-country FR: DFS-ETSI
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 40), (N/A, 20)
-	(5250 - 5330 @ 40), (N/A, 20), DFS
-	(5490 - 5710 @ 40), (N/A, 27), DFS
-
-country GE:
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 40), (N/A, 18)
-	(5250 - 5330 @ 40), (N/A, 18), DFS
-
-country GB: DFS-ETSI
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 40), (N/A, 20)
-	(5250 - 5330 @ 40), (N/A, 20), DFS
-	(5490 - 5710 @ 40), (N/A, 27), DFS
-
-country GD:
-	(2402 - 2472 @ 40), (3, 27)
-	(5170 - 5250 @ 40), (3, 17)
-	(5250 - 5330 @ 40), (3, 20), DFS
-	(5490 - 5710 @ 40), (3, 20), DFS
-	(5735 - 5835 @ 40), (3, 30)
-
-country GR: DFS-ETSI
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 40), (N/A, 20)
-	(5250 - 5330 @ 40), (N/A, 20), DFS
-	(5490 - 5710 @ 40), (N/A, 27), DFS
-
-country GL: DFS-ETSI
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 20), (N/A, 20)
-	(5250 - 5330 @ 20), (N/A, 20), DFS
-	(5490 - 5710 @ 20), (N/A, 27), DFS
-
-country GT:
-	(2402 - 2472 @ 40), (3, 27)
-	(5170 - 5250 @ 40), (3, 17)
-	(5250 - 5330 @ 40), (3, 23), DFS
-	(5735 - 5835 @ 40), (3, 30)
-
-country GU:
-	(2402 - 2472 @ 40), (3, 27)
-	(5170 - 5250 @ 20), (3, 17)
-	(5250 - 5330 @ 20), (3, 23), DFS
-	(5735 - 5835 @ 20), (3, 30)
-
-country HN:
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 40), (3, 17)
-	(5250 - 5330 @ 40), (3, 20), DFS
-	(5490 - 5710 @ 40), (3, 20), DFS
-	(5735 - 5835 @ 40), (3, 30)
-
-country HK:
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 40), (3, 17)
-	(5250 - 5330 @ 40), (3, 20), DFS
-	(5490 - 5710 @ 40), (3, 20), DFS
-	(5735 - 5835 @ 40), (3, 30)
-
-country HR: DFS-ETSI
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 40), (N/A, 20)
-	(5250 - 5330 @ 40), (N/A, 20), DFS
-	(5490 - 5710 @ 40), (N/A, 27), DFS
-
-country HT:
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 40), (N/A, 20)
-	(5250 - 5330 @ 40), (N/A, 20), DFS
-	(5490 - 5710 @ 40), (N/A, 27), DFS
-
-country HU: DFS-ETSI
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 40), (N/A, 20)
-	(5250 - 5330 @ 40), (N/A, 20), DFS
-	(5490 - 5710 @ 40), (N/A, 27), DFS
-
-country ID:
-	(2402 - 2482 @ 40), (N/A, 20)
-
-country IE: DFS-ETSI
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 40), (N/A, 20)
-	(5250 - 5330 @ 40), (N/A, 20), DFS
-	(5490 - 5710 @ 40), (N/A, 27), DFS
-
-country IL:
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5150 - 5250 @ 40), (N/A, 200 mW), NO-OUTDOOR
-	(5250 - 5350 @ 40), (N/A, 200 mW), NO-OUTDOOR, DFS
-
-country IN:
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 40), (N/A, 20)
-	(5250 - 5330 @ 40), (N/A, 20), DFS
-	(5735 - 5835 @ 40), (N/A, 20)
-
-country IS: DFS-ETSI
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 40), (N/A, 20)
-	(5250 - 5330 @ 40), (N/A, 20), DFS
-	(5490 - 5710 @ 40), (N/A, 27), DFS
-
-country IR:
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5735 - 5835 @ 40), (N/A, 30)
-
-country IT: DFS-ETSI
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 40), (N/A, 20)
-	(5250 - 5330 @ 40), (N/A, 20), DFS
-	(5490 - 5710 @ 40), (N/A, 27), DFS
-
-country JM:
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 40), (3, 17)
-	(5250 - 5330 @ 40), (3, 20), DFS
-	(5490 - 5710 @ 40), (3, 20), DFS
-	(5735 - 5835 @ 40), (3, 30)
-
-country JP:
-	(2402 - 2472 @ 40), (N/A, 20)
-	(2457 - 2482 @ 20), (N/A, 20)
-	(2474 - 2494 @ 20), (N/A, 20), NO-OFDM
-	(4910 - 4930 @ 10), (N/A, 23)
-	(4910 - 4990 @ 40), (N/A, 23)
-	(4930 - 4950 @ 10), (N/A, 23)
-	(5030 - 5045 @ 10), (N/A, 23)
-	(5030 - 5090 @ 40), (N/A, 23)
-	(5050 - 5060 @ 10), (N/A, 23)
-	(5170 - 5250 @ 40), (N/A, 20)
-	(5250 - 5330 @ 40), (N/A, 20), DFS
-	(5490 - 5710 @ 40), (N/A, 23), DFS
-
-country JO:
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 40), (N/A, 18)
-
-country KE:
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5735 - 5835 @ 40), (N/A, 30)
-
-country KH:
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 40), (N/A, 20)
-	(5250 - 5330 @ 40), (N/A, 20), DFS
-	(5490 - 5710 @ 40), (N/A, 27), DFS
-
-country KP:
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5330 @ 40), (3, 20)
-	(5160 - 5250 @ 40), (3, 20), DFS
-	(5490 - 5630 @ 40), (3, 30), DFS
-	(5735 - 5815 @ 40), (3, 30)
-
-country KR:
-	(2402 - 2482 @ 20), (N/A, 20)
-	(5170 - 5250 @ 20), (3, 20)
-	(5250 - 5330 @ 20), (3, 20), DFS
-	(5490 - 5630 @ 20), (3, 30), DFS
-	(5735 - 5815 @ 20), (3, 30)
-
-country KW:
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 40), (N/A, 20)
-	(5250 - 5330 @ 40), (N/A, 20), DFS
-
-country KZ:
-	(2402 - 2482 @ 40), (N/A, 20)
-
-country LB:
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5735 - 5835 @ 40), (N/A, 30)
-
-country LI: DFS-ETSI
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 40), (N/A, 20)
-	(5250 - 5330 @ 40), (N/A, 20), DFS
-	(5490 - 5710 @ 40), (N/A, 27), DFS
-
-country LK:
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 20), (3, 17)
-	(5250 - 5330 @ 20), (3, 20), DFS
-	(5490 - 5710 @ 20), (3, 20), DFS
-	(5735 - 5835 @ 20), (3, 30)
-
-country LT: DFS-ETSI
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 40), (N/A, 20)
-	(5250 - 5330 @ 40), (N/A, 20), DFS
-	(5490 - 5710 @ 40), (N/A, 27), DFS
-
-country LU: DFS-ETSI
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 40), (N/A, 20)
-	(5250 - 5330 @ 40), (N/A, 20), DFS
-	(5490 - 5710 @ 40), (N/A, 27), DFS
-
-country LV: DFS-ETSI
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 40), (N/A, 20)
-	(5250 - 5330 @ 40), (N/A, 20), DFS
-	(5490 - 5710 @ 40), (N/A, 27), DFS
-
-country MC: DFS-ETSI
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 40), (N/A, 18)
-	(5250 - 5330 @ 40), (N/A, 18), DFS
-
-country MA:
-	(2402 - 2482 @ 40), (N/A, 20)
-
-country MO:
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 40), (3, 23)
-	(5250 - 5330 @ 40), (3, 23), DFS
-	(5735 - 5835 @ 40), (3, 30)
-
-country MK: DFS-ETSI
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 40), (N/A, 20)
-	(5250 - 5330 @ 40), (N/A, 20), DFS
-	(5490 - 5710 @ 40), (N/A, 27), DFS
-
-country MT: DFS-ETSI
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 40), (N/A, 20)
-	(5250 - 5330 @ 40), (N/A, 20), DFS
-	(5490 - 5710 @ 40), (N/A, 27), DFS
-
-country MY:
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5250 - 5330 @ 40), (N/A, 30), DFS
-	(5735 - 5835 @ 40), (N/A, 30)
-
-country MX:
-	(2402 - 2472 @ 40), (3, 27)
-	(5170 - 5250 @ 40), (3, 17)
-	(5250 - 5330 @ 40), (3, 23), DFS
-	(5735 - 5835 @ 40), (3, 30)
-
-country NL: DFS-ETSI
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 40), (N/A, 20), NO-OUTDOOR
-	(5250 - 5330 @ 40), (N/A, 20), NO-OUTDOOR, DFS
-	(5490 - 5710 @ 40), (N/A, 27), DFS
-
-country NO: DFS-ETSI
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 40), (N/A, 20)
-	(5250 - 5330 @ 40), (N/A, 20), DFS
-	(5490 - 5710 @ 40), (N/A, 27), DFS
-
-country NP:
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5735 - 5835 @ 40), (N/A, 30)
-
-country NZ:
-	(2402 - 2482 @ 40), (N/A, 30)
-	(5170 - 5250 @ 20), (3, 23)
-	(5250 - 5330 @ 20), (3, 23), DFS
-	(5735 - 5835 @ 20), (3, 30)
-
-country OM:
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 40), (3, 17)
-	(5250 - 5330 @ 40), (3, 20), DFS
-	(5490 - 5710 @ 40), (3, 20), DFS
-	(5735 - 5835 @ 40), (3, 30)
-
-country PA:
-	(2402 - 2472 @ 40), (3, 27)
-	(5170 - 5250 @ 40), (3, 17)
-	(5250 - 5330 @ 40), (3, 23), DFS
-	(5735 - 5835 @ 40), (3, 30)
-
-country PE:
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5735 - 5835 @ 40), (N/A, 30)
-
-country PG:
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 40), (3, 17)
-	(5250 - 5330 @ 40), (3, 23), DFS
-	(5735 - 5835 @ 40), (3, 30)
-
-country PH:
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5735 - 5835 @ 40), (N/A, 30)
-
-country PK:
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5735 - 5835 @ 40), (N/A, 30)
-
-country PL: DFS-ETSI
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 40), (N/A, 20)
-	(5250 - 5330 @ 40), (N/A, 20), DFS
-	(5490 - 5710 @ 40), (N/A, 27), DFS
-
-country PT: DFS-ETSI
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 40), (N/A, 20)
-	(5250 - 5330 @ 40), (N/A, 20), DFS
-	(5490 - 5710 @ 40), (N/A, 27), DFS
-
-country PR:
-	(2402 - 2472 @ 40), (3, 27)
-	(5170 - 5250 @ 40), (3, 17)
-	(5250 - 5330 @ 40), (3, 23), DFS
-	(5735 - 5835 @ 40), (3, 30)
-
-country QA:
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5735 - 5835 @ 40), (N/A, 30)
-
-country RO: DFS-ETSI
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 40), (N/A, 20)
-	(5250 - 5330 @ 40), (N/A, 20), DFS
-	(5490 - 5710 @ 40), (N/A, 27), DFS
-
-country RU:
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5735 - 5835 @ 20), (N/A, 30)
-
-country SA:
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 20), (3, 23)
-	(5250 - 5330 @ 20), (3, 23), DFS
-	(5735 - 5835 @ 20), (3, 30)
-
-country SE: DFS-ETSI
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 40), (N/A, 20)
-	(5250 - 5330 @ 40), (N/A, 20), DFS
-	(5490 - 5710 @ 40), (N/A, 27), DFS
-
-country SG:
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 40), (N/A, 20)
-	(5250 - 5330 @ 40), (N/A, 20), DFS
-	(5735 - 5835 @ 40), (N/A, 20)
-
-country SI: DFS-ETSI
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 40), (N/A, 20)
-	(5250 - 5330 @ 40), (N/A, 20), DFS
-	(5490 - 5710 @ 40), (N/A, 27), DFS
-
-country SK: DFS-ETSI
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 40), (N/A, 20)
-	(5250 - 5330 @ 40), (N/A, 20), DFS
-	(5490 - 5710 @ 40), (N/A, 27), DFS
-
-country SV:
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 20), (3, 17)
-	(5250 - 5330 @ 20), (3, 23), DFS
-	(5735 - 5835 @ 20), (3, 30)
-
-country SY:
-	(2402 - 2482 @ 40), (N/A, 20)
-
-country TW:
-	(2402 - 2472 @ 40), (3, 27)
-	(5270 - 5330 @ 40), (3, 17), DFS
-	(5735 - 5815 @ 40), (3, 30)
-
-country TH:
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 40), (3, 17)
-	(5250 - 5330 @ 40), (3, 20), DFS
-	(5490 - 5710 @ 40), (3, 20), DFS
-	(5735 - 5835 @ 40), (3, 30)
-
-country TT:
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 40), (3, 17)
-	(5250 - 5330 @ 40), (3, 20), DFS
-	(5490 - 5710 @ 40), (3, 20), DFS
-	(5735 - 5835 @ 40), (3, 30)
-
-country TN:
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 20), (N/A, 20)
-	(5250 - 5330 @ 20), (N/A, 20), DFS
-
-country TR: DFS-ETSI
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 20), (N/A, 20)
-	(5250 - 5330 @ 20), (N/A, 20), DFS
-
-country UA:
-	(2402 - 2482 @ 40), (N/A, 20)
-
-country US: DFS-FCC
-	(2402 - 2472 @ 40), (3, 27)
-	(5170 - 5250 @ 40), (3, 17)
-	(5250 - 5330 @ 40), (3, 20), DFS
-	(5490 - 5600 @ 40), (3, 20), DFS
-	(5650 - 5710 @ 40), (3, 20), DFS
-	(5735 - 5835 @ 40), (3, 30)
-
-country UY:
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 40), (3, 17)
-	(5250 - 5330 @ 40), (3, 20), DFS
-	(5490 - 5710 @ 40), (3, 20), DFS
-	(5735 - 5835 @ 40), (3, 30)
-
-country UZ:
-	(2402 - 2472 @ 40), (3, 27)
-	(5170 - 5250 @ 40), (3, 17)
-	(5250 - 5330 @ 40), (3, 20), DFS
-	(5490 - 5710 @ 40), (3, 20), DFS
-	(5735 - 5835 @ 40), (3, 30)
-
-country VE:
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5735 - 5815 @ 40), (N/A, 23)
-
-country VN:
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 40), (N/A, 20)
-	(5250 - 5330 @ 40), (N/A, 20), DFS
-
-country YE:
-	(2402 - 2482 @ 40), (N/A, 20)
-
-country ZA:
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 40), (3, 17)
-	(5250 - 5330 @ 40), (3, 20), DFS
-	(5490 - 5710 @ 40), (3, 20), DFS
-	(5735 - 5835 @ 40), (3, 30)
-
-country ZW:
-	(2402 - 2482 @ 40), (N/A, 20)
-
diff --git a/package/mac80211/patches/000-fix_kconfig.patch b/package/mac80211/patches/000-fix_kconfig.patch
deleted file mode 100644
index 88d0b04..0000000
--- a/package/mac80211/patches/000-fix_kconfig.patch
+++ /dev/null
@@ -1,16 +0,0 @@
---- a/kconf/Makefile
-+++ b/kconf/Makefile
-@@ -1,10 +1,10 @@
--CFLAGS=-Wall -Wmissing-prototypes -Wstrict-prototypes -O2 -fomit-frame-pointer
-+CFLAGS=-Wall -Wmissing-prototypes -Wstrict-prototypes -O2 -fomit-frame-pointer -DKBUILD_NO_NLS
- 
- LXDIALOG := lxdialog/checklist.o lxdialog/inputbox.o lxdialog/menubox.o lxdialog/textbox.o lxdialog/util.o lxdialog/yesno.o
- 
- conf: conf.o zconf.tab.o
--mconf: LDFLAGS = -Wl,--no-as-needed $(shell ./lxdialog/check-lxdialog.sh -ldflags $(CC))
--mconf: CFLAGS += -DCURSES_LOC="<ncurses.h>" -DLOCALE
-+mconf: LDFLAGS = $(shell ./lxdialog/check-lxdialog.sh -ldflags $(CC))
-+mconf: CFLAGS += -DCURSES_LOC="<ncurses.h>"
- mconf: mconf.o zconf.tab.o $(LXDIALOG)
- 
- .PHONY: clean
diff --git a/package/mac80211/patches/001-fix_build.patch b/package/mac80211/patches/001-fix_build.patch
deleted file mode 100644
index c541985..0000000
--- a/package/mac80211/patches/001-fix_build.patch
+++ /dev/null
@@ -1,156 +0,0 @@
---- a/Makefile
-+++ b/Makefile
-@@ -19,6 +19,7 @@ KLIB_BUILD ?= $(KLIB)/build/
- KERNEL_CONFIG := $(KLIB_BUILD)/.config
- KERNEL_MAKEFILE := $(KLIB_BUILD)/Makefile
- CONFIG_MD5 := $(shell md5sum $(KERNEL_CONFIG) 2>/dev/null | sed 's/\s.*//')
-+STAMP_KERNEL_CONFIG := .kernel_config_md5_$(CONFIG_MD5)
- 
- export KLIB KLIB_BUILD BACKPORT_PWD KMODDIR KMODPATH_ARG
- 
-@@ -36,7 +37,8 @@ mrproper:
- 	@rm -f .kernel_config_md5 Kconfig.versions Kconfig.kernel
- 	@rm -f backport-include/backport/autoconf.h
- 
--.DEFAULT:
-+.SILENT: $(STAMP_KERNEL_CONFIG)
-+$(STAMP_KERNEL_CONFIG):
- 	@set -e ; test -f .local-symbols || (						\
- 	echo "/--------------"								;\
- 	echo "| You shouldn't run make in the backports tree, but only in"		;\
-@@ -60,56 +62,60 @@ mrproper:
- 	echo "| (that isn't currently running.)"					;\
- 	echo "\\--"									;\
- 	false)
--	@set -e ; if [ "$$(cat .kernel_config_md5 2>/dev/null)" != "$(CONFIG_MD5)" ]	;\
--	then 										\
--		echo -n "Generating local configuration database from kernel ..."	;\
--		grep -v -f .local-symbols $(KERNEL_CONFIG) | grep = | (			\
--			while read l ; do						\
--				if [ "$${l:0:7}" != "CONFIG_" ] ; then			\
--					continue					;\
--				fi							;\
--				l=$${l:7}						;\
--				n=$${l%%=*}						;\
--				v=$${l#*=}						;\
--				if [ "$$v" = "m" ] ; then				\
--					echo config $$n					;\
--					echo '    tristate' 				;\
--				elif [ "$$v" = "y" ] ; then				\
--					echo config $$n					;\
--					echo '    bool'					;\
--				else							\
--					continue					;\
--				fi							;\
--				echo "    default $$v"					;\
--				echo ""							;\
--			done								\
--		) > Kconfig.kernel							;\
--		kver=$$($(MAKE) --no-print-directory -C $(KLIB_BUILD) kernelversion |	\
--			sed 's/^\(\(3\|2\.6\)\.[0-9]\+\).*/\1/;t;d')			;\
--		test "$$kver" != "" || echo "Kernel version parse failed!"		;\
--		test "$$kver" != ""							;\
--		kvers="$$(seq 14 39 | sed 's/^/2.6./')"					;\
--		kvers="$$kvers $$(seq 0 99 | sed 's/^/3./')"				;\
--		print=0									;\
--		for v in $$kvers ; do							\
--			if [ "$$print" = "1" ] ; then					\
--				echo config BACKPORT_KERNEL_$$(echo $$v | tr . _)	;\
--				echo "    def_bool y"					;\
--			fi								;\
--			if [ "$$v" = "$$kver" ] ; then print=1 ; fi			;\
--		done > Kconfig.versions							;\
--		# RHEL as well, sadly we need to grep for it				;\
--		RHEL_MAJOR=$$(grep '^RHEL_MAJOR' $(KERNEL_MAKEFILE) | 			\
--					sed 's/.*=\s*\([0-9]*\)/\1/;t;d')		;\
--		RHEL_MINOR=$$(grep '^RHEL_MINOR' $(KERNEL_MAKEFILE) | 			\
--					sed 's/.*=\s*\([0-9]*\)/\1/;t;d')		;\
--		for v in $$(seq 0 $$RHEL_MINOR) ; do 					\
--			echo config BACKPORT_RHEL_KERNEL_$${RHEL_MAJOR}_$$v		;\
--			echo "    def_bool y"						;\
--		done >> Kconfig.versions						;\
--		echo " done."								;\
--	fi										;\
--	echo "$(CONFIG_MD5)" > .kernel_config_md5
-+	@rm -f .kernel_config_md5_*
-+	@touch $@
-+
-+Kconfig.kernel: $(STAMP_KERNEL_CONFIG) .local-symbols
-+	@printf "Generating local configuration database from kernel ..."
-+	@grep -v -f .local-symbols $(KERNEL_CONFIG) | grep = | (			\
-+		while read l ; do						\
-+			if [ "$${l:0:7}" != "CONFIG_" ] ; then			\
-+				continue					;\
-+			fi							;\
-+			l=$${l:7}						;\
-+			n=$${l%%=*}						;\
-+			v=$${l#*=}						;\
-+			if [ "$$v" = "m" ] ; then				\
-+				echo config $$n					;\
-+				echo '    tristate' 				;\
-+			elif [ "$$v" = "y" ] ; then				\
-+				echo config $$n					;\
-+				echo '    bool'					;\
-+			else							\
-+				continue					;\
-+			fi							;\
-+			echo "    default $$v"					;\
-+			echo ""							;\
-+		done								\
-+	) > $@
-+	@echo " done."
-+
-+Kconfig.versions: Kconfig.kernel
-+	@kver=$$($(MAKE) --no-print-directory -C $(KLIB_BUILD) kernelversion |	\
-+		sed 's/^\(\(3\|2\.6\)\.[0-9]\+\).*/\1/;t;d')			;\
-+	test "$$kver" != "" || echo "Kernel version parse failed!"		;\
-+	test "$$kver" != ""							;\
-+	kvers="$$(seq 14 39 | sed 's/^/2.6./')"					;\
-+	kvers="$$kvers $$(seq 0 99 | sed 's/^/3./')"				;\
-+	print=0									;\
-+	for v in $$kvers ; do							\
-+		if [ "$$print" = "1" ] ; then					\
-+			echo config BACKPORT_KERNEL_$$(echo $$v | tr . _)	;\
-+			echo "    def_bool y"					;\
-+		fi								;\
-+		if [ "$$v" = "$$kver" ] ; then print=1 ; fi			;\
-+	done > $@
-+	@RHEL_MAJOR=$$(grep '^RHEL_MAJOR' $(KERNEL_MAKEFILE) | 			\
-+				sed 's/.*=\s*\([0-9]*\)/\1/;t;d')		;\
-+	RHEL_MINOR=$$(grep '^RHEL_MINOR' $(KERNEL_MAKEFILE) | 			\
-+				sed 's/.*=\s*\([0-9]*\)/\1/;t;d')		;\
-+	for v in $$(seq 0 $$RHEL_MINOR) ; do 					\
-+		echo config BACKPORT_RHEL_KERNEL_$${RHEL_MAJOR}_$$v		;\
-+		echo "    def_bool y"						;\
-+	done >> $@
-+
-+.DEFAULT:
-+	@$(MAKE) Kconfig.versions
- 	@$(MAKE) -f Makefile.real "$@"
- 
- else
---- a/Makefile.real
-+++ b/Makefile.real
-@@ -54,7 +54,7 @@ defconfig-%::
- 
- backport-include/backport/autoconf.h: .config Kconfig.versions Kconfig.kernel
- 	@$(MAKE) oldconfig
--	@echo -n "Building backport-include/backport/autoconf.h ..."
-+	@printf "Building backport-include/backport/autoconf.h ..."
- 	@grep -f .local-symbols .config | (				\
- 		echo "#ifndef COMPAT_AUTOCONF_INCLUDED"			;\
- 		echo "#define COMPAT_AUTOCONF_INCLUDED"			;\
-@@ -75,7 +75,12 @@ backport-include/backport/autoconf.h: .c
- 			esac						;\
- 		done							;\
- 		echo "#endif /* COMPAT_AUTOCONF_INCLUDED */"		;\
--	) > backport-include/backport/autoconf.h
-+	) > $@.new
-+	@if cmp -s $@ $@.new; then \
-+		rm -f $@.new; \
-+	else \
-+		mv $@.new $@; \
-+	fi
- 	@echo " done."
- 
- .PHONY: modules
diff --git a/package/mac80211/patches/002-change_allconfig.patch b/package/mac80211/patches/002-change_allconfig.patch
deleted file mode 100644
index 91ad20f..0000000
--- a/package/mac80211/patches/002-change_allconfig.patch
+++ /dev/null
@@ -1,44 +0,0 @@
---- a/kconf/conf.c
-+++ b/kconf/conf.c
-@@ -578,40 +578,12 @@ int main(int ac, char **av)
- 	case oldconfig:
- 	case listnewconfig:
- 	case olddefconfig:
--		conf_read(NULL);
--		break;
- 	case allnoconfig:
- 	case allyesconfig:
- 	case allmodconfig:
- 	case alldefconfig:
- 	case randconfig:
--		name = getenv("KCONFIG_ALLCONFIG");
--		if (!name)
--			break;
--		if ((strcmp(name, "") != 0) && (strcmp(name, "1") != 0)) {
--			if (conf_read_simple(name, S_DEF_USER)) {
--				fprintf(stderr,
--					_("*** Can't read seed configuration \"%s\"!\n"),
--					name);
--				exit(1);
--			}
--			break;
--		}
--		switch (input_mode) {
--		case allnoconfig:	name = "allno.config"; break;
--		case allyesconfig:	name = "allyes.config"; break;
--		case allmodconfig:	name = "allmod.config"; break;
--		case alldefconfig:	name = "alldef.config"; break;
--		case randconfig:	name = "allrandom.config"; break;
--		default: break;
--		}
--		if (conf_read_simple(name, S_DEF_USER) &&
--		    conf_read_simple("all.config", S_DEF_USER)) {
--			fprintf(stderr,
--				_("*** KCONFIG_ALLCONFIG set, but no \"%s\" or \"all.config\" file found\n"),
--				name);
--			exit(1);
--		}
-+		conf_read(NULL);
- 		break;
- 	default:
- 		break;
diff --git a/package/mac80211/patches/003-remove_bogus_modparams.patch b/package/mac80211/patches/003-remove_bogus_modparams.patch
deleted file mode 100644
index c969b19..0000000
--- a/package/mac80211/patches/003-remove_bogus_modparams.patch
+++ /dev/null
@@ -1,34 +0,0 @@
---- a/compat/main.c
-+++ b/compat/main.c
-@@ -21,31 +21,6 @@ MODULE_LICENSE("GPL");
- #error "You need a BACKPORTS_VERSION"
- #endif
- 
--static char *backported_kernel_name = BACKPORTED_KERNEL_NAME;
--
--module_param(backported_kernel_name, charp, 0400);
--MODULE_PARM_DESC(backported_kernel_name,
--		 "The kernel tree name that was used for this backport (" BACKPORTED_KERNEL_NAME ")");
--
--#ifdef BACKPORTS_GIT_TRACKED 
--static char *backports_tracker_id = BACKPORTS_GIT_TRACKED;
--module_param(backports_tracker_id, charp, 0400);
--MODULE_PARM_DESC(backports_tracker_id,
--		 "The version of the tree containing this backport (" BACKPORTS_GIT_TRACKED ")");
--#else
--static char *backported_kernel_version = BACKPORTED_KERNEL_VERSION;
--static char *backports_version = BACKPORTS_VERSION;
--
--module_param(backported_kernel_version, charp, 0400);
--MODULE_PARM_DESC(backported_kernel_version,
--		 "The kernel version that was used for this backport (" BACKPORTED_KERNEL_VERSION ")");
--
--module_param(backports_version, charp, 0400);
--MODULE_PARM_DESC(backports_version,
--		 "The git version of the backports tree used to generate this backport (" BACKPORTS_VERSION ")");
--
--#endif
--
- void backport_dependency_symbol(void)
- {
- }
diff --git a/package/mac80211/patches/010-disable_rfkill.patch b/package/mac80211/patches/010-disable_rfkill.patch
deleted file mode 100644
index c5a92d6..0000000
--- a/package/mac80211/patches/010-disable_rfkill.patch
+++ /dev/null
@@ -1,13 +0,0 @@
---- a/backport-include/linux/rfkill.h
-+++ b/backport-include/linux/rfkill.h
-@@ -2,6 +2,10 @@
- #define __COMPAT_RFKILL_H
- #include <linux/version.h>
- 
-+#undef CONFIG_RFKILL
-+#undef CONFIG_RFKILL_LEDS
-+#undef CONFIG_RFKILL_MODULE
-+
- #if LINUX_VERSION_CODE >= KERNEL_VERSION(3,10,0)
- #include_next <linux/rfkill.h>
- #else
diff --git a/package/mac80211/patches/020-disable_tty_set_termios.patch b/package/mac80211/patches/020-disable_tty_set_termios.patch
deleted file mode 100644
index 89c6a60..0000000
--- a/package/mac80211/patches/020-disable_tty_set_termios.patch
+++ /dev/null
@@ -1,16 +0,0 @@
---- a/compat/compat-2.6.39.c
-+++ b/compat/compat-2.6.39.c
-@@ -13,6 +13,7 @@
- #include <linux/sched.h>
- #include <linux/module.h>
- 
-+#ifdef CONFIG_COMPAT_BLUETOOTH
- #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27))
- /*
-  *		Termios Helper Methods
-@@ -112,4 +113,4 @@ int tty_set_termios(struct tty_struct *t
- }
- EXPORT_SYMBOL_GPL(tty_set_termios);
- #endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27)) */
--
-+#endif
diff --git a/package/mac80211/patches/030-rt2x00_options.patch b/package/mac80211/patches/030-rt2x00_options.patch
deleted file mode 100644
index 789a77a..0000000
--- a/package/mac80211/patches/030-rt2x00_options.patch
+++ /dev/null
@@ -1,36 +0,0 @@
---- a/drivers/net/wireless/rt2x00/Kconfig
-+++ b/drivers/net/wireless/rt2x00/Kconfig
-@@ -202,25 +202,28 @@ config RT2800USB_UNKNOWN
- endif
- 
- config RT2800_LIB
--	tristate
-+	tristate "RT2800 USB/PCI support"
- 	depends on m
- 
- config RT2X00_LIB_MMIO
--	tristate
-+	tristate "RT2x00 MMIO support"
- 	depends on m
- 
- config RT2X00_LIB_PCI
--	tristate
-+	tristate "RT2x00 PCI support"
-+	depends on PCI
- 	depends on m
- 	select RT2X00_LIB
- 
- config RT2X00_LIB_SOC
--	tristate
-+	tristate "RT2x00 SoC support"
-+	depends on SOC_RT288X || SOC_RT305X
- 	depends on m
- 	select RT2X00_LIB
- 
- config RT2X00_LIB_USB
--	tristate
-+	tristate "RT2x00 USB support"
-+	depends on USB
- 	depends on m
- 	select RT2X00_LIB
- 
diff --git a/package/mac80211/patches/040-brcmutil_option.patch b/package/mac80211/patches/040-brcmutil_option.patch
deleted file mode 100644
index 8a6cae6..0000000
--- a/package/mac80211/patches/040-brcmutil_option.patch
+++ /dev/null
@@ -1,9 +0,0 @@
---- a/drivers/net/wireless/brcm80211/Kconfig
-+++ b/drivers/net/wireless/brcm80211/Kconfig
-@@ -1,5 +1,5 @@
- config BRCMUTIL
--	tristate
-+	tristate "Broadcom 802.11 driver utility functions"
- 	depends on m
- 
- config BRCMSMAC
diff --git a/package/mac80211/patches/050-lib80211_option.patch b/package/mac80211/patches/050-lib80211_option.patch
deleted file mode 100644
index 5372114..0000000
--- a/package/mac80211/patches/050-lib80211_option.patch
+++ /dev/null
@@ -1,30 +0,0 @@
---- a/net/wireless/Kconfig
-+++ b/net/wireless/Kconfig
-@@ -123,7 +123,7 @@ config CFG80211_WEXT
- 	  extensions with cfg80211-based drivers.
- 
- config LIB80211
--	tristate
-+	tristate "lib80211"
- 	depends on m
- 	default n
- 	help
-@@ -133,15 +133,15 @@ config LIB80211
- 	  Drivers should select this themselves if needed.
- 
- config LIB80211_CRYPT_WEP
--	tristate
-+	tristate "lib80211 WEP support"
- 	depends on m
- 
- config LIB80211_CRYPT_CCMP
--	tristate
-+	tristate "lib80211 CCMP support"
- 	depends on m
- 
- config LIB80211_CRYPT_TKIP
--	tristate
-+	tristate "lib80211 TKIP support"
- 	depends on m
- 
- config LIB80211_DEBUG
diff --git a/package/mac80211/patches/060-no_local_ssb_bcma.patch b/package/mac80211/patches/060-no_local_ssb_bcma.patch
deleted file mode 100644
index 5e8d421..0000000
--- a/package/mac80211/patches/060-no_local_ssb_bcma.patch
+++ /dev/null
@@ -1,129 +0,0 @@
---- a/.local-symbols
-+++ b/.local-symbols
-@@ -363,42 +363,6 @@ USB_CDC_PHONET=
- USB_IPHETH=
- USB_SIERRA_NET=
- USB_VL600=
--SSB_POSSIBLE=
--SSB=
--SSB_SPROM=
--SSB_BLOCKIO=
--SSB_PCIHOST_POSSIBLE=
--SSB_PCIHOST=
--SSB_B43_PCI_BRIDGE=
--SSB_PCMCIAHOST_POSSIBLE=
--SSB_PCMCIAHOST=
--SSB_SDIOHOST_POSSIBLE=
--SSB_SDIOHOST=
--SSB_SILENT=
--SSB_DEBUG=
--SSB_SERIAL=
--SSB_DRIVER_PCICORE_POSSIBLE=
--SSB_DRIVER_PCICORE=
--SSB_PCICORE_HOSTMODE=
--SSB_DRIVER_MIPS=
--SSB_SFLASH=
--SSB_EMBEDDED=
--SSB_DRIVER_EXTIF=
--SSB_DRIVER_GIGE=
--SSB_DRIVER_GPIO=
--BCMA_POSSIBLE=
--BCMA=
--BCMA_BLOCKIO=
--BCMA_HOST_PCI_POSSIBLE=
--BCMA_HOST_PCI=
--BCMA_DRIVER_PCI_HOSTMODE=
--BCMA_HOST_SOC=
--BCMA_DRIVER_MIPS=
--BCMA_SFLASH=
--BCMA_NFLASH=
--BCMA_DRIVER_GMAC_CMN=
--BCMA_DRIVER_GPIO=
--BCMA_DEBUG=
- DRM=
- DRM_USB=
- DRM_KMS_HELPER=
---- a/Kconfig
-+++ b/Kconfig
-@@ -33,9 +33,6 @@ source drivers/net/wireless/Kconfig
- source drivers/net/ethernet/Kconfig
- source drivers/net/usb/Kconfig
- 
--source drivers/ssb/Kconfig
--source drivers/bcma/Kconfig
--
- source drivers/gpu/drm/Kconfig
- 
- source net/nfc/Kconfig
---- a/Makefile.kernel
-+++ b/Makefile.kernel
-@@ -26,8 +26,6 @@ obj-$(CPTCFG_MAC80211) += net/mac80211/
- obj-$(CPTCFG_WLAN) += drivers/net/wireless/
- obj-$(CPTCFG_BT) += net/bluetooth/
- obj-$(CPTCFG_BT) += drivers/bluetooth/
--obj-$(CPTCFG_SSB) += drivers/ssb/
--obj-$(CPTCFG_BCMA) += drivers/bcma/
- obj-$(CPTCFG_ETHERNET) += drivers/net/ethernet/
- obj-$(CPTCFG_USB_NET_RNDIS_WLAN) += drivers/net/usb/
- obj-$(CPTCFG_DRM) += drivers/gpu/drm/
---- a/drivers/net/wireless/b43/main.c
-+++ b/drivers/net/wireless/b43/main.c
-@@ -2729,7 +2729,7 @@ static struct ssb_device *b43_ssb_gpio_d
- {
- 	struct ssb_bus *bus = dev->dev->sdev->bus;
- 
--#ifdef CPTCFG_SSB_DRIVER_PCICORE
-+#ifdef CONFIG_SSB_DRIVER_PCICORE
- 	return (bus->chipco.dev ? bus->chipco.dev : bus->pcicore.dev);
- #else
- 	return bus->chipco.dev;
-@@ -4735,7 +4735,7 @@ static int b43_wireless_core_init(struct
- 	}
- 	if (sprom->boardflags_lo & B43_BFL_XTAL_NOSLOW)
- 		hf |= B43_HF_DSCRQ; /* Disable slowclock requests from ucode. */
--#ifdef CPTCFG_SSB_DRIVER_PCICORE
-+#ifdef CONFIG_SSB_DRIVER_PCICORE
- 	if (dev->dev->bus_type == B43_BUS_SSB &&
- 	    dev->dev->sdev->bus->bustype == SSB_BUSTYPE_PCI &&
- 	    dev->dev->sdev->bus->pcicore.dev->id.revision <= 10)
---- a/drivers/net/wireless/b43legacy/main.c
-+++ b/drivers/net/wireless/b43legacy/main.c
-@@ -1937,7 +1937,7 @@ static int b43legacy_gpio_init(struct b4
- 	if (dev->dev->id.revision >= 2)
- 		mask  |= 0x0010; /* FIXME: This is redundant. */
- 
--#ifdef CPTCFG_SSB_DRIVER_PCICORE
-+#ifdef CONFIG_SSB_DRIVER_PCICORE
- 	pcidev = bus->pcicore.dev;
- #endif
- 	gpiodev = bus->chipco.dev ? : pcidev;
-@@ -1956,7 +1956,7 @@ static void b43legacy_gpio_cleanup(struc
- 	struct ssb_bus *bus = dev->dev->bus;
- 	struct ssb_device *gpiodev, *pcidev = NULL;
- 
--#ifdef CPTCFG_SSB_DRIVER_PCICORE
-+#ifdef CONFIG_SSB_DRIVER_PCICORE
- 	pcidev = bus->pcicore.dev;
- #endif
- 	gpiodev = bus->chipco.dev ? : pcidev;
---- a/drivers/net/wireless/brcm80211/brcmsmac/Makefile
-+++ b/drivers/net/wireless/brcm80211/brcmsmac/Makefile
-@@ -43,6 +43,6 @@ brcmsmac-y := \
- 	brcms_trace_events.o \
- 	debug.o
- 
--brcmsmac-$(CPTCFG_BCMA_DRIVER_GPIO) += led.o
-+brcmsmac-$(CONFIG_BCMA_DRIVER_GPIO) += led.o
- 
- obj-$(CPTCFG_BRCMSMAC)	+= brcmsmac.o
---- a/drivers/net/wireless/brcm80211/brcmsmac/led.h
-+++ b/drivers/net/wireless/brcm80211/brcmsmac/led.h
-@@ -22,7 +22,7 @@ struct brcms_led {
- 	bool active_low;
- };
- 
--#ifdef CPTCFG_BCMA_DRIVER_GPIO
-+#ifdef CONFIG_BCMA_DRIVER_GPIO
- void brcms_led_unregister(struct brcms_info *wl);
- int brcms_led_register(struct brcms_info *wl);
- #else
diff --git a/package/mac80211/patches/150-disable_addr_notifier.patch b/package/mac80211/patches/150-disable_addr_notifier.patch
deleted file mode 100644
index 92c1909..0000000
--- a/package/mac80211/patches/150-disable_addr_notifier.patch
+++ /dev/null
@@ -1,67 +0,0 @@
---- a/net/mac80211/main.c
-+++ b/net/mac80211/main.c
-@@ -300,7 +300,7 @@ void ieee80211_restart_hw(struct ieee802
- }
- EXPORT_SYMBOL(ieee80211_restart_hw);
- 
--#ifdef CONFIG_INET
-+#ifdef __disabled__CONFIG_INET
- static int ieee80211_ifa_changed(struct notifier_block *nb,
- 				 unsigned long data, void *arg)
- {
-@@ -359,7 +359,7 @@ static int ieee80211_ifa_changed(struct 
- }
- #endif
- 
--#if IS_ENABLED(CONFIG_IPV6)
-+#if IS_ENABLED(__disabled__CONFIG_IPV6)
- static int ieee80211_ifa6_changed(struct notifier_block *nb,
- 				  unsigned long data, void *arg)
- {
-@@ -990,14 +990,14 @@ int ieee80211_register_hw(struct ieee802
- 		goto fail_pm_qos;
- 	}
- 
--#ifdef CONFIG_INET
-+#ifdef __disabled__CONFIG_INET
- 	local->ifa_notifier.notifier_call = ieee80211_ifa_changed;
- 	result = register_inetaddr_notifier(&local->ifa_notifier);
- 	if (result)
- 		goto fail_ifa;
- #endif
- 
--#if IS_ENABLED(CONFIG_IPV6)
-+#if IS_ENABLED(__disabled__CONFIG_IPV6)
- 	local->ifa6_notifier.notifier_call = ieee80211_ifa6_changed;
- 	result = register_inet6addr_notifier(&local->ifa6_notifier);
- 	if (result)
-@@ -1006,13 +1006,13 @@ int ieee80211_register_hw(struct ieee802
- 
- 	return 0;
- 
--#if IS_ENABLED(CONFIG_IPV6)
-+#if IS_ENABLED(__disabled__CONFIG_IPV6)
-  fail_ifa6:
--#ifdef CONFIG_INET
-+#ifdef __disabled__CONFIG_INET
- 	unregister_inetaddr_notifier(&local->ifa_notifier);
- #endif
- #endif
--#if defined(CONFIG_INET) || defined(CONFIG_IPV6)
-+#if defined(__disabled__CONFIG_INET) || defined(__disabled__CONFIG_IPV6)
-  fail_ifa:
- 	pm_qos_remove_notifier(PM_QOS_NETWORK_LATENCY,
- 			       &local->network_latency_notifier);
-@@ -1045,10 +1045,10 @@ void ieee80211_unregister_hw(struct ieee
- 
- 	pm_qos_remove_notifier(PM_QOS_NETWORK_LATENCY,
- 			       &local->network_latency_notifier);
--#ifdef CONFIG_INET
-+#ifdef __disabled__CONFIG_INET
- 	unregister_inetaddr_notifier(&local->ifa_notifier);
- #endif
--#if IS_ENABLED(CONFIG_IPV6)
-+#if IS_ENABLED(__disabled__CONFIG_IPV6)
- 	unregister_inet6addr_notifier(&local->ifa6_notifier);
- #endif
- 
diff --git a/package/mac80211/patches/200-ath5k_pci_dependency.patch b/package/mac80211/patches/200-ath5k_pci_dependency.patch
deleted file mode 100644
index 2d99b4a..0000000
--- a/package/mac80211/patches/200-ath5k_pci_dependency.patch
+++ /dev/null
@@ -1,11 +0,0 @@
---- a/drivers/net/wireless/ath/ath5k/Kconfig
-+++ b/drivers/net/wireless/ath/ath5k/Kconfig
-@@ -55,7 +55,7 @@ config ATH5K_TRACER
- 
- config ATH5K_AHB
- 	bool "Atheros 5xxx AHB bus support"
--	depends on (ATHEROS_AR231X && !PCI)
-+	depends on ATHEROS_AR231X
- 	---help---
- 	  This adds support for WiSoC type chipsets of the 5xxx Atheros
- 	  family.
diff --git a/package/mac80211/patches/201-ath5k-WAR-for-AR71xx-PCI-bug.patch b/package/mac80211/patches/201-ath5k-WAR-for-AR71xx-PCI-bug.patch
deleted file mode 100644
index d9672d4..0000000
--- a/package/mac80211/patches/201-ath5k-WAR-for-AR71xx-PCI-bug.patch
+++ /dev/null
@@ -1,38 +0,0 @@
---- a/drivers/net/wireless/ath/ath5k/initvals.c
-+++ b/drivers/net/wireless/ath/ath5k/initvals.c
-@@ -62,8 +62,14 @@ static const struct ath5k_ini ar5210_ini
- 	{ AR5K_IMR,		0 },
- 	{ AR5K_IER,		AR5K_IER_DISABLE },
- 	{ AR5K_BSR,		0, AR5K_INI_READ },
-+#if !defined(CONFIG_ATHEROS_AR71XX) && !defined(CONFIG_ATH79)
- 	{ AR5K_TXCFG,		AR5K_DMASIZE_128B },
- 	{ AR5K_RXCFG,		AR5K_DMASIZE_128B },
-+#else
-+	/* WAR for AR71xx PCI bug */
-+	{ AR5K_TXCFG,		AR5K_DMASIZE_128B },
-+	{ AR5K_RXCFG,		AR5K_DMASIZE_4B },
-+#endif
- 	{ AR5K_CFG,		AR5K_INIT_CFG },
- 	{ AR5K_TOPS,		8 },
- 	{ AR5K_RXNOFRM,		8 },
---- a/drivers/net/wireless/ath/ath5k/dma.c
-+++ b/drivers/net/wireless/ath/ath5k/dma.c
-@@ -860,10 +860,18 @@ ath5k_hw_dma_init(struct ath5k_hw *ah)
- 	 * guess we can tweak it and see how it goes ;-)
- 	 */
- 	if (ah->ah_version != AR5K_AR5210) {
-+#if !defined(CONFIG_ATHEROS_AR71XX) && !defined(CONFIG_ATH79)
- 		AR5K_REG_WRITE_BITS(ah, AR5K_TXCFG,
- 			AR5K_TXCFG_SDMAMR, AR5K_DMASIZE_128B);
- 		AR5K_REG_WRITE_BITS(ah, AR5K_RXCFG,
- 			AR5K_RXCFG_SDMAMW, AR5K_DMASIZE_128B);
-+#else
-+		/* WAR for AR71xx PCI bug */
-+		AR5K_REG_WRITE_BITS(ah, AR5K_TXCFG,
-+			AR5K_TXCFG_SDMAMR, AR5K_DMASIZE_128B);
-+		AR5K_REG_WRITE_BITS(ah, AR5K_RXCFG,
-+			AR5K_RXCFG_SDMAMW, AR5K_DMASIZE_4B);
-+#endif
- 	}
- 
- 	/* Pre-enable interrupts on 5211/5212*/
diff --git a/package/mac80211/patches/300-pending_work.patch b/package/mac80211/patches/300-pending_work.patch
deleted file mode 100644
index 73f440b..0000000
--- a/package/mac80211/patches/300-pending_work.patch
+++ /dev/null
@@ -1,1234 +0,0 @@
---- a/net/mac80211/agg-rx.c
-+++ b/net/mac80211/agg-rx.c
-@@ -204,6 +204,8 @@ static void ieee80211_send_addba_resp(st
- 		memcpy(mgmt->bssid, sdata->u.mgd.bssid, ETH_ALEN);
- 	else if (sdata->vif.type == NL80211_IFTYPE_ADHOC)
- 		memcpy(mgmt->bssid, sdata->u.ibss.bssid, ETH_ALEN);
-+	else if (sdata->vif.type == NL80211_IFTYPE_WDS)
-+		memcpy(mgmt->bssid, da, ETH_ALEN);
- 
- 	mgmt->frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT |
- 					  IEEE80211_STYPE_ACTION);
---- a/net/mac80211/agg-tx.c
-+++ b/net/mac80211/agg-tx.c
-@@ -81,7 +81,8 @@ static void ieee80211_send_addba_request
- 	memcpy(mgmt->sa, sdata->vif.addr, ETH_ALEN);
- 	if (sdata->vif.type == NL80211_IFTYPE_AP ||
- 	    sdata->vif.type == NL80211_IFTYPE_AP_VLAN ||
--	    sdata->vif.type == NL80211_IFTYPE_MESH_POINT)
-+	    sdata->vif.type == NL80211_IFTYPE_MESH_POINT ||
-+	    sdata->vif.type == NL80211_IFTYPE_WDS)
- 		memcpy(mgmt->bssid, sdata->vif.addr, ETH_ALEN);
- 	else if (sdata->vif.type == NL80211_IFTYPE_STATION)
- 		memcpy(mgmt->bssid, sdata->u.mgd.bssid, ETH_ALEN);
-@@ -527,6 +528,7 @@ int ieee80211_start_tx_ba_session(struct
- 	    sdata->vif.type != NL80211_IFTYPE_MESH_POINT &&
- 	    sdata->vif.type != NL80211_IFTYPE_AP_VLAN &&
- 	    sdata->vif.type != NL80211_IFTYPE_AP &&
-+	    sdata->vif.type != NL80211_IFTYPE_WDS &&
- 	    sdata->vif.type != NL80211_IFTYPE_ADHOC)
- 		return -EINVAL;
- 
---- a/net/mac80211/debugfs_sta.c
-+++ b/net/mac80211/debugfs_sta.c
-@@ -66,11 +66,11 @@ static ssize_t sta_flags_read(struct fil
- 	test_sta_flag(sta, WLAN_STA_##flg) ? #flg "\n" : ""
- 
- 	int res = scnprintf(buf, sizeof(buf),
--			    "%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s",
-+			    "%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s",
- 			    TEST(AUTH), TEST(ASSOC), TEST(PS_STA),
- 			    TEST(PS_DRIVER), TEST(AUTHORIZED),
- 			    TEST(SHORT_PREAMBLE),
--			    TEST(WME), TEST(WDS), TEST(CLEAR_PS_FILT),
-+			    TEST(WME), TEST(CLEAR_PS_FILT),
- 			    TEST(MFP), TEST(BLOCK_BA), TEST(PSPOLL),
- 			    TEST(UAPSD), TEST(SP), TEST(TDLS_PEER),
- 			    TEST(TDLS_PEER_AUTH), TEST(4ADDR_EVENT),
---- a/net/mac80211/iface.c
-+++ b/net/mac80211/iface.c
-@@ -463,7 +463,6 @@ int ieee80211_do_open(struct wireless_de
- 	struct ieee80211_sub_if_data *sdata = IEEE80211_WDEV_TO_SUB_IF(wdev);
- 	struct net_device *dev = wdev->netdev;
- 	struct ieee80211_local *local = sdata->local;
--	struct sta_info *sta;
- 	u32 changed = 0;
- 	int res;
- 	u32 hw_reconf_flags = 0;
-@@ -629,30 +628,8 @@ int ieee80211_do_open(struct wireless_de
- 
- 	set_bit(SDATA_STATE_RUNNING, &sdata->state);
- 
--	if (sdata->vif.type == NL80211_IFTYPE_WDS) {
--		/* Create STA entry for the WDS peer */
--		sta = sta_info_alloc(sdata, sdata->u.wds.remote_addr,
--				     GFP_KERNEL);
--		if (!sta) {
--			res = -ENOMEM;
--			goto err_del_interface;
--		}
--
--		sta_info_pre_move_state(sta, IEEE80211_STA_AUTH);
--		sta_info_pre_move_state(sta, IEEE80211_STA_ASSOC);
--		sta_info_pre_move_state(sta, IEEE80211_STA_AUTHORIZED);
--
--		res = sta_info_insert(sta);
--		if (res) {
--			/* STA has been freed */
--			goto err_del_interface;
--		}
--
--		rate_control_rate_init(sta);
--		netif_carrier_on(dev);
--	} else if (sdata->vif.type == NL80211_IFTYPE_P2P_DEVICE) {
-+	if (sdata->vif.type == NL80211_IFTYPE_P2P_DEVICE)
- 		rcu_assign_pointer(local->p2p_sdata, sdata);
--	}
- 
- 	/*
- 	 * set_multicast_list will be invoked by the networking core
-@@ -1116,6 +1093,74 @@ static void ieee80211_if_setup(struct ne
- 	dev->destructor = free_netdev;
- }
- 
-+static void ieee80211_wds_rx_queued_mgmt(struct ieee80211_sub_if_data *sdata,
-+					 struct sk_buff *skb)
-+{
-+	struct ieee80211_local *local = sdata->local;
-+	struct ieee80211_rx_status *rx_status;
-+	struct ieee802_11_elems elems;
-+	struct ieee80211_mgmt *mgmt;
-+	struct sta_info *sta;
-+	size_t baselen;
-+	u32 rates = 0;
-+	u16 stype;
-+	bool new = false;
-+	enum ieee80211_band band;
-+	struct ieee80211_supported_band *sband;
-+
-+	rx_status = IEEE80211_SKB_RXCB(skb);
-+	band = rx_status->band;
-+	sband = local->hw.wiphy->bands[band];
-+	mgmt = (struct ieee80211_mgmt *) skb->data;
-+	stype = le16_to_cpu(mgmt->frame_control) & IEEE80211_FCTL_STYPE;
-+
-+	if (stype != IEEE80211_STYPE_BEACON)
-+		return;
-+
-+	baselen = (u8 *) mgmt->u.probe_resp.variable - (u8 *) mgmt;
-+	if (baselen > skb->len)
-+		return;
-+
-+	ieee802_11_parse_elems(mgmt->u.probe_resp.variable,
-+			       skb->len - baselen, false, &elems);
-+
-+	rates = ieee80211_sta_get_rates(local, &elems, band, NULL);
-+
-+	rcu_read_lock();
-+
-+	sta = sta_info_get(sdata, sdata->u.wds.remote_addr);
-+
-+	if (!sta) {
-+		rcu_read_unlock();
-+		sta = sta_info_alloc(sdata, sdata->u.wds.remote_addr,
-+				     GFP_KERNEL);
-+		if (!sta)
-+			return;
-+
-+		new = true;
-+	}
-+
-+	sta->last_rx = jiffies;
-+	sta->sta.supp_rates[band] = rates;
-+
-+	if (elems.ht_cap_elem)
-+		ieee80211_ht_cap_ie_to_sta_ht_cap(sdata, sband,
-+				elems.ht_cap_elem, sta);
-+
-+	if (elems.wmm_param)
-+		set_sta_flag(sta, WLAN_STA_WME);
-+
-+	if (new) {
-+		sta_info_pre_move_state(sta, IEEE80211_STA_AUTH);
-+		sta_info_pre_move_state(sta, IEEE80211_STA_ASSOC);
-+		sta_info_pre_move_state(sta, IEEE80211_STA_AUTHORIZED);
-+		rate_control_rate_init(sta);
-+		sta_info_insert_rcu(sta);
-+	}
-+
-+	rcu_read_unlock();
-+}
-+
- static void ieee80211_iface_work(struct work_struct *work)
- {
- 	struct ieee80211_sub_if_data *sdata =
-@@ -1220,6 +1265,9 @@ static void ieee80211_iface_work(struct 
- 				break;
- 			ieee80211_mesh_rx_queued_mgmt(sdata, skb);
- 			break;
-+		case NL80211_IFTYPE_WDS:
-+			ieee80211_wds_rx_queued_mgmt(sdata, skb);
-+			break;
- 		default:
- 			WARN(1, "frame for unexpected interface type");
- 			break;
---- a/net/mac80211/rc80211_minstrel_ht.c
-+++ b/net/mac80211/rc80211_minstrel_ht.c
-@@ -804,10 +804,18 @@ minstrel_ht_get_rate(void *priv, struct 
- 
- 	sample_group = &minstrel_mcs_groups[sample_idx / MCS_GROUP_RATES];
- 	info->flags |= IEEE80211_TX_CTL_RATE_CTRL_PROBE;
-+	rate->count = 1;
-+
-+	if (sample_idx / MCS_GROUP_RATES == MINSTREL_CCK_GROUP) {
-+		int idx = sample_idx % ARRAY_SIZE(mp->cck_rates);
-+		rate->idx = mp->cck_rates[idx];
-+		rate->flags = 0;
-+		return;
-+	}
-+
- 	rate->idx = sample_idx % MCS_GROUP_RATES +
- 		    (sample_group->streams - 1) * MCS_GROUP_RATES;
- 	rate->flags = IEEE80211_TX_RC_MCS | sample_group->flags;
--	rate->count = 1;
- }
- 
- static void
---- a/net/mac80211/rx.c
-+++ b/net/mac80211/rx.c
-@@ -936,8 +936,14 @@ ieee80211_rx_h_check(struct ieee80211_rx
- 	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)rx->skb->data;
- 	struct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(rx->skb);
- 
--	/* Drop duplicate 802.11 retransmissions (IEEE 802.11 Chap. 9.2.9) */
--	if (rx->sta && !is_multicast_ether_addr(hdr->addr1)) {
-+	/*
-+	 * Drop duplicate 802.11 retransmissions
-+	 * (IEEE 802.11-2012: 9.3.2.10 "Duplicate detection and recovery")
-+	 */
-+	if (rx->skb->len >= 24 && rx->sta &&
-+	    !ieee80211_is_ctl(hdr->frame_control) &&
-+	    !ieee80211_is_qos_nullfunc(hdr->frame_control) &&
-+	    !is_multicast_ether_addr(hdr->addr1)) {
- 		if (unlikely(ieee80211_has_retry(hdr->frame_control) &&
- 			     rx->sta->last_seq_ctrl[rx->seqno_idx] ==
- 			     hdr->seq_ctrl)) {
-@@ -2369,6 +2375,7 @@ ieee80211_rx_h_action(struct ieee80211_r
- 		    sdata->vif.type != NL80211_IFTYPE_MESH_POINT &&
- 		    sdata->vif.type != NL80211_IFTYPE_AP_VLAN &&
- 		    sdata->vif.type != NL80211_IFTYPE_AP &&
-+		    sdata->vif.type != NL80211_IFTYPE_WDS &&
- 		    sdata->vif.type != NL80211_IFTYPE_ADHOC)
- 			break;
- 
-@@ -2720,14 +2727,15 @@ ieee80211_rx_h_mgmt(struct ieee80211_rx_
- 
- 	if (!ieee80211_vif_is_mesh(&sdata->vif) &&
- 	    sdata->vif.type != NL80211_IFTYPE_ADHOC &&
--	    sdata->vif.type != NL80211_IFTYPE_STATION)
-+	    sdata->vif.type != NL80211_IFTYPE_STATION &&
-+	    sdata->vif.type != NL80211_IFTYPE_WDS)
- 		return RX_DROP_MONITOR;
- 
- 	switch (stype) {
- 	case cpu_to_le16(IEEE80211_STYPE_AUTH):
- 	case cpu_to_le16(IEEE80211_STYPE_BEACON):
- 	case cpu_to_le16(IEEE80211_STYPE_PROBE_RESP):
--		/* process for all: mesh, mlme, ibss */
-+		/* process for all: mesh, mlme, ibss, wds */
- 		break;
- 	case cpu_to_le16(IEEE80211_STYPE_ASSOC_RESP):
- 	case cpu_to_le16(IEEE80211_STYPE_REASSOC_RESP):
-@@ -3008,6 +3016,9 @@ static int prepare_for_handlers(struct i
- 	case NL80211_IFTYPE_ADHOC:
- 		if (!bssid)
- 			return 0;
-+		if (ether_addr_equal(sdata->vif.addr, hdr->addr2) ||
-+		    ether_addr_equal(sdata->u.ibss.bssid, hdr->addr2))
-+			return 0;
- 		if (ieee80211_is_beacon(hdr->frame_control)) {
- 			return 1;
- 		} else if (!ieee80211_bssid_match(bssid, sdata->u.ibss.bssid)) {
-@@ -3059,10 +3070,16 @@ static int prepare_for_handlers(struct i
- 		}
- 		break;
- 	case NL80211_IFTYPE_WDS:
--		if (bssid || !ieee80211_is_data(hdr->frame_control))
--			return 0;
- 		if (!ether_addr_equal(sdata->u.wds.remote_addr, hdr->addr2))
- 			return 0;
-+
-+		if (ieee80211_is_data(hdr->frame_control) ||
-+		    ieee80211_is_action(hdr->frame_control)) {
-+			if (compare_ether_addr(sdata->vif.addr, hdr->addr1))
-+				return 0;
-+		} else if (!ieee80211_is_beacon(hdr->frame_control))
-+			return 0;
-+
- 		break;
- 	case NL80211_IFTYPE_P2P_DEVICE:
- 		if (!ieee80211_is_public_action(hdr, skb->len) &&
---- a/net/mac80211/sta_info.h
-+++ b/net/mac80211/sta_info.h
-@@ -32,7 +32,6 @@
-  * @WLAN_STA_SHORT_PREAMBLE: Station is capable of receiving short-preamble
-  *	frames.
-  * @WLAN_STA_WME: Station is a QoS-STA.
-- * @WLAN_STA_WDS: Station is one of our WDS peers.
-  * @WLAN_STA_CLEAR_PS_FILT: Clear PS filter in hardware (using the
-  *	IEEE80211_TX_CTL_CLEAR_PS_FILT control flag) when the next
-  *	frame to this station is transmitted.
-@@ -66,7 +65,6 @@ enum ieee80211_sta_info_flags {
- 	WLAN_STA_AUTHORIZED,
- 	WLAN_STA_SHORT_PREAMBLE,
- 	WLAN_STA_WME,
--	WLAN_STA_WDS,
- 	WLAN_STA_CLEAR_PS_FILT,
- 	WLAN_STA_MFP,
- 	WLAN_STA_BLOCK_BA,
---- a/drivers/net/wireless/ath/ath9k/xmit.c
-+++ b/drivers/net/wireless/ath/ath9k/xmit.c
-@@ -146,6 +146,28 @@ static void ath_set_rates(struct ieee802
- 			       ARRAY_SIZE(bf->rates));
- }
- 
-+static void ath_txq_skb_done(struct ath_softc *sc, struct ath_txq *txq,
-+			     struct sk_buff *skb)
-+{
-+	int q;
-+
-+	q = skb_get_queue_mapping(skb);
-+	if (txq == sc->tx.uapsdq)
-+		txq = sc->tx.txq_map[q];
-+
-+	if (txq != sc->tx.txq_map[q])
-+		return;
-+
-+	if (WARN_ON(--txq->pending_frames < 0))
-+		txq->pending_frames = 0;
-+
-+	if (txq->stopped &&
-+	    txq->pending_frames < sc->tx.txq_max_pending[q]) {
-+		ieee80211_wake_queue(sc->hw, q);
-+		txq->stopped = false;
-+	}
-+}
-+
- static void ath_tx_flush_tid(struct ath_softc *sc, struct ath_atx_tid *tid)
- {
- 	struct ath_txq *txq = tid->ac->txq;
-@@ -167,6 +189,7 @@ static void ath_tx_flush_tid(struct ath_
- 		if (!bf) {
- 			bf = ath_tx_setup_buffer(sc, txq, tid, skb);
- 			if (!bf) {
-+				ath_txq_skb_done(sc, txq, skb);
- 				ieee80211_free_txskb(sc->hw, skb);
- 				continue;
- 			}
-@@ -811,6 +834,7 @@ ath_tx_get_tid_subframe(struct ath_softc
- 
- 		if (!bf) {
- 			__skb_unlink(skb, &tid->buf_q);
-+			ath_txq_skb_done(sc, txq, skb);
- 			ieee80211_free_txskb(sc->hw, skb);
- 			continue;
- 		}
-@@ -1824,6 +1848,7 @@ static void ath_tx_send_ampdu(struct ath
- 
- 	bf = ath_tx_setup_buffer(sc, txq, tid, skb);
- 	if (!bf) {
-+		ath_txq_skb_done(sc, txq, skb);
- 		ieee80211_free_txskb(sc->hw, skb);
- 		return;
- 	}
-@@ -2090,6 +2115,7 @@ int ath_tx_start(struct ieee80211_hw *hw
- 
- 	bf = ath_tx_setup_buffer(sc, txq, tid, skb);
- 	if (!bf) {
-+		ath_txq_skb_done(sc, txq, skb);
- 		if (txctl->paprd)
- 			dev_kfree_skb_any(skb);
- 		else
-@@ -2189,7 +2215,7 @@ static void ath_tx_complete(struct ath_s
- 	struct ieee80211_tx_info *tx_info = IEEE80211_SKB_CB(skb);
- 	struct ath_common *common = ath9k_hw_common(sc->sc_ah);
- 	struct ieee80211_hdr * hdr = (struct ieee80211_hdr *)skb->data;
--	int q, padpos, padsize;
-+	int padpos, padsize;
- 	unsigned long flags;
- 
- 	ath_dbg(common, XMIT, "TX complete: skb: %p\n", skb);
-@@ -2225,21 +2251,7 @@ static void ath_tx_complete(struct ath_s
- 	spin_unlock_irqrestore(&sc->sc_pm_lock, flags);
- 
- 	__skb_queue_tail(&txq->complete_q, skb);
--
--	q = skb_get_queue_mapping(skb);
--	if (txq == sc->tx.uapsdq)
--		txq = sc->tx.txq_map[q];
--
--	if (txq == sc->tx.txq_map[q]) {
--		if (WARN_ON(--txq->pending_frames < 0))
--			txq->pending_frames = 0;
--
--		if (txq->stopped &&
--		    txq->pending_frames < sc->tx.txq_max_pending[q]) {
--			ieee80211_wake_queue(sc->hw, q);
--			txq->stopped = false;
--		}
--	}
-+	ath_txq_skb_done(sc, txq, skb);
- }
- 
- static void ath_tx_complete_buf(struct ath_softc *sc, struct ath_buf *bf,
---- a/drivers/net/wireless/ath/ath9k/main.c
-+++ b/drivers/net/wireless/ath/ath9k/main.c
-@@ -209,6 +209,7 @@ static bool ath_complete_reset(struct at
- 	struct ath_hw *ah = sc->sc_ah;
- 	struct ath_common *common = ath9k_hw_common(ah);
- 	unsigned long flags;
-+	int i;
- 
- 	if (ath_startrecv(sc) != 0) {
- 		ath_err(common, "Unable to restart recv logic\n");
-@@ -236,6 +237,15 @@ static bool ath_complete_reset(struct at
- 		}
- 	work:
- 		ath_restart_work(sc);
-+
-+		for (i = 0; i < ATH9K_NUM_TX_QUEUES; i++) {
-+			if (!ATH_TXQ_SETUP(sc, i))
-+				continue;
-+
-+			spin_lock_bh(&sc->tx.txq[i].axq_lock);
-+			ath_txq_schedule(sc, &sc->tx.txq[i]);
-+			spin_unlock_bh(&sc->tx.txq[i].axq_lock);
-+		}
- 	}
- 
- 	if ((ah->caps.hw_caps & ATH9K_HW_CAP_ANT_DIV_COMB) && sc->ant_rx != 3)
-@@ -543,21 +553,10 @@ chip_reset:
- 
- static int ath_reset(struct ath_softc *sc)
- {
--	int i, r;
-+	int r;
- 
- 	ath9k_ps_wakeup(sc);
--
- 	r = ath_reset_internal(sc, NULL);
--
--	for (i = 0; i < ATH9K_NUM_TX_QUEUES; i++) {
--		if (!ATH_TXQ_SETUP(sc, i))
--			continue;
--
--		spin_lock_bh(&sc->tx.txq[i].axq_lock);
--		ath_txq_schedule(sc, &sc->tx.txq[i]);
--		spin_unlock_bh(&sc->tx.txq[i].axq_lock);
--	}
--
- 	ath9k_ps_restore(sc);
- 
- 	return r;
-@@ -2094,7 +2093,7 @@ static void ath9k_wow_add_pattern(struct
- {
- 	struct ath_hw *ah = sc->sc_ah;
- 	struct ath9k_wow_pattern *wow_pattern = NULL;
--	struct cfg80211_wowlan_trig_pkt_pattern *patterns = wowlan->patterns;
-+	struct cfg80211_pkt_pattern *patterns = wowlan->patterns;
- 	int mask_len;
- 	s8 i = 0;
- 
---- a/drivers/net/wireless/mwifiex/cfg80211.c
-+++ b/drivers/net/wireless/mwifiex/cfg80211.c
-@@ -2298,8 +2298,7 @@ EXPORT_SYMBOL_GPL(mwifiex_del_virtual_in
- 
- #ifdef CONFIG_PM
- static bool
--mwifiex_is_pattern_supported(struct cfg80211_wowlan_trig_pkt_pattern *pat,
--			     s8 *byte_seq)
-+mwifiex_is_pattern_supported(struct cfg80211_pkt_pattern *pat, s8 *byte_seq)
- {
- 	int j, k, valid_byte_cnt = 0;
- 	bool dont_care_byte = false;
---- a/drivers/net/wireless/ti/wlcore/main.c
-+++ b/drivers/net/wireless/ti/wlcore/main.c
-@@ -1315,7 +1315,7 @@ static struct sk_buff *wl12xx_alloc_dumm
- 
- #ifdef CONFIG_PM
- static int
--wl1271_validate_wowlan_pattern(struct cfg80211_wowlan_trig_pkt_pattern *p)
-+wl1271_validate_wowlan_pattern(struct cfg80211_pkt_pattern *p)
- {
- 	int num_fields = 0, in_field = 0, fields_size = 0;
- 	int i, pattern_len = 0;
-@@ -1458,9 +1458,9 @@ void wl1271_rx_filter_flatten_fields(str
-  * Allocates an RX filter returned through f
-  * which needs to be freed using rx_filter_free()
-  */
--static int wl1271_convert_wowlan_pattern_to_rx_filter(
--	struct cfg80211_wowlan_trig_pkt_pattern *p,
--	struct wl12xx_rx_filter **f)
-+static int
-+wl1271_convert_wowlan_pattern_to_rx_filter(struct cfg80211_pkt_pattern *p,
-+					   struct wl12xx_rx_filter **f)
- {
- 	int i, j, ret = 0;
- 	struct wl12xx_rx_filter *filter;
-@@ -1562,7 +1562,7 @@ static int wl1271_configure_wowlan(struc
- 
- 	/* Translate WoWLAN patterns into filters */
- 	for (i = 0; i < wow->n_patterns; i++) {
--		struct cfg80211_wowlan_trig_pkt_pattern *p;
-+		struct cfg80211_pkt_pattern *p;
- 		struct wl12xx_rx_filter *filter = NULL;
- 
- 		p = &wow->patterns[i];
---- a/include/net/cfg80211.h
-+++ b/include/net/cfg80211.h
-@@ -1698,7 +1698,7 @@ struct cfg80211_pmksa {
- };
- 
- /**
-- * struct cfg80211_wowlan_trig_pkt_pattern - packet pattern
-+ * struct cfg80211_pkt_pattern - packet pattern
-  * @mask: bitmask where to match pattern and where to ignore bytes,
-  *	one bit per byte, in same format as nl80211
-  * @pattern: bytes to match where bitmask is 1
-@@ -1708,7 +1708,7 @@ struct cfg80211_pmksa {
-  * Internal note: @mask and @pattern are allocated in one chunk of
-  * memory, free @mask only!
-  */
--struct cfg80211_wowlan_trig_pkt_pattern {
-+struct cfg80211_pkt_pattern {
- 	u8 *mask, *pattern;
- 	int pattern_len;
- 	int pkt_offset;
-@@ -1770,7 +1770,7 @@ struct cfg80211_wowlan {
- 	bool any, disconnect, magic_pkt, gtk_rekey_failure,
- 	     eap_identity_req, four_way_handshake,
- 	     rfkill_release;
--	struct cfg80211_wowlan_trig_pkt_pattern *patterns;
-+	struct cfg80211_pkt_pattern *patterns;
- 	struct cfg80211_wowlan_tcp *tcp;
- 	int n_patterns;
- };
---- a/include/uapi/linux/nl80211.h
-+++ b/include/uapi/linux/nl80211.h
-@@ -3060,11 +3060,11 @@ enum nl80211_tx_power_setting {
- };
- 
- /**
-- * enum nl80211_wowlan_packet_pattern_attr - WoWLAN packet pattern attribute
-- * @__NL80211_WOWLAN_PKTPAT_INVALID: invalid number for nested attribute
-- * @NL80211_WOWLAN_PKTPAT_PATTERN: the pattern, values where the mask has
-+ * enum nl80211_packet_pattern_attr - packet pattern attribute
-+ * @__NL80211_PKTPAT_INVALID: invalid number for nested attribute
-+ * @NL80211_PKTPAT_PATTERN: the pattern, values where the mask has
-  *	a zero bit are ignored
-- * @NL80211_WOWLAN_PKTPAT_MASK: pattern mask, must be long enough to have
-+ * @NL80211_PKTPAT_MASK: pattern mask, must be long enough to have
-  *	a bit for each byte in the pattern. The lowest-order bit corresponds
-  *	to the first byte of the pattern, but the bytes of the pattern are
-  *	in a little-endian-like format, i.e. the 9th byte of the pattern
-@@ -3075,23 +3075,23 @@ enum nl80211_tx_power_setting {
-  *	Note that the pattern matching is done as though frames were not
-  *	802.11 frames but 802.3 frames, i.e. the frame is fully unpacked
-  *	first (including SNAP header unpacking) and then matched.
-- * @NL80211_WOWLAN_PKTPAT_OFFSET: packet offset, pattern is matched after
-+ * @NL80211_PKTPAT_OFFSET: packet offset, pattern is matched after
-  *	these fixed number of bytes of received packet
-- * @NUM_NL80211_WOWLAN_PKTPAT: number of attributes
-- * @MAX_NL80211_WOWLAN_PKTPAT: max attribute number
-+ * @NUM_NL80211_PKTPAT: number of attributes
-+ * @MAX_NL80211_PKTPAT: max attribute number
-  */
--enum nl80211_wowlan_packet_pattern_attr {
--	__NL80211_WOWLAN_PKTPAT_INVALID,
--	NL80211_WOWLAN_PKTPAT_MASK,
--	NL80211_WOWLAN_PKTPAT_PATTERN,
--	NL80211_WOWLAN_PKTPAT_OFFSET,
-+enum nl80211_packet_pattern_attr {
-+	__NL80211_PKTPAT_INVALID,
-+	NL80211_PKTPAT_MASK,
-+	NL80211_PKTPAT_PATTERN,
-+	NL80211_PKTPAT_OFFSET,
- 
--	NUM_NL80211_WOWLAN_PKTPAT,
--	MAX_NL80211_WOWLAN_PKTPAT = NUM_NL80211_WOWLAN_PKTPAT - 1,
-+	NUM_NL80211_PKTPAT,
-+	MAX_NL80211_PKTPAT = NUM_NL80211_PKTPAT - 1,
- };
- 
- /**
-- * struct nl80211_wowlan_pattern_support - pattern support information
-+ * struct nl80211_pattern_support - packet pattern support information
-  * @max_patterns: maximum number of patterns supported
-  * @min_pattern_len: minimum length of each pattern
-  * @max_pattern_len: maximum length of each pattern
-@@ -3101,13 +3101,22 @@ enum nl80211_wowlan_packet_pattern_attr 
-  * that is part of %NL80211_ATTR_WOWLAN_TRIGGERS_SUPPORTED in the
-  * capability information given by the kernel to userspace.
-  */
--struct nl80211_wowlan_pattern_support {
-+struct nl80211_pattern_support {
- 	__u32 max_patterns;
- 	__u32 min_pattern_len;
- 	__u32 max_pattern_len;
- 	__u32 max_pkt_offset;
- } __attribute__((packed));
- 
-+/* only for backward compatibility */
-+#define __NL80211_WOWLAN_PKTPAT_INVALID __NL80211_PKTPAT_INVALID
-+#define NL80211_WOWLAN_PKTPAT_MASK NL80211_PKTPAT_MASK
-+#define NL80211_WOWLAN_PKTPAT_PATTERN NL80211_PKTPAT_PATTERN
-+#define NL80211_WOWLAN_PKTPAT_OFFSET NL80211_PKTPAT_OFFSET
-+#define NUM_NL80211_WOWLAN_PKTPAT NUM_NL80211_PKTPAT
-+#define MAX_NL80211_WOWLAN_PKTPAT MAX_NL80211_PKTPAT
-+#define nl80211_wowlan_pattern_support nl80211_pattern_support
-+
- /**
-  * enum nl80211_wowlan_triggers - WoWLAN trigger definitions
-  * @__NL80211_WOWLAN_TRIG_INVALID: invalid number for nested attributes
-@@ -3127,7 +3136,7 @@ struct nl80211_wowlan_pattern_support {
-  *	pattern matching is done after the packet is converted to the MSDU.
-  *
-  *	In %NL80211_ATTR_WOWLAN_TRIGGERS_SUPPORTED, it is a binary attribute
-- *	carrying a &struct nl80211_wowlan_pattern_support.
-+ *	carrying a &struct nl80211_pattern_support.
-  *
-  *	When reporting wakeup. it is a u32 attribute containing the 0-based
-  *	index of the pattern that caused the wakeup, in the patterns passed
-@@ -3284,7 +3293,7 @@ struct nl80211_wowlan_tcp_data_token_fea
-  * @NL80211_WOWLAN_TCP_WAKE_PAYLOAD: wake packet payload, for advertising a
-  *	u32 attribute holding the maximum length
-  * @NL80211_WOWLAN_TCP_WAKE_MASK: Wake packet payload mask, not used for
-- *	feature advertising. The mask works like @NL80211_WOWLAN_PKTPAT_MASK
-+ *	feature advertising. The mask works like @NL80211_PKTPAT_MASK
-  *	but on the TCP payload only.
-  * @NUM_NL80211_WOWLAN_TCP: number of TCP attributes
-  * @MAX_NL80211_WOWLAN_TCP: highest attribute number
---- a/net/mac80211/mesh_ps.c
-+++ b/net/mac80211/mesh_ps.c
-@@ -229,6 +229,10 @@ void ieee80211_mps_sta_status_update(str
- 	enum nl80211_mesh_power_mode pm;
- 	bool do_buffer;
- 
-+	/* For non-assoc STA, prevent buffering or frame transmission */
-+	if (sta->sta_state < IEEE80211_STA_ASSOC)
-+		return;
-+
- 	/*
- 	 * use peer-specific power mode if peering is established and the
- 	 * peer's power mode is known
---- a/net/wireless/nl80211.c
-+++ b/net/wireless/nl80211.c
-@@ -441,10 +441,12 @@ static int nl80211_prepare_wdev_dump(str
- 			goto out_unlock;
- 		}
- 		*rdev = wiphy_to_dev((*wdev)->wiphy);
--		cb->args[0] = (*rdev)->wiphy_idx;
-+		/* 0 is the first index - add 1 to parse only once */
-+		cb->args[0] = (*rdev)->wiphy_idx + 1;
- 		cb->args[1] = (*wdev)->identifier;
- 	} else {
--		struct wiphy *wiphy = wiphy_idx_to_wiphy(cb->args[0]);
-+		/* subtract the 1 again here */
-+		struct wiphy *wiphy = wiphy_idx_to_wiphy(cb->args[0] - 1);
- 		struct wireless_dev *tmp;
- 
- 		if (!wiphy) {
-@@ -974,7 +976,7 @@ static int nl80211_send_wowlan(struct sk
- 		return -ENOBUFS;
- 
- 	if (dev->wiphy.wowlan->n_patterns) {
--		struct nl80211_wowlan_pattern_support pat = {
-+		struct nl80211_pattern_support pat = {
- 			.max_patterns = dev->wiphy.wowlan->n_patterns,
- 			.min_pattern_len = dev->wiphy.wowlan->pattern_min_len,
- 			.max_pattern_len = dev->wiphy.wowlan->pattern_max_len,
-@@ -1568,8 +1570,10 @@ static int nl80211_dump_wiphy(struct sk_
- 	rtnl_lock();
- 	if (!state) {
- 		state = kzalloc(sizeof(*state), GFP_KERNEL);
--		if (!state)
-+		if (!state) {
-+			rtnl_unlock();
- 			return -ENOMEM;
-+		}
- 		state->filter_wiphy = -1;
- 		ret = nl80211_dump_wiphy_parse(skb, cb, state);
- 		if (ret) {
-@@ -6615,12 +6619,14 @@ EXPORT_SYMBOL(cfg80211_testmode_alloc_ev
- 
- void cfg80211_testmode_event(struct sk_buff *skb, gfp_t gfp)
- {
-+	struct cfg80211_registered_device *rdev = ((void **)skb->cb)[0];
- 	void *hdr = ((void **)skb->cb)[1];
- 	struct nlattr *data = ((void **)skb->cb)[2];
- 
- 	nla_nest_end(skb, data);
- 	genlmsg_end(skb, hdr);
--	genlmsg_multicast(skb, 0, nl80211_testmode_mcgrp.id, gfp);
-+	genlmsg_multicast_netns(wiphy_net(&rdev->wiphy), skb, 0,
-+				nl80211_testmode_mcgrp.id, gfp);
- }
- EXPORT_SYMBOL(cfg80211_testmode_event);
- #endif
-@@ -7593,12 +7599,11 @@ static int nl80211_send_wowlan_patterns(
- 		if (!nl_pat)
- 			return -ENOBUFS;
- 		pat_len = wowlan->patterns[i].pattern_len;
--		if (nla_put(msg, NL80211_WOWLAN_PKTPAT_MASK,
--			    DIV_ROUND_UP(pat_len, 8),
-+		if (nla_put(msg, NL80211_PKTPAT_MASK, DIV_ROUND_UP(pat_len, 8),
- 			    wowlan->patterns[i].mask) ||
--		    nla_put(msg, NL80211_WOWLAN_PKTPAT_PATTERN,
--			    pat_len, wowlan->patterns[i].pattern) ||
--		    nla_put_u32(msg, NL80211_WOWLAN_PKTPAT_OFFSET,
-+		    nla_put(msg, NL80211_PKTPAT_PATTERN, pat_len,
-+			    wowlan->patterns[i].pattern) ||
-+		    nla_put_u32(msg, NL80211_PKTPAT_OFFSET,
- 				wowlan->patterns[i].pkt_offset))
- 			return -ENOBUFS;
- 		nla_nest_end(msg, nl_pat);
-@@ -7939,7 +7944,7 @@ static int nl80211_set_wowlan(struct sk_
- 		struct nlattr *pat;
- 		int n_patterns = 0;
- 		int rem, pat_len, mask_len, pkt_offset;
--		struct nlattr *pat_tb[NUM_NL80211_WOWLAN_PKTPAT];
-+		struct nlattr *pat_tb[NUM_NL80211_PKTPAT];
- 
- 		nla_for_each_nested(pat, tb[NL80211_WOWLAN_TRIG_PKT_PATTERN],
- 				    rem)
-@@ -7958,26 +7963,25 @@ static int nl80211_set_wowlan(struct sk_
- 
- 		nla_for_each_nested(pat, tb[NL80211_WOWLAN_TRIG_PKT_PATTERN],
- 				    rem) {
--			nla_parse(pat_tb, MAX_NL80211_WOWLAN_PKTPAT,
--				  nla_data(pat), nla_len(pat), NULL);
-+			nla_parse(pat_tb, MAX_NL80211_PKTPAT, nla_data(pat),
-+				  nla_len(pat), NULL);
- 			err = -EINVAL;
--			if (!pat_tb[NL80211_WOWLAN_PKTPAT_MASK] ||
--			    !pat_tb[NL80211_WOWLAN_PKTPAT_PATTERN])
-+			if (!pat_tb[NL80211_PKTPAT_MASK] ||
-+			    !pat_tb[NL80211_PKTPAT_PATTERN])
- 				goto error;
--			pat_len = nla_len(pat_tb[NL80211_WOWLAN_PKTPAT_PATTERN]);
-+			pat_len = nla_len(pat_tb[NL80211_PKTPAT_PATTERN]);
- 			mask_len = DIV_ROUND_UP(pat_len, 8);
--			if (nla_len(pat_tb[NL80211_WOWLAN_PKTPAT_MASK]) !=
--			    mask_len)
-+			if (nla_len(pat_tb[NL80211_PKTPAT_MASK]) != mask_len)
- 				goto error;
- 			if (pat_len > wowlan->pattern_max_len ||
- 			    pat_len < wowlan->pattern_min_len)
- 				goto error;
- 
--			if (!pat_tb[NL80211_WOWLAN_PKTPAT_OFFSET])
-+			if (!pat_tb[NL80211_PKTPAT_OFFSET])
- 				pkt_offset = 0;
- 			else
- 				pkt_offset = nla_get_u32(
--					pat_tb[NL80211_WOWLAN_PKTPAT_OFFSET]);
-+					pat_tb[NL80211_PKTPAT_OFFSET]);
- 			if (pkt_offset > wowlan->max_pkt_offset)
- 				goto error;
- 			new_triggers.patterns[i].pkt_offset = pkt_offset;
-@@ -7991,11 +7995,11 @@ static int nl80211_set_wowlan(struct sk_
- 			new_triggers.patterns[i].pattern =
- 				new_triggers.patterns[i].mask + mask_len;
- 			memcpy(new_triggers.patterns[i].mask,
--			       nla_data(pat_tb[NL80211_WOWLAN_PKTPAT_MASK]),
-+			       nla_data(pat_tb[NL80211_PKTPAT_MASK]),
- 			       mask_len);
- 			new_triggers.patterns[i].pattern_len = pat_len;
- 			memcpy(new_triggers.patterns[i].pattern,
--			       nla_data(pat_tb[NL80211_WOWLAN_PKTPAT_PATTERN]),
-+			       nla_data(pat_tb[NL80211_PKTPAT_PATTERN]),
- 			       pat_len);
- 			i++;
- 		}
-@@ -10066,7 +10070,8 @@ void cfg80211_mgmt_tx_status(struct wire
- 
- 	genlmsg_end(msg, hdr);
- 
--	genlmsg_multicast(msg, 0, nl80211_mlme_mcgrp.id, gfp);
-+	genlmsg_multicast_netns(wiphy_net(&rdev->wiphy), msg, 0,
-+				nl80211_mlme_mcgrp.id, gfp);
- 	return;
- 
-  nla_put_failure:
---- a/net/wireless/reg.c
-+++ b/net/wireless/reg.c
-@@ -2247,10 +2247,13 @@ int reg_device_uevent(struct device *dev
- 
- void wiphy_regulatory_register(struct wiphy *wiphy)
- {
-+	struct regulatory_request *lr;
-+
- 	if (!reg_dev_ignore_cell_hint(wiphy))
- 		reg_num_devs_support_basehint++;
- 
--	wiphy_update_regulatory(wiphy, NL80211_REGDOM_SET_BY_CORE);
-+	lr = get_last_request();
-+	wiphy_update_regulatory(wiphy, lr->initiator);
- }
- 
- void wiphy_regulatory_deregister(struct wiphy *wiphy)
-@@ -2279,7 +2282,9 @@ void wiphy_regulatory_deregister(struct 
- static void reg_timeout_work(struct work_struct *work)
- {
- 	REG_DBG_PRINT("Timeout while waiting for CRDA to reply, restoring regulatory settings\n");
-+	rtnl_lock();
- 	restore_regulatory_settings(true);
-+	rtnl_unlock();
- }
- 
- int __init regulatory_init(void)
---- a/net/wireless/sme.c
-+++ b/net/wireless/sme.c
-@@ -34,8 +34,10 @@ struct cfg80211_conn {
- 		CFG80211_CONN_SCAN_AGAIN,
- 		CFG80211_CONN_AUTHENTICATE_NEXT,
- 		CFG80211_CONN_AUTHENTICATING,
-+		CFG80211_CONN_AUTH_FAILED,
- 		CFG80211_CONN_ASSOCIATE_NEXT,
- 		CFG80211_CONN_ASSOCIATING,
-+		CFG80211_CONN_ASSOC_FAILED,
- 		CFG80211_CONN_DEAUTH,
- 		CFG80211_CONN_CONNECTED,
- 	} state;
-@@ -164,6 +166,8 @@ static int cfg80211_conn_do_work(struct 
- 					  NULL, 0,
- 					  params->key, params->key_len,
- 					  params->key_idx, NULL, 0);
-+	case CFG80211_CONN_AUTH_FAILED:
-+		return -ENOTCONN;
- 	case CFG80211_CONN_ASSOCIATE_NEXT:
- 		BUG_ON(!rdev->ops->assoc);
- 		wdev->conn->state = CFG80211_CONN_ASSOCIATING;
-@@ -188,10 +192,17 @@ static int cfg80211_conn_do_work(struct 
- 					     WLAN_REASON_DEAUTH_LEAVING,
- 					     false);
- 		return err;
-+	case CFG80211_CONN_ASSOC_FAILED:
-+		cfg80211_mlme_deauth(rdev, wdev->netdev, params->bssid,
-+				     NULL, 0,
-+				     WLAN_REASON_DEAUTH_LEAVING, false);
-+		return -ENOTCONN;
- 	case CFG80211_CONN_DEAUTH:
- 		cfg80211_mlme_deauth(rdev, wdev->netdev, params->bssid,
- 				     NULL, 0,
- 				     WLAN_REASON_DEAUTH_LEAVING, false);
-+		/* free directly, disconnected event already sent */
-+		cfg80211_sme_free(wdev);
- 		return 0;
- 	default:
- 		return 0;
-@@ -371,7 +382,7 @@ bool cfg80211_sme_rx_assoc_resp(struct w
- 		return true;
- 	}
- 
--	wdev->conn->state = CFG80211_CONN_DEAUTH;
-+	wdev->conn->state = CFG80211_CONN_ASSOC_FAILED;
- 	schedule_work(&rdev->conn_work);
- 	return false;
- }
-@@ -383,7 +394,13 @@ void cfg80211_sme_deauth(struct wireless
- 
- void cfg80211_sme_auth_timeout(struct wireless_dev *wdev)
- {
--	cfg80211_sme_free(wdev);
-+	struct cfg80211_registered_device *rdev = wiphy_to_dev(wdev->wiphy);
-+
-+	if (!wdev->conn)
-+		return;
-+
-+	wdev->conn->state = CFG80211_CONN_AUTH_FAILED;
-+	schedule_work(&rdev->conn_work);
- }
- 
- void cfg80211_sme_disassoc(struct wireless_dev *wdev)
-@@ -399,7 +416,13 @@ void cfg80211_sme_disassoc(struct wirele
- 
- void cfg80211_sme_assoc_timeout(struct wireless_dev *wdev)
- {
--	cfg80211_sme_disassoc(wdev);
-+	struct cfg80211_registered_device *rdev = wiphy_to_dev(wdev->wiphy);
-+
-+	if (!wdev->conn)
-+		return;
-+
-+	wdev->conn->state = CFG80211_CONN_ASSOC_FAILED;
-+	schedule_work(&rdev->conn_work);
- }
- 
- static int cfg80211_sme_connect(struct wireless_dev *wdev,
---- a/net/mac80211/rc80211_minstrel.c
-+++ b/net/mac80211/rc80211_minstrel.c
-@@ -290,7 +290,7 @@ minstrel_get_rate(void *priv, struct iee
- 	struct minstrel_rate *msr, *mr;
- 	unsigned int ndx;
- 	bool mrr_capable;
--	bool prev_sample = mi->prev_sample;
-+	bool prev_sample;
- 	int delta;
- 	int sampling_ratio;
- 
-@@ -314,6 +314,7 @@ minstrel_get_rate(void *priv, struct iee
- 			(mi->sample_count + mi->sample_deferred / 2);
- 
- 	/* delta < 0: no sampling required */
-+	prev_sample = mi->prev_sample;
- 	mi->prev_sample = false;
- 	if (delta < 0 || (!mrr_capable && prev_sample))
- 		return;
---- a/drivers/net/wireless/rt2x00/rt2x00queue.c
-+++ b/drivers/net/wireless/rt2x00/rt2x00queue.c
-@@ -936,13 +936,8 @@ void rt2x00queue_index_inc(struct queue_
- 	spin_unlock_irqrestore(&queue->index_lock, irqflags);
- }
- 
--void rt2x00queue_pause_queue(struct data_queue *queue)
-+void rt2x00queue_pause_queue_nocheck(struct data_queue *queue)
- {
--	if (!test_bit(DEVICE_STATE_PRESENT, &queue->rt2x00dev->flags) ||
--	    !test_bit(QUEUE_STARTED, &queue->flags) ||
--	    test_and_set_bit(QUEUE_PAUSED, &queue->flags))
--		return;
--
- 	switch (queue->qid) {
- 	case QID_AC_VO:
- 	case QID_AC_VI:
-@@ -958,6 +953,15 @@ void rt2x00queue_pause_queue(struct data
- 		break;
- 	}
- }
-+void rt2x00queue_pause_queue(struct data_queue *queue)
-+{
-+	if (!test_bit(DEVICE_STATE_PRESENT, &queue->rt2x00dev->flags) ||
-+	    !test_bit(QUEUE_STARTED, &queue->flags) ||
-+	    test_and_set_bit(QUEUE_PAUSED, &queue->flags))
-+		return;
-+
-+	rt2x00queue_pause_queue_nocheck(queue);
-+}
- EXPORT_SYMBOL_GPL(rt2x00queue_pause_queue);
- 
- void rt2x00queue_unpause_queue(struct data_queue *queue)
-@@ -1019,7 +1023,7 @@ void rt2x00queue_stop_queue(struct data_
- 		return;
- 	}
- 
--	rt2x00queue_pause_queue(queue);
-+	rt2x00queue_pause_queue_nocheck(queue);
- 
- 	queue->rt2x00dev->ops->lib->stop_queue(queue);
- 
---- a/net/mac80211/mlme.c
-+++ b/net/mac80211/mlme.c
-@@ -31,10 +31,12 @@
- #include "led.h"
- 
- #define IEEE80211_AUTH_TIMEOUT		(HZ / 5)
-+#define IEEE80211_AUTH_TIMEOUT_LONG	(HZ / 2)
- #define IEEE80211_AUTH_TIMEOUT_SHORT	(HZ / 10)
- #define IEEE80211_AUTH_MAX_TRIES	3
- #define IEEE80211_AUTH_WAIT_ASSOC	(HZ * 5)
- #define IEEE80211_ASSOC_TIMEOUT		(HZ / 5)
-+#define IEEE80211_ASSOC_TIMEOUT_LONG	(HZ / 2)
- #define IEEE80211_ASSOC_TIMEOUT_SHORT	(HZ / 10)
- #define IEEE80211_ASSOC_MAX_TRIES	3
- 
-@@ -209,8 +211,9 @@ ieee80211_determine_chantype(struct ieee
- 			     struct ieee80211_channel *channel,
- 			     const struct ieee80211_ht_operation *ht_oper,
- 			     const struct ieee80211_vht_operation *vht_oper,
--			     struct cfg80211_chan_def *chandef, bool verbose)
-+			     struct cfg80211_chan_def *chandef, bool tracking)
- {
-+	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
- 	struct cfg80211_chan_def vht_chandef;
- 	u32 ht_cfreq, ret;
- 
-@@ -229,7 +232,7 @@ ieee80211_determine_chantype(struct ieee
- 	ht_cfreq = ieee80211_channel_to_frequency(ht_oper->primary_chan,
- 						  channel->band);
- 	/* check that channel matches the right operating channel */
--	if (channel->center_freq != ht_cfreq) {
-+	if (!tracking && channel->center_freq != ht_cfreq) {
- 		/*
- 		 * It's possible that some APs are confused here;
- 		 * Netgear WNDR3700 sometimes reports 4 higher than
-@@ -237,11 +240,10 @@ ieee80211_determine_chantype(struct ieee
- 		 * since we look at probe response/beacon data here
- 		 * it should be OK.
- 		 */
--		if (verbose)
--			sdata_info(sdata,
--				   "Wrong control channel: center-freq: %d ht-cfreq: %d ht->primary_chan: %d band: %d - Disabling HT\n",
--				   channel->center_freq, ht_cfreq,
--				   ht_oper->primary_chan, channel->band);
-+		sdata_info(sdata,
-+			   "Wrong control channel: center-freq: %d ht-cfreq: %d ht->primary_chan: %d band: %d - Disabling HT\n",
-+			   channel->center_freq, ht_cfreq,
-+			   ht_oper->primary_chan, channel->band);
- 		ret = IEEE80211_STA_DISABLE_HT | IEEE80211_STA_DISABLE_VHT;
- 		goto out;
- 	}
-@@ -295,7 +297,7 @@ ieee80211_determine_chantype(struct ieee
- 				channel->band);
- 		break;
- 	default:
--		if (verbose)
-+		if (!(ifmgd->flags & IEEE80211_STA_DISABLE_VHT))
- 			sdata_info(sdata,
- 				   "AP VHT operation IE has invalid channel width (%d), disable VHT\n",
- 				   vht_oper->chan_width);
-@@ -304,7 +306,7 @@ ieee80211_determine_chantype(struct ieee
- 	}
- 
- 	if (!cfg80211_chandef_valid(&vht_chandef)) {
--		if (verbose)
-+		if (!(ifmgd->flags & IEEE80211_STA_DISABLE_VHT))
- 			sdata_info(sdata,
- 				   "AP VHT information is invalid, disable VHT\n");
- 		ret = IEEE80211_STA_DISABLE_VHT;
-@@ -317,7 +319,7 @@ ieee80211_determine_chantype(struct ieee
- 	}
- 
- 	if (!cfg80211_chandef_compatible(chandef, &vht_chandef)) {
--		if (verbose)
-+		if (!(ifmgd->flags & IEEE80211_STA_DISABLE_VHT))
- 			sdata_info(sdata,
- 				   "AP VHT information doesn't match HT, disable VHT\n");
- 		ret = IEEE80211_STA_DISABLE_VHT;
-@@ -333,18 +335,27 @@ out:
- 	if (ret & IEEE80211_STA_DISABLE_VHT)
- 		vht_chandef = *chandef;
- 
-+	/*
-+	 * Ignore the DISABLED flag when we're already connected and only
-+	 * tracking the APs beacon for bandwidth changes - otherwise we
-+	 * might get disconnected here if we connect to an AP, update our
-+	 * regulatory information based on the AP's country IE and the
-+	 * information we have is wrong/outdated and disables the channel
-+	 * that we're actually using for the connection to the AP.
-+	 */
- 	while (!cfg80211_chandef_usable(sdata->local->hw.wiphy, chandef,
--					IEEE80211_CHAN_DISABLED)) {
-+					tracking ? 0 :
-+						   IEEE80211_CHAN_DISABLED)) {
- 		if (WARN_ON(chandef->width == NL80211_CHAN_WIDTH_20_NOHT)) {
- 			ret = IEEE80211_STA_DISABLE_HT |
- 			      IEEE80211_STA_DISABLE_VHT;
--			goto out;
-+			break;
- 		}
- 
- 		ret |= chandef_downgrade(chandef);
- 	}
- 
--	if (chandef->width != vht_chandef.width && verbose)
-+	if (chandef->width != vht_chandef.width && !tracking)
- 		sdata_info(sdata,
- 			   "capabilities/regulatory prevented using AP HT/VHT configuration, downgraded\n");
- 
-@@ -384,7 +395,7 @@ static int ieee80211_config_bw(struct ie
- 
- 	/* calculate new channel (type) based on HT/VHT operation IEs */
- 	flags = ieee80211_determine_chantype(sdata, sband, chan, ht_oper,
--					     vht_oper, &chandef, false);
-+					     vht_oper, &chandef, true);
- 
- 	/*
- 	 * Downgrade the new channel if we associated with restricted
-@@ -3394,10 +3405,13 @@ static int ieee80211_probe_auth(struct i
- 
- 	if (tx_flags == 0) {
- 		auth_data->timeout = jiffies + IEEE80211_AUTH_TIMEOUT;
--		ifmgd->auth_data->timeout_started = true;
-+		auth_data->timeout_started = true;
- 		run_again(sdata, auth_data->timeout);
- 	} else {
--		auth_data->timeout_started = false;
-+		auth_data->timeout =
-+			round_jiffies_up(jiffies + IEEE80211_AUTH_TIMEOUT_LONG);
-+		auth_data->timeout_started = true;
-+		run_again(sdata, auth_data->timeout);
- 	}
- 
- 	return 0;
-@@ -3434,7 +3448,11 @@ static int ieee80211_do_assoc(struct iee
- 		assoc_data->timeout_started = true;
- 		run_again(sdata, assoc_data->timeout);
- 	} else {
--		assoc_data->timeout_started = false;
-+		assoc_data->timeout =
-+			round_jiffies_up(jiffies +
-+					 IEEE80211_ASSOC_TIMEOUT_LONG);
-+		assoc_data->timeout_started = true;
-+		run_again(sdata, assoc_data->timeout);
- 	}
- 
- 	return 0;
-@@ -3829,7 +3847,7 @@ static int ieee80211_prep_channel(struct
- 	ifmgd->flags |= ieee80211_determine_chantype(sdata, sband,
- 						     cbss->channel,
- 						     ht_oper, vht_oper,
--						     &chandef, true);
-+						     &chandef, false);
- 
- 	sdata->needed_rx_chains = min(ieee80211_ht_vht_rx_chains(sdata, cbss),
- 				      local->rx_chains);
---- a/net/wireless/core.c
-+++ b/net/wireless/core.c
-@@ -772,6 +772,7 @@ void cfg80211_leave(struct cfg80211_regi
- 		cfg80211_leave_mesh(rdev, dev);
- 		break;
- 	case NL80211_IFTYPE_AP:
-+	case NL80211_IFTYPE_P2P_GO:
- 		cfg80211_stop_ap(rdev, dev);
- 		break;
- 	default:
---- a/drivers/net/wireless/rt2x00/rt2800lib.c
-+++ b/drivers/net/wireless/rt2x00/rt2800lib.c
-@@ -5404,19 +5404,20 @@ int rt2800_enable_radio(struct rt2x00_de
- 		     rt2800_init_registers(rt2x00dev)))
- 		return -EIO;
- 
-+	if (unlikely(rt2800_wait_bbp_rf_ready(rt2x00dev)))
-+		return -EIO;
-+
- 	/*
- 	 * Send signal to firmware during boot time.
- 	 */
- 	rt2800_register_write(rt2x00dev, H2M_BBP_AGENT, 0);
- 	rt2800_register_write(rt2x00dev, H2M_MAILBOX_CSR, 0);
--	if (rt2x00_is_usb(rt2x00dev)) {
-+	if (rt2x00_is_usb(rt2x00dev))
- 		rt2800_register_write(rt2x00dev, H2M_INT_SRC, 0);
--		rt2800_mcu_request(rt2x00dev, MCU_BOOT_SIGNAL, 0, 0, 0);
--	}
-+	rt2800_mcu_request(rt2x00dev, MCU_BOOT_SIGNAL, 0, 0, 0);
- 	msleep(1);
- 
--	if (unlikely(rt2800_wait_bbp_rf_ready(rt2x00dev) ||
--		     rt2800_wait_bbp_ready(rt2x00dev)))
-+	if (unlikely(rt2800_wait_bbp_ready(rt2x00dev)))
- 		return -EIO;
- 
- 	rt2800_init_bbp(rt2x00dev);
---- a/net/mac80211/main.c
-+++ b/net/mac80211/main.c
-@@ -101,7 +101,7 @@ static u32 ieee80211_hw_conf_chan(struct
- 	struct ieee80211_sub_if_data *sdata;
- 	struct cfg80211_chan_def chandef = {};
- 	u32 changed = 0;
--	int power;
-+	int power = 0;
- 	u32 offchannel_flag;
- 
- 	offchannel_flag = local->hw.conf.flags & IEEE80211_CONF_OFFCHANNEL;
-@@ -155,16 +155,16 @@ static u32 ieee80211_hw_conf_chan(struct
- 		changed |= IEEE80211_CONF_CHANGE_SMPS;
- 	}
- 
--	power = chandef.chan->max_power;
--
- 	rcu_read_lock();
- 	list_for_each_entry_rcu(sdata, &local->interfaces, list) {
- 		if (!rcu_access_pointer(sdata->vif.chanctx_conf))
- 			continue;
--		power = min(power, sdata->vif.bss_conf.txpower);
-+		power = max(power, sdata->vif.bss_conf.txpower);
- 	}
- 	rcu_read_unlock();
- 
-+	power = min(power, chandef.chan->max_power);
-+
- 	if (local->hw.conf.power_level != power) {
- 		changed |= IEEE80211_CONF_CHANGE_POWER;
- 		local->hw.conf.power_level = power;
---- a/net/mac80211/cfg.c
-+++ b/net/mac80211/cfg.c
-@@ -3332,7 +3332,7 @@ static int ieee80211_probe_client(struct
- 		return -EINVAL;
- 	}
- 	band = chanctx_conf->def.chan->band;
--	sta = sta_info_get(sdata, peer);
-+	sta = sta_info_get_bss(sdata, peer);
- 	if (sta) {
- 		qos = test_sta_flag(sta, WLAN_STA_WME);
- 	} else {
---- a/net/mac80211/status.c
-+++ b/net/mac80211/status.c
-@@ -180,6 +180,9 @@ static void ieee80211_frame_acked(struct
- 	struct ieee80211_local *local = sta->local;
- 	struct ieee80211_sub_if_data *sdata = sta->sdata;
- 
-+	if (local->hw.flags & IEEE80211_HW_REPORTS_TX_ACK_STATUS)
-+		sta->last_rx = jiffies;
-+
- 	if (ieee80211_is_data_qos(mgmt->frame_control)) {
- 		struct ieee80211_hdr *hdr = (void *) skb->data;
- 		u8 *qc = ieee80211_get_qos_ctl(hdr);
---- a/net/mac80211/tx.c
-+++ b/net/mac80211/tx.c
-@@ -1101,7 +1101,8 @@ ieee80211_tx_prepare(struct ieee80211_su
- 		tx->sta = rcu_dereference(sdata->u.vlan.sta);
- 		if (!tx->sta && sdata->dev->ieee80211_ptr->use_4addr)
- 			return TX_DROP;
--	} else if (info->flags & IEEE80211_TX_CTL_INJECTED ||
-+	} else if (info->flags & (IEEE80211_TX_CTL_INJECTED |
-+				  IEEE80211_TX_INTFL_NL80211_FRAME_TX) ||
- 		   tx->sdata->control_port_protocol == tx->skb->protocol) {
- 		tx->sta = sta_info_get_bss(sdata, hdr->addr1);
- 	}
---- a/drivers/net/wireless/ath/ath5k/base.c
-+++ b/drivers/net/wireless/ath/ath5k/base.c
-@@ -1628,15 +1628,15 @@ ath5k_tx_frame_completed(struct ath5k_hw
- 	ah->stats.tx_bytes_count += skb->len;
- 	info = IEEE80211_SKB_CB(skb);
- 
-+	size = min_t(int, sizeof(info->status.rates), sizeof(bf->rates));
-+	memcpy(info->status.rates, bf->rates, size);
-+
- 	tries[0] = info->status.rates[0].count;
- 	tries[1] = info->status.rates[1].count;
- 	tries[2] = info->status.rates[2].count;
- 
- 	ieee80211_tx_info_clear_status(info);
- 
--	size = min_t(int, sizeof(info->status.rates), sizeof(bf->rates));
--	memcpy(info->status.rates, bf->rates, size);
--
- 	for (i = 0; i < ts->ts_final_idx; i++) {
- 		struct ieee80211_tx_rate *r =
- 			&info->status.rates[i];
---- a/drivers/net/wireless/rt2x00/rt2800usb.c
-+++ b/drivers/net/wireless/rt2x00/rt2800usb.c
-@@ -176,8 +176,8 @@ static bool rt2800usb_tx_sta_fifo_read_c
- 		queue_work(rt2x00dev->workqueue, &rt2x00dev->txdone_work);
- 
- 	if (rt2800usb_txstatus_pending(rt2x00dev)) {
--		/* Read register after 250 us */
--		hrtimer_start(&rt2x00dev->txstatus_timer, ktime_set(0, 250000),
-+		/* Read register after 1 ms */
-+		hrtimer_start(&rt2x00dev->txstatus_timer, ktime_set(0, 1000000),
- 			      HRTIMER_MODE_REL);
- 		return false;
- 	}
-@@ -202,8 +202,8 @@ static void rt2800usb_async_read_tx_stat
- 	if (test_and_set_bit(TX_STATUS_READING, &rt2x00dev->flags))
- 		return;
- 
--	/* Read TX_STA_FIFO register after 500 us */
--	hrtimer_start(&rt2x00dev->txstatus_timer, ktime_set(0, 500000),
-+	/* Read TX_STA_FIFO register after 2 ms */
-+	hrtimer_start(&rt2x00dev->txstatus_timer, ktime_set(0, 2000000),
- 		      HRTIMER_MODE_REL);
- }
- 
diff --git a/package/mac80211/patches/310-ap_scan.patch b/package/mac80211/patches/310-ap_scan.patch
deleted file mode 100644
index d7479f2..0000000
--- a/package/mac80211/patches/310-ap_scan.patch
+++ /dev/null
@@ -1,11 +0,0 @@
---- a/net/mac80211/cfg.c
-+++ b/net/mac80211/cfg.c
-@@ -2092,7 +2092,7 @@ static int ieee80211_scan(struct wiphy *
- 		 * the  frames sent while scanning on other channel will be
- 		 * lost)
- 		 */
--		if (sdata->u.ap.beacon &&
-+		if (0 && sdata->u.ap.beacon &&
- 		    (!(wiphy->features & NL80211_FEATURE_AP_SCAN) ||
- 		     !(req->flags & NL80211_SCAN_FLAG_AP)))
- 			return -EOPNOTSUPP;
diff --git a/package/mac80211/patches/400-ath_move_debug_code.patch b/package/mac80211/patches/400-ath_move_debug_code.patch
deleted file mode 100644
index aa5ce94..0000000
--- a/package/mac80211/patches/400-ath_move_debug_code.patch
+++ /dev/null
@@ -1,28 +0,0 @@
---- a/drivers/net/wireless/ath/Makefile
-+++ b/drivers/net/wireless/ath/Makefile
-@@ -11,7 +11,7 @@ obj-$(CPTCFG_ATH_COMMON)	+= ath.o
- ath-objs :=	main.o \
- 		regd.o \
- 		hw.o \
--		key.o
-+		key.o \
-+		debug.o
- 
--ath-$(CPTCFG_ATH_DEBUG) += debug.o
- ccflags-y += -D__CHECK_ENDIAN__
---- a/drivers/net/wireless/ath/ath.h
-+++ b/drivers/net/wireless/ath/ath.h
-@@ -280,13 +280,6 @@ void _ath_dbg(struct ath_common *common,
- #endif /* CPTCFG_ATH_DEBUG */
- 
- /** Returns string describing opmode, or NULL if unknown mode. */
--#ifdef CPTCFG_ATH_DEBUG
- const char *ath_opmode_to_string(enum nl80211_iftype opmode);
--#else
--static inline const char *ath_opmode_to_string(enum nl80211_iftype opmode)
--{
--	return "UNKNOWN";
--}
--#endif
- 
- #endif /* ATH_H */
diff --git a/package/mac80211/patches/401-ath9k_blink_default.patch b/package/mac80211/patches/401-ath9k_blink_default.patch
deleted file mode 100644
index b0cef87..0000000
--- a/package/mac80211/patches/401-ath9k_blink_default.patch
+++ /dev/null
@@ -1,11 +0,0 @@
---- a/drivers/net/wireless/ath/ath9k/init.c
-+++ b/drivers/net/wireless/ath/ath9k/init.c
-@@ -45,7 +45,7 @@ int ath9k_modparam_nohwcrypt;
- module_param_named(nohwcrypt, ath9k_modparam_nohwcrypt, int, 0444);
- MODULE_PARM_DESC(nohwcrypt, "Disable hardware encryption");
- 
--int led_blink;
-+int led_blink = 1;
- module_param_named(blink, led_blink, int, 0444);
- MODULE_PARM_DESC(blink, "Enable LED blink on activity");
- 
diff --git a/package/mac80211/patches/402-ath9k-fix-invalid-mac-address-handling.patch b/package/mac80211/patches/402-ath9k-fix-invalid-mac-address-handling.patch
deleted file mode 100644
index b2a7073..0000000
--- a/package/mac80211/patches/402-ath9k-fix-invalid-mac-address-handling.patch
+++ /dev/null
@@ -1,29 +0,0 @@
---- a/drivers/net/wireless/ath/ath9k/hw.c
-+++ b/drivers/net/wireless/ath/ath9k/hw.c
-@@ -17,6 +17,7 @@
- #include <linux/io.h>
- #include <linux/slab.h>
- #include <linux/module.h>
-+#include <linux/etherdevice.h>
- #include <asm/unaligned.h>
- 
- #include "hw.h"
-@@ -518,8 +519,16 @@ static int ath9k_hw_init_macaddr(struct 
- 		common->macaddr[2 * i] = eeval >> 8;
- 		common->macaddr[2 * i + 1] = eeval & 0xff;
- 	}
--	if (sum == 0 || sum == 0xffff * 3)
--		return -EADDRNOTAVAIL;
-+	if (!is_valid_ether_addr(common->macaddr)) {
-+		ath_err(common,
-+			"eeprom contains invalid mac address: %pM\n",
-+			common->macaddr);
-+
-+		random_ether_addr(common->macaddr);
-+		ath_err(common,
-+			"random mac address will be used: %pM\n",
-+			common->macaddr);
-+	}
- 
- 	return 0;
- }
diff --git a/package/mac80211/patches/403-ath_regd_optional.patch b/package/mac80211/patches/403-ath_regd_optional.patch
deleted file mode 100644
index 303c4d7..0000000
--- a/package/mac80211/patches/403-ath_regd_optional.patch
+++ /dev/null
@@ -1,68 +0,0 @@
---- a/drivers/net/wireless/ath/regd.c
-+++ b/drivers/net/wireless/ath/regd.c
-@@ -196,6 +196,10 @@ ath_reg_apply_beaconing_flags(struct wip
- 	struct ieee80211_channel *ch;
- 	unsigned int i;
- 
-+#ifdef CPTCFG_ATH_USER_REGD
-+	return;
-+#endif
-+
- 	for (band = 0; band < IEEE80211_NUM_BANDS; band++) {
- 
- 		if (!wiphy->bands[band])
-@@ -250,6 +254,10 @@ ath_reg_apply_active_scan_flags(struct w
- 	struct ieee80211_channel *ch;
- 	const struct ieee80211_reg_rule *reg_rule;
- 
-+#ifdef CPTCFG_ATH_USER_REGD
-+	return;
-+#endif
-+
- 	sband = wiphy->bands[IEEE80211_BAND_2GHZ];
- 	if (!sband)
- 		return;
-@@ -299,6 +307,10 @@ static void ath_reg_apply_radar_flags(st
- 	struct ieee80211_channel *ch;
- 	unsigned int i;
- 
-+#ifdef CPTCFG_ATH_USER_REGD
-+	return;
-+#endif
-+
- 	if (!wiphy->bands[IEEE80211_BAND_5GHZ])
- 		return;
- 
-@@ -503,6 +515,10 @@ ath_regd_init_wiphy(struct ath_regulator
- {
- 	const struct ieee80211_regdomain *regd;
- 
-+#ifdef CPTCFG_ATH_USER_REGD
-+	return 0;
-+#endif
-+
- 	wiphy->reg_notifier = reg_notifier;
- 	wiphy->flags |= WIPHY_FLAG_STRICT_REGULATORY;
- 
---- a/drivers/net/wireless/ath/Kconfig
-+++ b/drivers/net/wireless/ath/Kconfig
-@@ -21,6 +21,9 @@ menuconfig ATH_CARDS
- 
- if ATH_CARDS
- 
-+config ATH_USER_REGD
-+	bool "Do not enforce EEPROM regulatory restrictions"
-+
- config ATH_DEBUG
- 	bool "Atheros wireless debugging"
- 	---help---
---- a/.local-symbols
-+++ b/.local-symbols
-@@ -123,6 +123,7 @@ RTL8187_LEDS=
- ATH_COMMON=
- ATH_CARDS=
- ATH_DEBUG=
-+ATH_USER_REGD=
- ATH5K=
- ATH5K_DEBUG=
- ATH5K_TRACER=
diff --git a/package/mac80211/patches/404-world_regd_fixup.patch b/package/mac80211/patches/404-world_regd_fixup.patch
deleted file mode 100644
index 7a5840e..0000000
--- a/package/mac80211/patches/404-world_regd_fixup.patch
+++ /dev/null
@@ -1,84 +0,0 @@
---- a/drivers/net/wireless/ath/regd.c
-+++ b/drivers/net/wireless/ath/regd.c
-@@ -42,7 +42,8 @@ static int __ath_regd_init(struct ath_re
- 				NL80211_RRF_PASSIVE_SCAN | NL80211_RRF_NO_OFDM)
- 
- /* We allow IBSS on these on a case by case basis by regulatory domain */
--#define ATH9K_5GHZ_5150_5350	REG_RULE(5150-10, 5350+10, 80, 0, 30,\
-+#define ATH9K_5GHZ_5150_5350	REG_RULE(5150-10, 5250, 80, 0, 30, 0), \
-+				REG_RULE(5250, 5350+10, 80, 0, 30,\
- 				NL80211_RRF_PASSIVE_SCAN | NL80211_RRF_NO_IBSS)
- #define ATH9K_5GHZ_5470_5850	REG_RULE(5470-10, 5850+10, 80, 0, 30,\
- 				NL80211_RRF_PASSIVE_SCAN | NL80211_RRF_NO_IBSS)
-@@ -60,57 +61,56 @@ static int __ath_regd_init(struct ath_re
- #define ATH9K_5GHZ_NO_MIDBAND	ATH9K_5GHZ_5150_5350, \
- 				ATH9K_5GHZ_5725_5850
- 
-+#define REGD_RULES(...) \
-+	.reg_rules = { __VA_ARGS__ }, \
-+	.n_reg_rules = ARRAY_SIZE(((struct ieee80211_reg_rule[]) { __VA_ARGS__ }))
-+
- /* Can be used for:
-  * 0x60, 0x61, 0x62 */
- static const struct ieee80211_regdomain ath_world_regdom_60_61_62 = {
--	.n_reg_rules = 5,
- 	.alpha2 =  "99",
--	.reg_rules = {
-+	REGD_RULES(
- 		ATH9K_2GHZ_ALL,
- 		ATH9K_5GHZ_ALL,
--	}
-+	)
- };
- 
- /* Can be used by 0x63 and 0x65 */
- static const struct ieee80211_regdomain ath_world_regdom_63_65 = {
--	.n_reg_rules = 4,
- 	.alpha2 =  "99",
--	.reg_rules = {
-+	REGD_RULES(
- 		ATH9K_2GHZ_CH01_11,
- 		ATH9K_2GHZ_CH12_13,
- 		ATH9K_5GHZ_NO_MIDBAND,
--	}
-+	)
- };
- 
- /* Can be used by 0x64 only */
- static const struct ieee80211_regdomain ath_world_regdom_64 = {
--	.n_reg_rules = 3,
- 	.alpha2 =  "99",
--	.reg_rules = {
-+	REGD_RULES(
- 		ATH9K_2GHZ_CH01_11,
- 		ATH9K_5GHZ_NO_MIDBAND,
--	}
-+	)
- };
- 
- /* Can be used by 0x66 and 0x69 */
- static const struct ieee80211_regdomain ath_world_regdom_66_69 = {
--	.n_reg_rules = 3,
- 	.alpha2 =  "99",
--	.reg_rules = {
-+	REGD_RULES(
- 		ATH9K_2GHZ_CH01_11,
- 		ATH9K_5GHZ_ALL,
--	}
-+	)
- };
- 
- /* Can be used by 0x67, 0x68, 0x6A and 0x6C */
- static const struct ieee80211_regdomain ath_world_regdom_67_68_6A_6C = {
--	.n_reg_rules = 4,
- 	.alpha2 =  "99",
--	.reg_rules = {
-+	REGD_RULES(
- 		ATH9K_2GHZ_CH01_11,
- 		ATH9K_2GHZ_CH12_13,
- 		ATH9K_5GHZ_ALL,
--	}
-+	)
- };
- 
- static inline bool is_wwr_sku(u16 regd)
diff --git a/package/mac80211/patches/405-regd_no_assoc_hints.patch b/package/mac80211/patches/405-regd_no_assoc_hints.patch
deleted file mode 100644
index 5380853..0000000
--- a/package/mac80211/patches/405-regd_no_assoc_hints.patch
+++ /dev/null
@@ -1,19 +0,0 @@
---- a/net/wireless/reg.c
-+++ b/net/wireless/reg.c
-@@ -1696,6 +1696,8 @@ void regulatory_hint_11d(struct wiphy *w
- 	enum environment_cap env = ENVIRON_ANY;
- 	struct regulatory_request *request = NULL, *lr;
- 
-+	return;
-+
- 	/* IE len must be evenly divisible by 2 */
- 	if (country_ie_len & 0x01)
- 		return;
-@@ -1890,6 +1892,7 @@ static void restore_regulatory_settings(
- 
- void regulatory_hint_disconnect(void)
- {
-+	return;
- 	REG_DBG_PRINT("All devices are disconnected, going to restore regulatory settings\n");
- 	restore_regulatory_settings(false);
- }
diff --git a/package/mac80211/patches/406-ath_regd_us.patch b/package/mac80211/patches/406-ath_regd_us.patch
deleted file mode 100644
index cc55877..0000000
--- a/package/mac80211/patches/406-ath_regd_us.patch
+++ /dev/null
@@ -1,26 +0,0 @@
---- a/drivers/net/wireless/ath/regd_common.h
-+++ b/drivers/net/wireless/ath/regd_common.h
-@@ -32,6 +32,7 @@ enum EnumRd {
- 	FCC2_WORLD = 0x21,
- 	FCC2_ETSIC = 0x22,
- 	FCC6_WORLD = 0x23,
-+	FCC3_FCCA_2 = 0x2A,
- 	FRANCE_RES = 0x31,
- 	FCC3_FCCA = 0x3A,
- 	FCC3_WORLD = 0x3B,
-@@ -167,6 +168,7 @@ static struct reg_dmn_pair_mapping regDo
- 	{FCC2_WORLD, CTL_FCC, CTL_ETSI},
- 	{FCC2_ETSIC, CTL_FCC, CTL_ETSI},
- 	{FCC3_FCCA, CTL_FCC, CTL_FCC},
-+	{FCC3_FCCA_2, CTL_FCC, CTL_FCC},
- 	{FCC3_WORLD, CTL_FCC, CTL_ETSI},
- 	{FCC4_FCCA, CTL_FCC, CTL_FCC},
- 	{FCC5_FCCA, CTL_FCC, CTL_FCC},
-@@ -463,6 +465,7 @@ static struct country_code_to_enum_rd al
- 	{CTRY_UAE, NULL1_WORLD, "AE"},
- 	{CTRY_UNITED_KINGDOM, ETSI1_WORLD, "GB"},
- 	{CTRY_UNITED_STATES, FCC3_FCCA, "US"},
-+	{CTRY_UNITED_STATES, FCC3_FCCA_2, "US"},
- 	/* This "PS" is for US public safety actually... to support this we
- 	 * would need to assign new special alpha2 to CRDA db as with the world
- 	 * regdomain and use another alpha2 */
diff --git a/package/mac80211/patches/410-ath9k_allow_adhoc_and_ap.patch b/package/mac80211/patches/410-ath9k_allow_adhoc_and_ap.patch
deleted file mode 100644
index f6182dd..0000000
--- a/package/mac80211/patches/410-ath9k_allow_adhoc_and_ap.patch
+++ /dev/null
@@ -1,10 +0,0 @@
---- a/drivers/net/wireless/ath/ath9k/init.c
-+++ b/drivers/net/wireless/ath/ath9k/init.c
-@@ -755,6 +755,7 @@ static const struct ieee80211_iface_limi
- #endif
- 				 BIT(NL80211_IFTYPE_AP) |
- 				 BIT(NL80211_IFTYPE_P2P_GO) },
-+	{ .max = 1,	.types = BIT(NL80211_IFTYPE_ADHOC) },
- };
- 
- 
diff --git a/package/mac80211/patches/411-ath5k_allow_adhoc_and_ap.patch b/package/mac80211/patches/411-ath5k_allow_adhoc_and_ap.patch
deleted file mode 100644
index 12e03e1..0000000
--- a/package/mac80211/patches/411-ath5k_allow_adhoc_and_ap.patch
+++ /dev/null
@@ -1,46 +0,0 @@
---- a/drivers/net/wireless/ath/ath5k/mac80211-ops.c
-+++ b/drivers/net/wireless/ath/ath5k/mac80211-ops.c
-@@ -86,13 +86,8 @@ ath5k_add_interface(struct ieee80211_hw 
- 		goto end;
- 	}
- 
--	/* Don't allow other interfaces if one ad-hoc is configured.
--	 * TODO: Fix the problems with ad-hoc and multiple other interfaces.
--	 * We would need to operate the HW in ad-hoc mode to allow TSF updates
--	 * for the IBSS, but this breaks with additional AP or STA interfaces
--	 * at the moment. */
--	if (ah->num_adhoc_vifs ||
--	    (ah->nvifs && vif->type == NL80211_IFTYPE_ADHOC)) {
-+	/* Don't allow more than one ad-hoc interface */
-+	if (ah->num_adhoc_vifs && vif->type == NL80211_IFTYPE_ADHOC) {
- 		ATH5K_ERR(ah, "Only one single ad-hoc interface is allowed.\n");
- 		ret = -ELNRNG;
- 		goto end;
---- a/drivers/net/wireless/ath/ath5k/base.c
-+++ b/drivers/net/wireless/ath/ath5k/base.c
-@@ -1916,7 +1916,7 @@ ath5k_beacon_send(struct ath5k_hw *ah)
- 	}
- 
- 	if ((ah->opmode == NL80211_IFTYPE_AP && ah->num_ap_vifs +
--			ah->num_mesh_vifs > 1) ||
-+			ah->num_adhoc_vifs + ah->num_mesh_vifs > 1) ||
- 			ah->opmode == NL80211_IFTYPE_MESH_POINT) {
- 		u64 tsf = ath5k_hw_get_tsf64(ah);
- 		u32 tsftu = TSF_TO_TU(tsf);
-@@ -2002,7 +2002,7 @@ ath5k_beacon_update_timers(struct ath5k_
- 
- 	intval = ah->bintval & AR5K_BEACON_PERIOD;
- 	if (ah->opmode == NL80211_IFTYPE_AP && ah->num_ap_vifs
--		+ ah->num_mesh_vifs > 1) {
-+		+ ah->num_adhoc_vifs + ah->num_mesh_vifs > 1) {
- 		intval /= ATH_BCBUF;	/* staggered multi-bss beacons */
- 		if (intval < 15)
- 			ATH5K_WARN(ah, "intval %u is too low, min 15\n",
-@@ -2469,6 +2469,7 @@ static const struct ieee80211_iface_limi
- 				 BIT(NL80211_IFTYPE_MESH_POINT) |
- #endif
- 				 BIT(NL80211_IFTYPE_AP) },
-+	{ .max = 1,	.types = BIT(NL80211_IFTYPE_ADHOC) },
- };
- 
- static const struct ieee80211_iface_combination if_comb = {
diff --git a/package/mac80211/patches/420-ath5k_disable_fast_cc.patch b/package/mac80211/patches/420-ath5k_disable_fast_cc.patch
deleted file mode 100644
index 414f495..0000000
--- a/package/mac80211/patches/420-ath5k_disable_fast_cc.patch
+++ /dev/null
@@ -1,18 +0,0 @@
---- a/drivers/net/wireless/ath/ath5k/reset.c
-+++ b/drivers/net/wireless/ath/ath5k/reset.c
-@@ -1154,6 +1154,7 @@ ath5k_hw_reset(struct ath5k_hw *ah, enum
- 	tsf_lo = 0;
- 	mode = 0;
- 
-+#if 0
- 	/*
- 	 * Sanity check for fast flag
- 	 * Fast channel change only available
-@@ -1161,6 +1162,7 @@ ath5k_hw_reset(struct ath5k_hw *ah, enum
- 	 */
- 	if (fast && (ah->ah_radio != AR5K_RF2413) &&
- 	(ah->ah_radio != AR5K_RF5413))
-+#endif
- 		fast = false;
- 
- 	/* Disable sleep clock operation
diff --git a/package/mac80211/patches/430-add_ath5k_platform.patch b/package/mac80211/patches/430-add_ath5k_platform.patch
deleted file mode 100644
index b213e2a..0000000
--- a/package/mac80211/patches/430-add_ath5k_platform.patch
+++ /dev/null
@@ -1,33 +0,0 @@
---- /dev/null
-+++ b/include/linux/ath5k_platform.h
-@@ -0,0 +1,30 @@
-+/*
-+ * Copyright (c) 2008 Atheros Communications Inc.
-+ * Copyright (c) 2009 Gabor Juhos <juhosg@openwrt.org>
-+ * Copyright (c) 2009 Imre Kaloz <kaloz@openwrt.org>
-+ * Copyright (c) 2010 Daniel Golle <daniel.golle@gmail.com>
-+ *
-+ * Permission to use, copy, modify, and/or distribute this software for any
-+ * purpose with or without fee is hereby granted, provided that the above
-+ * copyright notice and this permission notice appear in all copies.
-+ *
-+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
-+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
-+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
-+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
-+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
-+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
-+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
-+ */
-+
-+#ifndef _LINUX_ATH5K_PLATFORM_H
-+#define _LINUX_ATH5K_PLATFORM_H
-+
-+#define ATH5K_PLAT_EEP_MAX_WORDS	2048
-+
-+struct ath5k_platform_data {
-+	u16 *eeprom_data;
-+	u8 *macaddr;
-+};
-+
-+#endif /* _LINUX_ATH5K_PLATFORM_H */
diff --git a/package/mac80211/patches/431-add_platform_eeprom_support_to_ath5k.patch b/package/mac80211/patches/431-add_platform_eeprom_support_to_ath5k.patch
deleted file mode 100644
index a223b38..0000000
--- a/package/mac80211/patches/431-add_platform_eeprom_support_to_ath5k.patch
+++ /dev/null
@@ -1,56 +0,0 @@
---- a/drivers/net/wireless/ath/ath5k/pci.c
-+++ b/drivers/net/wireless/ath/ath5k/pci.c
-@@ -21,6 +21,7 @@
- #include <linux/pci-aspm.h>
- #include <linux/etherdevice.h>
- #include <linux/module.h>
-+#include <linux/ath5k_platform.h>
- #include "../ath.h"
- #include "ath5k.h"
- #include "debug.h"
-@@ -72,7 +73,7 @@ static void ath5k_pci_read_cachesize(str
- }
- 
- /*
-- * Read from eeprom
-+ * Read from eeprom or platform_data
-  */
- static bool
- ath5k_pci_eeprom_read(struct ath_common *common, u32 offset, u16 *data)
-@@ -80,6 +81,19 @@ ath5k_pci_eeprom_read(struct ath_common 
- 	struct ath5k_hw *ah = (struct ath5k_hw *) common->ah;
- 	u32 status, timeout;
- 
-+	struct ath5k_platform_data *pdata = NULL;
-+	
-+	if (ah->pdev)
-+		pdata = ah->pdev->dev.platform_data;
-+
-+	if (pdata && pdata->eeprom_data && pdata->eeprom_data[61] == AR5K_EEPROM_MAGIC_VALUE) {
-+		if (offset >= ATH5K_PLAT_EEP_MAX_WORDS) 
-+			return false;
-+		
-+		*data = pdata->eeprom_data[offset];
-+		return true;
-+	}
-+
- 	/*
- 	 * Initialize EEPROM access
- 	 */
-@@ -123,6 +137,16 @@ static int ath5k_pci_eeprom_read_mac(str
- 	u16 data;
- 	int octet;
- 
-+	struct ath5k_platform_data *pdata = NULL;
-+
-+	if (ah->pdev)
-+		pdata = ah->pdev->dev.platform_data;
-+
-+	if (pdata && pdata->macaddr) {
-+		memcpy(mac, pdata->macaddr, ETH_ALEN);
-+		return 0;
-+	}
-+
- 	AR5K_EEPROM_READ(0x20, data);
- 
- 	for (offset = 0x1f, octet = 0, total = 0; offset >= 0x1d; offset--) {
diff --git a/package/mac80211/patches/432-ath5k_add_pciids.patch b/package/mac80211/patches/432-ath5k_add_pciids.patch
deleted file mode 100644
index e5c85ce..0000000
--- a/package/mac80211/patches/432-ath5k_add_pciids.patch
+++ /dev/null
@@ -1,11 +0,0 @@
---- a/drivers/net/wireless/ath/ath5k/pci.c
-+++ b/drivers/net/wireless/ath/ath5k/pci.c
-@@ -48,6 +48,8 @@ static DEFINE_PCI_DEVICE_TABLE(ath5k_pci
- 	{ PCI_VDEVICE(ATHEROS, 0x001b) }, /* 5413 Eagle */
- 	{ PCI_VDEVICE(ATHEROS, 0x001c) }, /* PCI-E cards */
- 	{ PCI_VDEVICE(ATHEROS, 0x001d) }, /* 2417 Nala */
-+	{ PCI_VDEVICE(ATHEROS, 0xff16) }, /* 2413,2414 sx76x on lantiq_danube */
-+	{ PCI_VDEVICE(ATHEROS, 0xff1a) }, /* 2417 arv45xx on lantiq_danube */
- 	{ PCI_VDEVICE(ATHEROS, 0xff1b) }, /* AR5BXB63 */
- 	{ 0 }
- };
diff --git a/package/mac80211/patches/440-ath5k_channel_bw_debugfs.patch b/package/mac80211/patches/440-ath5k_channel_bw_debugfs.patch
deleted file mode 100644
index 01c28bc..0000000
--- a/package/mac80211/patches/440-ath5k_channel_bw_debugfs.patch
+++ /dev/null
@@ -1,113 +0,0 @@
-This adds a bwmode debugfs file which can be used to set alternate
-channel operating bandwidths.  Only tested with AR5413 and only at
-5 and 20 mhz channels.
-
-Signed-off-by: Pat Erley <pat-lkml at erley.org>
----
-Other devices will need to be added to the switch in  write_file_bwmode
-
-drivers/net/wireless/ath/ath5k/debug.c |   86 ++++++++++++++++++++++++++++++++
- 1 files changed, 86 insertions(+), 0 deletions(-)
-
---- a/drivers/net/wireless/ath/ath5k/debug.c
-+++ b/drivers/net/wireless/ath/ath5k/debug.c
-@@ -811,6 +811,89 @@ static const struct file_operations fops
- 	.llseek = default_llseek,
- };
- 
-+/* debugfs: bwmode */
-+
-+static ssize_t read_file_bwmode(struct file *file, char __user *user_buf,
-+				   size_t count, loff_t *ppos)
-+{
-+	struct ath5k_hw *ah = file->private_data;
-+	char buf[15];
-+	unsigned int len = 0;
-+
-+	int cur_ah_bwmode = ah->ah_bwmode;
-+
-+#define print_selected(MODE, LABEL) \
-+	if (cur_ah_bwmode == MODE) \
-+		len += snprintf(buf+len, sizeof(buf)-len, "[%s]", LABEL); \
-+	else \
-+		len += snprintf(buf+len, sizeof(buf)-len, "%s", LABEL); \
-+	len += snprintf(buf+len, sizeof(buf)-len, " ");
-+
-+	print_selected(AR5K_BWMODE_5MHZ, "5");
-+	print_selected(AR5K_BWMODE_10MHZ, "10");
-+	print_selected(AR5K_BWMODE_DEFAULT, "20");
-+	print_selected(AR5K_BWMODE_40MHZ, "40");
-+#undef print_selected
-+
-+	len += snprintf(buf+len, sizeof(buf)-len, "\n");
-+
-+	return simple_read_from_buffer(user_buf, count, ppos, buf, len);
-+}
-+
-+static ssize_t write_file_bwmode(struct file *file,
-+				 const char __user *userbuf,
-+				 size_t count, loff_t *ppos)
-+{
-+	struct ath5k_hw *ah = file->private_data;
-+	char buf[3];
-+	int bw = 20;
-+	int tobwmode = AR5K_BWMODE_DEFAULT;
-+
-+	if (copy_from_user(buf, userbuf, min(count, sizeof(buf))))
-+		return -EFAULT;
-+
-+	/* TODO: Add check for active interface */
-+
-+	if(strncmp(buf, "5", 1) == 0 ) {
-+		tobwmode = AR5K_BWMODE_5MHZ;
-+		bw = 5;
-+	} else if ( strncmp(buf, "10", 2) == 0 ) {
-+		tobwmode = AR5K_BWMODE_10MHZ;
-+		bw = 10;
-+	} else if ( strncmp(buf, "20", 2) == 0 ) {
-+		tobwmode = AR5K_BWMODE_DEFAULT;
-+		bw = 20;
-+	} else if ( strncmp(buf, "40", 2) == 0 ) {
-+		tobwmode = AR5K_BWMODE_40MHZ;
-+		bw = 40;
-+	} else
-+		return -EINVAL;
-+
-+	ATH5K_INFO(ah, "Changing to %imhz channel width[%i]\n",
-+		bw, tobwmode);
-+
-+	switch (ah->ah_radio) {
-+		/* TODO: only define radios that actually support 5/10mhz channels */
-+		case AR5K_RF5413: case AR5K_RF5110: case AR5K_RF5111: case AR5K_RF5112: case AR5K_RF2413: case AR5K_RF2316: case AR5K_RF2317: case AR5K_RF2425:
-+			if(ah->ah_bwmode != tobwmode) {
-+				mutex_lock(&ah->lock);
-+				ah->ah_bwmode = tobwmode;
-+				mutex_unlock(&ah->lock);
-+			}
-+			break;
-+		default:
-+			return -EOPNOTSUPP;
-+	}
-+	return count;
-+}
-+
-+static const struct file_operations fops_bwmode = {
-+	.read = read_file_bwmode,
-+	.write = write_file_bwmode,
-+	.open = simple_open,
-+	.owner = THIS_MODULE,
-+	.llseek = default_llseek,
-+};
- 
- /* debugfs: queues etc */
- 
-@@ -902,6 +985,9 @@ ath5k_debug_init_device(struct ath5k_hw 
- 	debugfs_create_file("beacon", S_IWUSR | S_IRUSR, phydir, ah,
- 			    &fops_beacon);
- 
-+	debugfs_create_file("bwmode", S_IWUSR | S_IRUSR, phydir, ah,
-+			    &fops_bwmode);
-+
- 	debugfs_create_file("reset", S_IWUSR, phydir, ah, &fops_reset);
- 
- 	debugfs_create_file("antenna", S_IWUSR | S_IRUSR, phydir, ah,
diff --git a/package/mac80211/patches/500-ath9k_eeprom_debugfs.patch b/package/mac80211/patches/500-ath9k_eeprom_debugfs.patch
deleted file mode 100644
index 7f4e68d..0000000
--- a/package/mac80211/patches/500-ath9k_eeprom_debugfs.patch
+++ /dev/null
@@ -1,65 +0,0 @@
---- a/drivers/net/wireless/ath/ath9k/debug.c
-+++ b/drivers/net/wireless/ath/ath9k/debug.c
-@@ -1735,6 +1735,53 @@ void ath9k_deinit_debug(struct ath_softc
- 	}
- }
- 
-+static ssize_t read_file_eeprom(struct file *file, char __user *user_buf,
-+			     size_t count, loff_t *ppos)
-+{
-+	struct ath_softc *sc = file->private_data;
-+	struct ath_hw *ah = sc->sc_ah;
-+	struct ath_common *common = ath9k_hw_common(ah);
-+	int bytes = 0;
-+	int pos = *ppos;
-+	int size = 4096;
-+	u16 val;
-+	int i;
-+
-+	if (AR_SREV_9300_20_OR_LATER(ah))
-+		size = 16384;
-+
-+	if (*ppos < 0)
-+		return -EINVAL;
-+
-+	if (count > size - *ppos)
-+		count = size - *ppos;
-+
-+	for (i = *ppos / 2; count > 0; count -= bytes, *ppos += bytes, i++) {
-+		void *from = &val;
-+
-+		if (!common->bus_ops->eeprom_read(common, i, &val))
-+			val = 0xffff;
-+
-+		if (*ppos % 2) {
-+			from++;
-+			bytes = 1;
-+		} else if (count == 1) {
-+			bytes = 1;
-+		} else {
-+			bytes = 2;
-+		}
-+		copy_to_user(user_buf, from, bytes);
-+		user_buf += bytes;
-+	}
-+	return *ppos - pos;
-+}
-+
-+static const struct file_operations fops_eeprom = {
-+	.read = read_file_eeprom,
-+	.open = simple_open,
-+	.owner = THIS_MODULE
-+};
-+
- int ath9k_init_debug(struct ath_hw *ah)
- {
- 	struct ath_common *common = ath9k_hw_common(ah);
-@@ -1752,6 +1799,8 @@ int ath9k_init_debug(struct ath_hw *ah)
- 
- 	ath9k_dfs_init_debug(sc);
- 
-+	debugfs_create_file("eeprom", S_IRUSR, sc->debug.debugfs_phy, sc,
-+			    &fops_eeprom);
- 	debugfs_create_file("dma", S_IRUSR, sc->debug.debugfs_phy, sc,
- 			    &fops_dma);
- 	debugfs_create_file("interrupt", S_IRUSR, sc->debug.debugfs_phy, sc,
diff --git a/package/mac80211/patches/501-ath9k-eeprom_endianess.patch b/package/mac80211/patches/501-ath9k-eeprom_endianess.patch
deleted file mode 100644
index b98e8f5..0000000
--- a/package/mac80211/patches/501-ath9k-eeprom_endianess.patch
+++ /dev/null
@@ -1,102 +0,0 @@
---- a/drivers/net/wireless/ath/ath9k/eeprom_def.c
-+++ b/drivers/net/wireless/ath/ath9k/eeprom_def.c
-@@ -262,7 +262,7 @@ static int ath9k_hw_def_check_eeprom(str
- {
- 	struct ar5416_eeprom_def *eep = &ah->eeprom.def;
- 	struct ath_common *common = ath9k_hw_common(ah);
--	u16 *eepdata, temp, magic, magic2;
-+	u16 *eepdata, temp, magic;
- 	u32 sum = 0, el;
- 	bool need_swap = false;
- 	int i, addr, size;
-@@ -272,27 +272,16 @@ static int ath9k_hw_def_check_eeprom(str
- 		return false;
- 	}
- 
--	if (!ath9k_hw_use_flash(ah)) {
--		ath_dbg(common, EEPROM, "Read Magic = 0x%04X\n", magic);
--
--		if (magic != AR5416_EEPROM_MAGIC) {
--			magic2 = swab16(magic);
--
--			if (magic2 == AR5416_EEPROM_MAGIC) {
--				size = sizeof(struct ar5416_eeprom_def);
--				need_swap = true;
--				eepdata = (u16 *) (&ah->eeprom);
--
--				for (addr = 0; addr < size / sizeof(u16); addr++) {
--					temp = swab16(*eepdata);
--					*eepdata = temp;
--					eepdata++;
--				}
--			} else {
--				ath_err(common,
--					"Invalid EEPROM Magic. Endianness mismatch.\n");
--				return -EINVAL;
--			}
-+	if (swab16(magic) == AR5416_EEPROM_MAGIC &&
-+	    !(ah->ah_flags & AH_NO_EEP_SWAP)) {
-+		size = sizeof(struct ar5416_eeprom_def);
-+		need_swap = true;
-+		eepdata = (u16 *) (&ah->eeprom);
-+
-+		for (addr = 0; addr < size / sizeof(u16); addr++) {
-+			temp = swab16(*eepdata);
-+			*eepdata = temp;
-+			eepdata++;
- 		}
- 	}
- 
---- a/drivers/net/wireless/ath/ath9k/eeprom_4k.c
-+++ b/drivers/net/wireless/ath/ath9k/eeprom_4k.c
-@@ -57,7 +57,7 @@ static bool ath9k_hw_4k_fill_eeprom(stru
- {
- 	struct ath_common *common = ath9k_hw_common(ah);
- 
--	if (!ath9k_hw_use_flash(ah)) {
-+	if (!(ah->ah_flags & AH_NO_EEP_SWAP)) {
- 		ath_dbg(common, EEPROM, "Reading from EEPROM, not flash\n");
- 	}
- 
---- a/drivers/net/wireless/ath/ath9k/eeprom_9287.c
-+++ b/drivers/net/wireless/ath/ath9k/eeprom_9287.c
-@@ -60,7 +60,7 @@ static bool ath9k_hw_ar9287_fill_eeprom(
- {
- 	struct ath_common *common = ath9k_hw_common(ah);
- 
--	if (!ath9k_hw_use_flash(ah)) {
-+	if (!(ah->ah_flags & AH_NO_EEP_SWAP)) {
- 		ath_dbg(common, EEPROM, "Reading from EEPROM, not flash\n");
- 	}
- 
---- a/drivers/net/wireless/ath/ath9k/hw.h
-+++ b/drivers/net/wireless/ath/ath9k/hw.h
-@@ -739,6 +739,7 @@ enum ath_cal_list {
- #define AH_USE_EEPROM   0x1
- #define AH_UNPLUGGED    0x2 /* The card has been physically removed. */
- #define AH_FASTCC       0x4
-+#define AH_NO_EEP_SWAP  0x8 /* Do not swap EEPROM data */
- 
- struct ath_hw {
- 	struct ath_ops reg_ops;
---- a/drivers/net/wireless/ath/ath9k/init.c
-+++ b/drivers/net/wireless/ath/ath9k/init.c
-@@ -613,6 +613,8 @@ static int ath9k_init_softc(u16 devid, s
- 		ah->is_clk_25mhz = pdata->is_clk_25mhz;
- 		ah->get_mac_revision = pdata->get_mac_revision;
- 		ah->external_reset = pdata->external_reset;
-+		if (!pdata->endian_check)
-+			ah->ah_flags |= AH_NO_EEP_SWAP;
- 	}
- 
- 	common = ath9k_hw_common(ah);
---- a/include/linux/ath9k_platform.h
-+++ b/include/linux/ath9k_platform.h
-@@ -31,6 +31,7 @@ struct ath9k_platform_data {
- 	u32 gpio_mask;
- 	u32 gpio_val;
- 
-+	bool endian_check;
- 	bool is_clk_25mhz;
- 	int (*get_mac_revision)(void);
- 	int (*external_reset)(void);
diff --git a/package/mac80211/patches/502-ath9k_ahb_init.patch b/package/mac80211/patches/502-ath9k_ahb_init.patch
deleted file mode 100644
index 03199d8..0000000
--- a/package/mac80211/patches/502-ath9k_ahb_init.patch
+++ /dev/null
@@ -1,32 +0,0 @@
---- a/drivers/net/wireless/ath/ath9k/init.c
-+++ b/drivers/net/wireless/ath/ath9k/init.c
-@@ -1011,23 +1011,23 @@ static int __init ath9k_init(void)
- 		goto err_out;
- 	}
- 
--	error = ath_pci_init();
-+	error = ath_ahb_init();
- 	if (error < 0) {
--		pr_err("No PCI devices found, driver not installed\n");
- 		error = -ENODEV;
- 		goto err_rate_unregister;
- 	}
- 
--	error = ath_ahb_init();
-+	error = ath_pci_init();
- 	if (error < 0) {
-+		pr_err("No PCI devices found, driver not installed\n");
- 		error = -ENODEV;
--		goto err_pci_exit;
-+		goto err_ahb_exit;
- 	}
- 
- 	return 0;
- 
-- err_pci_exit:
--	ath_pci_exit();
-+ err_ahb_exit:
-+	ath_ahb_exit();
- 
-  err_rate_unregister:
- 	ath_rate_control_unregister();
diff --git a/package/mac80211/patches/510-ath9k_intr_mitigation_tweak.patch b/package/mac80211/patches/510-ath9k_intr_mitigation_tweak.patch
deleted file mode 100644
index 647bde2..0000000
--- a/package/mac80211/patches/510-ath9k_intr_mitigation_tweak.patch
+++ /dev/null
@@ -1,13 +0,0 @@
---- a/drivers/net/wireless/ath/ath9k/hw.c
-+++ b/drivers/net/wireless/ath/ath9k/hw.c
-@@ -2010,8 +2010,8 @@ int ath9k_hw_reset(struct ath_hw *ah, st
- 		REG_WRITE(ah, AR_OBS, 8);
- 
- 	if (ah->config.rx_intr_mitigation) {
--		REG_RMW_FIELD(ah, AR_RIMT, AR_RIMT_LAST, 500);
--		REG_RMW_FIELD(ah, AR_RIMT, AR_RIMT_FIRST, 2000);
-+		REG_RMW_FIELD(ah, AR_RIMT, AR_RIMT_LAST, 250);
-+		REG_RMW_FIELD(ah, AR_RIMT, AR_RIMT_FIRST, 500);
- 	}
- 
- 	if (ah->config.tx_intr_mitigation) {
diff --git a/package/mac80211/patches/511-ath9k_reduce_rxbuf.patch b/package/mac80211/patches/511-ath9k_reduce_rxbuf.patch
deleted file mode 100644
index 8d8c5fd..0000000
--- a/package/mac80211/patches/511-ath9k_reduce_rxbuf.patch
+++ /dev/null
@@ -1,11 +0,0 @@
---- a/drivers/net/wireless/ath/ath9k/ath9k.h
-+++ b/drivers/net/wireless/ath/ath9k/ath9k.h
-@@ -119,7 +119,7 @@ int ath_descdma_setup(struct ath_softc *
- /* RX / TX */
- /***********/
- 
--#define ATH_RXBUF               512
-+#define ATH_RXBUF               256
- #define ATH_TXBUF               512
- #define ATH_TXBUF_RESERVE       5
- #define ATH_MAX_QDEPTH          (ATH_TXBUF / 4 - ATH_TXBUF_RESERVE)
diff --git a/package/mac80211/patches/512-ath9k_channelbw_debugfs.patch b/package/mac80211/patches/512-ath9k_channelbw_debugfs.patch
deleted file mode 100644
index a42daf5..0000000
--- a/package/mac80211/patches/512-ath9k_channelbw_debugfs.patch
+++ /dev/null
@@ -1,128 +0,0 @@
---- a/drivers/net/wireless/ath/ath9k/ath9k.h
-+++ b/drivers/net/wireless/ath/ath9k/ath9k.h
-@@ -701,6 +701,7 @@ struct ath_softc {
- 	struct ieee80211_hw *hw;
- 	struct device *dev;
- 
-+	u32 chan_bw;
- 	struct survey_info *cur_survey;
- 	struct survey_info survey[ATH9K_NUM_CHANNELS];
- 
-@@ -905,6 +906,7 @@ struct fft_sample_ht20 {
- 	u8 data[SPECTRAL_HT20_NUM_BINS];
- } __packed;
- 
-+int ath9k_config(struct ieee80211_hw *hw, u32 changed);
- void ath9k_tasklet(unsigned long data);
- int ath_cabq_update(struct ath_softc *);
- 
---- a/drivers/net/wireless/ath/ath9k/debug.c
-+++ b/drivers/net/wireless/ath/ath9k/debug.c
-@@ -1782,6 +1782,50 @@ static const struct file_operations fops
- 	.owner = THIS_MODULE
- };
- 
-+
-+static ssize_t read_file_chan_bw(struct file *file, char __user *user_buf,
-+			     size_t count, loff_t *ppos)
-+{
-+	struct ath_softc *sc = file->private_data;
-+	char buf[32];
-+	unsigned int len;
-+
-+	len = sprintf(buf, "0x%08x\n", sc->chan_bw);
-+	return simple_read_from_buffer(user_buf, count, ppos, buf, len);
-+}
-+
-+static ssize_t write_file_chan_bw(struct file *file, const char __user *user_buf,
-+			     size_t count, loff_t *ppos)
-+{
-+	struct ath_softc *sc = file->private_data;
-+	unsigned long chan_bw;
-+	char buf[32];
-+	ssize_t len;
-+
-+	len = min(count, sizeof(buf) - 1);
-+	if (copy_from_user(buf, user_buf, len))
-+		return -EFAULT;
-+
-+	buf[len] = '\0';
-+	if (kstrtoul(buf, 0, &chan_bw))
-+		return -EINVAL;
-+
-+	sc->chan_bw = chan_bw;
-+	if (!test_bit(SC_OP_INVALID, &sc->sc_flags))
-+		ath9k_config(sc->hw, IEEE80211_CONF_CHANGE_CHANNEL);
-+
-+	return count;
-+}
-+
-+static const struct file_operations fops_chanbw = {
-+	.read = read_file_chan_bw,
-+	.write = write_file_chan_bw,
-+	.open = simple_open,
-+	.owner = THIS_MODULE,
-+	.llseek = default_llseek,
-+};
-+
-+
- int ath9k_init_debug(struct ath_hw *ah)
- {
- 	struct ath_common *common = ath9k_hw_common(ah);
-@@ -1801,6 +1845,8 @@ int ath9k_init_debug(struct ath_hw *ah)
- 
- 	debugfs_create_file("eeprom", S_IRUSR, sc->debug.debugfs_phy, sc,
- 			    &fops_eeprom);
-+	debugfs_create_file("chanbw", S_IRUSR | S_IWUSR, sc->debug.debugfs_phy,
-+			    sc, &fops_chanbw);
- 	debugfs_create_file("dma", S_IRUSR, sc->debug.debugfs_phy, sc,
- 			    &fops_dma);
- 	debugfs_create_file("interrupt", S_IRUSR, sc->debug.debugfs_phy, sc,
---- a/drivers/net/wireless/ath/ath9k/main.c
-+++ b/drivers/net/wireless/ath/ath9k/main.c
-@@ -1138,7 +1138,7 @@ int ath9k_spectral_scan_config(struct ie
- 	return 0;
- }
- 
--static int ath9k_config(struct ieee80211_hw *hw, u32 changed)
-+int ath9k_config(struct ieee80211_hw *hw, u32 changed)
- {
- 	struct ath_softc *sc = hw->priv;
- 	struct ath_hw *ah = sc->sc_ah;
-@@ -1194,9 +1194,11 @@ static int ath9k_config(struct ieee80211
- 		struct ieee80211_channel *curchan = hw->conf.chandef.chan;
- 		enum nl80211_channel_type channel_type =
- 			cfg80211_get_chandef_type(&conf->chandef);
-+		struct ath9k_channel *hchan;
- 		int pos = curchan->hw_value;
- 		int old_pos = -1;
- 		unsigned long flags;
-+		u32 oldflags;
- 
- 		if (ah->curchan)
- 			old_pos = ah->curchan - &ah->channels[0];
-@@ -1232,7 +1234,23 @@ static int ath9k_config(struct ieee80211
- 			memset(&sc->survey[pos], 0, sizeof(struct survey_info));
- 		}
- 
--		if (ath_set_channel(sc, hw, &sc->sc_ah->channels[pos]) < 0) {
-+		hchan = &sc->sc_ah->channels[pos];
-+		oldflags = hchan->channelFlags;
-+		switch (sc->chan_bw) {
-+		case 5:
-+			hchan->channelFlags &= ~CHANNEL_HALF;
-+			hchan->channelFlags |= CHANNEL_QUARTER;
-+			break;
-+		case 10:
-+			hchan->channelFlags &= ~CHANNEL_QUARTER;
-+			hchan->channelFlags |= CHANNEL_HALF;
-+			break;
-+		default:
-+			hchan->channelFlags &= ~(CHANNEL_HALF | CHANNEL_QUARTER);
-+			break;
-+		}
-+
-+		if (ath_set_channel(sc, hw, hchan) < 0) {
- 			ath_err(common, "Unable to set channel\n");
- 			mutex_unlock(&sc->mutex);
- 			ath9k_ps_restore(sc);
diff --git a/package/mac80211/patches/520-mac80211_cur_txpower.patch b/package/mac80211/patches/520-mac80211_cur_txpower.patch
deleted file mode 100644
index 837d9f6..0000000
--- a/package/mac80211/patches/520-mac80211_cur_txpower.patch
+++ /dev/null
@@ -1,33 +0,0 @@
---- a/include/net/mac80211.h
-+++ b/include/net/mac80211.h
-@@ -1616,6 +1616,7 @@ struct ieee80211_hw {
- 	u8 max_tx_aggregation_subframes;
- 	u8 offchannel_tx_hw_queue;
- 	u8 radiotap_mcs_details;
-+	s8 cur_power_level;
- 	u16 radiotap_vht_details;
- 	netdev_features_t netdev_features;
- 	u8 uapsd_queues;
---- a/net/mac80211/cfg.c
-+++ b/net/mac80211/cfg.c
-@@ -2273,7 +2273,9 @@ static int ieee80211_get_tx_power(struct
- 	struct ieee80211_local *local = wiphy_priv(wiphy);
- 	struct ieee80211_sub_if_data *sdata = IEEE80211_WDEV_TO_SUB_IF(wdev);
- 
--	if (!local->use_chanctx)
-+	if (local->hw.cur_power_level)
-+		*dbm = local->hw.cur_power_level;
-+	else if (!local->use_chanctx)
- 		*dbm = local->hw.conf.power_level;
- 	else
- 		*dbm = sdata->vif.bss_conf.txpower;
---- a/net/mac80211/main.c
-+++ b/net/mac80211/main.c
-@@ -167,6 +167,7 @@ static u32 ieee80211_hw_conf_chan(struct
- 
- 	if (local->hw.conf.power_level != power) {
- 		changed |= IEEE80211_CONF_CHANGE_POWER;
-+		local->hw.cur_power_level = power;
- 		local->hw.conf.power_level = power;
- 	}
- 
diff --git a/package/mac80211/patches/521-ath9k_cur_txpower.patch b/package/mac80211/patches/521-ath9k_cur_txpower.patch
deleted file mode 100644
index a14d031..0000000
--- a/package/mac80211/patches/521-ath9k_cur_txpower.patch
+++ /dev/null
@@ -1,19 +0,0 @@
---- a/drivers/net/wireless/ath/ath9k/main.c
-+++ b/drivers/net/wireless/ath/ath9k/main.c
-@@ -1257,6 +1257,8 @@ int ath9k_config(struct ieee80211_hw *hw
- 			return -EINVAL;
- 		}
- 
-+		hw->cur_power_level = sc->curtxpow / 2;
-+
- 		/*
- 		 * The most recent snapshot of channel->noisefloor for the old
- 		 * channel is only available after the hardware reset. Copy it to
-@@ -1293,6 +1295,7 @@ int ath9k_config(struct ieee80211_hw *hw
- 		sc->config.txpowlimit = 2 * conf->power_level;
- 		ath9k_cmn_update_txpow(ah, sc->curtxpow,
- 				       sc->config.txpowlimit, &sc->curtxpow);
-+		hw->cur_power_level = sc->curtxpow / 2;
- 	}
- 
- 	mutex_unlock(&sc->mutex);
diff --git a/package/mac80211/patches/522-ath9k_per_chain_signal_strength.patch b/package/mac80211/patches/522-ath9k_per_chain_signal_strength.patch
deleted file mode 100644
index 50dbcd9..0000000
--- a/package/mac80211/patches/522-ath9k_per_chain_signal_strength.patch
+++ /dev/null
@@ -1,153 +0,0 @@
---- a/drivers/net/wireless/ath/ath9k/mac.h
-+++ b/drivers/net/wireless/ath/ath9k/mac.h
-@@ -133,12 +133,8 @@ struct ath_rx_status {
- 	u8 rs_rate;
- 	u8 rs_antenna;
- 	u8 rs_more;
--	int8_t rs_rssi_ctl0;
--	int8_t rs_rssi_ctl1;
--	int8_t rs_rssi_ctl2;
--	int8_t rs_rssi_ext0;
--	int8_t rs_rssi_ext1;
--	int8_t rs_rssi_ext2;
-+	int8_t rs_rssi_ctl[3];
-+	int8_t rs_rssi_ext[3];
- 	u8 rs_isaggr;
- 	u8 rs_moreaggr;
- 	u8 rs_num_delims;
---- a/drivers/net/wireless/ath/ath9k/recv.c
-+++ b/drivers/net/wireless/ath/ath9k/recv.c
-@@ -939,6 +939,7 @@ static int ath9k_rx_skb_preprocess(struc
- 	struct ath_hw *ah = sc->sc_ah;
- 	struct ath_common *common = ath9k_hw_common(ah);
- 	bool discard_current = sc->rx.discard_next;
-+	int i, j;
- 
- 	sc->rx.discard_next = rx_stats->rs_more;
- 	if (discard_current)
-@@ -968,6 +969,21 @@ static int ath9k_rx_skb_preprocess(struc
- 	if (rx_stats->rs_moreaggr)
- 		rx_status->flag |= RX_FLAG_NO_SIGNAL_VAL;
- 
-+	for (i = 0, j = 0; i < ARRAY_SIZE(rx_stats->rs_rssi_ctl); i++) {
-+		s8 rssi;
-+
-+		if (!(ah->rxchainmask & BIT(i)))
-+			continue;
-+
-+		rssi = rx_stats->rs_rssi_ctl[i];
-+		if (rssi != ATH9K_RSSI_BAD) {
-+		    rx_status->chains |= BIT(j);
-+		    rx_status->chain_signal[j] = ah->noise + rssi;
-+		}
-+		j++;
-+	}
-+
-+
- 	sc->rx.discard_next = false;
- 	return 0;
- }
-@@ -1077,7 +1093,7 @@ static int ath_process_fft(struct ath_so
- 	fft_sample.tlv.length = __cpu_to_be16(length);
- 
- 	fft_sample.freq = __cpu_to_be16(ah->curchan->chan->center_freq);
--	fft_sample.rssi = fix_rssi_inv_only(rs->rs_rssi_ctl0);
-+	fft_sample.rssi = fix_rssi_inv_only(rs->rs_rssi_ctl[0]);
- 	fft_sample.noise = ah->noise;
- 
- 	switch (len - SPECTRAL_HT20_TOTAL_DATA_LEN) {
---- a/drivers/net/wireless/ath/ath9k/ar9003_mac.c
-+++ b/drivers/net/wireless/ath/ath9k/ar9003_mac.c
-@@ -476,12 +476,12 @@ int ath9k_hw_process_rxdesc_edma(struct 
- 
- 	/* XXX: Keycache */
- 	rxs->rs_rssi = MS(rxsp->status5, AR_RxRSSICombined);
--	rxs->rs_rssi_ctl0 = MS(rxsp->status1, AR_RxRSSIAnt00);
--	rxs->rs_rssi_ctl1 = MS(rxsp->status1, AR_RxRSSIAnt01);
--	rxs->rs_rssi_ctl2 = MS(rxsp->status1, AR_RxRSSIAnt02);
--	rxs->rs_rssi_ext0 = MS(rxsp->status5, AR_RxRSSIAnt10);
--	rxs->rs_rssi_ext1 = MS(rxsp->status5, AR_RxRSSIAnt11);
--	rxs->rs_rssi_ext2 = MS(rxsp->status5, AR_RxRSSIAnt12);
-+	rxs->rs_rssi_ctl[0] = MS(rxsp->status1, AR_RxRSSIAnt00);
-+	rxs->rs_rssi_ctl[1] = MS(rxsp->status1, AR_RxRSSIAnt01);
-+	rxs->rs_rssi_ctl[2] = MS(rxsp->status1, AR_RxRSSIAnt02);
-+	rxs->rs_rssi_ext[0] = MS(rxsp->status5, AR_RxRSSIAnt10);
-+	rxs->rs_rssi_ext[1] = MS(rxsp->status5, AR_RxRSSIAnt11);
-+	rxs->rs_rssi_ext[2] = MS(rxsp->status5, AR_RxRSSIAnt12);
- 
- 	if (rxsp->status11 & AR_RxKeyIdxValid)
- 		rxs->rs_keyix = MS(rxsp->status11, AR_KeyIdx);
---- a/drivers/net/wireless/ath/ath9k/mac.c
-+++ b/drivers/net/wireless/ath/ath9k/mac.c
-@@ -554,25 +554,25 @@ int ath9k_hw_rxprocdesc(struct ath_hw *a
- 
- 	if (ads.ds_rxstatus8 & AR_PostDelimCRCErr) {
- 		rs->rs_rssi = ATH9K_RSSI_BAD;
--		rs->rs_rssi_ctl0 = ATH9K_RSSI_BAD;
--		rs->rs_rssi_ctl1 = ATH9K_RSSI_BAD;
--		rs->rs_rssi_ctl2 = ATH9K_RSSI_BAD;
--		rs->rs_rssi_ext0 = ATH9K_RSSI_BAD;
--		rs->rs_rssi_ext1 = ATH9K_RSSI_BAD;
--		rs->rs_rssi_ext2 = ATH9K_RSSI_BAD;
-+		rs->rs_rssi_ctl[0] = ATH9K_RSSI_BAD;
-+		rs->rs_rssi_ctl[1] = ATH9K_RSSI_BAD;
-+		rs->rs_rssi_ctl[2] = ATH9K_RSSI_BAD;
-+		rs->rs_rssi_ext[0] = ATH9K_RSSI_BAD;
-+		rs->rs_rssi_ext[1] = ATH9K_RSSI_BAD;
-+		rs->rs_rssi_ext[2] = ATH9K_RSSI_BAD;
- 	} else {
- 		rs->rs_rssi = MS(ads.ds_rxstatus4, AR_RxRSSICombined);
--		rs->rs_rssi_ctl0 = MS(ads.ds_rxstatus0,
-+		rs->rs_rssi_ctl[0] = MS(ads.ds_rxstatus0,
- 						AR_RxRSSIAnt00);
--		rs->rs_rssi_ctl1 = MS(ads.ds_rxstatus0,
-+		rs->rs_rssi_ctl[1] = MS(ads.ds_rxstatus0,
- 						AR_RxRSSIAnt01);
--		rs->rs_rssi_ctl2 = MS(ads.ds_rxstatus0,
-+		rs->rs_rssi_ctl[2] = MS(ads.ds_rxstatus0,
- 						AR_RxRSSIAnt02);
--		rs->rs_rssi_ext0 = MS(ads.ds_rxstatus4,
-+		rs->rs_rssi_ext[0] = MS(ads.ds_rxstatus4,
- 						AR_RxRSSIAnt10);
--		rs->rs_rssi_ext1 = MS(ads.ds_rxstatus4,
-+		rs->rs_rssi_ext[1] = MS(ads.ds_rxstatus4,
- 						AR_RxRSSIAnt11);
--		rs->rs_rssi_ext2 = MS(ads.ds_rxstatus4,
-+		rs->rs_rssi_ext[2] = MS(ads.ds_rxstatus4,
- 						AR_RxRSSIAnt12);
- 	}
- 	if (ads.ds_rxstatus8 & AR_RxKeyIdxValid)
---- a/drivers/net/wireless/ath/ath9k/dfs.c
-+++ b/drivers/net/wireless/ath/ath9k/dfs.c
-@@ -158,8 +158,8 @@ void ath9k_dfs_process_phyerr(struct ath
- 		return;
- 	}
- 
--	ard.rssi = rs->rs_rssi_ctl0;
--	ard.ext_rssi = rs->rs_rssi_ext0;
-+	ard.rssi = rs->rs_rssi_ctl[0];
-+	ard.ext_rssi = rs->rs_rssi_ext[0];
- 
- 	/*
- 	 * hardware stores this as 8 bit signed value.
---- a/drivers/net/wireless/ath/ath9k/antenna.c
-+++ b/drivers/net/wireless/ath/ath9k/antenna.c
-@@ -546,14 +546,14 @@ void ath_ant_comb_scan(struct ath_softc 
- 	struct ath_ant_comb *antcomb = &sc->ant_comb;
- 	int alt_ratio = 0, alt_rssi_avg = 0, main_rssi_avg = 0, curr_alt_set;
- 	int curr_main_set;
--	int main_rssi = rs->rs_rssi_ctl0;
--	int alt_rssi = rs->rs_rssi_ctl1;
-+	int main_rssi = rs->rs_rssi_ctl[0];
-+	int alt_rssi = rs->rs_rssi_ctl[1];
- 	int rx_ant_conf,  main_ant_conf;
- 	bool short_scan = false;
- 
--	rx_ant_conf = (rs->rs_rssi_ctl2 >> ATH_ANT_RX_CURRENT_SHIFT) &
-+	rx_ant_conf = (rs->rs_rssi_ctl[2] >> ATH_ANT_RX_CURRENT_SHIFT) &
- 		       ATH_ANT_RX_MASK;
--	main_ant_conf = (rs->rs_rssi_ctl2 >> ATH_ANT_RX_MAIN_SHIFT) &
-+	main_ant_conf = (rs->rs_rssi_ctl[2] >> ATH_ANT_RX_MAIN_SHIFT) &
- 			 ATH_ANT_RX_MASK;
- 
- 	/* Record packet only when both main_rssi and  alt_rssi is positive */
diff --git a/package/mac80211/patches/523-mac80211_configure_antenna_gain.patch b/package/mac80211/patches/523-mac80211_configure_antenna_gain.patch
deleted file mode 100644
index d247c56..0000000
--- a/package/mac80211/patches/523-mac80211_configure_antenna_gain.patch
+++ /dev/null
@@ -1,161 +0,0 @@
---- a/include/net/mac80211.h
-+++ b/include/net/mac80211.h
-@@ -999,6 +999,7 @@ enum ieee80211_smps_mode {
-  *
-  * @power_level: requested transmit power (in dBm), backward compatibility
-  *	value only that is set to the minimum of all interfaces
-+ * @max_antenna_gain: maximum antenna gain adjusted by user config (in dBi)
-  *
-  * @chandef: the channel definition to tune to
-  * @radar_enabled: whether radar detection is enabled
-@@ -1020,6 +1021,7 @@ struct ieee80211_conf {
- 	u32 flags;
- 	int power_level, dynamic_ps_timeout;
- 	int max_sleep_period;
-+	int max_antenna_gain;
- 
- 	u16 listen_interval;
- 	u8 ps_dtim_period;
---- a/net/mac80211/ieee80211_i.h
-+++ b/net/mac80211/ieee80211_i.h
-@@ -1126,6 +1126,7 @@ struct ieee80211_local {
- 	int dynamic_ps_forced_timeout;
- 
- 	int user_power_level; /* in dBm, for all interfaces */
-+	int user_antenna_gain; /* in dBi */
- 
- 	enum ieee80211_smps_mode smps_mode;
- 
---- a/include/uapi/linux/nl80211.h
-+++ b/include/uapi/linux/nl80211.h
-@@ -1736,6 +1736,8 @@ enum nl80211_attrs {
- 
- 	NL80211_ATTR_PEER_AID,
- 
-+	NL80211_ATTR_WIPHY_ANTENNA_GAIN,
-+
- 	/* add attributes here, update the policy in nl80211.c */
- 
- 	__NL80211_ATTR_AFTER_LAST,
---- a/net/wireless/nl80211.c
-+++ b/net/wireless/nl80211.c
-@@ -349,6 +349,7 @@ static const struct nla_policy nl80211_p
- 	[NL80211_ATTR_IE_RIC] = { .type = NLA_BINARY,
- 				  .len = IEEE80211_MAX_DATA_LEN },
- 	[NL80211_ATTR_PEER_AID] = { .type = NLA_U16 },
-+	[NL80211_ATTR_WIPHY_ANTENNA_GAIN] = { .type = NLA_U32 },
- };
- 
- /* policy for the key attributes */
-@@ -1993,6 +1994,22 @@ static int nl80211_set_wiphy(struct sk_b
- 			goto bad_res;
- 	}
- 
-+	if (info->attrs[NL80211_ATTR_WIPHY_ANTENNA_GAIN]) {
-+		int idx, dbi = 0;
-+
-+		if (!rdev->ops->set_antenna_gain) {
-+			result = -EOPNOTSUPP;
-+			goto bad_res;
-+		}
-+
-+		idx = NL80211_ATTR_WIPHY_ANTENNA_GAIN;
-+		dbi = nla_get_u32(info->attrs[idx]);
-+
-+		result = rdev->ops->set_antenna_gain(&rdev->wiphy, dbi);
-+		if (result)
-+			goto bad_res;
-+	}
-+
- 	if (info->attrs[NL80211_ATTR_WIPHY_ANTENNA_TX] &&
- 	    info->attrs[NL80211_ATTR_WIPHY_ANTENNA_RX]) {
- 		u32 tx_ant, rx_ant;
---- a/net/mac80211/cfg.c
-+++ b/net/mac80211/cfg.c
-@@ -2283,6 +2283,19 @@ static int ieee80211_get_tx_power(struct
- 	return 0;
- }
- 
-+static int ieee80211_set_antenna_gain(struct wiphy *wiphy, int dbi)
-+{
-+	struct ieee80211_local *local = wiphy_priv(wiphy);
-+
-+	if (dbi < 0)
-+		return -EINVAL;
-+
-+	local->user_antenna_gain = dbi;
-+	ieee80211_hw_config(local, 0);
-+
-+	return 0;
-+}
-+
- static int ieee80211_set_wds_peer(struct wiphy *wiphy, struct net_device *dev,
- 				  const u8 *addr)
- {
-@@ -3474,6 +3487,7 @@ struct cfg80211_ops mac80211_config_ops 
- 	.set_wiphy_params = ieee80211_set_wiphy_params,
- 	.set_tx_power = ieee80211_set_tx_power,
- 	.get_tx_power = ieee80211_get_tx_power,
-+	.set_antenna_gain = ieee80211_set_antenna_gain,
- 	.set_wds_peer = ieee80211_set_wds_peer,
- 	.rfkill_poll = ieee80211_rfkill_poll,
- 	CFG80211_TESTMODE_CMD(ieee80211_testmode_cmd)
---- a/include/net/cfg80211.h
-+++ b/include/net/cfg80211.h
-@@ -1970,6 +1970,7 @@ struct cfg80211_update_ft_ies_params {
-  *	(as advertised by the nl80211 feature flag.)
-  * @get_tx_power: store the current TX power into the dbm variable;
-  *	return 0 if successful
-+ * @set_antenna_gain: set antenna gain to reduce maximum tx power if necessary
-  *
-  * @set_wds_peer: set the WDS peer for a WDS interface
-  *
-@@ -2189,6 +2190,7 @@ struct cfg80211_ops {
- 				enum nl80211_tx_power_setting type, int mbm);
- 	int	(*get_tx_power)(struct wiphy *wiphy, struct wireless_dev *wdev,
- 				int *dbm);
-+	int	(*set_antenna_gain)(struct wiphy *wiphy, int dbi);
- 
- 	int	(*set_wds_peer)(struct wiphy *wiphy, struct net_device *dev,
- 				const u8 *addr);
---- a/net/mac80211/main.c
-+++ b/net/mac80211/main.c
-@@ -102,6 +102,7 @@ static u32 ieee80211_hw_conf_chan(struct
- 	struct cfg80211_chan_def chandef = {};
- 	u32 changed = 0;
- 	int power = 0;
-+	int ant_gain, max_power;
- 	u32 offchannel_flag;
- 
- 	offchannel_flag = local->hw.conf.flags & IEEE80211_CONF_OFFCHANNEL;
-@@ -165,8 +166,21 @@ static u32 ieee80211_hw_conf_chan(struct
- 
- 	power = min(power, chandef.chan->max_power);
- 
--	if (local->hw.conf.power_level != power) {
-+	max_power = chandef.chan->max_reg_power;
-+	ant_gain = chandef.chan->max_antenna_gain;
-+	if (local->user_antenna_gain > 0) {
-+		if (local->user_antenna_gain > ant_gain) {
-+			max_power -= local->user_antenna_gain - ant_gain;
-+			ant_gain = 0;
-+		} else
-+			ant_gain -= local->user_antenna_gain;
-+		power = min(power, max_power);
-+	}
-+
-+	if (local->hw.conf.power_level != power ||
-+		local->hw.conf.max_antenna_gain != ant_gain) {
- 		changed |= IEEE80211_CONF_CHANGE_POWER;
-+		local->hw.conf.max_antenna_gain = ant_gain;
- 		local->hw.cur_power_level = power;
- 		local->hw.conf.power_level = power;
- 	}
-@@ -597,6 +611,7 @@ struct ieee80211_hw *ieee80211_alloc_hw(
- 					 IEEE80211_RADIOTAP_MCS_HAVE_BW;
- 	local->hw.radiotap_vht_details = IEEE80211_RADIOTAP_VHT_KNOWN_GI |
- 					 IEEE80211_RADIOTAP_VHT_KNOWN_BANDWIDTH;
-+	local->user_antenna_gain = 0;
- 	local->hw.uapsd_queues = IEEE80211_DEFAULT_UAPSD_QUEUES;
- 	local->hw.uapsd_max_sp_len = IEEE80211_DEFAULT_MAX_SP_LEN;
- 	local->user_power_level = IEEE80211_UNSET_POWER_LEVEL;
diff --git a/package/mac80211/patches/524-ath9k_use_configured_antenna_gain.patch b/package/mac80211/patches/524-ath9k_use_configured_antenna_gain.patch
deleted file mode 100644
index 9d627ac..0000000
--- a/package/mac80211/patches/524-ath9k_use_configured_antenna_gain.patch
+++ /dev/null
@@ -1,34 +0,0 @@
---- a/drivers/net/wireless/ath/ath.h
-+++ b/drivers/net/wireless/ath/ath.h
-@@ -73,6 +73,7 @@ struct ath_regulatory {
- 	u16 max_power_level;
- 	u16 current_rd;
- 	int16_t power_limit;
-+	int16_t max_antenna_gain;
- 	struct reg_dmn_pair_mapping *regpair;
- };
- 
---- a/drivers/net/wireless/ath/ath9k/hw.c
-+++ b/drivers/net/wireless/ath/ath9k/hw.c
-@@ -2847,7 +2847,7 @@ void ath9k_hw_apply_txpower(struct ath_h
- 	channel = chan->chan;
- 	chan_pwr = min_t(int, channel->max_power * 2, MAX_RATE_POWER);
- 	new_pwr = min_t(int, chan_pwr, reg->power_limit);
--	max_gain = chan_pwr - new_pwr + channel->max_antenna_gain * 2;
-+	max_gain = chan_pwr - new_pwr + reg->max_antenna_gain * 2;
- 
- 	ant_gain = get_antenna_gain(ah, chan);
- 	if (ant_gain > max_gain)
---- a/drivers/net/wireless/ath/ath9k/main.c
-+++ b/drivers/net/wireless/ath/ath9k/main.c
-@@ -1291,7 +1291,10 @@ int ath9k_config(struct ieee80211_hw *hw
- 	}
- 
- 	if (changed & IEEE80211_CONF_CHANGE_POWER) {
-+		struct ath_regulatory *reg = ath9k_hw_regulatory(ah);
-+
- 		ath_dbg(common, CONFIG, "Set power: %d\n", conf->power_level);
-+		reg->max_antenna_gain = conf->max_antenna_gain;
- 		sc->config.txpowlimit = 2 * conf->power_level;
- 		ath9k_cmn_update_txpow(ah, sc->curtxpow,
- 				       sc->config.txpowlimit, &sc->curtxpow);
diff --git a/package/mac80211/patches/530-ath9k_extra_leds.patch b/package/mac80211/patches/530-ath9k_extra_leds.patch
deleted file mode 100644
index b931d5f..0000000
--- a/package/mac80211/patches/530-ath9k_extra_leds.patch
+++ /dev/null
@@ -1,248 +0,0 @@
---- a/drivers/net/wireless/ath/ath9k/ath9k.h
-+++ b/drivers/net/wireless/ath/ath9k/ath9k.h
-@@ -557,6 +557,9 @@ struct ath9k_wow_pattern {
- void ath_init_leds(struct ath_softc *sc);
- void ath_deinit_leds(struct ath_softc *sc);
- void ath_fill_led_pin(struct ath_softc *sc);
-+int ath_create_gpio_led(struct ath_softc *sc, int gpio, const char *name,
-+                        const char *trigger, bool active_low);
-+
- #else
- static inline void ath_init_leds(struct ath_softc *sc)
- {
-@@ -697,6 +700,13 @@ enum spectral_mode {
- 	SPECTRAL_CHANSCAN,
- };
- 
-+struct ath_led {
-+	struct list_head list;
-+	struct ath_softc *sc;
-+	const struct gpio_led *gpio;
-+	struct led_classdev cdev;
-+};
-+
- struct ath_softc {
- 	struct ieee80211_hw *hw;
- 	struct device *dev;
-@@ -739,9 +749,8 @@ struct ath_softc {
- 	struct ieee80211_supported_band sbands[IEEE80211_NUM_BANDS];
- 
- #ifdef CPTCFG_MAC80211_LEDS
--	bool led_registered;
--	char led_name[32];
--	struct led_classdev led_cdev;
-+	const char *led_default_trigger;
-+	struct list_head leds;
- #endif
- 
- 	struct ath9k_hw_cal_data caldata;
---- a/drivers/net/wireless/ath/ath9k/gpio.c
-+++ b/drivers/net/wireless/ath/ath9k/gpio.c
-@@ -24,40 +24,102 @@
- static void ath_led_brightness(struct led_classdev *led_cdev,
- 			       enum led_brightness brightness)
- {
--	struct ath_softc *sc = container_of(led_cdev, struct ath_softc, led_cdev);
--	ath9k_hw_set_gpio(sc->sc_ah, sc->sc_ah->led_pin, (brightness == LED_OFF));
-+	struct ath_led *led = container_of(led_cdev, struct ath_led, cdev);
-+	struct ath_softc *sc = led->sc;
-+
-+	ath9k_ps_wakeup(sc);
-+	ath9k_hw_set_gpio(sc->sc_ah, led->gpio->gpio,
-+			  (brightness != LED_OFF) ^ led->gpio->active_low);
-+	ath9k_ps_restore(sc);
-+}
-+
-+static int ath_add_led(struct ath_softc *sc, struct ath_led *led)
-+{
-+	const struct gpio_led *gpio = led->gpio;
-+	int ret;
-+
-+	led->cdev.name = gpio->name;
-+	led->cdev.default_trigger = gpio->default_trigger;
-+	led->cdev.brightness_set = ath_led_brightness;
-+
-+	ret = led_classdev_register(wiphy_dev(sc->hw->wiphy), &led->cdev);
-+	if (ret < 0)
-+		return ret;
-+
-+	led->sc = sc;
-+	list_add(&led->list, &sc->leds);
-+
-+	/* Configure gpio for output */
-+	ath9k_hw_cfg_output(sc->sc_ah, gpio->gpio,
-+			    AR_GPIO_OUTPUT_MUX_AS_OUTPUT);
-+
-+	/* LED off */
-+	ath9k_hw_set_gpio(sc->sc_ah, gpio->gpio, gpio->active_low);
-+
-+	return 0;
-+}
-+
-+int ath_create_gpio_led(struct ath_softc *sc, int gpio_num, const char *name,
-+			const char *trigger, bool active_low)
-+{
-+	struct ath_led *led;
-+	struct gpio_led *gpio;
-+	char *_name;
-+	int ret;
-+
-+	led = kzalloc(sizeof(*led) + sizeof(*gpio) + strlen(name) + 1,
-+		      GFP_KERNEL);
-+	if (!led)
-+		return -ENOMEM;
-+
-+	led->gpio = gpio = (struct gpio_led *) (led + 1);
-+	_name = (char *) (led->gpio + 1);
-+
-+	strcpy(_name, name);
-+	gpio->name = _name;
-+	gpio->gpio = gpio_num;
-+	gpio->active_low = active_low;
-+	gpio->default_trigger = trigger;
-+
-+	ret = ath_add_led(sc, led);
-+	if (unlikely(ret < 0))
-+		kfree(led);
-+
-+	return ret;
- }
- 
- void ath_deinit_leds(struct ath_softc *sc)
- {
--	if (!sc->led_registered)
--		return;
-+	struct ath_led *led;
- 
--	ath_led_brightness(&sc->led_cdev, LED_OFF);
--	led_classdev_unregister(&sc->led_cdev);
-+	while (!list_empty(&sc->leds)) {
-+		led = list_first_entry(&sc->leds, struct ath_led, list);
-+		list_del(&led->list);
-+		ath_led_brightness(&led->cdev, LED_OFF);
-+		led_classdev_unregister(&led->cdev);
-+		kfree(led);
-+	}
- }
- 
- void ath_init_leds(struct ath_softc *sc)
- {
--	int ret;
-+	char led_name[32];
-+	const char *trigger;
-+
-+	INIT_LIST_HEAD(&sc->leds);
- 
- 	if (AR_SREV_9100(sc->sc_ah))
- 		return;
- 
--	if (!led_blink)
--		sc->led_cdev.default_trigger =
--			ieee80211_get_radio_led_name(sc->hw);
--
--	snprintf(sc->led_name, sizeof(sc->led_name),
--		"ath9k-%s", wiphy_name(sc->hw->wiphy));
--	sc->led_cdev.name = sc->led_name;
--	sc->led_cdev.brightness_set = ath_led_brightness;
-+	snprintf(led_name, sizeof(led_name), "ath9k-%s",
-+		 wiphy_name(sc->hw->wiphy));
- 
--	ret = led_classdev_register(wiphy_dev(sc->hw->wiphy), &sc->led_cdev);
--	if (ret < 0)
--		return;
-+	if (led_blink)
-+		trigger = sc->led_default_trigger;
-+	else
-+		trigger = ieee80211_get_radio_led_name(sc->hw);
- 
--	sc->led_registered = true;
-+	ath_create_gpio_led(sc, sc->sc_ah->led_pin, led_name, trigger, 1);
- }
- 
- void ath_fill_led_pin(struct ath_softc *sc)
---- a/drivers/net/wireless/ath/ath9k/init.c
-+++ b/drivers/net/wireless/ath/ath9k/init.c
-@@ -918,7 +918,7 @@ int ath9k_init_device(u16 devid, struct 
- 
- #ifdef CPTCFG_MAC80211_LEDS
- 	/* must be initialized before ieee80211_register_hw */
--	sc->led_cdev.default_trigger = ieee80211_create_tpt_led_trigger(sc->hw,
-+	sc->led_default_trigger = ieee80211_create_tpt_led_trigger(sc->hw,
- 		IEEE80211_TPT_LEDTRIG_FL_RADIO, ath9k_tpt_blink,
- 		ARRAY_SIZE(ath9k_tpt_blink));
- #endif
---- a/drivers/net/wireless/ath/ath9k/debug.c
-+++ b/drivers/net/wireless/ath/ath9k/debug.c
-@@ -1825,6 +1825,61 @@ static const struct file_operations fops
- 	.llseek = default_llseek,
- };
- 
-+#ifdef CONFIG_MAC80211_LEDS
-+
-+static ssize_t write_file_gpio_led(struct file *file, const char __user *ubuf,
-+				   size_t count, loff_t *ppos)
-+{
-+	struct ath_softc *sc = file->private_data;
-+	char buf[32], *str, *name, *c;
-+	ssize_t len;
-+	unsigned int gpio;
-+	bool active_low = false;
-+
-+	len = min(count, sizeof(buf) - 1);
-+	if (copy_from_user(buf, ubuf, len))
-+		return -EFAULT;
-+
-+	buf[len] = '\0';
-+	name = strchr(buf, ',');
-+	if (!name)
-+		return -EINVAL;
-+
-+	*(name++) = 0;
-+	if (!*name)
-+		return -EINVAL;
-+
-+	c = strchr(name, '\n');
-+	if (c)
-+		*c = 0;
-+
-+	str = buf;
-+	if (*str == '!') {
-+		str++;
-+		active_low = true;
-+	}
-+
-+	if (kstrtouint(str, 0, &gpio) < 0)
-+		return -EINVAL;
-+
-+	if (gpio >= sc->sc_ah->caps.num_gpio_pins)
-+		return -EINVAL;
-+
-+	if (ath_create_gpio_led(sc, gpio, name, NULL, active_low) < 0)
-+		return -EINVAL;
-+
-+	return count;
-+}
-+
-+static const struct file_operations fops_gpio_led = {
-+	.write = write_file_gpio_led,
-+	.open = simple_open,
-+	.owner = THIS_MODULE,
-+	.llseek = default_llseek,
-+};
-+
-+#endif
-+
- 
- int ath9k_init_debug(struct ath_hw *ah)
- {
-@@ -1847,6 +1902,10 @@ int ath9k_init_debug(struct ath_hw *ah)
- 			    &fops_eeprom);
- 	debugfs_create_file("chanbw", S_IRUSR | S_IWUSR, sc->debug.debugfs_phy,
- 			    sc, &fops_chanbw);
-+#ifdef CONFIG_MAC80211_LEDS
-+	debugfs_create_file("gpio_led", S_IWUSR,
-+			   sc->debug.debugfs_phy, sc, &fops_gpio_led);
-+#endif
- 	debugfs_create_file("dma", S_IRUSR, sc->debug.debugfs_phy, sc,
- 			    &fops_dma);
- 	debugfs_create_file("interrupt", S_IRUSR, sc->debug.debugfs_phy, sc,
diff --git a/package/mac80211/patches/531-ath9k_extra_platform_leds.patch b/package/mac80211/patches/531-ath9k_extra_platform_leds.patch
deleted file mode 100644
index 764242c..0000000
--- a/package/mac80211/patches/531-ath9k_extra_platform_leds.patch
+++ /dev/null
@@ -1,71 +0,0 @@
---- a/include/linux/ath9k_platform.h
-+++ b/include/linux/ath9k_platform.h
-@@ -35,6 +35,9 @@ struct ath9k_platform_data {
- 	bool is_clk_25mhz;
- 	int (*get_mac_revision)(void);
- 	int (*external_reset)(void);
-+
-+	int num_leds;
-+	const struct gpio_led *leds;
- };
- 
- #endif /* _LINUX_ATH9K_PLATFORM_H */
---- a/drivers/net/wireless/ath/ath9k/gpio.c
-+++ b/drivers/net/wireless/ath/ath9k/gpio.c
-@@ -15,6 +15,7 @@
-  */
- 
- #include "ath9k.h"
-+#include <linux/ath9k_platform.h>
- 
- /********************************/
- /*	 LED functions		*/
-@@ -88,6 +89,24 @@ int ath_create_gpio_led(struct ath_softc
- 	return ret;
- }
- 
-+static int ath_create_platform_led(struct ath_softc *sc,
-+				   const struct gpio_led *gpio)
-+{
-+	struct ath_led *led;
-+	int ret;
-+
-+	led = kzalloc(sizeof(*led), GFP_KERNEL);
-+	if (!led)
-+		return -ENOMEM;
-+
-+	led->gpio = gpio;
-+	ret = ath_add_led(sc, led);
-+	if (ret < 0)
-+		kfree(led);
-+
-+	return ret;
-+}
-+
- void ath_deinit_leds(struct ath_softc *sc)
- {
- 	struct ath_led *led;
-@@ -103,8 +122,10 @@ void ath_deinit_leds(struct ath_softc *s
- 
- void ath_init_leds(struct ath_softc *sc)
- {
-+	struct ath9k_platform_data *pdata = sc->dev->platform_data;
- 	char led_name[32];
- 	const char *trigger;
-+	int i;
- 
- 	INIT_LIST_HEAD(&sc->leds);
- 
-@@ -120,6 +141,12 @@ void ath_init_leds(struct ath_softc *sc)
- 		trigger = ieee80211_get_radio_led_name(sc->hw);
- 
- 	ath_create_gpio_led(sc, sc->sc_ah->led_pin, led_name, trigger, 1);
-+
-+	if (!pdata)
-+		return;
-+
-+	for (i = 0; i < pdata->num_leds; i++)
-+		ath_create_platform_led(sc, &pdata->leds[i]);
- }
- 
- void ath_fill_led_pin(struct ath_softc *sc)
diff --git a/package/mac80211/patches/541-ath9k_optimize_interrupt_mitigation.patch b/package/mac80211/patches/541-ath9k_optimize_interrupt_mitigation.patch
deleted file mode 100644
index 95ceb35..0000000
--- a/package/mac80211/patches/541-ath9k_optimize_interrupt_mitigation.patch
+++ /dev/null
@@ -1,30 +0,0 @@
---- a/drivers/net/wireless/ath/ath9k/ar9003_mac.c
-+++ b/drivers/net/wireless/ath/ath9k/ar9003_mac.c
-@@ -241,21 +241,19 @@ static bool ar9003_hw_get_isr(struct ath
- 
- 		*masked = isr & ATH9K_INT_COMMON;
- 
--		if (ah->config.rx_intr_mitigation)
-+		if (ah->config.rx_intr_mitigation) {
- 			if (isr & (AR_ISR_RXMINTR | AR_ISR_RXINTM))
- 				*masked |= ATH9K_INT_RXLP;
--
--		if (ah->config.tx_intr_mitigation)
--			if (isr & (AR_ISR_TXMINTR | AR_ISR_TXINTM))
--				*masked |= ATH9K_INT_TX;
--
--		if (isr & (AR_ISR_LP_RXOK | AR_ISR_RXERR))
-+		} else if (isr & (AR_ISR_LP_RXOK | AR_ISR_RXERR))
- 			*masked |= ATH9K_INT_RXLP;
- 
- 		if (isr & AR_ISR_HP_RXOK)
- 			*masked |= ATH9K_INT_RXHP;
- 
--		if (isr & (AR_ISR_TXOK | AR_ISR_TXERR | AR_ISR_TXEOL)) {
-+		if (ah->config.tx_intr_mitigation) {
-+			if (isr & (AR_ISR_TXMINTR | AR_ISR_TXINTM))
-+				*masked |= ATH9K_INT_TX;
-+		} else if (isr & (AR_ISR_TXOK | AR_ISR_TXERR | AR_ISR_TXEOL)) {
- 			*masked |= ATH9K_INT_TX;
- 
- 			if (!(pCap->hw_caps & ATH9K_HW_CAP_RAC_SUPPORTED)) {
diff --git a/package/mac80211/patches/550-ath9k_reduce_ani_interval.patch b/package/mac80211/patches/550-ath9k_reduce_ani_interval.patch
deleted file mode 100644
index 7c24f46..0000000
--- a/package/mac80211/patches/550-ath9k_reduce_ani_interval.patch
+++ /dev/null
@@ -1,11 +0,0 @@
---- a/drivers/net/wireless/ath/ath9k/ani.h
-+++ b/drivers/net/wireless/ath/ath9k/ani.h
-@@ -38,7 +38,7 @@
- #define ATH9K_ANI_PERIOD                  300
- 
- /* in ms */
--#define ATH9K_ANI_POLLINTERVAL            1000
-+#define ATH9K_ANI_POLLINTERVAL            300
- 
- #define ATH9K_SIG_FIRSTEP_SETTING_MIN     0
- #define ATH9K_SIG_FIRSTEP_SETTING_MAX     20
diff --git a/package/mac80211/patches/552-ath9k_rx_dma_stop_check.patch b/package/mac80211/patches/552-ath9k_rx_dma_stop_check.patch
deleted file mode 100644
index 5d063c7..0000000
--- a/package/mac80211/patches/552-ath9k_rx_dma_stop_check.patch
+++ /dev/null
@@ -1,28 +0,0 @@
---- a/drivers/net/wireless/ath/ath9k/mac.c
-+++ b/drivers/net/wireless/ath/ath9k/mac.c
-@@ -705,7 +705,7 @@ bool ath9k_hw_stopdmarecv(struct ath_hw 
- {
- #define AH_RX_STOP_DMA_TIMEOUT 10000   /* usec */
- 	struct ath_common *common = ath9k_hw_common(ah);
--	u32 mac_status, last_mac_status = 0;
-+	u32 mac_status = 0, last_mac_status = 0;
- 	int i;
- 
- 	/* Enable access to the DMA observation bus */
-@@ -735,6 +735,16 @@ bool ath9k_hw_stopdmarecv(struct ath_hw 
- 	}
- 
- 	if (i == 0) {
-+		if (!AR_SREV_9300_20_OR_LATER(ah) &&
-+		    (mac_status & 0x700) == 0) {
-+			/*
-+			 * DMA is idle but the MAC is still stuck
-+			 * processing events
-+			 */
-+			*reset = true;
-+			return true;
-+		}
-+
- 		ath_err(common,
- 			"DMA failed to stop in %d ms AR_CR=0x%08x AR_DIAG_SW=0x%08x DMADBG_7=0x%08x\n",
- 			AH_RX_STOP_DMA_TIMEOUT / 1000,
diff --git a/package/mac80211/patches/553-ath9k_debugfs_diag.patch b/package/mac80211/patches/553-ath9k_debugfs_diag.patch
deleted file mode 100644
index 7230d32..0000000
--- a/package/mac80211/patches/553-ath9k_debugfs_diag.patch
+++ /dev/null
@@ -1,139 +0,0 @@
---- a/drivers/net/wireless/ath/ath9k/debug.c
-+++ b/drivers/net/wireless/ath/ath9k/debug.c
-@@ -1881,6 +1881,50 @@ static const struct file_operations fops
- #endif
- 
- 
-+static ssize_t read_file_diag(struct file *file, char __user *user_buf,
-+			     size_t count, loff_t *ppos)
-+{
-+	struct ath_softc *sc = file->private_data;
-+	struct ath_hw *ah = sc->sc_ah;
-+	char buf[32];
-+	unsigned int len;
-+
-+	len = sprintf(buf, "0x%08lx\n", ah->diag);
-+	return simple_read_from_buffer(user_buf, count, ppos, buf, len);
-+}
-+
-+static ssize_t write_file_diag(struct file *file, const char __user *user_buf,
-+			     size_t count, loff_t *ppos)
-+{
-+	struct ath_softc *sc = file->private_data;
-+	struct ath_hw *ah = sc->sc_ah;
-+	unsigned long diag;
-+	char buf[32];
-+	ssize_t len;
-+
-+	len = min(count, sizeof(buf) - 1);
-+	if (copy_from_user(buf, user_buf, len))
-+		return -EFAULT;
-+
-+	buf[len] = '\0';
-+	if (kstrtoul(buf, 0, &diag))
-+		return -EINVAL;
-+
-+	ah->diag = diag;
-+	ath9k_hw_update_diag(ah);
-+
-+	return count;
-+}
-+
-+static const struct file_operations fops_diag = {
-+	.read = read_file_diag,
-+	.write = write_file_diag,
-+	.open = simple_open,
-+	.owner = THIS_MODULE,
-+	.llseek = default_llseek,
-+};
-+
-+
- int ath9k_init_debug(struct ath_hw *ah)
- {
- 	struct ath_common *common = ath9k_hw_common(ah);
-@@ -1906,6 +1950,8 @@ int ath9k_init_debug(struct ath_hw *ah)
- 	debugfs_create_file("gpio_led", S_IWUSR,
- 			   sc->debug.debugfs_phy, sc, &fops_gpio_led);
- #endif
-+	debugfs_create_file("diag", S_IRUSR | S_IWUSR, sc->debug.debugfs_phy,
-+			    sc, &fops_diag);
- 	debugfs_create_file("dma", S_IRUSR, sc->debug.debugfs_phy, sc,
- 			    &fops_dma);
- 	debugfs_create_file("interrupt", S_IRUSR, sc->debug.debugfs_phy, sc,
---- a/drivers/net/wireless/ath/ath9k/hw.h
-+++ b/drivers/net/wireless/ath/ath9k/hw.h
-@@ -499,6 +499,12 @@ enum {
- 	ATH9K_RESET_COLD,
- };
- 
-+enum {
-+	ATH_DIAG_DISABLE_RX,
-+	ATH_DIAG_DISABLE_TX,
-+	ATH_DIAG_TRIGGER_ERROR,
-+};
-+
- struct ath9k_hw_version {
- 	u32 magic;
- 	u16 devid;
-@@ -777,6 +783,8 @@ struct ath_hw {
- 	u32 rfkill_polarity;
- 	u32 ah_flags;
- 
-+	unsigned long diag;
-+
- 	bool reset_power_on;
- 	bool htc_reset_init;
- 
-@@ -1027,6 +1035,7 @@ void ath9k_hw_set_sta_beacon_timers(stru
- bool ath9k_hw_check_alive(struct ath_hw *ah);
- 
- bool ath9k_hw_setpower(struct ath_hw *ah, enum ath9k_power_mode mode);
-+void ath9k_hw_update_diag(struct ath_hw *ah);
- 
- #ifdef CPTCFG_ATH9K_DEBUGFS
- void ath9k_debug_sync_cause(struct ath_common *common, u32 sync_cause);
---- a/drivers/net/wireless/ath/ath9k/hw.c
-+++ b/drivers/net/wireless/ath/ath9k/hw.c
-@@ -1853,6 +1853,20 @@ fail:
- 	return -EINVAL;
- }
- 
-+void ath9k_hw_update_diag(struct ath_hw *ah)
-+{
-+	if (test_bit(ATH_DIAG_DISABLE_RX, &ah->diag))
-+		REG_SET_BIT(ah, AR_DIAG_SW, AR_DIAG_RX_DIS);
-+	else
-+		REG_CLR_BIT(ah, AR_DIAG_SW, AR_DIAG_RX_DIS);
-+
-+	if (test_bit(ATH_DIAG_DISABLE_TX, &ah->diag))
-+		REG_SET_BIT(ah, AR_DIAG_SW, AR_DIAG_LOOP_BACK);
-+	else
-+		REG_CLR_BIT(ah, AR_DIAG_SW, AR_DIAG_LOOP_BACK);
-+}
-+EXPORT_SYMBOL(ath9k_hw_update_diag);
-+
- int ath9k_hw_reset(struct ath_hw *ah, struct ath9k_channel *chan,
- 		   struct ath9k_hw_cal_data *caldata, bool fastcc)
- {
-@@ -2055,6 +2069,7 @@ int ath9k_hw_reset(struct ath_hw *ah, st
- 	}
- 
- 	ath9k_hw_apply_gpio_override(ah);
-+	ath9k_hw_update_diag(ah);
- 
- 	if (AR_SREV_9565(ah) && ah->shared_chain_lnadiv)
- 		REG_SET_BIT(ah, AR_BTCOEX_WL_LNADIV, AR_BTCOEX_WL_LNADIV_FORCE_ON);
---- a/drivers/net/wireless/ath/ath9k/main.c
-+++ b/drivers/net/wireless/ath/ath9k/main.c
-@@ -472,6 +472,11 @@ irqreturn_t ath_isr(int irq, void *dev)
- 	ath9k_hw_getisr(ah, &status);	/* NB: clears ISR too */
- 	status &= ah->imask;	/* discard unasked-for bits */
- 
-+	if (test_bit(ATH_DIAG_TRIGGER_ERROR, &ah->diag)) {
-+		status |= ATH9K_INT_FATAL;
-+		clear_bit(ATH_DIAG_TRIGGER_ERROR, &ah->diag);
-+	}
-+
- 	/*
- 	 * If there are no status bits set, then this interrupt was not
- 	 * for me (should have been caught above).
diff --git a/package/mac80211/patches/554-ath9k_ani_mrc_fix.patch b/package/mac80211/patches/554-ath9k_ani_mrc_fix.patch
deleted file mode 100644
index 47df721..0000000
--- a/package/mac80211/patches/554-ath9k_ani_mrc_fix.patch
+++ /dev/null
@@ -1,13 +0,0 @@
---- a/drivers/net/wireless/ath/ath9k/ar9003_phy.c
-+++ b/drivers/net/wireless/ath/ath9k/ar9003_phy.c
-@@ -1173,6 +1173,10 @@ skip_ws_det:
- 		 * is_on == 0 means MRC CCK is OFF (more noise imm)
- 		 */
- 		bool is_on = param ? 1 : 0;
-+
-+		if (ah->caps.rx_chainmask == 1)
-+			break;
-+
- 		REG_RMW_FIELD(ah, AR_PHY_MRC_CCK_CTRL,
- 			      AR_PHY_MRC_CCK_ENABLE, is_on);
- 		REG_RMW_FIELD(ah, AR_PHY_MRC_CCK_CTRL,
diff --git a/package/mac80211/patches/555-ath9k-allow-to-disable-bands-via-platform-data.patch b/package/mac80211/patches/555-ath9k-allow-to-disable-bands-via-platform-data.patch
deleted file mode 100644
index 584a7d7..0000000
--- a/package/mac80211/patches/555-ath9k-allow-to-disable-bands-via-platform-data.patch
+++ /dev/null
@@ -1,70 +0,0 @@
---- a/include/linux/ath9k_platform.h
-+++ b/include/linux/ath9k_platform.h
-@@ -33,6 +33,9 @@ struct ath9k_platform_data {
- 
- 	bool endian_check;
- 	bool is_clk_25mhz;
-+	bool disable_2ghz;
-+	bool disable_5ghz;
-+
- 	int (*get_mac_revision)(void);
- 	int (*external_reset)(void);
- 
---- a/drivers/net/wireless/ath/ath9k/hw.c
-+++ b/drivers/net/wireless/ath/ath9k/hw.c
-@@ -2448,17 +2448,25 @@ int ath9k_hw_fill_cap_info(struct ath_hw
- 	}
- 
- 	eeval = ah->eep_ops->get_eeprom(ah, EEP_OP_MODE);
--	if ((eeval & (AR5416_OPFLAGS_11G | AR5416_OPFLAGS_11A)) == 0) {
--		ath_err(common,
--			"no band has been marked as supported in EEPROM\n");
--		return -EINVAL;
-+
-+	if (eeval & AR5416_OPFLAGS_11A) {
-+		if (ah->disable_5ghz)
-+			ath_warn(common, "disabling 5GHz band\n");
-+		else
-+			pCap->hw_caps |= ATH9K_HW_CAP_5GHZ;
- 	}
- 
--	if (eeval & AR5416_OPFLAGS_11A)
--		pCap->hw_caps |= ATH9K_HW_CAP_5GHZ;
-+	if (eeval & AR5416_OPFLAGS_11G) {
-+		if (ah->disable_2ghz)
-+			ath_warn(common, "disabling 2GHz band\n");
-+		else
-+			pCap->hw_caps |= ATH9K_HW_CAP_2GHZ;
-+	}
- 
--	if (eeval & AR5416_OPFLAGS_11G)
--		pCap->hw_caps |= ATH9K_HW_CAP_2GHZ;
-+	if ((pCap->hw_caps & (ATH9K_HW_CAP_2GHZ | ATH9K_HW_CAP_5GHZ)) == 0) {
-+		ath_err(common, "both bands are disabled\n");
-+		return -EINVAL;
-+	}
- 
- 	if (AR_SREV_9485(ah) ||
- 	    AR_SREV_9285(ah) ||
---- a/drivers/net/wireless/ath/ath9k/hw.h
-+++ b/drivers/net/wireless/ath/ath9k/hw.h
-@@ -947,6 +947,8 @@ struct ath_hw {
- 	bool is_clk_25mhz;
- 	int (*get_mac_revision)(void);
- 	int (*external_reset)(void);
-+	bool disable_2ghz;
-+	bool disable_5ghz;
- 
- 	const struct firmware *eeprom_blob;
- };
---- a/drivers/net/wireless/ath/ath9k/init.c
-+++ b/drivers/net/wireless/ath/ath9k/init.c
-@@ -613,6 +613,8 @@ static int ath9k_init_softc(u16 devid, s
- 		ah->is_clk_25mhz = pdata->is_clk_25mhz;
- 		ah->get_mac_revision = pdata->get_mac_revision;
- 		ah->external_reset = pdata->external_reset;
-+		ah->disable_2ghz = pdata->disable_2ghz;
-+		ah->disable_5ghz = pdata->disable_5ghz;
- 		if (!pdata->endian_check)
- 			ah->ah_flags |= AH_NO_EEP_SWAP;
- 	}
diff --git a/package/mac80211/patches/556-ath9k_fix_rx_race.patch b/package/mac80211/patches/556-ath9k_fix_rx_race.patch
deleted file mode 100644
index 69030d2..0000000
--- a/package/mac80211/patches/556-ath9k_fix_rx_race.patch
+++ /dev/null
@@ -1,82 +0,0 @@
---- a/drivers/net/wireless/ath/ath9k/ath9k.h
-+++ b/drivers/net/wireless/ath/ath9k/ath9k.h
-@@ -79,10 +79,6 @@ struct ath_config {
- 		       sizeof(struct ath_buf_state));		\
- 	} while (0)
- 
--#define ATH_RXBUF_RESET(_bf) do {		\
--		(_bf)->bf_stale = false;	\
--	} while (0)
--
- /**
-  * enum buffer_type - Buffer type flags
-  *
-@@ -317,6 +313,7 @@ struct ath_rx {
- 	struct ath_descdma rxdma;
- 	struct ath_rx_edma rx_edma[ATH9K_RX_QUEUE_MAX];
- 
-+	struct ath_buf *buf_hold;
- 	struct sk_buff *frag;
- 
- 	u32 ampdu_ref;
---- a/drivers/net/wireless/ath/ath9k/recv.c
-+++ b/drivers/net/wireless/ath/ath9k/recv.c
-@@ -42,8 +42,6 @@ static void ath_rx_buf_link(struct ath_s
- 	struct ath_desc *ds;
- 	struct sk_buff *skb;
- 
--	ATH_RXBUF_RESET(bf);
--
- 	ds = bf->bf_desc;
- 	ds->ds_link = 0; /* link to null */
- 	ds->ds_data = bf->bf_buf_addr;
-@@ -70,6 +68,14 @@ static void ath_rx_buf_link(struct ath_s
- 	sc->rx.rxlink = &ds->ds_link;
- }
- 
-+static void ath_rx_buf_relink(struct ath_softc *sc, struct ath_buf *bf)
-+{
-+	if (sc->rx.buf_hold)
-+		ath_rx_buf_link(sc, sc->rx.buf_hold);
-+
-+	sc->rx.buf_hold = bf;
-+}
-+
- static void ath_setdefantenna(struct ath_softc *sc, u32 antenna)
- {
- 	/* XXX block beacon interrupts */
-@@ -117,7 +123,6 @@ static bool ath_rx_edma_buf_link(struct 
- 
- 	skb = bf->bf_mpdu;
- 
--	ATH_RXBUF_RESET(bf);
- 	memset(skb->data, 0, ah->caps.rx_status_len);
- 	dma_sync_single_for_device(sc->dev, bf->bf_buf_addr,
- 				ah->caps.rx_status_len, DMA_TO_DEVICE);
-@@ -432,6 +437,7 @@ int ath_startrecv(struct ath_softc *sc)
- 	if (list_empty(&sc->rx.rxbuf))
- 		goto start_recv;
- 
-+	sc->rx.buf_hold = NULL;
- 	sc->rx.rxlink = NULL;
- 	list_for_each_entry_safe(bf, tbf, &sc->rx.rxbuf, list) {
- 		ath_rx_buf_link(sc, bf);
-@@ -677,6 +683,9 @@ static struct ath_buf *ath_get_next_rx_b
- 	}
- 
- 	bf = list_first_entry(&sc->rx.rxbuf, struct ath_buf, list);
-+	if (bf == sc->rx.buf_hold)
-+		return NULL;
-+
- 	ds = bf->bf_desc;
- 
- 	/*
-@@ -1391,7 +1400,7 @@ requeue:
- 		if (edma) {
- 			ath_rx_edma_buf_link(sc, qtype);
- 		} else {
--			ath_rx_buf_link(sc, bf);
-+			ath_rx_buf_relink(sc, bf);
- 			ath9k_hw_rxena(ah);
- 		}
- 	} while (1);
diff --git a/package/mac80211/patches/560-ath9k_tx_queueing_rework.patch b/package/mac80211/patches/560-ath9k_tx_queueing_rework.patch
deleted file mode 100644
index 47ecd74..0000000
--- a/package/mac80211/patches/560-ath9k_tx_queueing_rework.patch
+++ /dev/null
@@ -1,546 +0,0 @@
---- a/drivers/net/wireless/ath/ath9k/ath9k.h
-+++ b/drivers/net/wireless/ath/ath9k/ath9k.h
-@@ -133,7 +133,6 @@ int ath_descdma_setup(struct ath_softc *
- #define ATH_AGGR_ENCRYPTDELIM      10
- /* minimum h/w qdepth to be sustained to maximize aggregation */
- #define ATH_AGGR_MIN_QDEPTH        2
--#define ATH_AMPDU_SUBFRAME_DEFAULT 32
- 
- #define IEEE80211_SEQ_SEQ_SHIFT    4
- #define IEEE80211_SEQ_MAX          4096
-@@ -208,8 +207,9 @@ struct ath_frame_info {
- 	int framelen;
- 	enum ath9k_key_type keytype;
- 	u8 keyix;
--	u8 retries;
- 	u8 rtscts_rate;
-+	u8 retries : 7;
-+	u8 baw_tracked : 1;
- };
- 
- struct ath_buf_state {
-@@ -237,6 +237,7 @@ struct ath_buf {
- struct ath_atx_tid {
- 	struct list_head list;
- 	struct sk_buff_head buf_q;
-+	struct sk_buff_head retry_q;
- 	struct ath_node *an;
- 	struct ath_atx_ac *ac;
- 	unsigned long tx_buf[BITS_TO_LONGS(ATH_TID_MAX_BUFS)];
---- a/drivers/net/wireless/ath/ath9k/debug.c
-+++ b/drivers/net/wireless/ath/ath9k/debug.c
-@@ -607,6 +607,28 @@ static ssize_t read_file_xmit(struct fil
- 	return retval;
- }
- 
-+static ssize_t print_queue(struct ath_softc *sc, struct ath_txq *txq,
-+			   char *buf, ssize_t size)
-+{
-+	ssize_t len = 0;
-+
-+	ath_txq_lock(sc, txq);
-+
-+	len += snprintf(buf + len, size - len, "%s: %d ",
-+			"qnum", txq->axq_qnum);
-+	len += snprintf(buf + len, size - len, "%s: %2d ",
-+			"qdepth", txq->axq_depth);
-+	len += snprintf(buf + len, size - len, "%s: %2d ",
-+			"ampdu-depth", txq->axq_ampdu_depth);
-+	len += snprintf(buf + len, size - len, "%s: %3d ",
-+			"pending", txq->pending_frames);
-+	len += snprintf(buf + len, size - len, "%s: %d\n",
-+			"stopped", txq->stopped);
-+
-+	ath_txq_unlock(sc, txq);
-+	return len;
-+}
-+
- static ssize_t read_file_queues(struct file *file, char __user *user_buf,
- 				size_t count, loff_t *ppos)
- {
-@@ -624,24 +646,13 @@ static ssize_t read_file_queues(struct f
- 
- 	for (i = 0; i < IEEE80211_NUM_ACS; i++) {
- 		txq = sc->tx.txq_map[i];
--		len += snprintf(buf + len, size - len, "(%s): ", qname[i]);
--
--		ath_txq_lock(sc, txq);
--
--		len += snprintf(buf + len, size - len, "%s: %d ",
--				"qnum", txq->axq_qnum);
--		len += snprintf(buf + len, size - len, "%s: %2d ",
--				"qdepth", txq->axq_depth);
--		len += snprintf(buf + len, size - len, "%s: %2d ",
--				"ampdu-depth", txq->axq_ampdu_depth);
--		len += snprintf(buf + len, size - len, "%s: %3d ",
--				"pending", txq->pending_frames);
--		len += snprintf(buf + len, size - len, "%s: %d\n",
--				"stopped", txq->stopped);
--
--		ath_txq_unlock(sc, txq);
-+		len += snprintf(buf + len, size - len, "(%s):  ", qname[i]);
-+		len += print_queue(sc, txq, buf + len, size - len);
- 	}
- 
-+	len += snprintf(buf + len, size - len, "(CAB): ");
-+	len += print_queue(sc, sc->beacon.cabq, buf + len, size - len);
-+
- 	if (len > size)
- 		len = size;
- 
---- a/drivers/net/wireless/ath/ath9k/main.c
-+++ b/drivers/net/wireless/ath/ath9k/main.c
-@@ -1402,9 +1402,6 @@ static void ath9k_sta_notify(struct ieee
- 	struct ath_softc *sc = hw->priv;
- 	struct ath_node *an = (struct ath_node *) sta->drv_priv;
- 
--	if (!sta->ht_cap.ht_supported)
--		return;
--
- 	switch (cmd) {
- 	case STA_NOTIFY_SLEEP:
- 		an->sleeping = true;
---- a/drivers/net/wireless/ath/ath9k/xmit.c
-+++ b/drivers/net/wireless/ath/ath9k/xmit.c
-@@ -168,6 +168,36 @@ static void ath_txq_skb_done(struct ath_
- 	}
- }
- 
-+static struct ath_atx_tid *
-+ath_get_skb_tid(struct ath_softc *sc, struct ath_node *an, struct sk_buff *skb)
-+{
-+	struct ieee80211_hdr *hdr;
-+	u8 tidno = 0;
-+
-+	hdr = (struct ieee80211_hdr *) skb->data;
-+	if (ieee80211_is_data_qos(hdr->frame_control))
-+		tidno = ieee80211_get_qos_ctl(hdr)[0];
-+
-+	tidno &= IEEE80211_QOS_CTL_TID_MASK;
-+	return ATH_AN_2_TID(an, tidno);
-+}
-+
-+static bool ath_tid_has_buffered(struct ath_atx_tid *tid)
-+{
-+	return !skb_queue_empty(&tid->buf_q) || !skb_queue_empty(&tid->retry_q);
-+}
-+
-+static struct sk_buff *ath_tid_dequeue(struct ath_atx_tid *tid)
-+{
-+	struct sk_buff *skb;
-+
-+	skb = __skb_dequeue(&tid->retry_q);
-+	if (!skb)
-+		skb = __skb_dequeue(&tid->buf_q);
-+
-+	return skb;
-+}
-+
- static void ath_tx_flush_tid(struct ath_softc *sc, struct ath_atx_tid *tid)
- {
- 	struct ath_txq *txq = tid->ac->txq;
-@@ -182,7 +212,7 @@ static void ath_tx_flush_tid(struct ath_
- 
- 	memset(&ts, 0, sizeof(ts));
- 
--	while ((skb = __skb_dequeue(&tid->buf_q))) {
-+	while ((skb = ath_tid_dequeue(tid))) {
- 		fi = get_frame_info(skb);
- 		bf = fi->bf;
- 
-@@ -195,7 +225,7 @@ static void ath_tx_flush_tid(struct ath_
- 			}
- 		}
- 
--		if (fi->retries) {
-+		if (fi->baw_tracked) {
- 			list_add_tail(&bf->list, &bf_head);
- 			ath_tx_update_baw(sc, tid, bf->bf_state.seqno);
- 			ath_tx_complete_buf(sc, bf, txq, &bf_head, &ts, 0);
-@@ -232,13 +262,16 @@ static void ath_tx_update_baw(struct ath
- }
- 
- static void ath_tx_addto_baw(struct ath_softc *sc, struct ath_atx_tid *tid,
--			     u16 seqno)
-+			     struct ath_buf *bf)
- {
-+	struct ath_frame_info *fi = get_frame_info(bf->bf_mpdu);
-+	u16 seqno = bf->bf_state.seqno;
- 	int index, cindex;
- 
- 	index  = ATH_BA_INDEX(tid->seq_start, seqno);
- 	cindex = (tid->baw_head + index) & (ATH_TID_MAX_BUFS - 1);
- 	__set_bit(cindex, tid->tx_buf);
-+	fi->baw_tracked = 1;
- 
- 	if (index >= ((tid->baw_tail - tid->baw_head) &
- 		(ATH_TID_MAX_BUFS - 1))) {
-@@ -266,7 +299,7 @@ static void ath_tid_drain(struct ath_sof
- 	memset(&ts, 0, sizeof(ts));
- 	INIT_LIST_HEAD(&bf_head);
- 
--	while ((skb = __skb_dequeue(&tid->buf_q))) {
-+	while ((skb = ath_tid_dequeue(tid))) {
- 		fi = get_frame_info(skb);
- 		bf = fi->bf;
- 
-@@ -403,7 +436,6 @@ static void ath_tx_complete_aggr(struct 
- 	struct ieee80211_tx_rate rates[4];
- 	struct ath_frame_info *fi;
- 	int nframes;
--	u8 tidno;
- 	bool flush = !!(ts->ts_status & ATH9K_TX_FLUSH);
- 	int i, retries;
- 	int bar_index = -1;
-@@ -440,8 +472,7 @@ static void ath_tx_complete_aggr(struct 
- 	}
- 
- 	an = (struct ath_node *)sta->drv_priv;
--	tidno = ieee80211_get_qos_ctl(hdr)[0] & IEEE80211_QOS_CTL_TID_MASK;
--	tid = ATH_AN_2_TID(an, tidno);
-+	tid = ath_get_skb_tid(sc, an, skb);
- 	seq_first = tid->seq_start;
- 	isba = ts->ts_flags & ATH9K_TX_BA;
- 
-@@ -453,7 +484,7 @@ static void ath_tx_complete_aggr(struct 
- 	 * Only BlockAcks have a TID and therefore normal Acks cannot be
- 	 * checked
- 	 */
--	if (isba && tidno != ts->tid)
-+	if (isba && tid->tidno != ts->tid)
- 		txok = false;
- 
- 	isaggr = bf_isaggr(bf);
-@@ -489,7 +520,8 @@ static void ath_tx_complete_aggr(struct 
- 		tx_info = IEEE80211_SKB_CB(skb);
- 		fi = get_frame_info(skb);
- 
--		if (!BAW_WITHIN(tid->seq_start, tid->baw_size, seqno)) {
-+		if (!BAW_WITHIN(tid->seq_start, tid->baw_size, seqno) ||
-+		    !tid->active) {
- 			/*
- 			 * Outside of the current BlockAck window,
- 			 * maybe part of a previous session
-@@ -583,7 +615,7 @@ static void ath_tx_complete_aggr(struct 
- 		if (an->sleeping)
- 			ieee80211_sta_set_buffered(sta, tid->tidno, true);
- 
--		skb_queue_splice(&bf_pending, &tid->buf_q);
-+		skb_queue_splice_tail(&bf_pending, &tid->retry_q);
- 		if (!an->sleeping) {
- 			ath_tx_queue_tid(txq, tid);
- 
-@@ -641,7 +673,7 @@ static void ath_tx_process_buffer(struct
- 	} else
- 		ath_tx_complete_aggr(sc, txq, bf, bf_head, ts, txok);
- 
--	if ((sc->sc_ah->caps.hw_caps & ATH9K_HW_CAP_HT) && !flush)
-+	if (!flush)
- 		ath_txq_schedule(sc, txq);
- }
- 
-@@ -815,15 +847,20 @@ static int ath_compute_num_delims(struct
- 
- static struct ath_buf *
- ath_tx_get_tid_subframe(struct ath_softc *sc, struct ath_txq *txq,
--			struct ath_atx_tid *tid)
-+			struct ath_atx_tid *tid, struct sk_buff_head **q)
- {
-+	struct ieee80211_tx_info *tx_info;
- 	struct ath_frame_info *fi;
- 	struct sk_buff *skb;
- 	struct ath_buf *bf;
- 	u16 seqno;
- 
- 	while (1) {
--		skb = skb_peek(&tid->buf_q);
-+		*q = &tid->retry_q;
-+		if (skb_queue_empty(*q))
-+			*q = &tid->buf_q;
-+
-+		skb = skb_peek(*q);
- 		if (!skb)
- 			break;
- 
-@@ -833,12 +870,22 @@ ath_tx_get_tid_subframe(struct ath_softc
- 			bf = ath_tx_setup_buffer(sc, txq, tid, skb);
- 
- 		if (!bf) {
--			__skb_unlink(skb, &tid->buf_q);
-+			__skb_unlink(skb, *q);
- 			ath_txq_skb_done(sc, txq, skb);
- 			ieee80211_free_txskb(sc->hw, skb);
- 			continue;
- 		}
- 
-+		bf->bf_next = NULL;
-+		bf->bf_lastbf = bf;
-+
-+		tx_info = IEEE80211_SKB_CB(skb);
-+		tx_info->flags &= ~IEEE80211_TX_CTL_CLEAR_PS_FILT;
-+		if (!(tx_info->flags & IEEE80211_TX_CTL_AMPDU)) {
-+			bf->bf_state.bf_type = 0;
-+			return bf;
-+		}
-+
- 		bf->bf_state.bf_type = BUF_AMPDU | BUF_AGGR;
- 		seqno = bf->bf_state.seqno;
- 
-@@ -852,14 +899,12 @@ ath_tx_get_tid_subframe(struct ath_softc
- 
- 			INIT_LIST_HEAD(&bf_head);
- 			list_add(&bf->list, &bf_head);
--			__skb_unlink(skb, &tid->buf_q);
-+			__skb_unlink(skb, *q);
- 			ath_tx_update_baw(sc, tid, seqno);
- 			ath_tx_complete_buf(sc, bf, txq, &bf_head, &ts, 0);
- 			continue;
- 		}
- 
--		bf->bf_next = NULL;
--		bf->bf_lastbf = bf;
- 		return bf;
- 	}
- 
-@@ -874,16 +919,17 @@ static enum ATH_AGGR_STATUS ath_tx_form_
- {
- #define PADBYTES(_len) ((4 - ((_len) % 4)) % 4)
- 	struct ath_buf *bf, *bf_first = NULL, *bf_prev = NULL;
--	int rl = 0, nframes = 0, ndelim, prev_al = 0;
-+	int nframes = 0, ndelim;
- 	u16 aggr_limit = 0, al = 0, bpad = 0,
--		al_delta, h_baw = tid->baw_size / 2;
-+	    al_delta, h_baw = tid->baw_size / 2;
- 	enum ATH_AGGR_STATUS status = ATH_AGGR_DONE;
- 	struct ieee80211_tx_info *tx_info;
- 	struct ath_frame_info *fi;
- 	struct sk_buff *skb;
-+	struct sk_buff_head *tid_q;
- 
- 	do {
--		bf = ath_tx_get_tid_subframe(sc, txq, tid);
-+		bf = ath_tx_get_tid_subframe(sc, txq, tid, &tid_q);
- 		if (!bf) {
- 			status = ATH_AGGR_BAW_CLOSED;
- 			break;
-@@ -892,33 +938,24 @@ static enum ATH_AGGR_STATUS ath_tx_form_
- 		skb = bf->bf_mpdu;
- 		fi = get_frame_info(skb);
- 
--		if (!bf_first)
-+		if (!bf_first) {
- 			bf_first = bf;
--
--		if (!rl) {
- 			ath_set_rates(tid->an->vif, tid->an->sta, bf);
- 			aggr_limit = ath_lookup_rate(sc, bf, tid);
--			rl = 1;
- 		}
- 
- 		/* do not exceed aggregation limit */
- 		al_delta = ATH_AGGR_DELIM_SZ + fi->framelen;
-+		if (nframes) {
-+			if (aggr_limit < al + bpad + al_delta ||
-+			    ath_lookup_legacy(bf) || nframes >= h_baw) {
-+				status = ATH_AGGR_LIMITED;
-+				break;
-+			}
- 
--		if (nframes &&
--		    ((aggr_limit < (al + bpad + al_delta + prev_al)) ||
--		     ath_lookup_legacy(bf))) {
--			status = ATH_AGGR_LIMITED;
--			break;
--		}
--
--		tx_info = IEEE80211_SKB_CB(bf->bf_mpdu);
--		if (nframes && (tx_info->flags & IEEE80211_TX_CTL_RATE_CTRL_PROBE))
--			break;
--
--		/* do not exceed subframe limit */
--		if (nframes >= min((int)h_baw, ATH_AMPDU_SUBFRAME_DEFAULT)) {
--			status = ATH_AGGR_LIMITED;
--			break;
-+			tx_info = IEEE80211_SKB_CB(bf->bf_mpdu);
-+			if (tx_info->flags & IEEE80211_TX_CTL_RATE_CTRL_PROBE)
-+				break;
- 		}
- 
- 		/* add padding for previous frame to aggregation length */
-@@ -936,18 +973,18 @@ static enum ATH_AGGR_STATUS ath_tx_form_
- 		bf->bf_next = NULL;
- 
- 		/* link buffers of this frame to the aggregate */
--		if (!fi->retries)
--			ath_tx_addto_baw(sc, tid, bf->bf_state.seqno);
-+		if (!fi->baw_tracked)
-+			ath_tx_addto_baw(sc, tid, bf);
- 		bf->bf_state.ndelim = ndelim;
- 
--		__skb_unlink(skb, &tid->buf_q);
-+		__skb_unlink(skb, tid_q);
- 		list_add_tail(&bf->list, bf_q);
- 		if (bf_prev)
- 			bf_prev->bf_next = bf;
- 
- 		bf_prev = bf;
- 
--	} while (!skb_queue_empty(&tid->buf_q));
-+	} while (ath_tid_has_buffered(tid));
- 
- 	*aggr_len = al;
- 
-@@ -1222,7 +1259,7 @@ static void ath_tx_sched_aggr(struct ath
- 	int aggr_len;
- 
- 	do {
--		if (skb_queue_empty(&tid->buf_q))
-+		if (!ath_tid_has_buffered(tid))
- 			return;
- 
- 		INIT_LIST_HEAD(&bf_q);
-@@ -1301,7 +1338,7 @@ void ath_tx_aggr_stop(struct ath_softc *
- 
- 	ath_txq_lock(sc, txq);
- 	txtid->active = false;
--	txtid->paused = true;
-+	txtid->paused = false;
- 	ath_tx_flush_tid(sc, txtid);
- 	ath_txq_unlock_complete(sc, txq);
- }
-@@ -1326,7 +1363,7 @@ void ath_tx_aggr_sleep(struct ieee80211_
- 
- 		ath_txq_lock(sc, txq);
- 
--		buffered = !skb_queue_empty(&tid->buf_q);
-+		buffered = ath_tid_has_buffered(tid);
- 
- 		tid->sched = false;
- 		list_del(&tid->list);
-@@ -1358,7 +1395,7 @@ void ath_tx_aggr_wakeup(struct ath_softc
- 		ath_txq_lock(sc, txq);
- 		ac->clear_ps_filter = true;
- 
--		if (!skb_queue_empty(&tid->buf_q) && !tid->paused) {
-+		if (!tid->paused && ath_tid_has_buffered(tid)) {
- 			ath_tx_queue_tid(txq, tid);
- 			ath_txq_schedule(sc, txq);
- 		}
-@@ -1383,7 +1420,7 @@ void ath_tx_aggr_resume(struct ath_softc
- 	tid->baw_size = IEEE80211_MIN_AMPDU_BUF << sta->ht_cap.ampdu_factor;
- 	tid->paused = false;
- 
--	if (!skb_queue_empty(&tid->buf_q)) {
-+	if (ath_tid_has_buffered(tid)) {
- 		ath_tx_queue_tid(txq, tid);
- 		ath_txq_schedule(sc, txq);
- 	}
-@@ -1403,6 +1440,7 @@ void ath9k_release_buffered_frames(struc
- 	struct ieee80211_tx_info *info;
- 	struct list_head bf_q;
- 	struct ath_buf *bf_tail = NULL, *bf;
-+	struct sk_buff_head *tid_q;
- 	int sent = 0;
- 	int i;
- 
-@@ -1418,15 +1456,15 @@ void ath9k_release_buffered_frames(struc
- 			continue;
- 
- 		ath_txq_lock(sc, tid->ac->txq);
--		while (!skb_queue_empty(&tid->buf_q) && nframes > 0) {
--			bf = ath_tx_get_tid_subframe(sc, sc->tx.uapsdq, tid);
-+		while (nframes > 0) {
-+			bf = ath_tx_get_tid_subframe(sc, sc->tx.uapsdq, tid, &tid_q);
- 			if (!bf)
- 				break;
- 
--			__skb_unlink(bf->bf_mpdu, &tid->buf_q);
-+			__skb_unlink(bf->bf_mpdu, tid_q);
- 			list_add_tail(&bf->list, &bf_q);
- 			ath_set_rates(tid->an->vif, tid->an->sta, bf);
--			ath_tx_addto_baw(sc, tid, bf->bf_state.seqno);
-+			ath_tx_addto_baw(sc, tid, bf);
- 			bf->bf_state.bf_type &= ~BUF_AGGR;
- 			if (bf_tail)
- 				bf_tail->bf_next = bf;
-@@ -1436,7 +1474,7 @@ void ath9k_release_buffered_frames(struc
- 			sent++;
- 			TX_STAT_INC(txq->axq_qnum, a_queued_hw);
- 
--			if (skb_queue_empty(&tid->buf_q))
-+			if (!ath_tid_has_buffered(tid))
- 				ieee80211_sta_set_buffered(an->sta, i, false);
- 		}
- 		ath_txq_unlock_complete(sc, tid->ac->txq);
-@@ -1722,7 +1760,7 @@ void ath_txq_schedule(struct ath_softc *
- 			 * add tid to round-robin queue if more frames
- 			 * are pending for the tid
- 			 */
--			if (!skb_queue_empty(&tid->buf_q))
-+			if (ath_tid_has_buffered(tid))
- 				ath_tx_queue_tid(txq, tid);
- 
- 			if (tid == last_tid ||
-@@ -1831,7 +1869,7 @@ static void ath_tx_send_ampdu(struct ath
- 	 * - seqno is not within block-ack window
- 	 * - h/w queue depth exceeds low water mark
- 	 */
--	if ((!skb_queue_empty(&tid->buf_q) || tid->paused ||
-+	if ((ath_tid_has_buffered(tid) || tid->paused ||
- 	     !BAW_WITHIN(tid->seq_start, tid->baw_size, tid->seq_next) ||
- 	     txq->axq_ampdu_depth >= ATH_AGGR_MIN_QDEPTH) &&
- 	    txq != sc->tx.uapsdq) {
-@@ -1859,7 +1897,7 @@ static void ath_tx_send_ampdu(struct ath
- 	list_add(&bf->list, &bf_head);
- 
- 	/* Add sub-frame to BAW */
--	ath_tx_addto_baw(sc, tid, bf->bf_state.seqno);
-+	ath_tx_addto_baw(sc, tid, bf);
- 
- 	/* Queue to h/w without aggregation */
- 	TX_STAT_INC(txq->axq_qnum, a_queued_hw);
-@@ -2066,7 +2104,6 @@ int ath_tx_start(struct ieee80211_hw *hw
- 	struct ath_txq *txq = txctl->txq;
- 	struct ath_atx_tid *tid = NULL;
- 	struct ath_buf *bf;
--	u8 tidno;
- 	int q;
- 	int ret;
- 
-@@ -2097,9 +2134,7 @@ int ath_tx_start(struct ieee80211_hw *hw
- 	}
- 
- 	if (txctl->an && ieee80211_is_data_qos(hdr->frame_control)) {
--		tidno = ieee80211_get_qos_ctl(hdr)[0] &
--			IEEE80211_QOS_CTL_TID_MASK;
--		tid = ATH_AN_2_TID(txctl->an, tidno);
-+		tid = ath_get_skb_tid(sc, txctl->an, skb);
- 
- 		WARN_ON(tid->ac->txq != txctl->txq);
- 	}
-@@ -2372,8 +2407,7 @@ static void ath_tx_processq(struct ath_s
- 
- 		if (list_empty(&txq->axq_q)) {
- 			txq->axq_link = NULL;
--			if (sc->sc_ah->caps.hw_caps & ATH9K_HW_CAP_HT)
--				ath_txq_schedule(sc, txq);
-+			ath_txq_schedule(sc, txq);
- 			break;
- 		}
- 		bf = list_first_entry(&txq->axq_q, struct ath_buf, list);
-@@ -2595,6 +2629,7 @@ void ath_tx_node_init(struct ath_softc *
- 		tid->paused    = false;
- 		tid->active	   = false;
- 		__skb_queue_head_init(&tid->buf_q);
-+		__skb_queue_head_init(&tid->retry_q);
- 		acno = TID_TO_WME_AC(tidno);
- 		tid->ac = &an->ac[acno];
- 	}
-@@ -2602,6 +2637,7 @@ void ath_tx_node_init(struct ath_softc *
- 	for (acno = 0, ac = &an->ac[acno];
- 	     acno < IEEE80211_NUM_ACS; acno++, ac++) {
- 		ac->sched    = false;
-+		ac->clear_ps_filter = true;
- 		ac->txq = sc->tx.txq_map[acno];
- 		INIT_LIST_HEAD(&ac->tid_q);
- 	}
diff --git a/package/mac80211/patches/601-rt2x00-set_pci_mwi.patch b/package/mac80211/patches/601-rt2x00-set_pci_mwi.patch
deleted file mode 100644
index d9a20bc..0000000
--- a/package/mac80211/patches/601-rt2x00-set_pci_mwi.patch
+++ /dev/null
@@ -1,13 +0,0 @@
---- a/drivers/net/wireless/rt2x00/rt2x00pci.c
-+++ b/drivers/net/wireless/rt2x00/rt2x00pci.c
-@@ -96,8 +96,10 @@ int rt2x00pci_probe(struct pci_dev *pci_
- 
- 	pci_set_master(pci_dev);
- 
-+#ifdef CONFIG_PCI_SET_MWI
- 	if (pci_set_mwi(pci_dev))
- 		rt2x00_probe_err("MWI not available\n");
-+#endif
- 
- 	if (dma_set_mask(&pci_dev->dev, DMA_BIT_MASK(32))) {
- 		rt2x00_probe_err("PCI DMA not supported\n");
diff --git a/package/mac80211/patches/602-rt2x00-introduce-rt2x00_platform_h.patch b/package/mac80211/patches/602-rt2x00-introduce-rt2x00_platform_h.patch
deleted file mode 100644
index 6c80c3d..0000000
--- a/package/mac80211/patches/602-rt2x00-introduce-rt2x00_platform_h.patch
+++ /dev/null
@@ -1,32 +0,0 @@
---- /dev/null
-+++ b/include/linux/rt2x00_platform.h
-@@ -0,0 +1,19 @@
-+/*
-+ * Platform data definition for the rt2x00 driver
-+ *
-+ * Copyright (C) 2011 Gabor Juhos <juhosg@openwrt.org>
-+ *
-+ * This program is free software; you can redistribute it and/or modify it
-+ * under the terms of the GNU General Public License version 2 as published
-+ * by the Free Software Foundation.
-+ *
-+ */
-+
-+#ifndef _RT2X00_PLATFORM_H
-+#define _RT2X00_PLATFORM_H
-+
-+struct rt2x00_platform_data {
-+	char *eeprom_file_name;
-+};
-+
-+#endif /* _RT2X00_PLATFORM_H */
---- a/drivers/net/wireless/rt2x00/rt2x00.h
-+++ b/drivers/net/wireless/rt2x00/rt2x00.h
-@@ -39,6 +39,7 @@
- #include <linux/input-polldev.h>
- #include <linux/kfifo.h>
- #include <linux/hrtimer.h>
-+#include <linux/rt2x00_platform.h>
- 
- #include <net/mac80211.h>
- 
diff --git a/package/mac80211/patches/603-rt2x00-introduce-rt2x00eeprom.patch b/package/mac80211/patches/603-rt2x00-introduce-rt2x00eeprom.patch
deleted file mode 100644
index f47c1a5..0000000
--- a/package/mac80211/patches/603-rt2x00-introduce-rt2x00eeprom.patch
+++ /dev/null
@@ -1,289 +0,0 @@
---- /dev/null
-+++ b/drivers/net/wireless/rt2x00/rt2x00eeprom.c
-@@ -0,0 +1,98 @@
-+/*
-+	Copyright (C) 2004 - 2009 Ivo van Doorn <IvDoorn@gmail.com>
-+	Copyright (C) 2004 - 2009 Gertjan van Wingerde <gwingerde@gmail.com>
-+	<http://rt2x00.serialmonkey.com>
-+
-+	This program is free software; you can redistribute it and/or modify
-+	it under the terms of the GNU General Public License as published by
-+	the Free Software Foundation; either version 2 of the License, or
-+	(at your option) any later version.
-+
-+	This program is distributed in the hope that it will be useful,
-+	but WITHOUT ANY WARRANTY; without even the implied warranty of
-+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-+	GNU General Public License for more details.
-+
-+	You should have received a copy of the GNU General Public License
-+	along with this program; if not, write to the
-+	Free Software Foundation, Inc.,
-+	59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
-+ */
-+
-+/*
-+	Module: rt2x00lib
-+	Abstract: rt2x00 eeprom file loading routines.
-+ */
-+
-+#include <linux/kernel.h>
-+#include <linux/module.h>
-+
-+#include "rt2x00.h"
-+#include "rt2x00lib.h"
-+
-+static int rt2x00lib_request_eeprom_file(struct rt2x00_dev *rt2x00dev)
-+{
-+	const struct firmware *ee;
-+	char *ee_name;
-+	int retval;
-+
-+	ee_name = rt2x00dev->ops->lib->get_eeprom_file_name(rt2x00dev);
-+	if (!ee_name) {
-+		rt2x00_err(rt2x00dev,
-+			   "Invalid EEPROM filename.\n"
-+			   "Please file bug report to %s.\n", DRV_PROJECT);
-+		return -EINVAL;
-+	}
-+
-+	rt2x00_info(rt2x00dev, "Loading EEPROM data from '%s'.\n", ee_name);
-+
-+	retval = request_firmware(&ee, ee_name, rt2x00dev->dev);
-+	if (retval) {
-+		rt2x00_err(rt2x00dev, "Failed to request EEPROM.\n");
-+		return retval;
-+	}
-+
-+	if (!ee || !ee->size || !ee->data) {
-+		rt2x00_err(rt2x00dev, "Failed to read EEPROM file.\n");
-+		retval = -ENOENT;
-+		goto err_exit;
-+	}
-+
-+	if (ee->size != rt2x00dev->ops->eeprom_size) {
-+		rt2x00_err(rt2x00dev,
-+			   "EEPROM file size is invalid, it should be %d bytes\n",
-+			   rt2x00dev->ops->eeprom_size);
-+		retval = -EINVAL;
-+		goto err_release_ee;
-+	}
-+
-+	rt2x00dev->eeprom_file = ee;
-+	return 0;
-+
-+err_release_ee:
-+	release_firmware(ee);
-+err_exit:
-+	return retval;
-+}
-+
-+int rt2x00lib_load_eeprom_file(struct rt2x00_dev *rt2x00dev)
-+{
-+	int retval;
-+
-+	if (!test_bit(REQUIRE_EEPROM_FILE, &rt2x00dev->cap_flags))
-+		return 0;
-+
-+	if (!rt2x00dev->eeprom_file) {
-+		retval = rt2x00lib_request_eeprom_file(rt2x00dev);
-+		if (retval)
-+			return retval;
-+	}
-+
-+	return 0;
-+}
-+
-+void rt2x00lib_free_eeprom_file(struct rt2x00_dev *rt2x00dev)
-+{
-+	release_firmware(rt2x00dev->eeprom_file);
-+	rt2x00dev->eeprom_file = NULL;
-+}
---- a/drivers/net/wireless/rt2x00/rt2x00.h
-+++ b/drivers/net/wireless/rt2x00/rt2x00.h
-@@ -549,6 +549,7 @@ struct rt2x00lib_ops {
- 			       const u8 *data, const size_t len);
- 	int (*load_firmware) (struct rt2x00_dev *rt2x00dev,
- 			      const u8 *data, const size_t len);
-+	char *(*get_eeprom_file_name) (struct rt2x00_dev *rt2x00dev);
- 
- 	/*
- 	 * Device initialization/deinitialization handlers.
-@@ -705,6 +706,7 @@ enum rt2x00_capability_flags {
- 	REQUIRE_SW_SEQNO,
- 	REQUIRE_HT_TX_DESC,
- 	REQUIRE_PS_AUTOWAKE,
-+	REQUIRE_EEPROM_FILE,
- 
- 	/*
- 	 * Capabilities
-@@ -974,6 +976,11 @@ struct rt2x00_dev {
- 	const struct firmware *fw;
- 
- 	/*
-+	 * EEPROM image.
-+	 */
-+	const struct firmware *eeprom_file;
-+
-+	/*
- 	 * FIFO for storing tx status reports between isr and tasklet.
- 	 */
- 	DECLARE_KFIFO_PTR(txstatus_fifo, u32);
---- a/drivers/net/wireless/rt2x00/rt2x00lib.h
-+++ b/drivers/net/wireless/rt2x00/rt2x00lib.h
-@@ -322,6 +322,22 @@ static inline void rt2x00lib_free_firmwa
- #endif /* CPTCFG_RT2X00_LIB_FIRMWARE */
- 
- /*
-+ * EEPROM file handlers.
-+ */
-+#ifdef CPTCFG_RT2X00_LIB_EEPROM
-+int rt2x00lib_load_eeprom_file(struct rt2x00_dev *rt2x00dev);
-+void rt2x00lib_free_eeprom_file(struct rt2x00_dev *rt2x00dev);
-+#else
-+static inline int rt2x00lib_load_eeprom_file(struct rt2x00_dev *rt2x00dev)
-+{
-+	return 0;
-+}
-+static inline void rt2x00lib_free_eeprom_file(struct rt2x00_dev *rt2x00dev)
-+{
-+}
-+#endif /* CPTCFG_RT2X00_LIB_EEPROM */
-+
-+/*
-  * Debugfs handlers.
-  */
- #ifdef CPTCFG_RT2X00_LIB_DEBUGFS
---- a/drivers/net/wireless/rt2x00/Kconfig
-+++ b/drivers/net/wireless/rt2x00/Kconfig
-@@ -69,6 +69,7 @@ config RT2800PCI
- 	select RT2X00_LIB_PCI if PCI
- 	select RT2X00_LIB_SOC if SOC_RT288X || SOC_RT305X
- 	select RT2X00_LIB_FIRMWARE
-+	select RT2X00_LIB_EEPROM
- 	select RT2X00_LIB_CRYPTO
- 	depends on CRC_CCITT
- 	depends on EEPROM_93CX6
-@@ -238,6 +239,9 @@ config RT2X00_LIB_FIRMWARE
- config RT2X00_LIB_CRYPTO
- 	boolean
- 
-+config RT2X00_LIB_EEPROM
-+	boolean
-+
- config RT2X00_LIB_LEDS
- 	depends on !BACKPORT_KERNEL_2_6_25
- 	boolean
---- a/drivers/net/wireless/rt2x00/Makefile
-+++ b/drivers/net/wireless/rt2x00/Makefile
-@@ -7,6 +7,7 @@ rt2x00lib-$(CPTCFG_RT2X00_LIB_DEBUGFS)	+
- rt2x00lib-$(CPTCFG_RT2X00_LIB_CRYPTO)	+= rt2x00crypto.o
- rt2x00lib-$(CPTCFG_RT2X00_LIB_FIRMWARE)	+= rt2x00firmware.o
- rt2x00lib-$(CPTCFG_RT2X00_LIB_LEDS)	+= rt2x00leds.o
-+rt2x00lib-$(CPTCFG_RT2X00_LIB_EEPROM)	+= rt2x00eeprom.o
- 
- obj-$(CPTCFG_RT2X00_LIB)		+= rt2x00lib.o
- obj-$(CPTCFG_RT2X00_LIB_MMIO)		+= rt2x00mmio.o
---- a/drivers/net/wireless/rt2x00/rt2800pci.c
-+++ b/drivers/net/wireless/rt2x00/rt2800pci.c
-@@ -90,25 +90,11 @@ static void rt2800pci_mcu_status(struct 
- 	rt2x00mmio_register_write(rt2x00dev, H2M_MAILBOX_CID, ~0);
- }
- 
--#if defined(CONFIG_SOC_RT288X) || defined(CONFIG_SOC_RT305X)
- static int rt2800pci_read_eeprom_soc(struct rt2x00_dev *rt2x00dev)
- {
--	void __iomem *base_addr = ioremap(0x1F040000, EEPROM_SIZE);
--
--	if (!base_addr)
--		return -ENOMEM;
--
--	memcpy_fromio(rt2x00dev->eeprom, base_addr, EEPROM_SIZE);
--
--	iounmap(base_addr);
-+	memcpy(rt2x00dev->eeprom, rt2x00dev->eeprom_file->data, EEPROM_SIZE);
- 	return 0;
- }
--#else
--static inline int rt2800pci_read_eeprom_soc(struct rt2x00_dev *rt2x00dev)
--{
--	return -ENOMEM;
--}
--#endif /* CONFIG_SOC_RT288X || CONFIG_SOC_RT305X */
- 
- #ifdef CONFIG_PCI
- static void rt2800pci_eepromregister_read(struct eeprom_93cx6 *eeprom)
-@@ -332,6 +318,20 @@ static int rt2800pci_write_firmware(stru
- }
- 
- /*
-+ * EEPROM file functions.
-+ */
-+static char *rt2800pci_get_eeprom_file_name(struct rt2x00_dev *rt2x00dev)
-+{
-+	struct rt2x00_platform_data *pdata;
-+
-+	pdata = rt2x00dev->dev->platform_data;
-+	if (pdata)
-+		return pdata->eeprom_file_name;
-+
-+	return NULL;
-+}
-+
-+/*
-  * Initialization functions.
-  */
- static bool rt2800pci_get_entry_state(struct queue_entry *entry)
-@@ -1156,6 +1156,7 @@ static const struct rt2x00lib_ops rt2800
- 	.get_firmware_name	= rt2800pci_get_firmware_name,
- 	.check_firmware		= rt2800_check_firmware,
- 	.load_firmware		= rt2800_load_firmware,
-+	.get_eeprom_file_name	= rt2800pci_get_eeprom_file_name,
- 	.initialize		= rt2x00mmio_initialize,
- 	.uninitialize		= rt2x00mmio_uninitialize,
- 	.get_entry_state	= rt2800pci_get_entry_state,
---- a/drivers/net/wireless/rt2x00/rt2x00dev.c
-+++ b/drivers/net/wireless/rt2x00/rt2x00dev.c
-@@ -1325,6 +1325,10 @@ int rt2x00lib_probe_dev(struct rt2x00_de
- 	INIT_DELAYED_WORK(&rt2x00dev->autowakeup_work, rt2x00lib_autowakeup);
- 	INIT_WORK(&rt2x00dev->sleep_work, rt2x00lib_sleep);
- 
-+	retval = rt2x00lib_load_eeprom_file(rt2x00dev);
-+	if (retval)
-+		goto exit;
-+
- 	/*
- 	 * Let the driver probe the device to detect the capabilities.
- 	 */
-@@ -1455,6 +1459,11 @@ void rt2x00lib_remove_dev(struct rt2x00_
- 	 */
- 	if (rt2x00dev->drv_data)
- 		kfree(rt2x00dev->drv_data);
-+
-+	/*
-+	 * Free EEPROM image.
-+	 */
-+	rt2x00lib_free_eeprom_file(rt2x00dev);
- }
- EXPORT_SYMBOL_GPL(rt2x00lib_remove_dev);
- 
---- a/drivers/net/wireless/rt2x00/rt2x00soc.c
-+++ b/drivers/net/wireless/rt2x00/rt2x00soc.c
-@@ -94,6 +94,7 @@ int rt2x00soc_probe(struct platform_devi
- 	rt2x00dev->hw = hw;
- 	rt2x00dev->irq = platform_get_irq(pdev, 0);
- 	rt2x00dev->name = pdev->dev.driver->name;
-+	set_bit(REQUIRE_EEPROM_FILE, &rt2x00dev->cap_flags);
- 
- 	rt2x00_set_chip_intf(rt2x00dev, RT2X00_CHIP_INTF_SOC);
- 
---- a/.local-symbols
-+++ b/.local-symbols
-@@ -272,6 +272,7 @@ RT2X00_LIB_FIRMWARE=
- RT2X00_LIB_CRYPTO=
- RT2X00_LIB_LEDS=
- RT2X00_LIB_DEBUGFS=
-+RT2X00_LIB_EEPROM=
- RT2X00_DEBUG=
- RTLWIFI=
- RTLWIFI_DEBUG=
diff --git a/package/mac80211/patches/605-rt2x00-pci-eeprom.patch b/package/mac80211/patches/605-rt2x00-pci-eeprom.patch
deleted file mode 100644
index bcbb435..0000000
--- a/package/mac80211/patches/605-rt2x00-pci-eeprom.patch
+++ /dev/null
@@ -1,46 +0,0 @@
---- a/drivers/net/wireless/rt2x00/rt2800pci.c
-+++ b/drivers/net/wireless/rt2x00/rt2800pci.c
-@@ -90,7 +90,7 @@ static void rt2800pci_mcu_status(struct 
- 	rt2x00mmio_register_write(rt2x00dev, H2M_MAILBOX_CID, ~0);
- }
- 
--static int rt2800pci_read_eeprom_soc(struct rt2x00_dev *rt2x00dev)
-+static int rt2800pci_read_eeprom_file(struct rt2x00_dev *rt2x00dev)
- {
- 	memcpy(rt2x00dev->eeprom, rt2x00dev->eeprom_file->data, EEPROM_SIZE);
- 	return 0;
-@@ -1093,8 +1093,9 @@ static int rt2800pci_read_eeprom(struct 
- {
- 	int retval;
- 
--	if (rt2x00_is_soc(rt2x00dev))
--		retval = rt2800pci_read_eeprom_soc(rt2x00dev);
-+	if (rt2x00_is_soc(rt2x00dev) ||
-+	    test_bit(REQUIRE_EEPROM_FILE, &rt2x00dev->cap_flags))
-+		retval = rt2800pci_read_eeprom_file(rt2x00dev);
- 	else if (rt2800pci_efuse_detect(rt2x00dev))
- 		retval = rt2800pci_read_eeprom_efuse(rt2x00dev);
- 	else
---- a/drivers/net/wireless/rt2x00/rt2x00pci.c
-+++ b/drivers/net/wireless/rt2x00/rt2x00pci.c
-@@ -78,6 +78,7 @@ exit:
- int rt2x00pci_probe(struct pci_dev *pci_dev, const struct rt2x00_ops *ops)
- {
- 	struct ieee80211_hw *hw;
-+	struct rt2x00_platform_data *pdata;
- 	struct rt2x00_dev *rt2x00dev;
- 	int retval;
- 	u16 chip;
-@@ -125,6 +126,12 @@ int rt2x00pci_probe(struct pci_dev *pci_
- 	rt2x00dev->irq = pci_dev->irq;
- 	rt2x00dev->name = pci_name(pci_dev);
- 
-+	/* if we get passed the name of a eeprom_file_name, then use this in
-+	   favour of the eeprom */
-+	pdata = rt2x00dev->dev->platform_data;
-+	if (pdata && pdata->eeprom_file_name)
-+		set_bit(REQUIRE_EEPROM_FILE, &rt2x00dev->cap_flags);
-+
- 	if (pci_is_pcie(pci_dev))
- 		rt2x00_set_chip_intf(rt2x00dev, RT2X00_CHIP_INTF_PCIE);
- 	else
diff --git a/package/mac80211/patches/606-rt2x00_no_realign.patch b/package/mac80211/patches/606-rt2x00_no_realign.patch
deleted file mode 100644
index 9608df2..0000000
--- a/package/mac80211/patches/606-rt2x00_no_realign.patch
+++ /dev/null
@@ -1,67 +0,0 @@
-[RFC] rt2x00: For drivers that only need L2 padding don't realign frames
-
-Signed-off-by: Helmut Schaa <helmut.schaa@...>
----
-
-Ivo, Gertjan, do you remeber by any chance why this alignment stuff was added
-in the first place? Was it because of DMA restrictions?
-
-While doing some profiling on the rt3052 SoC I noticed that 30-40% time was
-spent in memmove calls. And the culprit is the memmove aligning the payload
-to a 4byte boundary since that has to move a whole bunch of data.
-
-Interesstingly the legacy drivers insert an l2pad between the header and the
-payload but doesn't realign the payload itself to a 4-byte boundary. Hence,
-I came up with this patch and indeed CPU usage improves impressively.
-
-Only tested on rt2800pci!
-
-Thanks,
-Helmut
-
- drivers/net/wireless/rt2x00/rt2x00queue.c |   30 +++-------------------------
- 1 files changed, 4 insertions(+), 26 deletions(-)
-
---- a/drivers/net/wireless/rt2x00/rt2x00queue.c
-+++ b/drivers/net/wireless/rt2x00/rt2x00queue.c
-@@ -163,36 +163,14 @@ void rt2x00queue_align_frame(struct sk_b
- void rt2x00queue_insert_l2pad(struct sk_buff *skb, unsigned int header_length)
- {
- 	unsigned int payload_length = skb->len - header_length;
--	unsigned int header_align = ALIGN_SIZE(skb, 0);
--	unsigned int payload_align = ALIGN_SIZE(skb, header_length);
- 	unsigned int l2pad = payload_length ? L2PAD_SIZE(header_length) : 0;
- 
--	/*
--	 * Adjust the header alignment if the payload needs to be moved more
--	 * than the header.
--	 */
--	if (payload_align > header_align)
--		header_align += 4;
--
--	/* There is nothing to do if no alignment is needed */
--	if (!header_align)
-+	if (!l2pad)
- 		return;
- 
--	/* Reserve the amount of space needed in front of the frame */
--	skb_push(skb, header_align);
--
--	/*
--	 * Move the header.
--	 */
--	memmove(skb->data, skb->data + header_align, header_length);
--
--	/* Move the payload, if present and if required */
--	if (payload_length && payload_align)
--		memmove(skb->data + header_length + l2pad,
--			skb->data + header_length + l2pad + payload_align,
--			payload_length);
--
--	/* Trim the skb to the correct size */
-+	/* insert l2pad -> Move header */
-+	skb_push(skb, l2pad);
-+	memmove(skb->data, skb->data + l2pad, header_length);
- 	skb_trim(skb, header_length + l2pad + payload_length);
- }
- 
diff --git a/package/mac80211/patches/607-rt2x00-allow_disabling_bands_through_platform_data.patch b/package/mac80211/patches/607-rt2x00-allow_disabling_bands_through_platform_data.patch
deleted file mode 100644
index 5e6e27d..0000000
--- a/package/mac80211/patches/607-rt2x00-allow_disabling_bands_through_platform_data.patch
+++ /dev/null
@@ -1,47 +0,0 @@
---- a/include/linux/rt2x00_platform.h
-+++ b/include/linux/rt2x00_platform.h
-@@ -14,6 +14,9 @@
- 
- struct rt2x00_platform_data {
- 	char *eeprom_file_name;
-+
-+	int disable_2ghz;
-+	int disable_5ghz;
- };
- 
- #endif /* _RT2X00_PLATFORM_H */
---- a/drivers/net/wireless/rt2x00/rt2x00dev.c
-+++ b/drivers/net/wireless/rt2x00/rt2x00dev.c
-@@ -938,6 +938,22 @@ static int rt2x00lib_probe_hw_modes(stru
- 	unsigned int num_rates;
- 	unsigned int i;
- 
-+	if (rt2x00dev->dev->platform_data) {
-+		struct rt2x00_platform_data *pdata;
-+
-+		pdata = rt2x00dev->dev->platform_data;
-+		if (pdata->disable_2ghz)
-+			spec->supported_bands &= ~SUPPORT_BAND_2GHZ;
-+		if (pdata->disable_5ghz)
-+			spec->supported_bands &= ~SUPPORT_BAND_5GHZ;
-+	}
-+
-+	if ((spec->supported_bands & SUPPORT_BAND_BOTH) == 0) {
-+		rt2x00_err(rt2x00dev, "No supported bands\n");
-+		return -EINVAL;
-+	}
-+
-+
- 	num_rates = 0;
- 	if (spec->supported_rates & SUPPORT_RATE_CCK)
- 		num_rates += 4;
---- a/drivers/net/wireless/rt2x00/rt2x00.h
-+++ b/drivers/net/wireless/rt2x00/rt2x00.h
-@@ -414,6 +414,7 @@ struct hw_mode_spec {
- 	unsigned int supported_bands;
- #define SUPPORT_BAND_2GHZ	0x00000001
- #define SUPPORT_BAND_5GHZ	0x00000002
-+#define SUPPORT_BAND_BOTH	(SUPPORT_BAND_2GHZ | SUPPORT_BAND_5GHZ)
- 
- 	unsigned int supported_rates;
- #define SUPPORT_RATE_CCK	0x00000001
diff --git a/package/mac80211/patches/608-add_platform_data_mac_addr.patch b/package/mac80211/patches/608-add_platform_data_mac_addr.patch
deleted file mode 100644
index 0695b89..0000000
--- a/package/mac80211/patches/608-add_platform_data_mac_addr.patch
+++ /dev/null
@@ -1,63 +0,0 @@
---- a/include/linux/rt2x00_platform.h
-+++ b/include/linux/rt2x00_platform.h
-@@ -14,6 +14,7 @@
- 
- struct rt2x00_platform_data {
- 	char *eeprom_file_name;
-+	const u8 *mac_address;
- 
- 	int disable_2ghz;
- 	int disable_5ghz;
---- a/drivers/net/wireless/rt2x00/rt2x00dev.c
-+++ b/drivers/net/wireless/rt2x00/rt2x00dev.c
-@@ -929,6 +929,18 @@ static void rt2x00lib_rate(struct ieee80
- 		entry->flags |= IEEE80211_RATE_SHORT_PREAMBLE;
- }
- 
-+const u8 *rt2x00lib_get_mac_address(struct rt2x00_dev *rt2x00dev)
-+{
-+	struct rt2x00_platform_data *pdata;
-+
-+	pdata = rt2x00dev->dev->platform_data;
-+	if (!pdata)
-+		return NULL;
-+
-+	return pdata->mac_address;
-+}
-+EXPORT_SYMBOL_GPL(rt2x00lib_get_mac_address);
-+
- static int rt2x00lib_probe_hw_modes(struct rt2x00_dev *rt2x00dev,
- 				    struct hw_mode_spec *spec)
- {
---- a/drivers/net/wireless/rt2x00/rt2x00.h
-+++ b/drivers/net/wireless/rt2x00/rt2x00.h
-@@ -1326,6 +1326,7 @@ static inline void rt2x00debug_dump_fram
-  */
- u32 rt2x00lib_get_bssidx(struct rt2x00_dev *rt2x00dev,
- 			 struct ieee80211_vif *vif);
-+const u8 *rt2x00lib_get_mac_address(struct rt2x00_dev *rt2x00dev);
- 
- /*
-  * Interrupt context handlers.
---- a/drivers/net/wireless/rt2x00/rt61pci.c
-+++ b/drivers/net/wireless/rt2x00/rt61pci.c
-@@ -2395,6 +2395,7 @@ static int rt61pci_validate_eeprom(struc
- 	u32 reg;
- 	u16 word;
- 	u8 *mac;
-+	const u8 *pdata_mac;
- 	s8 value;
- 
- 	rt2x00mmio_register_read(rt2x00dev, E2PROM_CSR, &reg);
-@@ -2415,7 +2416,11 @@ static int rt61pci_validate_eeprom(struc
- 	/*
- 	 * Start validation of the data that has been read.
- 	 */
-+	pdata_mac = rt2x00lib_get_mac_address(rt2x00dev);
- 	mac = rt2x00_eeprom_addr(rt2x00dev, EEPROM_MAC_ADDR_0);
-+	if (pdata_mac)
-+		memcpy(mac, pdata_mac, 6);
-+
- 	if (!is_valid_ether_addr(mac)) {
- 		eth_random_addr(mac);
- 		rt2x00_eeprom_dbg(rt2x00dev, "MAC: %pM\n", mac);
diff --git a/package/mac80211/patches/610-rt2x00-fix-rt3352-ext-pa.patch b/package/mac80211/patches/610-rt2x00-fix-rt3352-ext-pa.patch
deleted file mode 100644
index 8369a78..0000000
--- a/package/mac80211/patches/610-rt2x00-fix-rt3352-ext-pa.patch
+++ /dev/null
@@ -1,214 +0,0 @@
---- a/drivers/net/wireless/rt2x00/rt2800lib.c
-+++ b/drivers/net/wireless/rt2x00/rt2800lib.c
-@@ -2631,15 +2631,18 @@ static void rt2800_config_channel(struct
- 	/*
- 	 * Change BBP settings
- 	 */
-+	rt2800_bbp_write(rt2x00dev, 62, 0x37 - rt2x00dev->lna_gain);
-+	rt2800_bbp_write(rt2x00dev, 63, 0x37 - rt2x00dev->lna_gain);
-+	rt2800_bbp_write(rt2x00dev, 64, 0x37 - rt2x00dev->lna_gain);
-+
- 	if (rt2x00_rt(rt2x00dev, RT3352)) {
- 		rt2800_bbp_write(rt2x00dev, 27, 0x0);
- 		rt2800_bbp_write(rt2x00dev, 66, 0x26 + rt2x00dev->lna_gain);
- 		rt2800_bbp_write(rt2x00dev, 27, 0x20);
- 		rt2800_bbp_write(rt2x00dev, 66, 0x26 + rt2x00dev->lna_gain);
-+		rt2800_bbp_write(rt2x00dev, 86, 0x38);
-+		rt2800_bbp_write(rt2x00dev, 83, 0x6a);
- 	} else {
--		rt2800_bbp_write(rt2x00dev, 62, 0x37 - rt2x00dev->lna_gain);
--		rt2800_bbp_write(rt2x00dev, 63, 0x37 - rt2x00dev->lna_gain);
--		rt2800_bbp_write(rt2x00dev, 64, 0x37 - rt2x00dev->lna_gain);
- 		rt2800_bbp_write(rt2x00dev, 86, 0);
- 	}
- 
-@@ -4971,6 +4974,12 @@ static void rt2800_init_rfcsr_3290(struc
- 
- static void rt2800_init_rfcsr_3352(struct rt2x00_dev *rt2x00dev)
- {
-+	int tx0_int_pa = test_bit(CAPABILITY_INTERNAL_PA_TX0,
-+				  &rt2x00dev->cap_flags);
-+	int tx1_int_pa = test_bit(CAPABILITY_INTERNAL_PA_TX1,
-+				  &rt2x00dev->cap_flags);
-+	u8 rfcsr;
-+
- 	rt2800_rf_init_calibration(rt2x00dev, 30);
- 
- 	rt2800_rfcsr_write(rt2x00dev, 0, 0xf0);
-@@ -5006,15 +5015,30 @@ static void rt2800_init_rfcsr_3352(struc
- 	rt2800_rfcsr_write(rt2x00dev, 31, 0x80);
- 	rt2800_rfcsr_write(rt2x00dev, 32, 0x80);
- 	rt2800_rfcsr_write(rt2x00dev, 33, 0x00);
--	rt2800_rfcsr_write(rt2x00dev, 34, 0x01);
-+	rfcsr = 0x01;
-+	if (!tx0_int_pa)
-+		rt2x00_set_field8(&rfcsr, RFCSR34_TX0_EXT_PA, 1);
-+	if (!tx1_int_pa)
-+		rt2x00_set_field8(&rfcsr, RFCSR34_TX1_EXT_PA, 1);
-+	rt2800_rfcsr_write(rt2x00dev, 34, rfcsr);
- 	rt2800_rfcsr_write(rt2x00dev, 35, 0x03);
- 	rt2800_rfcsr_write(rt2x00dev, 36, 0xbd);
- 	rt2800_rfcsr_write(rt2x00dev, 37, 0x3c);
- 	rt2800_rfcsr_write(rt2x00dev, 38, 0x5f);
- 	rt2800_rfcsr_write(rt2x00dev, 39, 0xc5);
- 	rt2800_rfcsr_write(rt2x00dev, 40, 0x33);
--	rt2800_rfcsr_write(rt2x00dev, 41, 0x5b);
--	rt2800_rfcsr_write(rt2x00dev, 42, 0x5b);
-+	rfcsr = 0x52;
-+	if (tx0_int_pa) {
-+		rt2x00_set_field8(&rfcsr, RFCSR41_BIT1, 1);
-+		rt2x00_set_field8(&rfcsr, RFCSR41_BIT4, 1);
-+	}
-+	rt2800_rfcsr_write(rt2x00dev, 41, rfcsr);
-+	rfcsr = 0x52;
-+	if (tx1_int_pa) {
-+		rt2x00_set_field8(&rfcsr, RFCSR42_BIT1, 1);
-+		rt2x00_set_field8(&rfcsr, RFCSR42_BIT4, 1);
-+	}
-+	rt2800_rfcsr_write(rt2x00dev, 42, rfcsr);
- 	rt2800_rfcsr_write(rt2x00dev, 43, 0xdb);
- 	rt2800_rfcsr_write(rt2x00dev, 44, 0xdb);
- 	rt2800_rfcsr_write(rt2x00dev, 45, 0xdb);
-@@ -5022,15 +5046,20 @@ static void rt2800_init_rfcsr_3352(struc
- 	rt2800_rfcsr_write(rt2x00dev, 47, 0x0d);
- 	rt2800_rfcsr_write(rt2x00dev, 48, 0x14);
- 	rt2800_rfcsr_write(rt2x00dev, 49, 0x00);
--	rt2800_rfcsr_write(rt2x00dev, 50, 0x2d);
--	rt2800_rfcsr_write(rt2x00dev, 51, 0x7f);
--	rt2800_rfcsr_write(rt2x00dev, 52, 0x00);
--	rt2800_rfcsr_write(rt2x00dev, 53, 0x52);
--	rt2800_rfcsr_write(rt2x00dev, 54, 0x1b);
--	rt2800_rfcsr_write(rt2x00dev, 55, 0x7f);
--	rt2800_rfcsr_write(rt2x00dev, 56, 0x00);
--	rt2800_rfcsr_write(rt2x00dev, 57, 0x52);
--	rt2800_rfcsr_write(rt2x00dev, 58, 0x1b);
-+	rfcsr = 0x2d;
-+	if (!tx0_int_pa)
-+		rt2x00_set_field8(&rfcsr, RFCSR50_TX0_EXT_PA, 1);
-+	if (!tx1_int_pa)
-+		rt2x00_set_field8(&rfcsr, RFCSR50_TX1_EXT_PA, 1);
-+	rt2800_rfcsr_write(rt2x00dev, 50, rfcsr);
-+	rt2800_rfcsr_write(rt2x00dev, 51, (tx0_int_pa ? 0x7f : 0x52));
-+	rt2800_rfcsr_write(rt2x00dev, 52, (tx0_int_pa ? 0x00 : 0xc0));
-+	rt2800_rfcsr_write(rt2x00dev, 53, (tx0_int_pa ? 0x52 : 0xd2));
-+	rt2800_rfcsr_write(rt2x00dev, 54, (tx0_int_pa ? 0x1b : 0xc0));
-+	rt2800_rfcsr_write(rt2x00dev, 55, (tx1_int_pa ? 0x7f : 0x52));
-+	rt2800_rfcsr_write(rt2x00dev, 56, (tx1_int_pa ? 0x00 : 0xc0));
-+	rt2800_rfcsr_write(rt2x00dev, 57, (tx0_int_pa ? 0x52 : 0x49));
-+	rt2800_rfcsr_write(rt2x00dev, 58, (tx1_int_pa ? 0x1b : 0xc0));
- 	rt2800_rfcsr_write(rt2x00dev, 59, 0x00);
- 	rt2800_rfcsr_write(rt2x00dev, 60, 0x00);
- 	rt2800_rfcsr_write(rt2x00dev, 61, 0x00);
-@@ -5716,6 +5745,7 @@ static int rt2800_init_eeprom(struct rt2
- 	 * RT53xx: defined in "EEPROM_CHIP_ID" field
- 	 */
- 	if (rt2x00_rt(rt2x00dev, RT3290) ||
-+	    rt2x00_rt(rt2x00dev, RT3352) ||
- 	    rt2x00_rt(rt2x00dev, RT5390) ||
- 	    rt2x00_rt(rt2x00dev, RT5392))
- 		rt2x00_eeprom_read(rt2x00dev, EEPROM_CHIP_ID, &rf);
-@@ -5805,7 +5835,8 @@ static int rt2800_init_eeprom(struct rt2
- 	/*
- 	 * Detect if this device has Bluetooth co-existence.
- 	 */
--	if (rt2x00_get_field16(eeprom, EEPROM_NIC_CONF1_BT_COEXIST))
-+	if (!rt2x00_rt(rt2x00dev, RT3352) &&
-+	    rt2x00_get_field16(eeprom, EEPROM_NIC_CONF1_BT_COEXIST))
- 		__set_bit(CAPABILITY_BT_COEXIST, &rt2x00dev->cap_flags);
- 
- 	/*
-@@ -5834,6 +5865,22 @@ static int rt2800_init_eeprom(struct rt2
- 					EIRP_MAX_TX_POWER_LIMIT)
- 		__set_bit(CAPABILITY_POWER_LIMIT, &rt2x00dev->cap_flags);
- 
-+	/*
-+	 * Detect if device uses internal or external PA
-+	 */
-+	rt2x00_eeprom_read(rt2x00dev, EEPROM_NIC_CONF1, &eeprom);
-+
-+	if (rt2x00_rt(rt2x00dev, RT3352)) {
-+		if (!rt2x00_get_field16(eeprom,
-+		    EEPROM_NIC_CONF1_EXTERNAL_TX0_PA_3352))
-+			__set_bit(CAPABILITY_INTERNAL_PA_TX0,
-+				  &rt2x00dev->cap_flags);
-+		if (!rt2x00_get_field16(eeprom,
-+		    EEPROM_NIC_CONF1_EXTERNAL_TX1_PA_3352))
-+			__set_bit(CAPABILITY_INTERNAL_PA_TX1,
-+				  &rt2x00dev->cap_flags);
-+	}
-+
- 	return 0;
- }
- 
---- a/drivers/net/wireless/rt2x00/rt2800.h
-+++ b/drivers/net/wireless/rt2x00/rt2800.h
-@@ -2153,6 +2153,12 @@ struct mac_iveiv_entry {
- #define RFCSR31_RX_CALIB		FIELD8(0x7f)
- 
- /*
-+ * RFCSR 34:
-+ */
-+#define RFCSR34_TX0_EXT_PA		FIELD8(0x04)
-+#define RFCSR34_TX1_EXT_PA		FIELD8(0x08)
-+
-+/*
-  * RFCSR 38:
-  */
- #define RFCSR38_RX_LO1_EN		FIELD8(0x20)
-@@ -2163,6 +2169,18 @@ struct mac_iveiv_entry {
- #define RFCSR39_RX_LO2_EN		FIELD8(0x80)
- 
- /*
-+ * RFCSR 41:
-+ */
-+#define RFCSR41_BIT1			FIELD8(0x01)
-+#define RFCSR41_BIT4			FIELD8(0x08)
-+
-+/*
-+ * RFCSR 42:
-+ */
-+#define RFCSR42_BIT1			FIELD8(0x01)
-+#define RFCSR42_BIT4			FIELD8(0x08)
-+
-+/*
-  * RFCSR 49:
-  */
- #define RFCSR49_TX			FIELD8(0x3f)
-@@ -2172,6 +2190,8 @@ struct mac_iveiv_entry {
-  * RFCSR 50:
-  */
- #define RFCSR50_TX			FIELD8(0x3f)
-+#define RFCSR50_TX0_EXT_PA		FIELD8(0x02)
-+#define RFCSR50_TX1_EXT_PA		FIELD8(0x10)
- #define RFCSR50_EP			FIELD8(0xc0)
- 
- /*
-@@ -2260,6 +2280,8 @@ struct mac_iveiv_entry {
-  * INTERNAL_TX_ALC: 0: disable, 1: enable
-  * BT_COEXIST: 0: disable, 1: enable
-  * DAC_TEST: 0: disable, 1: enable
-+ * EXTERNAL_TX0_PA: 0: disable, 1: enable (only on RT3352)
-+ * EXTERNAL_TX1_PA: 0: disable, 1: enable (only on RT3352)
-  */
- #define	EEPROM_NIC_CONF1		0x001b
- #define EEPROM_NIC_CONF1_HW_RADIO		FIELD16(0x0001)
-@@ -2277,6 +2299,8 @@ struct mac_iveiv_entry {
- #define EEPROM_NIC_CONF1_INTERNAL_TX_ALC		FIELD16(0x2000)
- #define EEPROM_NIC_CONF1_BT_COEXIST		FIELD16(0x4000)
- #define EEPROM_NIC_CONF1_DAC_TEST		FIELD16(0x8000)
-+#define EEPROM_NIC_CONF1_EXTERNAL_TX0_PA_3352	FIELD16(0x4000)
-+#define EEPROM_NIC_CONF1_EXTERNAL_TX1_PA_3352	FIELD16(0x8000)
- 
- /*
-  * EEPROM frequency
---- a/drivers/net/wireless/rt2x00/rt2x00.h
-+++ b/drivers/net/wireless/rt2x00/rt2x00.h
-@@ -726,6 +726,8 @@ enum rt2x00_capability_flags {
- 	CAPABILITY_DOUBLE_ANTENNA,
- 	CAPABILITY_BT_COEXIST,
- 	CAPABILITY_VCO_RECALIBRATION,
-+	CAPABILITY_INTERNAL_PA_TX0,
-+	CAPABILITY_INTERNAL_PA_TX1,
- };
- 
- /*
diff --git a/package/mac80211/patches/611-rt2x00-rf_vals-rt3352-xtal20.patch b/package/mac80211/patches/611-rt2x00-rf_vals-rt3352-xtal20.patch
deleted file mode 100644
index e16d970..0000000
--- a/package/mac80211/patches/611-rt2x00-rf_vals-rt3352-xtal20.patch
+++ /dev/null
@@ -1,115 +0,0 @@
---- a/drivers/net/wireless/rt2x00/rt2800lib.c
-+++ b/drivers/net/wireless/rt2x00/rt2800lib.c
-@@ -6157,6 +6157,27 @@ static const struct rf_channel rf_vals_5
- 	{196, 83, 0, 12, 1},
- };
- 
-+/*
-+ * RF value list for rt3xxx with Xtal20MHz
-+ * Supports: 2.4 GHz (all) (RF3322)
-+ */
-+static const struct rf_channel rf_vals_xtal20mhz_3x[] = {
-+	{1,    0xE2,	 2,  0x14},
-+	{2,    0xE3,	 2,  0x14},
-+	{3,    0xE4,	 2,  0x14},
-+	{4,    0xE5,	 2,  0x14},
-+	{5,    0xE6,	 2,  0x14},
-+	{6,    0xE7,	 2,  0x14},
-+	{7,    0xE8,	 2,  0x14},
-+	{8,    0xE9,	 2,  0x14},
-+	{9,    0xEA,	 2,  0x14},
-+	{10,   0xEB,	 2,  0x14},
-+	{11,   0xEC,	 2,  0x14},
-+	{12,   0xED,	 2,  0x14},
-+	{13,   0xEE,	 2,  0x14},
-+	{14,   0xF0,	 2,  0x18},
-+};
-+
- static int rt2800_probe_hw_mode(struct rt2x00_dev *rt2x00dev)
- {
- 	struct hw_mode_spec *spec = &rt2x00dev->spec;
-@@ -6235,7 +6256,6 @@ static int rt2800_probe_hw_mode(struct r
- 		   rt2x00_rf(rt2x00dev, RF3022) ||
- 		   rt2x00_rf(rt2x00dev, RF3290) ||
- 		   rt2x00_rf(rt2x00dev, RF3320) ||
--		   rt2x00_rf(rt2x00dev, RF3322) ||
- 		   rt2x00_rf(rt2x00dev, RF5360) ||
- 		   rt2x00_rf(rt2x00dev, RF5370) ||
- 		   rt2x00_rf(rt2x00dev, RF5372) ||
-@@ -6243,6 +6263,12 @@ static int rt2800_probe_hw_mode(struct r
- 		   rt2x00_rf(rt2x00dev, RF5392)) {
- 		spec->num_channels = 14;
- 		spec->channels = rf_vals_3x;
-+	} else if (rt2x00_rf(rt2x00dev, RF3322)) {
-+		spec->num_channels = 14;
-+		if (spec->clk_is_20mhz)
-+			spec->channels = rf_vals_xtal20mhz_3x;
-+		else
-+			spec->channels = rf_vals_3x;
- 	} else if (rt2x00_rf(rt2x00dev, RF3052)) {
- 		spec->supported_bands |= SUPPORT_BAND_5GHZ;
- 		spec->num_channels = ARRAY_SIZE(rf_vals_3x);
-@@ -6390,6 +6416,19 @@ static int rt2800_probe_rt(struct rt2x00
- 	return 0;
- }
- 
-+int rt2800_probe_clk(struct rt2x00_dev *rt2x00dev)
-+{
-+	struct rt2x00_platform_data *pdata = rt2x00dev->dev->platform_data;
-+	struct hw_mode_spec *spec = &rt2x00dev->spec;
-+
-+	if (!pdata)
-+		return -EINVAL;
-+
-+	spec->clk_is_20mhz = pdata->clk_is_20mhz;
-+
-+	return 0;
-+}
-+
- int rt2800_probe_hw(struct rt2x00_dev *rt2x00dev)
- {
- 	int retval;
-@@ -6419,6 +6458,15 @@ int rt2800_probe_hw(struct rt2x00_dev *r
- 	rt2800_register_write(rt2x00dev, GPIO_CTRL, reg);
- 
- 	/*
-+	 * Probe SoC clock.
-+	 */
-+	if (rt2x00_is_soc(rt2x00dev)) {
-+		retval = rt2800_probe_clk(rt2x00dev);
-+		if (retval)
-+			return retval;
-+	}
-+
-+	/*
- 	 * Initialize hw specifications.
- 	 */
- 	retval = rt2800_probe_hw_mode(rt2x00dev);
---- a/drivers/net/wireless/rt2x00/rt2x00.h
-+++ b/drivers/net/wireless/rt2x00/rt2x00.h
-@@ -409,6 +409,7 @@ static inline struct rt2x00_intf* vif_to
-  * @channels: Device/chipset specific channel values (See &struct rf_channel).
-  * @channels_info: Additional information for channels (See &struct channel_info).
-  * @ht: Driver HT Capabilities (See &ieee80211_sta_ht_cap).
-+ * @clk_is_20mhz: External crystal of WiSoC is 20MHz instead of 40MHz
-  */
- struct hw_mode_spec {
- 	unsigned int supported_bands;
-@@ -425,6 +426,7 @@ struct hw_mode_spec {
- 	const struct channel_info *channels_info;
- 
- 	struct ieee80211_sta_ht_cap ht;
-+	int clk_is_20mhz;
- };
- 
- /*
---- a/include/linux/rt2x00_platform.h
-+++ b/include/linux/rt2x00_platform.h
-@@ -18,6 +18,7 @@ struct rt2x00_platform_data {
- 
- 	int disable_2ghz;
- 	int disable_5ghz;
-+	int clk_is_20mhz;
- };
- 
- #endif /* _RT2X00_PLATFORM_H */
diff --git a/package/mac80211/patches/612-rt2x00-make-wmac-loadable-via-OF-on-rt288x-305x-SoC.patch b/package/mac80211/patches/612-rt2x00-make-wmac-loadable-via-OF-on-rt288x-305x-SoC.patch
deleted file mode 100644
index 81125a9..0000000
--- a/package/mac80211/patches/612-rt2x00-make-wmac-loadable-via-OF-on-rt288x-305x-SoC.patch
+++ /dev/null
@@ -1,34 +0,0 @@
-From 04dbd87265f6ba4a373b211ba324b437d224fb2d Mon Sep 17 00:00:00 2001
-From: John Crispin <blogic@openwrt.org>
-Date: Sun, 17 Mar 2013 00:03:31 +0100
-Subject: [PATCH 21/38] rt2x00: make wmac loadable via OF on rt288x/305x SoC
-
-This patch ads the match table to allow loading the wmac support from a
-devicetree.
-
-Signed-off-by: John Crispin <blogic@openwrt.org>
----
- drivers/net/wireless/rt2x00/rt2800pci.c |    7 +++++++
- 1 file changed, 7 insertions(+)
-
---- a/drivers/net/wireless/rt2x00/rt2800pci.c
-+++ b/drivers/net/wireless/rt2x00/rt2800pci.c
-@@ -1309,11 +1309,18 @@ static int rt2800soc_probe(struct platfo
- 	return rt2x00soc_probe(pdev, &rt2800pci_ops);
- }
- 
-+static const struct of_device_id rt2880_wmac_match[] = {
-+	{ .compatible = "ralink,rt2880-wmac" },
-+	{},
-+};
-+MODULE_DEVICE_TABLE(of, rt2880_wmac_match);
-+
- static struct platform_driver rt2800soc_driver = {
- 	.driver		= {
- 		.name		= "rt2800_wmac",
- 		.owner		= THIS_MODULE,
- 		.mod_name	= KBUILD_MODNAME,
-+		.of_match_table	= rt2880_wmac_match,
- 	},
- 	.probe		= rt2800soc_probe,
- 	.remove		= rt2x00soc_remove,
diff --git a/package/mac80211/patches/614-rt2x00-of_load_eeprom_filename.patch b/package/mac80211/patches/614-rt2x00-of_load_eeprom_filename.patch
deleted file mode 100644
index 293b71a..0000000
--- a/package/mac80211/patches/614-rt2x00-of_load_eeprom_filename.patch
+++ /dev/null
@@ -1,28 +0,0 @@
---- a/drivers/net/wireless/rt2x00/rt2800pci.c
-+++ b/drivers/net/wireless/rt2x00/rt2800pci.c
-@@ -39,6 +39,7 @@
- #include <linux/pci.h>
- #include <linux/platform_device.h>
- #include <linux/eeprom_93cx6.h>
-+#include <linux/of.h>
- 
- #include "rt2x00.h"
- #include "rt2x00mmio.h"
-@@ -323,11 +324,17 @@ static int rt2800pci_write_firmware(stru
- static char *rt2800pci_get_eeprom_file_name(struct rt2x00_dev *rt2x00dev)
- {
- 	struct rt2x00_platform_data *pdata;
-+	struct device_node *np;
-+	char *eep;
- 
- 	pdata = rt2x00dev->dev->platform_data;
- 	if (pdata)
- 		return pdata->eeprom_file_name;
- 
-+	np = rt2x00dev->dev->of_node;
-+	if (np && !of_property_read_string(np, "ralink,eeprom", &eep))
-+		return eep;
-+
- 	return NULL;
- }
- 
diff --git a/package/mac80211/patches/616-rt2x00-support-rt5350.patch b/package/mac80211/patches/616-rt2x00-support-rt5350.patch
deleted file mode 100644
index 9dc5835..0000000
--- a/package/mac80211/patches/616-rt2x00-support-rt5350.patch
+++ /dev/null
@@ -1,281 +0,0 @@
---- a/drivers/net/wireless/rt2x00/rt2800.h
-+++ b/drivers/net/wireless/rt2x00/rt2800.h
-@@ -71,6 +71,7 @@
- #define RF3053				0x000d
- #define RF5592				0x000f
- #define RF3290				0x3290
-+#define RF5350				0x5350
- #define RF5360				0x5360
- #define RF5370				0x5370
- #define RF5372				0x5372
---- a/drivers/net/wireless/rt2x00/rt2800lib.c
-+++ b/drivers/net/wireless/rt2x00/rt2800lib.c
-@@ -2140,6 +2140,15 @@ static void rt2800_config_channel_rf53xx
- 	if (rf->channel <= 14) {
- 		int idx = rf->channel-1;
- 
-+		if (rt2x00_rt(rt2x00dev, RT5350)) {
-+			static const char r59_non_bt[] = {0x0b, 0x0b,
-+				0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0a,
-+				0x0a, 0x09, 0x08, 0x07, 0x07, 0x06};
-+
-+			rt2800_rfcsr_write(rt2x00dev, 59,
-+					   r59_non_bt[idx]);
-+		}
-+
- 		if (test_bit(CAPABILITY_BT_COEXIST, &rt2x00dev->cap_flags)) {
- 			if (rt2x00_rt_rev_gte(rt2x00dev, RT5390, REV_RT5390F)) {
- 				/* r55/r59 value array of channel 1~14 */
-@@ -2597,6 +2606,7 @@ static void rt2800_config_channel(struct
- 	case RF3322:
- 		rt2800_config_channel_rf3322(rt2x00dev, conf, rf, info);
- 		break;
-+	case RF5350:
- 	case RF5360:
- 	case RF5370:
- 	case RF5372:
-@@ -2613,6 +2623,7 @@ static void rt2800_config_channel(struct
- 
- 	if (rt2x00_rf(rt2x00dev, RF3290) ||
- 	    rt2x00_rf(rt2x00dev, RF3322) ||
-+	    rt2x00_rf(rt2x00dev, RF5350) ||
- 	    rt2x00_rf(rt2x00dev, RF5360) ||
- 	    rt2x00_rf(rt2x00dev, RF5370) ||
- 	    rt2x00_rf(rt2x00dev, RF5372) ||
-@@ -2777,7 +2788,8 @@ static void rt2800_config_channel(struct
- 	/*
- 	 * Clear update flag
- 	 */
--	if (rt2x00_rt(rt2x00dev, RT3352)) {
-+	if (rt2x00_rt(rt2x00dev, RT3352) ||
-+	    rt2x00_rt(rt2x00dev, RT5350)) {
- 		rt2800_bbp_read(rt2x00dev, 49, &bbp);
- 		rt2x00_set_field8(&bbp, BBP49_UPDATE_FLAG, 0);
- 		rt2800_bbp_write(rt2x00dev, 49, bbp);
-@@ -3223,6 +3235,7 @@ void rt2800_vco_calibration(struct rt2x0
- 		rt2800_rfcsr_write(rt2x00dev, 7, rfcsr);
- 		break;
- 	case RF3290:
-+	case RF5350:
- 	case RF5360:
- 	case RF5370:
- 	case RF5372:
-@@ -3562,7 +3575,8 @@ static int rt2800_init_registers(struct 
- 	} else if (rt2x00_rt(rt2x00dev, RT3572)) {
- 		rt2800_register_write(rt2x00dev, TX_SW_CFG0, 0x00000400);
- 		rt2800_register_write(rt2x00dev, TX_SW_CFG1, 0x00080606);
--	} else if (rt2x00_rt(rt2x00dev, RT5390) ||
-+	} else if (rt2x00_rt(rt2x00dev, RT5350) ||
-+		   rt2x00_rt(rt2x00dev, RT5390) ||
- 		   rt2x00_rt(rt2x00dev, RT5392) ||
- 		   rt2x00_rt(rt2x00dev, RT5592)) {
- 		rt2800_register_write(rt2x00dev, TX_SW_CFG0, 0x00000404);
-@@ -4215,9 +4229,13 @@ static void rt2800_init_bbp_3352(struct 
- 
- 	rt2800_bbp_write(rt2x00dev, 82, 0x62);
- 
--	rt2800_bbp_write(rt2x00dev, 83, 0x6a);
--
--	rt2800_bbp_write(rt2x00dev, 84, 0x99);
-+	if (rt2x00_rt(rt2x00dev, RT5350)) {
-+		rt2800_bbp_write(rt2x00dev, 83, 0x7a);
-+		rt2800_bbp_write(rt2x00dev, 84, 0x9a);
-+	} else {
-+		rt2800_bbp_write(rt2x00dev, 83, 0x6a);
-+		rt2800_bbp_write(rt2x00dev, 84, 0x99);
-+	}
- 
- 	rt2800_bbp_write(rt2x00dev, 86, 0x38);
- 
-@@ -4231,9 +4249,13 @@ static void rt2800_init_bbp_3352(struct 
- 
- 	rt2800_bbp_write(rt2x00dev, 104, 0x92);
- 
--	rt2800_bbp_write(rt2x00dev, 105, 0x34);
--
--	rt2800_bbp_write(rt2x00dev, 106, 0x05);
-+	if (rt2x00_rt(rt2x00dev, RT5350)) {
-+		rt2800_bbp_write(rt2x00dev, 105, 0x3c);
-+		rt2800_bbp_write(rt2x00dev, 106, 0x03);
-+	} else {
-+		rt2800_bbp_write(rt2x00dev, 105, 0x34);
-+		rt2800_bbp_write(rt2x00dev, 106, 0x05);
-+	}
- 
- 	rt2800_bbp_write(rt2x00dev, 120, 0x50);
- 
-@@ -4258,6 +4280,13 @@ static void rt2800_init_bbp_3352(struct 
- 	rt2800_bbp_write(rt2x00dev, 143, 0xa2);
- 
- 	rt2800_bbp_write(rt2x00dev, 148, 0xc8);
-+
-+	if (rt2x00_rt(rt2x00dev, RT5350)) {
-+		rt2800_bbp_write(rt2x00dev, 150, 0x40); /* Antenna Software OFDM */
-+		rt2800_bbp_write(rt2x00dev, 151, 0x30); /* Antenna Software CCK */
-+		rt2800_bbp_write(rt2x00dev, 152, 0xa3);
-+		rt2800_bbp_write(rt2x00dev, 154, 0); /* Clear previously selected antenna */
-+	}
- }
- 
- static void rt2800_init_bbp_3390(struct rt2x00_dev *rt2x00dev)
-@@ -4542,6 +4571,7 @@ static void rt2800_init_bbp(struct rt2x0
- 		rt2800_init_bbp_3290(rt2x00dev);
- 		break;
- 	case RT3352:
-+	case RT5350:
- 		rt2800_init_bbp_3352(rt2x00dev);
- 		break;
- 	case RT3390:
-@@ -5181,6 +5211,76 @@ static void rt2800_init_rfcsr_3572(struc
- 	rt2800_normal_mode_setup_3xxx(rt2x00dev);
- }
- 
-+static void rt2800_init_rfcsr_5350(struct rt2x00_dev *rt2x00dev)
-+{
-+	rt2800_rfcsr_write(rt2x00dev, 0, 0xf0);
-+	rt2800_rfcsr_write(rt2x00dev, 1, 0x23);
-+	rt2800_rfcsr_write(rt2x00dev, 2, 0x50);
-+	rt2800_rfcsr_write(rt2x00dev, 3, 0x08);
-+	rt2800_rfcsr_write(rt2x00dev, 4, 0x49);
-+	rt2800_rfcsr_write(rt2x00dev, 5, 0x10);
-+	rt2800_rfcsr_write(rt2x00dev, 6, 0xe0);
-+	rt2800_rfcsr_write(rt2x00dev, 7, 0x00);
-+	rt2800_rfcsr_write(rt2x00dev, 8, 0xf1);
-+	rt2800_rfcsr_write(rt2x00dev, 9, 0x02);
-+	rt2800_rfcsr_write(rt2x00dev, 10, 0x53);
-+	rt2800_rfcsr_write(rt2x00dev, 11, 0x4a);
-+	rt2800_rfcsr_write(rt2x00dev, 12, 0x46);
-+	if(rt2x00dev->spec.clk_is_20mhz)
-+		rt2800_rfcsr_write(rt2x00dev, 13, 0x1f);
-+	else
-+		rt2800_rfcsr_write(rt2x00dev, 13, 0x9f);
-+	rt2800_rfcsr_write(rt2x00dev, 14, 0x00);
-+	rt2800_rfcsr_write(rt2x00dev, 15, 0x00);
-+	rt2800_rfcsr_write(rt2x00dev, 16, 0xc0);
-+	rt2800_rfcsr_write(rt2x00dev, 18, 0x03);
-+	rt2800_rfcsr_write(rt2x00dev, 19, 0x00);
-+	rt2800_rfcsr_write(rt2x00dev, 20, 0x00);
-+	rt2800_rfcsr_write(rt2x00dev, 21, 0x00);
-+	rt2800_rfcsr_write(rt2x00dev, 22, 0x20);
-+	rt2800_rfcsr_write(rt2x00dev, 23, 0x00);
-+	rt2800_rfcsr_write(rt2x00dev, 24, 0x00);
-+	rt2800_rfcsr_write(rt2x00dev, 25, 0x80);
-+	rt2800_rfcsr_write(rt2x00dev, 26, 0x00);
-+	rt2800_rfcsr_write(rt2x00dev, 27, 0x03);
-+	rt2800_rfcsr_write(rt2x00dev, 28, 0x00);
-+	rt2800_rfcsr_write(rt2x00dev, 29, 0xd0);
-+	rt2800_rfcsr_write(rt2x00dev, 30, 0x10);
-+	rt2800_rfcsr_write(rt2x00dev, 31, 0x80);
-+	rt2800_rfcsr_write(rt2x00dev, 32, 0x80);
-+	rt2800_rfcsr_write(rt2x00dev, 33, 0x00);
-+	rt2800_rfcsr_write(rt2x00dev, 34, 0x07);
-+	rt2800_rfcsr_write(rt2x00dev, 35, 0x12);
-+	rt2800_rfcsr_write(rt2x00dev, 36, 0x00);
-+	rt2800_rfcsr_write(rt2x00dev, 37, 0x08);
-+	rt2800_rfcsr_write(rt2x00dev, 38, 0x85);
-+	rt2800_rfcsr_write(rt2x00dev, 39, 0x1b);
-+	rt2800_rfcsr_write(rt2x00dev, 40, 0x0b);
-+	rt2800_rfcsr_write(rt2x00dev, 41, 0xbb);
-+	rt2800_rfcsr_write(rt2x00dev, 42, 0xd5);
-+	rt2800_rfcsr_write(rt2x00dev, 43, 0x9b);
-+	rt2800_rfcsr_write(rt2x00dev, 44, 0x0c);
-+	rt2800_rfcsr_write(rt2x00dev, 45, 0xa6);
-+	rt2800_rfcsr_write(rt2x00dev, 46, 0x73);
-+	rt2800_rfcsr_write(rt2x00dev, 47, 0x00);
-+	rt2800_rfcsr_write(rt2x00dev, 48, 0x10);
-+	rt2800_rfcsr_write(rt2x00dev, 49, 0x80);
-+	rt2800_rfcsr_write(rt2x00dev, 50, 0x00);
-+	rt2800_rfcsr_write(rt2x00dev, 51, 0x00);
-+	rt2800_rfcsr_write(rt2x00dev, 52, 0x38);
-+	rt2800_rfcsr_write(rt2x00dev, 53, 0x00);
-+	rt2800_rfcsr_write(rt2x00dev, 54, 0x38);
-+	rt2800_rfcsr_write(rt2x00dev, 55, 0x43);
-+	rt2800_rfcsr_write(rt2x00dev, 56, 0x82);
-+	rt2800_rfcsr_write(rt2x00dev, 57, 0x00);
-+	rt2800_rfcsr_write(rt2x00dev, 58, 0x39);
-+	rt2800_rfcsr_write(rt2x00dev, 59, 0x0b);
-+	rt2800_rfcsr_write(rt2x00dev, 60, 0x45);
-+	rt2800_rfcsr_write(rt2x00dev, 61, 0xd1);
-+	rt2800_rfcsr_write(rt2x00dev, 62, 0x00);
-+	rt2800_rfcsr_write(rt2x00dev, 63, 0x00);
-+}
-+
- static void rt2800_init_rfcsr_5390(struct rt2x00_dev *rt2x00dev)
- {
- 	rt2800_rf_init_calibration(rt2x00dev, 2);
-@@ -5409,6 +5509,9 @@ static void rt2800_init_rfcsr(struct rt2
- 	case RT3572:
- 		rt2800_init_rfcsr_3572(rt2x00dev);
- 		break;
-+	case RT5350:
-+		rt2800_init_rfcsr_5350(rt2x00dev);
-+		break;
- 	case RT5390:
- 		rt2800_init_rfcsr_5390(rt2x00dev);
- 		break;
-@@ -5621,6 +5724,12 @@ static int rt2800_validate_eeprom(struct
- 		rt2x00_set_field16(&word, EEPROM_NIC_CONF0_RF_TYPE, RF2820);
- 		rt2x00_eeprom_write(rt2x00dev, EEPROM_NIC_CONF0, word);
- 		rt2x00_eeprom_dbg(rt2x00dev, "Antenna: 0x%04x\n", word);
-+	} else if (rt2x00_rt(rt2x00dev, RT5350)) {
-+		rt2x00_set_field16(&word, EEPROM_NIC_CONF0_RXPATH, 1);
-+		rt2x00_set_field16(&word, EEPROM_NIC_CONF0_TXPATH, 1);
-+		rt2x00_set_field16(&word, EEPROM_NIC_CONF0_RF_TYPE, RF3320);
-+		rt2x00_eeprom_write(rt2x00dev, EEPROM_NIC_CONF0, word);
-+		rt2x00_eeprom_dbg(rt2x00dev, "Antenna: 0x%04x\n", word);
- 	} else if (rt2x00_rt(rt2x00dev, RT2860) ||
- 		   rt2x00_rt(rt2x00dev, RT2872)) {
- 		/*
-@@ -5749,6 +5858,8 @@ static int rt2800_init_eeprom(struct rt2
- 	    rt2x00_rt(rt2x00dev, RT5390) ||
- 	    rt2x00_rt(rt2x00dev, RT5392))
- 		rt2x00_eeprom_read(rt2x00dev, EEPROM_CHIP_ID, &rf);
-+	else if (rt2x00_rt(rt2x00dev, RT5350))
-+		rf = RF5350;
- 	else
- 		rf = rt2x00_get_field16(eeprom, EEPROM_NIC_CONF0_RF_TYPE);
- 
-@@ -5765,6 +5876,7 @@ static int rt2800_init_eeprom(struct rt2
- 	case RF3290:
- 	case RF3320:
- 	case RF3322:
-+	case RF5350:
- 	case RF5360:
- 	case RF5370:
- 	case RF5372:
-@@ -6263,7 +6375,8 @@ static int rt2800_probe_hw_mode(struct r
- 		   rt2x00_rf(rt2x00dev, RF5392)) {
- 		spec->num_channels = 14;
- 		spec->channels = rf_vals_3x;
--	} else if (rt2x00_rf(rt2x00dev, RF3322)) {
-+	} else if (rt2x00_rf(rt2x00dev, RF3322) ||
-+		   rt2x00_rf(rt2x00dev, RF5350)) {
- 		spec->num_channels = 14;
- 		if (spec->clk_is_20mhz)
- 			spec->channels = rf_vals_xtal20mhz_3x;
-@@ -6364,6 +6477,7 @@ static int rt2800_probe_hw_mode(struct r
- 	case RF3320:
- 	case RF3052:
- 	case RF3290:
-+	case RF5350:
- 	case RF5360:
- 	case RF5370:
- 	case RF5372:
-@@ -6401,6 +6515,7 @@ static int rt2800_probe_rt(struct rt2x00
- 	case RT3352:
- 	case RT3390:
- 	case RT3572:
-+	case RT5350:
- 	case RT5390:
- 	case RT5392:
- 	case RT5592:
---- a/drivers/net/wireless/rt2x00/rt2x00.h
-+++ b/drivers/net/wireless/rt2x00/rt2x00.h
-@@ -181,6 +181,7 @@ struct rt2x00_chip {
- #define RT3572		0x3572
- #define RT3593		0x3593
- #define RT3883		0x3883	/* WSOC */
-+#define RT5350		0x5350  /* WSOC 2.4GHz */
- #define RT5390		0x5390  /* 2.4GHz */
- #define RT5392		0x5392  /* 2.4GHz */
- #define RT5592		0x5592
diff --git a/package/mac80211/patches/617-rt2x00-load-eeprom-on-SoC-from-a-mtd-device-defines-.patch b/package/mac80211/patches/617-rt2x00-load-eeprom-on-SoC-from-a-mtd-device-defines-.patch
deleted file mode 100644
index d5af4c9..0000000
--- a/package/mac80211/patches/617-rt2x00-load-eeprom-on-SoC-from-a-mtd-device-defines-.patch
+++ /dev/null
@@ -1,102 +0,0 @@
-From 339fe73f340161a624cc08e738d2244814852c3e Mon Sep 17 00:00:00 2001
-From: John Crispin <blogic@openwrt.org>
-Date: Sun, 17 Mar 2013 00:55:04 +0100
-Subject: [PATCH] rt2x00: load eeprom on SoC from a mtd device defines inside
- OF
-
-Signed-off-by: John Crispin <blogic@openwrt.org>
----
- drivers/net/wireless/rt2x00/Kconfig     |    1 +
- drivers/net/wireless/rt2x00/rt2800pci.c |   44 ++++++++++++++++++++++++++-----
- 2 files changed, 39 insertions(+), 6 deletions(-)
-
---- a/drivers/net/wireless/rt2x00/Kconfig
-+++ b/drivers/net/wireless/rt2x00/Kconfig
-@@ -71,6 +71,7 @@ config RT2800PCI
- 	select RT2X00_LIB_FIRMWARE
- 	select RT2X00_LIB_EEPROM
- 	select RT2X00_LIB_CRYPTO
-+	select MTD if SOC_RT288X || SOC_RT305X
- 	depends on CRC_CCITT
- 	depends on EEPROM_93CX6
- 	---help---
---- a/drivers/net/wireless/rt2x00/rt2x00eeprom.c
-+++ b/drivers/net/wireless/rt2x00/rt2x00eeprom.c
-@@ -30,12 +30,77 @@
- #include "rt2x00.h"
- #include "rt2x00lib.h"
- 
-+#ifdef CONFIG_OF
-+#include <linux/of.h>
-+#include <linux/mtd/mtd.h>
-+#include <linux/mtd/partitions.h>
-+
-+static struct firmware mtd_fw;
-+
-+static int rt2800pci_read_eeprom_mtd(struct rt2x00_dev *rt2x00dev)
-+{
-+	struct device_node *np = rt2x00dev->dev->of_node, *mtd_np = NULL;
-+	size_t retlen, len = rt2x00dev->ops->eeprom_size;
-+	int ret, size, offset = 0;
-+	struct mtd_info *mtd;
-+	const char *part;
-+	const __be32 *list;
-+	phandle phandle;
-+
-+	list = of_get_property(np, "ralink,mtd-eeprom", &size);
-+	if (!list) {
-+		dev_err(rt2x00dev->dev, "failed to load eeprom property\n");
-+		return -ENOENT;
-+	}
-+
-+	phandle = be32_to_cpup(list++);
-+	if (phandle)
-+		mtd_np = of_find_node_by_phandle(phandle);
-+	if (!mtd_np) {
-+		dev_err(rt2x00dev->dev, "failed to load mtd phandle\n");
-+		return -EINVAL;
-+	}
-+
-+	part = of_get_property(mtd_np, "label", NULL);
-+	if (!part)
-+		part = mtd_np->name;
-+
-+	mtd = get_mtd_device_nm(part);
-+	if (IS_ERR(mtd)) {
-+		dev_err(rt2x00dev->dev, "failed to get mtd device \"%s\"\n", part);
-+		return PTR_ERR(mtd);
-+	}
-+
-+	if (size > sizeof(*list))
-+		offset = be32_to_cpup(list);
-+
-+	ret = mtd_read(mtd, offset, len, &retlen, (u_char *) rt2x00dev->eeprom);
-+	put_mtd_device(mtd);
-+
-+	if (!ret) {
-+		rt2x00dev->eeprom_file = &mtd_fw;
-+		mtd_fw.size = len;
-+		mtd_fw.data = rt2x00dev->eeprom;
-+	}
-+
-+	return ret;
-+}
-+#else
-+static inline int rt2800pci_read_eeprom_mtd(struct rt2x00_dev *rt2x00dev)
-+{
-+	return -EINVAL;
-+}
-+#endif
-+
- static int rt2x00lib_request_eeprom_file(struct rt2x00_dev *rt2x00dev)
- {
- 	const struct firmware *ee;
- 	char *ee_name;
- 	int retval;
- 
-+	if (!rt2800pci_read_eeprom_mtd(rt2x00dev))
-+		return 0;
-+
- 	ee_name = rt2x00dev->ops->lib->get_eeprom_file_name(rt2x00dev);
- 	if (!ee_name) {
- 		rt2x00_err(rt2x00dev,
diff --git a/package/mac80211/patches/618-rt2x00-msi-fix.patch b/package/mac80211/patches/618-rt2x00-msi-fix.patch
deleted file mode 100644
index ceddbe4..0000000
--- a/package/mac80211/patches/618-rt2x00-msi-fix.patch
+++ /dev/null
@@ -1,32 +0,0 @@
---- a/drivers/net/wireless/rt2x00/rt2x00pci.c
-+++ b/drivers/net/wireless/rt2x00/rt2x00pci.c
-@@ -108,7 +108,9 @@ int rt2x00pci_probe(struct pci_dev *pci_
- 		goto exit_release_regions;
- 	}
- 
-+#ifdef CONFIG_PCI_MSI
- 	pci_enable_msi(pci_dev);
-+#endif
- 
- 	hw = ieee80211_alloc_hw(sizeof(struct rt2x00_dev), ops->hw);
- 	if (!hw) {
-@@ -162,7 +164,9 @@ exit_free_device:
- 	ieee80211_free_hw(hw);
- 
- exit_disable_msi:
-+#ifdef CONFIG_PCI_SET_MWI
- 	pci_disable_msi(pci_dev);
-+#endif
- 
- exit_release_regions:
- 	pci_release_regions(pci_dev);
-@@ -188,7 +192,9 @@ void rt2x00pci_remove(struct pci_dev *pc
- 	rt2x00pci_free_reg(rt2x00dev);
- 	ieee80211_free_hw(hw);
- 
-+#ifdef CONFIG_PCI_MSI
- 	pci_disable_msi(pci_dev);
-+#endif
- 
- 	/*
- 	 * Free the PCI device data.
diff --git a/package/mac80211/patches/620-rt2x00-rt3352-rf-id.patch b/package/mac80211/patches/620-rt2x00-rt3352-rf-id.patch
deleted file mode 100644
index ef6b1af..0000000
--- a/package/mac80211/patches/620-rt2x00-rt3352-rf-id.patch
+++ /dev/null
@@ -1,15 +0,0 @@
---- a/drivers/net/wireless/rt2x00/rt2800lib.c
-+++ b/drivers/net/wireless/rt2x00/rt2800lib.c
-@@ -5854,10 +5854,11 @@ static int rt2800_init_eeprom(struct rt2
- 	 * RT53xx: defined in "EEPROM_CHIP_ID" field
- 	 */
- 	if (rt2x00_rt(rt2x00dev, RT3290) ||
--	    rt2x00_rt(rt2x00dev, RT3352) ||
- 	    rt2x00_rt(rt2x00dev, RT5390) ||
- 	    rt2x00_rt(rt2x00dev, RT5392))
- 		rt2x00_eeprom_read(rt2x00dev, EEPROM_CHIP_ID, &rf);
-+	else if (rt2x00_rt(rt2x00dev, RT3352))
-+		rf = RF3322;
- 	else if (rt2x00_rt(rt2x00dev, RT5350))
- 		rf = RF5350;
- 	else
diff --git a/package/mac80211/patches/700-mwl8k-missing-pci-id-for-WNR854T.patch b/package/mac80211/patches/700-mwl8k-missing-pci-id-for-WNR854T.patch
deleted file mode 100644
index 3381ba5..0000000
--- a/package/mac80211/patches/700-mwl8k-missing-pci-id-for-WNR854T.patch
+++ /dev/null
@@ -1,10 +0,0 @@
---- a/drivers/net/wireless/mwl8k.c
-+++ b/drivers/net/wireless/mwl8k.c
-@@ -5530,6 +5530,7 @@ MODULE_FIRMWARE("mwl8k/fmimage_8366.fw")
- MODULE_FIRMWARE(MWL8K_8366_AP_FW(MWL8K_8366_AP_FW_API));
- 
- static DEFINE_PCI_DEVICE_TABLE(mwl8k_pci_id_table) = {
-+	{ PCI_VDEVICE(MARVELL, 0x2a02), .driver_data = MWL8363, },
- 	{ PCI_VDEVICE(MARVELL, 0x2a0a), .driver_data = MWL8363, },
- 	{ PCI_VDEVICE(MARVELL, 0x2a0c), .driver_data = MWL8363, },
- 	{ PCI_VDEVICE(MARVELL, 0x2a24), .driver_data = MWL8363, },
diff --git a/package/mac80211/patches/750-rtlwifi-Align-private-space-in-rtl_priv-struct.patch b/package/mac80211/patches/750-rtlwifi-Align-private-space-in-rtl_priv-struct.patch
deleted file mode 100644
index 050defa..0000000
--- a/package/mac80211/patches/750-rtlwifi-Align-private-space-in-rtl_priv-struct.patch
+++ /dev/null
@@ -1,27 +0,0 @@
-From 60ce314d1750fef843e9db70050e09e49f838b69 Mon Sep 17 00:00:00 2001
-From: Larry Finger <Larry.Finger@lwfinger.net>
-Date: Thu, 19 Sep 2013 02:21:35 +0000
-Subject: rtlwifi: Align private space in rtl_priv struct
-
-The private array at the end of the rtl_priv struct is not aligned.
-On ARM architecture, this causes an alignment trap and is fixed by aligning
-that array with __align(sizeof(void *)). That should properly align that
-space according to the requirements of all architectures.
-
-Reported-by: Jason Andrews <jasona@cadence.com>
-Tested-by: Jason Andrews <jasona@cadence.com>
-Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>
-Cc: Stable <stable@vger.kernel.org>
-Signed-off-by: John W. Linville <linville@tuxdriver.com>
----
---- a/drivers/net/wireless/rtlwifi/wifi.h
-+++ b/drivers/net/wireless/rtlwifi/wifi.h
-@@ -2057,7 +2057,7 @@ struct rtl_priv {
- 	   that it points to the data allocated
- 	   beyond  this structure like:
- 	   rtl_pci_priv or rtl_usb_priv */
--	u8 priv[0];
-+	u8 priv[0] __aligned(sizeof(void *));
- };
- 
- #define rtl_priv(hw)		(((struct rtl_priv *)(hw)->priv))
diff --git a/package/mac80211/patches/800-b43-gpio-mask-module-option.patch b/package/mac80211/patches/800-b43-gpio-mask-module-option.patch
deleted file mode 100644
index 46de746..0000000
--- a/package/mac80211/patches/800-b43-gpio-mask-module-option.patch
+++ /dev/null
@@ -1,37 +0,0 @@
---- a/drivers/net/wireless/b43/b43.h
-+++ b/drivers/net/wireless/b43/b43.h
-@@ -820,6 +820,7 @@ struct b43_wldev {
- 	bool qos_enabled;		/* TRUE, if QoS is used. */
- 	bool hwcrypto_enabled;		/* TRUE, if HW crypto acceleration is enabled. */
- 	bool use_pio;			/* TRUE if next init should use PIO */
-+	int gpiomask;			/* GPIO LED mask as a module parameter */
- 
- 	/* PHY/Radio device. */
- 	struct b43_phy phy;
---- a/drivers/net/wireless/b43/main.c
-+++ b/drivers/net/wireless/b43/main.c
-@@ -76,6 +76,11 @@ MODULE_FIRMWARE("b43/ucode16_mimo.fw");
- MODULE_FIRMWARE("b43/ucode5.fw");
- MODULE_FIRMWARE("b43/ucode9.fw");
- 
-+static int modparam_gpiomask = 0x000F;
-+module_param_named(gpiomask, modparam_gpiomask, int, 0444);
-+MODULE_PARM_DESC(gpiomask,
-+         "GPIO mask for LED control (default 0x000F)");
-+
- static int modparam_bad_frames_preempt;
- module_param_named(bad_frames_preempt, modparam_bad_frames_preempt, int, 0444);
- MODULE_PARM_DESC(bad_frames_preempt,
-@@ -2742,10 +2747,10 @@ static int b43_gpio_init(struct b43_wlde
- 	u32 mask, set;
- 
- 	b43_maskset32(dev, B43_MMIO_MACCTL, ~B43_MACCTL_GPOUTSMSK, 0);
--	b43_maskset16(dev, B43_MMIO_GPIO_MASK, ~0, 0xF);
-+	b43_maskset16(dev, B43_MMIO_GPIO_MASK, ~0, modparam_gpiomask);
- 
- 	mask = 0x0000001F;
--	set = 0x0000000F;
-+	set = modparam_gpiomask;
- 	if (dev->dev->chip_id == 0x4301) {
- 		mask |= 0x0060;
- 		set |= 0x0060;
diff --git a/package/mac80211/patches/810-b43_no_pio.patch b/package/mac80211/patches/810-b43_no_pio.patch
deleted file mode 100644
index 1206923..0000000
--- a/package/mac80211/patches/810-b43_no_pio.patch
+++ /dev/null
@@ -1,86 +0,0 @@
---- a/drivers/net/wireless/b43/Makefile
-+++ b/drivers/net/wireless/b43/Makefile
-@@ -20,7 +20,7 @@ b43-y				+= xmit.o
- b43-y				+= lo.o
- b43-y				+= wa.o
- b43-y				+= dma.o
--b43-y				+= pio.o
-+b43-$(CONFIG_B43_PIO)		+= pio.o
- b43-y				+= rfkill.o
- b43-$(CPTCFG_B43_LEDS)		+= leds.o
- b43-$(CPTCFG_B43_PCMCIA)	+= pcmcia.o
---- a/drivers/net/wireless/b43/main.c
-+++ b/drivers/net/wireless/b43/main.c
-@@ -1915,10 +1915,12 @@ static void b43_do_interrupt_thread(stru
- 			dma_reason[0], dma_reason[1],
- 			dma_reason[2], dma_reason[3],
- 			dma_reason[4], dma_reason[5]);
-+#ifdef CONFIG_B43_PIO
- 		b43err(dev->wl, "This device does not support DMA "
- 			       "on your system. It will now be switched to PIO.\n");
- 		/* Fall back to PIO transfers if we get fatal DMA errors! */
- 		dev->use_pio = true;
-+#endif
- 		b43_controller_restart(dev, "DMA error");
- 		return;
- 	}
---- a/drivers/net/wireless/b43/pio.h
-+++ b/drivers/net/wireless/b43/pio.h
-@@ -150,7 +150,7 @@ static inline void b43_piorx_write32(str
- 	b43_write32(q->dev, q->mmio_base + offset, value);
- }
- 
--
-+#ifdef CONFIG_B43_PIO
- int b43_pio_init(struct b43_wldev *dev);
- void b43_pio_free(struct b43_wldev *dev);
- 
-@@ -161,5 +161,37 @@ void b43_pio_rx(struct b43_pio_rxqueue *
- 
- void b43_pio_tx_suspend(struct b43_wldev *dev);
- void b43_pio_tx_resume(struct b43_wldev *dev);
-+#else
-+static inline int b43_pio_init(struct b43_wldev *dev)
-+{
-+	return 0;
-+}
-+
-+static inline void b43_pio_free(struct b43_wldev *dev)
-+{
-+}
-+
-+static inline int b43_pio_tx(struct b43_wldev *dev, struct sk_buff *skb)
-+{
-+	return 0;
-+}
-+
-+static inline void b43_pio_handle_txstatus(struct b43_wldev *dev,
-+					   const struct b43_txstatus *status)
-+{
-+}
-+
-+static inline void b43_pio_rx(struct b43_pio_rxqueue *q)
-+{
-+}
-+
-+static inline void b43_pio_tx_suspend(struct b43_wldev *dev)
-+{
-+}
-+
-+static inline void b43_pio_tx_resume(struct b43_wldev *dev)
-+{
-+}
-+#endif /* CONFIG_B43_PIO */
- 
- #endif /* B43_PIO_H_ */
---- a/drivers/net/wireless/b43/Kconfig
-+++ b/drivers/net/wireless/b43/Kconfig
-@@ -98,7 +98,7 @@ config B43_BCMA_PIO
- 	default y
- 
- config B43_PIO
--	bool
-+	bool "Broadcom 43xx PIO support"
- 	depends on B43
- 	select SSB_BLOCKIO
- 	default y
diff --git a/package/mac80211/patches/820-b43-add-antenna-control.patch b/package/mac80211/patches/820-b43-add-antenna-control.patch
deleted file mode 100644
index 56aef89..0000000
--- a/package/mac80211/patches/820-b43-add-antenna-control.patch
+++ /dev/null
@@ -1,131 +0,0 @@
---- a/drivers/net/wireless/b43/main.c
-+++ b/drivers/net/wireless/b43/main.c
-@@ -1562,7 +1562,7 @@ static void b43_write_beacon_template(st
- 				  len, ram_offset, shm_size_offset, rate);
- 
- 	/* Write the PHY TX control parameters. */
--	antenna = B43_ANTENNA_DEFAULT;
-+	antenna = dev->tx_antenna;
- 	antenna = b43_antenna_to_phyctl(antenna);
- 	ctl = b43_shm_read16(dev, B43_SHM_SHARED, B43_SHM_SH_BEACPHYCTL);
- 	/* We can't send beacons with short preamble. Would get PHY errors. */
-@@ -3100,8 +3100,8 @@ static int b43_chip_init(struct b43_wlde
- 
- 	/* Select the antennae */
- 	if (phy->ops->set_rx_antenna)
--		phy->ops->set_rx_antenna(dev, B43_ANTENNA_DEFAULT);
--	b43_mgmtframe_txantenna(dev, B43_ANTENNA_DEFAULT);
-+		phy->ops->set_rx_antenna(dev, dev->rx_antenna);
-+	b43_mgmtframe_txantenna(dev, dev->tx_antenna);
- 
- 	if (phy->type == B43_PHYTYPE_B) {
- 		value16 = b43_read16(dev, 0x005E);
-@@ -3845,7 +3845,6 @@ static int b43_op_config(struct ieee8021
- 	struct b43_wldev *dev;
- 	struct b43_phy *phy;
- 	struct ieee80211_conf *conf = &hw->conf;
--	int antenna;
- 	int err = 0;
- 	bool reload_bss = false;
- 
-@@ -3899,11 +3898,9 @@ static int b43_op_config(struct ieee8021
- 	}
- 
- 	/* Antennas for RX and management frame TX. */
--	antenna = B43_ANTENNA_DEFAULT;
--	b43_mgmtframe_txantenna(dev, antenna);
--	antenna = B43_ANTENNA_DEFAULT;
-+	b43_mgmtframe_txantenna(dev, dev->tx_antenna);
- 	if (phy->ops->set_rx_antenna)
--		phy->ops->set_rx_antenna(dev, antenna);
-+		phy->ops->set_rx_antenna(dev, dev->rx_antenna);
- 
- 	if (wl->radio_enabled != phy->radio_on) {
- 		if (wl->radio_enabled) {
-@@ -5028,6 +5025,47 @@ static int b43_op_get_survey(struct ieee
- 	return 0;
- }
- 
-+static int b43_op_set_antenna(struct ieee80211_hw *hw, u32 tx_ant, u32 rx_ant)
-+{
-+	struct b43_wl *wl = hw_to_b43_wl(hw);
-+	struct b43_wldev *dev = wl->current_dev;
-+
-+	if (tx_ant == 1 && rx_ant == 1) {
-+		dev->tx_antenna = B43_ANTENNA0;
-+		dev->rx_antenna = B43_ANTENNA0;
-+	}
-+	else if (tx_ant == 2 && rx_ant == 2) {
-+		dev->tx_antenna = B43_ANTENNA1;
-+		dev->rx_antenna = B43_ANTENNA1;
-+	}
-+	else if ((tx_ant & 3) == 3 && (rx_ant & 3) == 3) {
-+		dev->tx_antenna = B43_ANTENNA_DEFAULT;
-+		dev->rx_antenna = B43_ANTENNA_DEFAULT;
-+	}
-+	else {
-+		return -EINVAL;
-+	}
-+
-+	return 0;
-+}
-+
-+
-+static int b43_op_get_antenna(struct ieee80211_hw *hw, u32 *tx_ant, u32 *rx_ant)
-+{
-+	struct b43_wl *wl = hw_to_b43_wl(hw);
-+	struct b43_wldev *dev = wl->current_dev;
-+
-+	switch (dev->tx_antenna) {
-+	case B43_ANTENNA0:
-+		*tx_ant = 1; *rx_ant = 1; break;
-+	case B43_ANTENNA1:
-+		*tx_ant = 2; *rx_ant = 2; break;
-+	case B43_ANTENNA_DEFAULT:
-+		*tx_ant = 3; *rx_ant = 3; break;
-+	}
-+	return 0;
-+}
-+
- static const struct ieee80211_ops b43_hw_ops = {
- 	.tx			= b43_op_tx,
- 	.conf_tx		= b43_op_conf_tx,
-@@ -5049,6 +5087,8 @@ static const struct ieee80211_ops b43_hw
- 	.sw_scan_complete	= b43_op_sw_scan_complete_notifier,
- 	.get_survey		= b43_op_get_survey,
- 	.rfkill_poll		= b43_rfkill_poll,
-+	.set_antenna		= b43_op_set_antenna,
-+	.get_antenna		= b43_op_get_antenna,
- };
- 
- /* Hard-reset the chip. Do not call this directly.
-@@ -5295,6 +5335,8 @@ static int b43_one_core_attach(struct b4
- 	if (!wldev)
- 		goto out;
- 
-+	wldev->rx_antenna = B43_ANTENNA_DEFAULT;
-+	wldev->tx_antenna = B43_ANTENNA_DEFAULT;
- 	wldev->use_pio = b43_modparam_pio;
- 	wldev->dev = dev;
- 	wldev->wl = wl;
-@@ -5385,6 +5427,9 @@ static struct b43_wl *b43_wireless_init(
- 
- 	hw->wiphy->flags |= WIPHY_FLAG_IBSS_RSN;
- 
-+	hw->wiphy->available_antennas_rx = 0x3;
-+	hw->wiphy->available_antennas_tx = 0x3;
-+
- 	wl->hw_registred = false;
- 	hw->max_rates = 2;
- 	SET_IEEE80211_DEV(hw, dev->dev);
---- a/drivers/net/wireless/b43/b43.h
-+++ b/drivers/net/wireless/b43/b43.h
-@@ -821,6 +821,8 @@ struct b43_wldev {
- 	bool hwcrypto_enabled;		/* TRUE, if HW crypto acceleration is enabled. */
- 	bool use_pio;			/* TRUE if next init should use PIO */
- 	int gpiomask;			/* GPIO LED mask as a module parameter */
-+	int rx_antenna;			/* Used RX antenna (B43_ANTENNAxxx) */
-+	int tx_antenna;			/* Used TX antenna (B43_ANTENNAxxx) */
- 
- 	/* PHY/Radio device. */
- 	struct b43_phy phy;
diff --git a/package/mac80211/patches/830-b43-workaround-pcie-bcm4716.patch b/package/mac80211/patches/830-b43-workaround-pcie-bcm4716.patch
deleted file mode 100644
index e55d4fe..0000000
--- a/package/mac80211/patches/830-b43-workaround-pcie-bcm4716.patch
+++ /dev/null
@@ -1,134 +0,0 @@
-From 4f214b1ead0af7439921637645cb63f378516175 Mon Sep 17 00:00:00 2001
-From: Hauke Mehrtens <hauke@hauke-m.de>
-Date: Sat, 21 Jan 2012 18:48:38 +0100
-Subject: [PATCH 33/34] b43: add workaround for b43 on pcie bus of bcm4716.
-
-bcm4716 (which includes 4717 & 4718), plus 4706 on PCIe can reorder
-transactions. As a fix, a read after write is performed on certain
-places in the code. Older chips and the newer 5357 family don't require
-this fix.
-This code is based on the brcmsmac driver.
-
-Signed-off-by: Hauke Mehrtens <hauke@hauke-m.de>
----
- drivers/net/wireless/b43/b43.h        |   26 ++++++++++++++++++++++++++
- drivers/net/wireless/b43/bus.h        |   10 ++++++++++
- drivers/net/wireless/b43/phy_common.c |    6 ++++++
- drivers/net/wireless/b43/phy_n.c      |   10 +++++-----
- 4 files changed, 47 insertions(+), 5 deletions(-)
-
---- a/drivers/net/wireless/b43/b43.h
-+++ b/drivers/net/wireless/b43/b43.h
-@@ -1061,6 +1061,32 @@ static inline bool b43_using_pio_transfe
- 	return dev->__using_pio_transfers;
- }
- 
-+/*
-+ * bcm4716 (which includes 4717 & 4718), plus 4706 on PCIe can reorder
-+ * transactions. As a fix, a read after write is performed on certain places
-+ * in the code. Older chips and the newer 5357 family don't require this fix.
-+ */
-+#ifdef CONFIG_BCM47XX_BCMA
-+#include <asm/mach-bcm47xx/bcm47xx.h>
-+static inline void b43_wflush16(struct b43_wldev *dev, u16 offset, u16 value)
-+{
-+	if (b43_bus_host_is_pci(dev->dev) &&
-+	    bcm47xx_bus_type == BCM47XX_BUS_TYPE_BCMA &&
-+	    (bcm47xx_bus.bcma.bus.chipinfo.id == 0x4716 ||
-+	     bcm47xx_bus.bcma.bus.chipinfo.id == 0x5300)) {
-+		b43_write16(dev, offset, value);
-+		b43_read16(dev, offset);
-+	} else {
-+		b43_write16(dev, offset, value);
-+	}
-+}
-+#else
-+static inline void b43_wflush16(struct b43_wldev *dev, u16 offset, u16 value)
-+{
-+	b43_write16(dev, offset, value);
-+}
-+#endif
-+
- /* Message printing */
- __printf(2, 3) void b43info(struct b43_wl *wl, const char *fmt, ...);
- __printf(2, 3) void b43err(struct b43_wl *wl, const char *fmt, ...);
---- a/drivers/net/wireless/b43/bus.h
-+++ b/drivers/net/wireless/b43/bus.h
-@@ -60,6 +60,16 @@ static inline bool b43_bus_host_is_sdio(
- 	return (dev->bus_type == B43_BUS_SSB &&
- 		dev->sdev->bus->bustype == SSB_BUSTYPE_SDIO);
- }
-+static inline bool b43_bus_host_is_pci(struct b43_bus_dev *dev)
-+{
-+	if (dev->bus_type == B43_BUS_SSB)
-+		return (dev->sdev->bus->bustype == SSB_BUSTYPE_PCI);
-+#ifdef CONFIG_B43_BCMA
-+	if (dev->bus_type == B43_BUS_BCMA)
-+		return (dev->bdev->bus->hosttype == BCMA_HOSTTYPE_PCI);
-+#endif
-+	return false;
-+}
- 
- struct b43_bus_dev *b43_bus_dev_bcma_init(struct bcma_device *core);
- struct b43_bus_dev *b43_bus_dev_ssb_init(struct ssb_device *sdev);
---- a/drivers/net/wireless/b43/phy_common.c
-+++ b/drivers/net/wireless/b43/phy_common.c
-@@ -266,6 +266,12 @@ void b43_phy_write(struct b43_wldev *dev
- {
- 	assert_mac_suspended(dev);
- 	dev->phy.ops->phy_write(dev, reg, value);
-+#ifdef CONFIG_BCM47XX
-+	if (b43_bus_host_is_pci(dev->dev) && reg == 0x72) {
-+		b43_read16(dev, B43_MMIO_PHY_VER);
-+		return;
-+	}
-+#endif
- 	if (++dev->phy.writes_counter == B43_MAX_WRITES_IN_ROW) {
- 		b43_read16(dev, B43_MMIO_PHY_VER);
- 		dev->phy.writes_counter = 0;
---- a/drivers/net/wireless/b43/phy_n.c
-+++ b/drivers/net/wireless/b43/phy_n.c
-@@ -5417,14 +5417,14 @@ static inline void check_phyreg(struct b
- static u16 b43_nphy_op_read(struct b43_wldev *dev, u16 reg)
- {
- 	check_phyreg(dev, reg);
--	b43_write16(dev, B43_MMIO_PHY_CONTROL, reg);
-+	b43_wflush16(dev, B43_MMIO_PHY_CONTROL, reg);
- 	return b43_read16(dev, B43_MMIO_PHY_DATA);
- }
- 
- static void b43_nphy_op_write(struct b43_wldev *dev, u16 reg, u16 value)
- {
- 	check_phyreg(dev, reg);
--	b43_write16(dev, B43_MMIO_PHY_CONTROL, reg);
-+	b43_wflush16(dev, B43_MMIO_PHY_CONTROL, reg);
- 	b43_write16(dev, B43_MMIO_PHY_DATA, value);
- }
- 
-@@ -5432,7 +5432,7 @@ static void b43_nphy_op_maskset(struct b
- 				 u16 set)
- {
- 	check_phyreg(dev, reg);
--	b43_write16(dev, B43_MMIO_PHY_CONTROL, reg);
-+	b43_wflush16(dev, B43_MMIO_PHY_CONTROL, reg);
- 	b43_maskset16(dev, B43_MMIO_PHY_DATA, mask, set);
- }
- 
-@@ -5443,7 +5443,7 @@ static u16 b43_nphy_op_radio_read(struct
- 	/* N-PHY needs 0x100 for read access */
- 	reg |= 0x100;
- 
--	b43_write16(dev, B43_MMIO_RADIO_CONTROL, reg);
-+	b43_wflush16(dev, B43_MMIO_RADIO_CONTROL, reg);
- 	return b43_read16(dev, B43_MMIO_RADIO_DATA_LOW);
- }
- 
-@@ -5452,7 +5452,7 @@ static void b43_nphy_op_radio_write(stru
- 	/* Register 1 is a 32-bit register. */
- 	B43_WARN_ON(reg == 1);
- 
--	b43_write16(dev, B43_MMIO_RADIO_CONTROL, reg);
-+	b43_wflush16(dev, B43_MMIO_RADIO_CONTROL, reg);
- 	b43_write16(dev, B43_MMIO_RADIO_DATA_LOW, value);
- }
- 
diff --git a/package/mac80211/patches/841-b43-reduce-number-of-RX-slots.patch b/package/mac80211/patches/841-b43-reduce-number-of-RX-slots.patch
deleted file mode 100644
index 9c51ac6..0000000
--- a/package/mac80211/patches/841-b43-reduce-number-of-RX-slots.patch
+++ /dev/null
@@ -1,11 +0,0 @@
---- a/drivers/net/wireless/b43/dma.h
-+++ b/drivers/net/wireless/b43/dma.h
-@@ -169,7 +169,7 @@ struct b43_dmadesc_generic {
- 
- /* DMA engine tuning knobs */
- #define B43_TXRING_SLOTS		256
--#define B43_RXRING_SLOTS		256
-+#define B43_RXRING_SLOTS		32
- #define B43_DMA0_RX_FW598_BUFSIZE	(B43_DMA0_RX_FW598_FO + IEEE80211_MAX_FRAME_LEN)
- #define B43_DMA0_RX_FW351_BUFSIZE	(B43_DMA0_RX_FW351_FO + IEEE80211_MAX_FRAME_LEN)
- 
diff --git a/package/mac80211/patches/845-b43-only-use-gpio-0-1-for-led.patch b/package/mac80211/patches/845-b43-only-use-gpio-0-1-for-led.patch
deleted file mode 100644
index a1eafa4..0000000
--- a/package/mac80211/patches/845-b43-only-use-gpio-0-1-for-led.patch
+++ /dev/null
@@ -1,17 +0,0 @@
---- a/drivers/net/wireless/b43/main.c
-+++ b/drivers/net/wireless/b43/main.c
-@@ -2759,6 +2759,14 @@ static int b43_gpio_init(struct b43_wlde
- 	} else if (dev->dev->chip_id == 0x5354) {
- 		/* Don't allow overtaking buttons GPIOs */
- 		set &= 0x2; /* 0x2 is LED GPIO on BCM5354 */
-+	} else if (dev->dev->chip_id == BCMA_CHIP_ID_BCM4716 || 
-+		   dev->dev->chip_id == BCMA_CHIP_ID_BCM47162 ||
-+		   dev->dev->chip_id == BCMA_CHIP_ID_BCM5356 ||
-+		   dev->dev->chip_id == BCMA_CHIP_ID_BCM5357 ||
-+		   dev->dev->chip_id == BCMA_CHIP_ID_BCM53572) {
-+		/* just use gpio 0 and 1 for 2.4 GHz wifi led */
-+		set &= 0x3;
-+		mask &= 0x3;
- 	}
- 
- 	if (0 /* FIXME: conditional unknown */ ) {
diff --git a/package/mac80211/patches/847-b43-always-take-overlapping-devs.patch b/package/mac80211/patches/847-b43-always-take-overlapping-devs.patch
deleted file mode 100644
index 9d1d419..0000000
--- a/package/mac80211/patches/847-b43-always-take-overlapping-devs.patch
+++ /dev/null
@@ -1,11 +0,0 @@
---- a/drivers/net/wireless/b43/main.c
-+++ b/drivers/net/wireless/b43/main.c
-@@ -118,7 +118,7 @@ static int b43_modparam_pio = 0;
- module_param_named(pio, b43_modparam_pio, int, 0644);
- MODULE_PARM_DESC(pio, "Use PIO accesses by default: 0=DMA, 1=PIO");
- 
--static int modparam_allhwsupport = !IS_ENABLED(CPTCFG_BRCMSMAC);
-+static int modparam_allhwsupport = 1;
- module_param_named(allhwsupport, modparam_allhwsupport, int, 0444);
- MODULE_PARM_DESC(allhwsupport, "Enable support for all hardware (even it if overlaps with the brcmsmac driver)");
- 
diff --git a/package/mac80211/patches/851-brcmsmac-remove-extra-regulation-restriction.patch b/package/mac80211/patches/851-brcmsmac-remove-extra-regulation-restriction.patch
deleted file mode 100644
index dd1393a..0000000
--- a/package/mac80211/patches/851-brcmsmac-remove-extra-regulation-restriction.patch
+++ /dev/null
@@ -1,31 +0,0 @@
---- a/drivers/net/wireless/brcm80211/brcmsmac/channel.c
-+++ b/drivers/net/wireless/brcm80211/brcmsmac/channel.c
-@@ -59,23 +59,16 @@
- 
- #define BRCM_2GHZ_2412_2462	REG_RULE(2412-10, 2462+10, 40, 0, 19, 0)
- #define BRCM_2GHZ_2467_2472	REG_RULE(2467-10, 2472+10, 20, 0, 19, \
--					 NL80211_RRF_PASSIVE_SCAN | \
--					 NL80211_RRF_NO_IBSS)
-+					 0)
- 
- #define BRCM_5GHZ_5180_5240	REG_RULE(5180-10, 5240+10, 40, 0, 21, \
--					 NL80211_RRF_PASSIVE_SCAN | \
--					 NL80211_RRF_NO_IBSS)
-+					 0)
- #define BRCM_5GHZ_5260_5320	REG_RULE(5260-10, 5320+10, 40, 0, 21, \
--					 NL80211_RRF_PASSIVE_SCAN | \
--					 NL80211_RRF_DFS | \
--					 NL80211_RRF_NO_IBSS)
-+					 0)
- #define BRCM_5GHZ_5500_5700	REG_RULE(5500-10, 5700+10, 40, 0, 21, \
--					 NL80211_RRF_PASSIVE_SCAN | \
--					 NL80211_RRF_DFS | \
--					 NL80211_RRF_NO_IBSS)
-+					 0)
- #define BRCM_5GHZ_5745_5825	REG_RULE(5745-10, 5825+10, 40, 0, 21, \
--					 NL80211_RRF_PASSIVE_SCAN | \
--					 NL80211_RRF_NO_IBSS)
-+					 0)
- 
- static const struct ieee80211_regdomain brcms_regdom_x2 = {
- 	.n_reg_rules = 6,
