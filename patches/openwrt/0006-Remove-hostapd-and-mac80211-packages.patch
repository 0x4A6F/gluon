From: Matthias Schiffer <mschiffer@universe-factory.net>
Date: Sat, 11 Jan 2014 17:28:18 +0100
Subject: Remove hostapd and mac80211 packages

diff --git a/package/hostapd/Config.in b/package/hostapd/Config.in
deleted file mode 100644
index b39be38..0000000
--- a/package/hostapd/Config.in
+++ /dev/null
@@ -1,47 +0,0 @@
-# wpa_supplicant config
-config WPA_SUPPLICANT_NO_TIMESTAMP_CHECK
-	bool "Disable timestamp check"
-	depends on PACKAGE_wpa-supplicant || PACKAGE_wpa-supplicant-mini || PACKAGE_wpad || PACKAGE_wpad-mini
-	default n
-	help
-	  This disables the timestamp check for certificates in wpa_supplicant
-	  Useful for devices without RTC that cannot reliably get the real date/time
-
-choice
-	prompt "Choose TLS provider"
-	default WPA_SUPPLICANT_INTERNAL
-	depends on PACKAGE_wpa-supplicant || PACKAGE_wpad
-
-config WPA_SUPPLICANT_INTERNAL
-	bool "internal"
-
-config WPA_SUPPLICANT_OPENSSL
-	bool "openssl"
-	select PACKAGE_libopenssl
-
-endchoice
-
-config WPA_RFKILL_SUPPORT
-	bool "Add rfkill support"
-	depends on PACKAGE_wpa-supplicant || PACKAGE_wpa-supplicant-mini || PACKAGE_wpad || PACKAGE_wpad-mini
-	default n
-
-config WPA_MSG_MIN_PRIORITY
-	int "Minimum debug message priority"
-	default 3
-	help
-	  Useful values are:
-	    0 = all messages
-		1 = raw message dumps
-		2 = most debugging messages
-		3 = info messages
-		4 = warnings
-		5 = errors
-
-config DRIVER_WEXT_SUPPORT
-	bool
-	default n
-
-config DRIVER_11N_SUPPORT
-	bool
-	default n
diff --git a/package/hostapd/Makefile b/package/hostapd/Makefile
deleted file mode 100644
index b4dc242..0000000
--- a/package/hostapd/Makefile
+++ /dev/null
@@ -1,356 +0,0 @@
-#
-# Copyright (C) 2006-2012 OpenWrt.org
-#
-# This is free software, licensed under the GNU General Public License v2.
-# See /LICENSE for more information.
-#
-
-include $(TOPDIR)/rules.mk
-
-PKG_NAME:=hostapd
-PKG_VERSION:=20131120
-PKG_RELEASE:=1
-PKG_REV:=594516b4c28a94ca686b17f1e463dfd6712b75a7
-
-PKG_SOURCE:=$(PKG_NAME)-$(PKG_VERSION).tar.bz2
-PKG_SOURCE_URL:=git://w1.fi/srv/git/hostap.git
-PKG_SOURCE_SUBDIR:=$(PKG_NAME)-$(PKG_VERSION)
-PKG_SOURCE_VERSION:=$(PKG_REV)
-PKG_SOURCE_PROTO:=git
-# PKG_MIRROR_MD5SUM:=4e7c1f97edd7514535056fce54ae053a
-
-PKG_MAINTAINER:=Felix Fietkau <nbd@openwrt.org>
-
-PKG_BUILD_PARALLEL:=1
-
-PKG_BUILD_DEPENDS:= \
-	PACKAGE_kmod-madwifi:madwifi \
-
-PKG_CONFIG_DEPENDS:= \
-	CONFIG_WPA_SUPPLICANT_NO_TIMESTAMP_CHECK \
-	CONFIG_PACKAGE_kmod-ath9k \
-	CONFIG_PACKAGE_kmod-mac80211 \
-	CONFIG_PACKAGE_kmod-madwifi \
-	CONFIG_PACKAGE_hostapd \
-	CONFIG_PACKAGE_hostapd-mini \
-	CONFIG_PACKAGE_kmod-hostap \
-	CONFIG_WPA_RFKILL_SUPPORT \
-	CONFIG_DRIVER_WEXT_SUPPORT \
-	CONFIG_DRIVER_11N_SUPPORT
-
-LOCAL_TYPE=$(strip \
-		$(if $(findstring wpad,$(BUILD_VARIANT)),wpad, \
-		$(if $(findstring supplicant,$(BUILD_VARIANT)),supplicant, \
-		hostapd \
-	)))
-LOCAL_VARIANT=$(patsubst wpad-%,%,$(patsubst supplicant-%,%,$(BUILD_VARIANT)))
-
-ifeq ($(LOCAL_TYPE),supplicant)
-  ifeq ($(LOCAL_VARIANT),full)
-    PKG_CONFIG_DEPENDS += \
-		CONFIG_WPA_SUPPLICANT_INTERNAL \
-		CONFIG_WPA_SUPPLICANT_OPENSSL
-  endif
-endif
-
-PKG_BUILD_DIR:=$(BUILD_DIR)/$(PKG_NAME)-$(BUILD_VARIANT)/$(PKG_NAME)-$(PKG_VERSION)
-
-include $(INCLUDE_DIR)/package.mk
-
-STAMP_CONFIGURED:=$(STAMP_CONFIGURED)_$(CONFIG_WPA_MSG_MIN_PRIORITY)
-
-ifneq ($(CONFIG_DRIVER_11N_SUPPORT),)
-  HOSTAPD_IEEE80211N:=y
-endif
-
-DRIVER_MAKEOPTS= \
-	CONFIG_DRIVER_NL80211=$(CONFIG_PACKAGE_kmod-mac80211) \
-	CONFIG_DRIVER_MADWIFI=$(CONFIG_PACKAGE_kmod-madwifi) \
-	CONFIG_DRIVER_HOSTAP=$(CONFIG_PACKAGE_kmod-hostap) \
-	CONFIG_IEEE80211N=$(HOSTAPD_IEEE80211N) \
-	CONFIG_IEEE80211W=$(CONFIG_PACKAGE_kmod-ath9k) \
-	CONFIG_DRIVER_WEXT=$(CONFIG_DRIVER_WEXT_SUPPORT) \
-	$(if $(CONFIG_WPA_RFKILL_SUPPORT),NEED_RFKILL=y)
-
-ifneq ($(LOCAL_TYPE),hostapd)
-  ifdef CONFIG_WPA_SUPPLICANT_OPENSSL
-    ifeq ($(LOCAL_VARIANT),full)
-      DRIVER_MAKEOPTS += CONFIG_TLS=openssl
-      TARGET_LDFLAGS += -lcrypto -lssl
-    endif
-  endif
-  ifdef CONFIG_WPA_SUPPLICANT_NO_TIMESTAMP_CHECK
-    TARGET_CFLAGS += -DNO_TIMESTAMP_CHECK
-  endif
-  DRIVER_MAKEOPTS += \
-	CONFIG_DRIVER_ROBOSWITCH=$(CONFIG_PACKAGE_kmod-switch)
-endif
-
-DRV_DEPENDS:=+PACKAGE_kmod-mac80211:libnl-tiny @(!TARGET_avr32||BROKEN)
-
-define Package/hostapd/Default
-  SECTION:=net
-  CATEGORY:=Network
-  TITLE:=IEEE 802.1x Authenticator
-  URL:=http://hostap.epitest.fi/
-  DEPENDS:=$(DRV_DEPENDS) +libubus
-endef
-
-define Package/hostapd
-$(call Package/hostapd/Default)
-  TITLE+= (full)
-  VARIANT:=full
-endef
-
-define Package/hostapd/description
- This package contains a full featured IEEE 802.1x/WPA/EAP/RADIUS
- Authenticator.
-endef
-
-define Package/hostapd-mini
-$(call Package/hostapd/Default)
-  TITLE+= (WPA-PSK only)
-  VARIANT:=mini
-endef
-
-define Package/hostapd-mini/description
- This package contains a minimal IEEE 802.1x/WPA Authenticator (WPA-PSK only).
-endef
-
-define Package/hostapd-utils
-  $(call Package/hostapd/Default)
-  TITLE+= (utils)
-  DEPENDS:=@PACKAGE_hostapd||PACKAGE_hostapd-mini||PACKAGE_wpad||PACKAGE_wpad-mini
-endef
-
-define Package/hostapd-utils/description
- This package contains a command line utility to control the
- IEEE 802.1x/WPA/EAP/RADIUS Authenticator.
-endef
-
-define Package/wpad/Default
-  SECTION:=net
-  CATEGORY:=Network
-  TITLE:=IEEE 802.1x Authenticator/Supplicant
-  URL:=http://hostap.epitest.fi/
-endef
-
-define Package/wpad
-$(call Package/wpad/Default)
-  TITLE+= (full)
-  DEPENDS:=$(DRV_DEPENDS) +WPA_SUPPLICANT_OPENSSL:libopenssl +libubus
-  VARIANT:=wpad-full
-endef
-
-define Package/wpad/description
- This package contains a full featured IEEE 802.1x/WPA/EAP/RADIUS
- Authenticator and Supplicant
-endef
-
-define Package/wpad-mini
-$(call Package/wpad/Default)
-  TITLE+= (WPA-PSK only)
-  DEPENDS:=$(DRV_DEPENDS) +libubus
-  VARIANT:=wpad-mini
-endef
-
-define Package/wpad-mini/description
- This package contains a minimal IEEE 802.1x/WPA Authenticator and Supplicant (WPA-PSK only).
-endef
-
-define Package/wpa-supplicant
-  SECTION:=net
-  CATEGORY:=Network
-  TITLE:=WPA Supplicant
-  URL:=http://hostap.epitest.fi/wpa_supplicant/
-  DEPENDS:=$(DRV_DEPENDS) +WPA_SUPPLICANT_OPENSSL:libopenssl
-  VARIANT:=supplicant-full
-endef
-
-define Package/wpa-supplicant/Description
-  WPA Supplicant
-endef
-
-define Package/wpa-supplicant/config
-	source "$(SOURCE)/Config.in"
-endef
-
-define Package/wpa-supplicant-p2p
-  $(Package/wpa-supplicant)
-  TITLE:=WPA Supplicant (with Wi-Fi P2P support)
-  DEPENDS:=$(DRV_DEPENDS)
-  VARIANT:=supplicant-p2p
-endef
-
-define Package/wpa-supplicant-p2p/Description
-  WPA Supplicant (with Wi-Fi P2P support)
-endef
-
-define Package/wpa-supplicant-mini
-  $(Package/wpa-supplicant)
-  TITLE:=WPA Supplicant (minimal version)
-  DEPENDS:=$(DRV_DEPENDS)
-  VARIANT:=supplicant-mini
-endef
-
-define Package/wpa-supplicant-mini/Description
-  WPA Supplicant (minimal version)
-endef
-
-define Package/wpa-cli
-  SECTION:=net
-  CATEGORY:=Network
-  DEPENDS:=@PACKAGE_wpa-supplicant||PACKAGE_wpa-supplicant-p2p||PACKAGE_wpad-mini||PACKAGE_wpad
-  TITLE:=WPA Supplicant command line interface
-endef
-
-define Package/wpa-cli/Description
-  WPA Supplicant control utility
-endef
-
-ifneq ($(wildcard $(PKG_BUILD_DIR)/.config_*),$(subst .configured_,.config_,$(STAMP_CONFIGURED)))
-  define Build/Configure/rebuild
-	$(FIND) $(PKG_BUILD_DIR) -name \*.o -or -name \*.a | $(XARGS) rm -f
-	rm -f $(PKG_BUILD_DIR)/hostapd/hostapd
-	rm -f $(PKG_BUILD_DIR)/wpa_supplicant/wpa_supplicant
-	rm -f $(PKG_BUILD_DIR)/.config_*
-	touch $(subst .configured_,.config_,$(STAMP_CONFIGURED))
-  endef
-endif
-
-define Build/Configure
-	$(Build/Configure/rebuild)
-	$(if $(wildcard ./files/hostapd-$(LOCAL_VARIANT).config), \
-		$(CP) ./files/hostapd-$(LOCAL_VARIANT).config $(PKG_BUILD_DIR)/hostapd/.config \
-	)
-	$(CP) ./files/wpa_supplicant-$(LOCAL_VARIANT).config $(PKG_BUILD_DIR)/wpa_supplicant/.config
-endef
-
-TARGET_CPPFLAGS := \
-	-I$(STAGING_DIR)/usr/include/libnl-tiny \
-	-I$(PKG_BUILD_DIR)/src/crypto \
-	$(TARGET_CPPFLAGS) \
-	-I$(CURDIR)/madwifi \
-	-DCONFIG_LIBNL20 \
-	-D_GNU_SOURCE \
-	$(if $(CONFIG_WPA_MSG_MIN_PRIORITY),-DCONFIG_MSG_MIN_PRIORITY=$(CONFIG_WPA_MSG_MIN_PRIORITY))
-
-TARGET_CFLAGS += -ffunction-sections -fdata-sections
-TARGET_LDFLAGS += -Wl,--gc-sections
-ifeq ($(findstring supplicant,$(BUILD_VARIANT)),)
-  TARGET_LDFLAGS += -lubox -lubus
-endif
-
-ifdef CONFIG_PACKAGE_kmod-mac80211
-  TARGET_LDFLAGS += -lm -lnl-tiny
-endif
-
-define Build/RunMake
-	CFLAGS="$(TARGET_CPPFLAGS) $(TARGET_CFLAGS)" \
-	$(MAKE) $(PKG_JOBS) -C $(PKG_BUILD_DIR)/$(1) \
-		$(TARGET_CONFIGURE_OPTS) \
-		$(DRIVER_MAKEOPTS) \
-		LIBS="$(TARGET_LDFLAGS)" \
-		LIBS_c="" \
-		BCHECK= \
-		$(2)
-endef
-
-define Build/Compile/wpad
-	echo ` \
-		$(call Build/RunMake,hostapd,-s MULTICALL=1 dump_cflags); \
-		$(call Build/RunMake,wpa_supplicant,-s MULTICALL=1 dump_cflags) | \
-		sed -e 's,-n ,,g' -e 's,$(TARGET_CFLAGS),,' \
-	` > $(PKG_BUILD_DIR)/.cflags
-	+$(call Build/RunMake,hostapd, \
-		CFLAGS="$$$$(cat $(PKG_BUILD_DIR)/.cflags)" \
-		MULTICALL=1 \
-		hostapd_cli hostapd_multi.a \
-	)
-	+$(call Build/RunMake,wpa_supplicant, \
-		CFLAGS="$$$$(cat $(PKG_BUILD_DIR)/.cflags)" \
-		MULTICALL=1 \
-		wpa_cli wpa_supplicant_multi.a \
-	)
-	$(TARGET_CC) -o $(PKG_BUILD_DIR)/wpad \
-		$(TARGET_CFLAGS) \
-		./files/multicall.c \
-		$(PKG_BUILD_DIR)/hostapd/hostapd_multi.a \
-		$(PKG_BUILD_DIR)/wpa_supplicant/wpa_supplicant_multi.a \
-		$(TARGET_LDFLAGS)
-endef
-
-define Build/Compile/hostapd
-	$(call Build/RunMake,hostapd, \
-		hostapd hostapd_cli \
-	)
-endef
-
-define Build/Compile/supplicant
-	$(call Build/RunMake,wpa_supplicant, \
-		wpa_cli wpa_supplicant \
-	)
-endef
-
-define Build/Compile
-	$(Build/Compile/$(LOCAL_TYPE))
-endef
-
-define Install/hostapd
-	$(INSTALL_DIR) $(1)/lib/wifi
-	$(INSTALL_DATA) ./files/hostapd.sh $(1)/lib/wifi/hostapd.sh
-	$(INSTALL_DIR) $(1)/usr/sbin
-endef
-
-define Install/supplicant
-	$(INSTALL_DIR) $(1)/lib/wifi
-	$(INSTALL_DATA) ./files/wpa_supplicant.sh $(1)/lib/wifi/wpa_supplicant.sh
-	$(INSTALL_DIR) $(1)/usr/sbin
-endef
-
-define Package/hostapd/install
-	$(call Install/hostapd,$(1))
-	$(INSTALL_BIN) $(PKG_BUILD_DIR)/hostapd/hostapd $(1)/usr/sbin/
-endef
-Package/hostapd-mini/install = $(Package/hostapd/install)
-
-ifneq ($(LOCAL_TYPE),supplicant)
-  define Package/hostapd-utils/install
-	$(INSTALL_DIR) $(1)/usr/sbin $(1)/etc/rc.button
-	$(INSTALL_BIN) $(PKG_BUILD_DIR)/hostapd/hostapd_cli $(1)/usr/sbin/
-	$(INSTALL_BIN) ./files/wps-hotplug.sh $(1)/etc/rc.button/wps
-  endef
-endif
-
-define Package/wpad/install
-	$(call Install/hostapd,$(1))
-	$(call Install/supplicant,$(1))
-	$(INSTALL_BIN) $(PKG_BUILD_DIR)/wpad $(1)/usr/sbin/
-	ln -sf wpad $(1)/usr/sbin/hostapd
-	ln -sf wpad $(1)/usr/sbin/wpa_supplicant
-endef
-Package/wpad-mini/install = $(Package/wpad/install)
-
-define Package/wpa-supplicant/install
-	$(call Install/supplicant,$(1))
-	$(INSTALL_BIN) $(PKG_BUILD_DIR)/wpa_supplicant/wpa_supplicant $(1)/usr/sbin/
-endef
-Package/wpa-supplicant-mini/install = $(Package/wpa-supplicant/install)
-Package/wpa-supplicant-p2p/install = $(Package/wpa-supplicant/install)
-
-ifneq ($(LOCAL_TYPE),hostapd)
-  define Package/wpa-cli/install
-	$(INSTALL_DIR) $(1)/usr/sbin
-	$(CP) $(PKG_BUILD_DIR)/wpa_supplicant/wpa_cli $(1)/usr/sbin/
-  endef
-endif
-
-$(eval $(call BuildPackage,hostapd))
-$(eval $(call BuildPackage,hostapd-mini))
-$(eval $(call BuildPackage,wpad))
-$(eval $(call BuildPackage,wpad-mini))
-$(eval $(call BuildPackage,wpa-supplicant))
-$(eval $(call BuildPackage,wpa-supplicant-mini))
-$(eval $(call BuildPackage,wpa-supplicant-p2p))
-$(eval $(call BuildPackage,wpa-cli))
-$(eval $(call BuildPackage,hostapd-utils))
diff --git a/package/hostapd/files/hostapd-full.config b/package/hostapd/files/hostapd-full.config
deleted file mode 100644
index bc999c0..0000000
--- a/package/hostapd/files/hostapd-full.config
+++ /dev/null
@@ -1,169 +0,0 @@
-# Example hostapd build time configuration
-#
-# This file lists the configuration options that are used when building the
-# hostapd binary. All lines starting with # are ignored. Configuration option
-# lines must be commented out complete, if they are not to be included, i.e.,
-# just setting VARIABLE=n is not disabling that variable.
-#
-# This file is included in Makefile, so variables like CFLAGS and LIBS can also
-# be modified from here. In most cass, these lines should use += in order not
-# to override previous values of the variables.
-
-# Driver interface for Host AP driver
-CONFIG_DRIVER_HOSTAP=y
-
-# Driver interface for wired authenticator
-CONFIG_DRIVER_WIRED=y
-
-# Driver interface for madwifi driver
-CONFIG_DRIVER_MADWIFI=y
-#CFLAGS += -I../../madwifi # change to the madwifi source directory
-
-# Driver interface for Prism54 driver
-#CONFIG_DRIVER_PRISM54=y
-
-# Driver interface for drivers using the nl80211 kernel interface
-CONFIG_DRIVER_NL80211=y
-# driver_nl80211.c requires a rather new libnl (version 1.1) which may not be
-# shipped with your distribution yet. If that is the case, you need to build
-# newer libnl version and point the hostapd build to use it.
-#LIBNL=/usr/src/libnl
-#CFLAGS += -I$(LIBNL)/include
-#LIBS += -L$(LIBNL)/lib
-
-# Driver interface for FreeBSD net80211 layer (e.g., Atheros driver)
-#CONFIG_DRIVER_BSD=y
-#CFLAGS += -I/usr/local/include
-#LIBS += -L/usr/local/lib
-
-# Driver interface for no driver (e.g., RADIUS server only)
-#CONFIG_DRIVER_NONE=y
-
-# IEEE 802.11F/IAPP
-CONFIG_IAPP=y
-
-# WPA2/IEEE 802.11i RSN pre-authentication
-CONFIG_RSN_PREAUTH=y
-
-# PeerKey handshake for Station to Station Link (IEEE 802.11e DLS)
-CONFIG_PEERKEY=y
-
-# IEEE 802.11w (management frame protection)
-# This version is an experimental implementation based on IEEE 802.11w/D1.0
-# draft and is subject to change since the standard has not yet been finalized.
-# Driver support is also needed for IEEE 802.11w.
-#CONFIG_IEEE80211W=y
-
-# Integrated EAP server
-CONFIG_EAP=y
-
-# EAP-MD5 for the integrated EAP server
-CONFIG_EAP_MD5=y
-
-# EAP-TLS for the integrated EAP server
-CONFIG_EAP_TLS=y
-
-# EAP-MSCHAPv2 for the integrated EAP server
-CONFIG_EAP_MSCHAPV2=y
-
-# EAP-PEAP for the integrated EAP server
-CONFIG_EAP_PEAP=y
-
-# EAP-GTC for the integrated EAP server
-CONFIG_EAP_GTC=y
-
-# EAP-TTLS for the integrated EAP server
-CONFIG_EAP_TTLS=y
-
-# EAP-SIM for the integrated EAP server
-#CONFIG_EAP_SIM=y
-
-# EAP-AKA for the integrated EAP server
-#CONFIG_EAP_AKA=y
-
-# EAP-AKA' for the integrated EAP server
-# This requires CONFIG_EAP_AKA to be enabled, too.
-#CONFIG_EAP_AKA_PRIME=y
-
-# EAP-PAX for the integrated EAP server
-#CONFIG_EAP_PAX=y
-
-# EAP-PSK for the integrated EAP server (this is _not_ needed for WPA-PSK)
-#CONFIG_EAP_PSK=y
-
-# EAP-SAKE for the integrated EAP server
-#CONFIG_EAP_SAKE=y
-
-# EAP-GPSK for the integrated EAP server
-#CONFIG_EAP_GPSK=y
-# Include support for optional SHA256 cipher suite in EAP-GPSK
-#CONFIG_EAP_GPSK_SHA256=y
-
-# EAP-FAST for the integrated EAP server
-# Note: Default OpenSSL package does not include support for all the
-# functionality needed for EAP-FAST. If EAP-FAST is enabled with OpenSSL,
-# the OpenSSL library must be patched (openssl-0.9.9-session-ticket.patch)
-# to add the needed functions.
-#CONFIG_EAP_FAST=y
-
-# Wi-Fi Protected Setup (WPS)
-CONFIG_WPS=y
-CONFIG_WPS2=y
-# Enable UPnP support for external WPS Registrars
-#CONFIG_WPS_UPNP=y
-
-# EAP-IKEv2
-#CONFIG_EAP_IKEV2=y
-
-# Trusted Network Connect (EAP-TNC)
-#CONFIG_EAP_TNC=y
-
-# PKCS#12 (PFX) support (used to read private key and certificate file from
-# a file that usually has extension .p12 or .pfx)
-CONFIG_PKCS12=y
-
-# RADIUS authentication server. This provides access to the integrated EAP
-# server from external hosts using RADIUS.
-#CONFIG_RADIUS_SERVER=y
-
-# Build IPv6 support for RADIUS operations
-CONFIG_IPV6=y
-
-# IEEE Std 802.11r-2008 (Fast BSS Transition)
-CONFIG_IEEE80211R=y
-
-# Use the hostapd's IEEE 802.11 authentication (ACL), but without
-# the IEEE 802.11 Management capability (e.g., madwifi or FreeBSD/net80211)
-#CONFIG_DRIVER_RADIUS_ACL=y
-
-# IEEE 802.11n (High Throughput) support
-CONFIG_IEEE80211N=y
-
-# Remove debugging code that is printing out debug messages to stdout.
-# This can be used to reduce the size of the hostapd considerably if debugging
-# code is not needed.
-#CONFIG_NO_STDOUT_DEBUG=y
-
-# Remove support for RADIUS accounting
-#CONFIG_NO_ACCOUNTING=y
-
-# Remove support for RADIUS
-#CONFIG_NO_RADIUS=y
-
-# Remove support for VLANs
-#CONFIG_NO_VLAN=y
-
-CONFIG_TLS=internal
-CONFIG_INTERNAL_LIBTOMMATH=y
-CONFIG_INTERNAL_AES=y
-NEED_AES_DEC=y
-
-CONFIG_NO_RANDOM_POOL=y
-CONFIG_NO_DUMP_STATE=y
-
-CONFIG_WPS=y
-CONFIG_FULL_DYNAMIC_VLAN=y
-
-CONFIG_ACS=y
-
-CONFIG_UBUS=y
diff --git a/package/hostapd/files/hostapd-mini.config b/package/hostapd/files/hostapd-mini.config
deleted file mode 100644
index 01a04cb..0000000
--- a/package/hostapd/files/hostapd-mini.config
+++ /dev/null
@@ -1,162 +0,0 @@
-# Example hostapd build time configuration
-#
-# This file lists the configuration options that are used when building the
-# hostapd binary. All lines starting with # are ignored. Configuration option
-# lines must be commented out complete, if they are not to be included, i.e.,
-# just setting VARIABLE=n is not disabling that variable.
-#
-# This file is included in Makefile, so variables like CFLAGS and LIBS can also
-# be modified from here. In most cass, these lines should use += in order not
-# to override previous values of the variables.
-
-# Driver interface for Host AP driver
-CONFIG_DRIVER_HOSTAP=y
-
-# Driver interface for wired authenticator
-CONFIG_DRIVER_WIRED=y
-
-# Driver interface for madwifi driver
-CONFIG_DRIVER_MADWIFI=y
-#CFLAGS += -I../../madwifi # change to the madwifi source directory
-
-# Driver interface for Prism54 driver
-#CONFIG_DRIVER_PRISM54=y
-
-# Driver interface for drivers using the nl80211 kernel interface
-CONFIG_DRIVER_NL80211=y
-# driver_nl80211.c requires a rather new libnl (version 1.1) which may not be
-# shipped with your distribution yet. If that is the case, you need to build
-# newer libnl version and point the hostapd build to use it.
-#LIBNL=/usr/src/libnl
-#CFLAGS += -I$(LIBNL)/include
-#LIBS += -L$(LIBNL)/lib
-
-# Driver interface for FreeBSD net80211 layer (e.g., Atheros driver)
-#CONFIG_DRIVER_BSD=y
-#CFLAGS += -I/usr/local/include
-#LIBS += -L/usr/local/lib
-
-# Driver interface for no driver (e.g., RADIUS server only)
-#CONFIG_DRIVER_NONE=y
-
-# IEEE 802.11F/IAPP
-# CONFIG_IAPP=y
-
-# WPA2/IEEE 802.11i RSN pre-authentication
-CONFIG_RSN_PREAUTH=y
-
-# PeerKey handshake for Station to Station Link (IEEE 802.11e DLS)
-CONFIG_PEERKEY=y
-
-# IEEE 802.11w (management frame protection)
-# This version is an experimental implementation based on IEEE 802.11w/D1.0
-# draft and is subject to change since the standard has not yet been finalized.
-# Driver support is also needed for IEEE 802.11w.
-#CONFIG_IEEE80211W=y
-
-# Integrated EAP server
-#CONFIG_EAP=y
-
-# EAP-MD5 for the integrated EAP server
-#CONFIG_EAP_MD5=y
-
-# EAP-TLS for the integrated EAP server
-#CONFIG_EAP_TLS=y
-
-# EAP-MSCHAPv2 for the integrated EAP server
-#CONFIG_EAP_MSCHAPV2=y
-
-# EAP-PEAP for the integrated EAP server
-#CONFIG_EAP_PEAP=y
-
-# EAP-GTC for the integrated EAP server
-#CONFIG_EAP_GTC=y
-
-# EAP-TTLS for the integrated EAP server
-#CONFIG_EAP_TTLS=y
-
-# EAP-SIM for the integrated EAP server
-#CONFIG_EAP_SIM=y
-
-# EAP-AKA for the integrated EAP server
-#CONFIG_EAP_AKA=y
-
-# EAP-AKA' for the integrated EAP server
-# This requires CONFIG_EAP_AKA to be enabled, too.
-#CONFIG_EAP_AKA_PRIME=y
-
-# EAP-PAX for the integrated EAP server
-#CONFIG_EAP_PAX=y
-
-# EAP-PSK for the integrated EAP server (this is _not_ needed for WPA-PSK)
-#CONFIG_EAP_PSK=y
-
-# EAP-SAKE for the integrated EAP server
-#CONFIG_EAP_SAKE=y
-
-# EAP-GPSK for the integrated EAP server
-#CONFIG_EAP_GPSK=y
-# Include support for optional SHA256 cipher suite in EAP-GPSK
-#CONFIG_EAP_GPSK_SHA256=y
-
-# EAP-FAST for the integrated EAP server
-# Note: Default OpenSSL package does not include support for all the
-# functionality needed for EAP-FAST. If EAP-FAST is enabled with OpenSSL,
-# the OpenSSL library must be patched (openssl-0.9.9-session-ticket.patch)
-# to add the needed functions.
-#CONFIG_EAP_FAST=y
-
-# Wi-Fi Protected Setup (WPS)
-#CONFIG_WPS=y
-# Enable UPnP support for external WPS Registrars
-#CONFIG_WPS_UPNP=y
-
-# EAP-IKEv2
-#CONFIG_EAP_IKEV2=y
-
-# Trusted Network Connect (EAP-TNC)
-#CONFIG_EAP_TNC=y
-
-# PKCS#12 (PFX) support (used to read private key and certificate file from
-# a file that usually has extension .p12 or .pfx)
-#CONFIG_PKCS12=y
-
-# RADIUS authentication server. This provides access to the integrated EAP
-# server from external hosts using RADIUS.
-#CONFIG_RADIUS_SERVER=y
-
-# Build IPv6 support for RADIUS operations
-#CONFIG_IPV6=y
-
-# IEEE Std 802.11r-2008 (Fast BSS Transition)
-#CONFIG_IEEE80211R=y
-
-# Use the hostapd's IEEE 802.11 authentication (ACL), but without
-# the IEEE 802.11 Management capability (e.g., madwifi or FreeBSD/net80211)
-#CONFIG_DRIVER_RADIUS_ACL=y
-
-# IEEE 802.11n (High Throughput) support
-CONFIG_IEEE80211N=y
-
-# Remove debugging code that is printing out debug messages to stdout.
-# This can be used to reduce the size of the hostapd considerably if debugging
-# code is not needed.
-#CONFIG_NO_STDOUT_DEBUG=y
-
-# Remove support for RADIUS accounting
-CONFIG_NO_ACCOUNTING=y
-
-# Remove support for RADIUS
-CONFIG_NO_RADIUS=y
-
-# Remove support for VLANs
-#CONFIG_NO_VLAN=y
-
-CONFIG_TLS=internal
-
-CONFIG_NO_RANDOM_POOL=y
-CONFIG_NO_DUMP_STATE=y
-
-CONFIG_ACS=y
-
-CONFIG_UBUS=y
diff --git a/package/hostapd/files/hostapd.sh b/package/hostapd/files/hostapd.sh
deleted file mode 100644
index b55b63d..0000000
--- a/package/hostapd/files/hostapd.sh
+++ /dev/null
@@ -1,357 +0,0 @@
-hostapd_set_bss_options() {
-	local var="$1"
-	local vif="$2"
-	local enc wep_rekey wpa_group_rekey wpa_pair_rekey wpa_master_rekey wps_possible
-
-	config_get enc "$vif" encryption "none"
-	config_get wep_rekey        "$vif" wep_rekey        # 300
-	config_get wpa_group_rekey  "$vif" wpa_group_rekey  # 300
-	config_get wpa_pair_rekey   "$vif" wpa_pair_rekey   # 300
-	config_get wpa_master_rekey "$vif" wpa_master_rekey # 640
-	config_get_bool ap_isolate "$vif" isolate 0
-	config_get_bool disassoc_low_ack "$vif" disassoc_low_ack 1
-	config_get max_num_sta "$vif" max_num_sta 0
-	config_get max_inactivity "$vif" max_inactivity 0
-	config_get_bool preamble "$vif" short_preamble 1
-
-	config_get device "$vif" device
-	config_get hwmode "$device" hwmode
-	config_get phy "$device" phy
-
-	append "$var" "ctrl_interface=/var/run/hostapd-$phy" "$N"
-
-	if [ "$ap_isolate" -gt 0 ]; then
-		append "$var" "ap_isolate=$ap_isolate" "$N"
-	fi
-	if [ "$max_num_sta" -gt 0 ]; then
-		append "$var" "max_num_sta=$max_num_sta" "$N"
-	fi
-	if [ "$max_inactivity" -gt 0 ]; then
-		append "$var" "ap_max_inactivity=$max_inactivity" "$N"
-	fi
-	append "$var" "disassoc_low_ack=$disassoc_low_ack" "$N"
-	if [ "$preamble" -gt 0 ]; then
-		append "$var" "preamble=$preamble" "$N"
-	fi
-
-	# Examples:
-	# psk-mixed/tkip 	=> WPA1+2 PSK, TKIP
-	# wpa-psk2/tkip+aes	=> WPA2 PSK, CCMP+TKIP
-	# wpa2/tkip+aes 	=> WPA2 RADIUS, CCMP+TKIP
-	# ...
-
-	# TODO: move this parsing function somewhere generic, so that
-	# later it can be reused by drivers that don't use hostapd
-
-	# crypto defaults: WPA2 vs WPA1
-	case "$enc" in
-		wpa2*|*psk2*)
-			wpa=2
-			crypto="CCMP"
-		;;
-		*mixed*)
-			wpa=3
-			crypto="CCMP TKIP"
-		;;
-		*)
-			wpa=1
-			crypto="TKIP"
-		;;
-	esac
-
-	# explicit override for crypto setting
-	case "$enc" in
-		*tkip+aes|*tkip+ccmp|*aes+tkip|*ccmp+tkip) crypto="CCMP TKIP";;
-		*aes|*ccmp) crypto="CCMP";;
-		*tkip) crypto="TKIP";;
-	esac
-
-	# enforce CCMP for 11ng and 11na
-	case "$hwmode:$crypto" in
-		*ng:TKIP|*na:TKIP) crypto="CCMP TKIP";;
-	esac
-
-	# use crypto/auth settings for building the hostapd config
-	case "$enc" in
-		none)
-			wps_possible=1
-			wpa=0
-			crypto=
-			# Here we make the assumption that if we're in open mode
-			# with WPS enabled, we got to be in unconfigured state.
-			wps_not_configured=1
-		;;
-		*psk*)
-			config_get psk "$vif" key
-			if [ ${#psk} -eq 64 ]; then
-				append "$var" "wpa_psk=$psk" "$N"
-			else
-				append "$var" "wpa_passphrase=$psk" "$N"
-			fi
-			wps_possible=1
-			[ -n "$wpa_group_rekey"  ] && append "$var" "wpa_group_rekey=$wpa_group_rekey" "$N"
-			[ -n "$wpa_pair_rekey"   ] && append "$var" "wpa_ptk_rekey=$wpa_pair_rekey"    "$N"
-			[ -n "$wpa_master_rekey" ] && append "$var" "wpa_gmk_rekey=$wpa_master_rekey"  "$N"
-		;;
-		*wpa*|*8021x*)
-			# required fields? formats?
-			# hostapd is particular, maybe a default configuration for failures
-			config_get auth_server "$vif" auth_server
-			[ -z "$auth_server" ] && config_get auth_server "$vif" server
-			append "$var" "auth_server_addr=$auth_server" "$N"
-			config_get auth_port "$vif" auth_port
-			[ -z "$auth_port" ] && config_get auth_port "$vif" port
-			auth_port=${auth_port:-1812}
-			append "$var" "auth_server_port=$auth_port" "$N"
-			config_get auth_secret "$vif" auth_secret
-			[ -z "$auth_secret" ] && config_get auth_secret "$vif" key
-			append "$var" "auth_server_shared_secret=$auth_secret" "$N"
-			# You don't really want to enable this unless you are doing
-			# some corner case testing or are using OpenWrt as a work around
-			# for some systematic issues.
-			config_get_bool auth_cache "$vif" auth_cache 0
-			config_get rsn_preauth "$vif" rsn_preauth
-			[ "$auth_cache" -gt 0 ] || [[ "$rsn_preauth" = 1 ]] || append "$var" "disable_pmksa_caching=1" "$N"
-			[ "$auth_cache" -gt 0 ] || [[ "$rsn_preauth" = 1 ]] || append "$var" "okc=0" "$N"
-			config_get acct_server "$vif" acct_server
-			[ -n "$acct_server" ] && append "$var" "acct_server_addr=$acct_server" "$N"
-			config_get acct_port "$vif" acct_port
-			[ -n "$acct_port" ] && acct_port=${acct_port:-1813}
-			[ -n "$acct_port" ] && append "$var" "acct_server_port=$acct_port" "$N"
-			config_get acct_secret "$vif" acct_secret
-			[ -n "$acct_secret" ] && append "$var" "acct_server_shared_secret=$acct_secret" "$N"
-			config_get eap_reauth_period "$vif" eap_reauth_period
-			[ -n "$eap_reauth_period" ] && append "$var" "eap_reauth_period=$eap_reauth_period" "$N"
-			config_get dae_client "$vif" dae_client
-			config_get dae_secret "$vif" dae_secret
-			[ -n "$dae_client" -a -n "$dae_secret" ] && {
-				config_get dae_port  "$vif" dae_port
-				append "$var" "radius_das_port=${dae_port:-3799}" "$N"
-				append "$var" "radius_das_client=$dae_client $dae_secret" "$N"
-			}
-			config_get nasid "$vif" nasid
-			append "$var" "nas_identifier=$nasid" "$N"
-			append "$var" "eapol_key_index_workaround=1" "$N"
-			append "$var" "ieee8021x=1" "$N"
-			append "$var" "wpa_key_mgmt=WPA-EAP" "$N"
-			[ -n "$wpa_group_rekey"  ] && append "$var" "wpa_group_rekey=$wpa_group_rekey" "$N"
-			[ -n "$wpa_pair_rekey"   ] && append "$var" "wpa_ptk_rekey=$wpa_pair_rekey"    "$N"
-			[ -n "$wpa_master_rekey" ] && append "$var" "wpa_gmk_rekey=$wpa_master_rekey"  "$N"
-		;;
-		*wep*)
-			config_get key "$vif" key
-			key="${key:-1}"
-			case "$key" in
-				[1234])
-					for idx in 1 2 3 4; do
-						local zidx
-						zidx=$(($idx - 1))
-						config_get ckey "$vif" "key${idx}"
-						[ -n "$ckey" ] && \
-							append "$var" "wep_key${zidx}=$(prepare_key_wep "$ckey")" "$N"
-					done
-					append "$var" "wep_default_key=$((key - 1))"  "$N"
-				;;
-				*)
-					append "$var" "wep_key0=$(prepare_key_wep "$key")" "$N"
-					append "$var" "wep_default_key=0" "$N"
-					[ -n "$wep_rekey" ] && append "$var" "wep_rekey_period=$wep_rekey" "$N"
-				;;
-			esac
-			case "$enc" in
-				*shared*)
-					auth_algs=2
-				;;
-				*mixed*)
-					auth_algs=3
-				;;
-			esac
-			wpa=0
-			crypto=
-		;;
-		*)
-			wpa=0
-			crypto=
-		;;
-	esac
-	append "$var" "auth_algs=${auth_algs:-1}" "$N"
-	append "$var" "wpa=$wpa" "$N"
-	[ -n "$crypto" ] && append "$var" "wpa_pairwise=$crypto" "$N"
-	[ -n "$wpa_group_rekey" ] && append "$var" "wpa_group_rekey=$wpa_group_rekey" "$N"
-
-	config_get ssid "$vif" ssid
-	config_get bridge "$vif" bridge
-	config_get ieee80211d "$vif" ieee80211d
-	config_get iapp_interface "$vif" iapp_interface
-
-	config_get_bool wps_pbc "$vif" wps_pushbutton 0
-	config_get_bool wps_label "$vif" wps_label 0
-
-	config_get config_methods "$vif" wps_config
-	[ "$wps_pbc" -gt 0 ] && append config_methods push_button
-
-	[ -n "$wps_possible" -a -n "$config_methods" ] && {
-		config_get device_type "$vif" wps_device_type "6-0050F204-1"
-		config_get device_name "$vif" wps_device_name "OpenWrt AP"
-		config_get manufacturer "$vif" wps_manufacturer "openwrt.org"
-		config_get wps_pin "$vif" wps_pin "12345670"
-
-		config_get_bool ext_registrar "$vif" ext_registrar 0
-		[ "$ext_registrar" -gt 0 -a -n "$bridge" ] && append "$var" "upnp_iface=$bridge" "$N"
-
-		append "$var" "eap_server=1" "$N"
-		append "$var" "ap_pin=$wps_pin" "$N"
-		append "$var" "wps_state=${wps_not_configured:-2}" "$N"
-		append "$var" "ap_setup_locked=0" "$N"
-		append "$var" "device_type=$device_type" "$N"
-		append "$var" "device_name=$device_name" "$N"
-		append "$var" "manufacturer=$manufacturer" "$N"
-		append "$var" "config_methods=$config_methods" "$N"
-	}
-
-	append "$var" "ssid=$ssid" "$N"
-	[ -n "$bridge" ] && append "$var" "bridge=$bridge" "$N"
-	[ -n "$ieee80211d" ] && append "$var" "ieee80211d=$ieee80211d" "$N"
-	[ -n "$iapp_interface" ] && append "$var" iapp_interface=$(uci_get_state network "$iapp_interface" ifname "$iapp_interface") "$N"
-
-	if [ "$wpa" -ge "2" ]
-	then
-		# RSN -> allow preauthentication. You have two
-		# options, rsn_preauth for production or rsn_preauth_testing
-		# for validation / testing.
-		if [ -n "$bridge" -a "$rsn_preauth" = 1 ]
-		then
-			append "$var" "rsn_preauth=1" "$N"
-			append "$var" "rsn_preauth_interfaces=$bridge" "$N"
-			append "$var" "okc=1" "$N"
-		else
-			# RSN preauthentication testings hould disable
-			# Opportunistic Key Caching (okc) as otherwise the PMKSA
-			# entry for a test could come from the Opportunistic Key Caching
-			config_get rsn_preauth_testing "$vif" rsn_preauth_testing
-			if [ -n "$bridge" -a "$rsn_preauth_testing" = 1 ]
-			then
-				append "$var" "rsn_preauth=1" "$N"
-				append "$var" "rsn_preauth_interfaces=$bridge" "$N"
-				append "$var" "okc=0" "$N"
-			fi
-		fi
-
-		# RSN -> allow management frame protection
-		config_get ieee80211w "$vif" ieee80211w
-		case "$ieee80211w" in
-			[012])
-				append "$var" "ieee80211w=$ieee80211w" "$N"
-				[ "$ieee80211w" -gt "0" ] && {
-					config_get ieee80211w_max_timeout "$vif" ieee80211w_max_timeout
-					config_get ieee80211w_retry_timeout "$vif" ieee80211w_retry_timeout
-					[ -n "$ieee80211w_max_timeout" ] && \
-						append "$var" "assoc_sa_query_max_timeout=$ieee80211w_max_timeout" "$N"
-					[ -n "$ieee80211w_retry_timeout" ] && \
-						append "$var" "assoc_sa_query_retry_timeout=$ieee80211w_retry_timeout" "$N"
-				}
-			;;
-		esac
-	fi
-
-	config_get macfile "$vif" macfile
-	config_get maclist "$vif" maclist
-	if [ -z "$macfile" ]
-	then
-		# if no macfile has been specified, fallback to the default name
-		# and truncate file to avoid aggregating entries over time
-		macfile="/var/run/hostapd-$ifname.maclist"
-		echo "" > "$macfile"
-	else
-		if [ -n "$maclist" ]
-		then
-			# to avoid to overwrite the original file, make a copy
-			# before appending the entries specified by the maclist
-			# option
-			cp $macfile $macfile.maclist
-			macfile=$macfile.maclist
-		fi
-	fi
-
-	if [ -n "$maclist" ]
-	then
-		for mac in $maclist; do
-			echo "$mac" >> $macfile
-		done
-	fi
-
-	config_get macfilter "$vif" macfilter
-	case "$macfilter" in
-		allow)
-			append "$var" "macaddr_acl=1" "$N"
-			append "$var" "accept_mac_file=$macfile" "$N"
-			;;
-		deny)
-			append "$var" "macaddr_acl=0" "$N"
-			append "$var" "deny_mac_file=$macfile" "$N"
-			;;
-	esac
-}
-
-hostapd_set_log_options() {
-	local var="$1"
-	local cfg="$2"
-	local log_level log_80211 log_8021x log_radius log_wpa log_driver log_iapp log_mlme
-
-	config_get log_level "$cfg" log_level 2
-
-	config_get_bool log_80211  "$cfg" log_80211  1
-	config_get_bool log_8021x  "$cfg" log_8021x  1
-	config_get_bool log_radius "$cfg" log_radius 1
-	config_get_bool log_wpa    "$cfg" log_wpa    1
-	config_get_bool log_driver "$cfg" log_driver 1
-	config_get_bool log_iapp   "$cfg" log_iapp   1
-	config_get_bool log_mlme   "$cfg" log_mlme   1
-
-	local log_mask=$((       \
-		($log_80211  << 0) | \
-		($log_8021x  << 1) | \
-		($log_radius << 2) | \
-		($log_wpa    << 3) | \
-		($log_driver << 4) | \
-		($log_iapp   << 5) | \
-		($log_mlme   << 6)   \
-	))
-
-	append "$var" "logger_syslog=$log_mask" "$N"
-	append "$var" "logger_syslog_level=$log_level" "$N"
-	append "$var" "logger_stdout=$log_mask" "$N"
-	append "$var" "logger_stdout_level=$log_level" "$N"
-}
-
-hostapd_setup_vif() {
-	local vif="$1"
-	local driver="$2"
-	local ifname device channel hwmode
-
-	hostapd_cfg=
-
-	config_get ifname "$vif" ifname
-	config_get device "$vif" device
-	config_get channel "$device" channel
-	config_get hwmode "$device" hwmode
-
-	hostapd_set_log_options hostapd_cfg "$device"
-	hostapd_set_bss_options hostapd_cfg "$vif"
-
-	case "$hwmode" in
-		*bg|*gdt|*gst|*fh) hwmode=g;;
-		*adt|*ast) hwmode=a;;
-	esac
-	[ "$channel" = auto ] && channel=
-	[ -n "$channel" -a -z "$hwmode" ] && wifi_fixup_hwmode "$device"
-	cat > /var/run/hostapd-$ifname.conf <<EOF
-driver=$driver
-interface=$ifname
-${hwmode:+hw_mode=${hwmode#11}}
-${channel:+channel=$channel}
-$hostapd_cfg
-EOF
-	hostapd -P /var/run/wifi-$ifname.pid -B /var/run/hostapd-$ifname.conf
-}
-
diff --git a/package/hostapd/files/multicall.c b/package/hostapd/files/multicall.c
deleted file mode 100644
index c8e814b..0000000
--- a/package/hostapd/files/multicall.c
+++ /dev/null
@@ -1,28 +0,0 @@
-#include <stdio.h>
-#include <string.h>
-#include <stdbool.h>
-
-extern int hostapd_main(int argc, char **argv);
-extern int wpa_supplicant_main(int argc, char **argv);
-
-int main(int argc, char **argv)
-{
-	bool restart = false;
-	const char *prog = argv[0];
-
-restart:
-	if (strstr(argv[0], "hostapd"))
-		return hostapd_main(argc, argv);
-	else if (strstr(argv[0], "wpa_supplicant"))
-		return wpa_supplicant_main(argc, argv);
-
-	if (!restart && argc > 1) {
-		argv++;
-		argc--;
-		restart = true;
-		goto restart;
-	}
-
-	fprintf(stderr, "Invalid command.\nUsage: %s wpa_supplicant|hostapd [<arguments>]\n", prog);
-	return 255;
-}
diff --git a/package/hostapd/files/wpa_supplicant-full.config b/package/hostapd/files/wpa_supplicant-full.config
deleted file mode 100644
index bbfaa73..0000000
--- a/package/hostapd/files/wpa_supplicant-full.config
+++ /dev/null
@@ -1,409 +0,0 @@
-# Example wpa_supplicant build time configuration
-#
-# This file lists the configuration options that are used when building the
-# hostapd binary. All lines starting with # are ignored. Configuration option
-# lines must be commented out complete, if they are not to be included, i.e.,
-# just setting VARIABLE=n is not disabling that variable.
-#
-# This file is included in Makefile, so variables like CFLAGS and LIBS can also
-# be modified from here. In most cases, these lines should use += in order not
-# to override previous values of the variables.
-
-
-# Uncomment following two lines and fix the paths if you have installed OpenSSL
-# or GnuTLS in non-default location
-#CFLAGS += -I/usr/local/openssl/include
-#LIBS += -L/usr/local/openssl/lib
-
-# Some Red Hat versions seem to include kerberos header files from OpenSSL, but
-# the kerberos files are not in the default include path. Following line can be
-# used to fix build issues on such systems (krb5.h not found).
-#CFLAGS += -I/usr/include/kerberos
-
-# Example configuration for various cross-compilation platforms
-
-#### sveasoft (e.g., for Linksys WRT54G) ######################################
-#CC=mipsel-uclibc-gcc
-#CC=/opt/brcm/hndtools-mipsel-uclibc/bin/mipsel-uclibc-gcc
-#CFLAGS += -Os
-#CPPFLAGS += -I../src/include -I../../src/router/openssl/include
-#LIBS += -L/opt/brcm/hndtools-mipsel-uclibc-0.9.19/lib -lssl
-###############################################################################
-
-#### openwrt (e.g., for Linksys WRT54G) #######################################
-#CC=mipsel-uclibc-gcc
-#CC=/opt/brcm/hndtools-mipsel-uclibc/bin/mipsel-uclibc-gcc
-#CFLAGS += -Os
-#CPPFLAGS=-I../src/include -I../openssl-0.9.7d/include \
-#	-I../WRT54GS/release/src/include
-#LIBS = -lssl
-###############################################################################
-
-
-# Driver interface for Host AP driver
-CONFIG_DRIVER_HOSTAP=y
-
-# Driver interface for Agere driver
-#CONFIG_DRIVER_HERMES=y
-# Change include directories to match with the local setup
-#CFLAGS += -I../../hcf -I../../include -I../../include/hcf
-#CFLAGS += -I../../include/wireless
-
-# Driver interface for madwifi driver
-# Deprecated; use CONFIG_DRIVER_WEXT=y instead.
-#CONFIG_DRIVER_MADWIFI=y
-# Set include directory to the madwifi source tree
-#CFLAGS += -I../../madwifi
-
-# Driver interface for ndiswrapper
-# Deprecated; use CONFIG_DRIVER_WEXT=y instead.
-#CONFIG_DRIVER_NDISWRAPPER=y
-
-# Driver interface for Atmel driver
-# CONFIG_DRIVER_ATMEL=y
-
-# Driver interface for old Broadcom driver
-# Please note that the newer Broadcom driver ("hybrid Linux driver") supports
-# Linux wireless extensions and does not need (or even work) with the old
-# driver wrapper. Use CONFIG_DRIVER_WEXT=y with that driver.
-#CONFIG_DRIVER_BROADCOM=y
-# Example path for wlioctl.h; change to match your configuration
-#CFLAGS += -I/opt/WRT54GS/release/src/include
-
-# Driver interface for Intel ipw2100/2200 driver
-# Deprecated; use CONFIG_DRIVER_WEXT=y instead.
-#CONFIG_DRIVER_IPW=y
-
-# Driver interface for Ralink driver
-#CONFIG_DRIVER_RALINK=y
-
-# Driver interface for generic Linux wireless extensions
-CONFIG_DRIVER_WEXT=y
-
-# Driver interface for Linux drivers using the nl80211 kernel interface
-CONFIG_DRIVER_NL80211=y
-
-# Driver interface for FreeBSD net80211 layer (e.g., Atheros driver)
-#CONFIG_DRIVER_BSD=y
-#CFLAGS += -I/usr/local/include
-#LIBS += -L/usr/local/lib
-#LIBS_p += -L/usr/local/lib
-#LIBS_c += -L/usr/local/lib
-
-# Driver interface for Windows NDIS
-#CONFIG_DRIVER_NDIS=y
-#CFLAGS += -I/usr/include/w32api/ddk
-#LIBS += -L/usr/local/lib
-# For native build using mingw
-#CONFIG_NATIVE_WINDOWS=y
-# Additional directories for cross-compilation on Linux host for mingw target
-#CFLAGS += -I/opt/mingw/mingw32/include/ddk
-#LIBS += -L/opt/mingw/mingw32/lib
-#CC=mingw32-gcc
-# By default, driver_ndis uses WinPcap for low-level operations. This can be
-# replaced with the following option which replaces WinPcap calls with NDISUIO.
-# However, this requires that WZC is disabled (net stop wzcsvc) before starting
-# wpa_supplicant.
-# CONFIG_USE_NDISUIO=y
-
-# Driver interface for development testing
-#CONFIG_DRIVER_TEST=y
-
-# Include client MLME (management frame processing) for test driver
-# This can be used to test MLME operations in hostapd with the test interface.
-# space.
-#CONFIG_CLIENT_MLME=y
-
-# Driver interface for wired Ethernet drivers
-CONFIG_DRIVER_WIRED=y
-
-# Driver interface for the Broadcom RoboSwitch family
-#CONFIG_DRIVER_ROBOSWITCH=y
-
-# Driver interface for no driver (e.g., WPS ER only)
-#CONFIG_DRIVER_NONE=y
-
-# Enable IEEE 802.1X Supplicant (automatically included if any EAP method is
-# included)
-CONFIG_IEEE8021X_EAPOL=y
-
-# EAP-MD5
-CONFIG_EAP_MD5=y
-
-# EAP-MSCHAPv2
-CONFIG_EAP_MSCHAPV2=y
-
-# EAP-TLS
-CONFIG_EAP_TLS=y
-
-# EAL-PEAP
-CONFIG_EAP_PEAP=y
-
-# EAP-TTLS
-CONFIG_EAP_TTLS=y
-
-# EAP-FAST
-# Note: Default OpenSSL package does not include support for all the
-# functionality needed for EAP-FAST. If EAP-FAST is enabled with OpenSSL,
-# the OpenSSL library must be patched (openssl-0.9.8d-tls-extensions.patch)
-# to add the needed functions.
-#CONFIG_EAP_FAST=y
-
-# EAP-GTC
-CONFIG_EAP_GTC=y
-
-# EAP-OTP
-CONFIG_EAP_OTP=y
-
-# EAP-SIM (enable CONFIG_PCSC, if EAP-SIM is used)
-#CONFIG_EAP_SIM=y
-
-# EAP-PSK (experimental; this is _not_ needed for WPA-PSK)
-#CONFIG_EAP_PSK=y
-
-# EAP-PAX
-#CONFIG_EAP_PAX=y
-
-# LEAP
-CONFIG_EAP_LEAP=y
-
-# EAP-AKA (enable CONFIG_PCSC, if EAP-AKA is used)
-#CONFIG_EAP_AKA=y
-
-# EAP-AKA' (enable CONFIG_PCSC, if EAP-AKA' is used).
-# This requires CONFIG_EAP_AKA to be enabled, too.
-#CONFIG_EAP_AKA_PRIME=y
-
-# Enable USIM simulator (Milenage) for EAP-AKA
-#CONFIG_USIM_SIMULATOR=y
-
-# EAP-SAKE
-#CONFIG_EAP_SAKE=y
-
-# EAP-GPSK
-#CONFIG_EAP_GPSK=y
-# Include support for optional SHA256 cipher suite in EAP-GPSK
-#CONFIG_EAP_GPSK_SHA256=y
-
-# EAP-TNC and related Trusted Network Connect support (experimental)
-#CONFIG_EAP_TNC=y
-
-# Wi-Fi Protected Setup (WPS)
-CONFIG_WPS=y
-
-# EAP-IKEv2
-#CONFIG_EAP_IKEV2=y
-
-# PKCS#12 (PFX) support (used to read private key and certificate file from
-# a file that usually has extension .p12 or .pfx)
-CONFIG_PKCS12=y
-
-# Smartcard support (i.e., private key on a smartcard), e.g., with openssl
-# engine.
-CONFIG_SMARTCARD=y
-
-# PC/SC interface for smartcards (USIM, GSM SIM)
-# Enable this if EAP-SIM or EAP-AKA is included
-#CONFIG_PCSC=y
-
-# Development testing
-#CONFIG_EAPOL_TEST=y
-
-# Select control interface backend for external programs, e.g, wpa_cli:
-# unix = UNIX domain sockets (default for Linux/*BSD)
-# udp = UDP sockets using localhost (127.0.0.1)
-# named_pipe = Windows Named Pipe (default for Windows)
-# y = use default (backwards compatibility)
-# If this option is commented out, control interface is not included in the
-# build.
-CONFIG_CTRL_IFACE=y
-
-# Include support for GNU Readline and History Libraries in wpa_cli.
-# When building a wpa_cli binary for distribution, please note that these
-# libraries are licensed under GPL and as such, BSD license may not apply for
-# the resulting binary.
-#CONFIG_READLINE=y
-
-# Remove debugging code that is printing out debug message to stdout.
-# This can be used to reduce the size of the wpa_supplicant considerably
-# if debugging code is not needed. The size reduction can be around 35%
-# (e.g., 90 kB).
-#CONFIG_NO_STDOUT_DEBUG=y
-
-# Remove WPA support, e.g., for wired-only IEEE 802.1X supplicant, to save
-# 35-50 kB in code size.
-#CONFIG_NO_WPA=y
-
-# Remove WPA2 support. This allows WPA to be used, but removes WPA2 code to
-# save about 1 kB in code size when building only WPA-Personal (no EAP support)
-# or 6 kB if building for WPA-Enterprise.
-#CONFIG_NO_WPA2=y
-
-# Remove IEEE 802.11i/WPA-Personal ASCII passphrase support
-# This option can be used to reduce code size by removing support for
-# converting ASCII passphrases into PSK. If this functionality is removed, the
-# PSK can only be configured as the 64-octet hexstring (e.g., from
-# wpa_passphrase). This saves about 0.5 kB in code size.
-#CONFIG_NO_WPA_PASSPHRASE=y
-
-# Disable scan result processing (ap_mode=1) to save code size by about 1 kB.
-# This can be used if ap_scan=1 mode is never enabled.
-#CONFIG_NO_SCAN_PROCESSING=y
-
-# Select configuration backend:
-# file = text file (e.g., wpa_supplicant.conf; note: the configuration file
-#	path is given on command line, not here; this option is just used to
-#	select the backend that allows configuration files to be used)
-# winreg = Windows registry (see win_example.reg for an example)
-CONFIG_BACKEND=file
-
-# Remove configuration write functionality (i.e., to allow the configuration
-# file to be updated based on runtime configuration changes). The runtime
-# configuration can still be changed, the changes are just not going to be
-# persistent over restarts. This option can be used to reduce code size by
-# about 3.5 kB.
-#CONFIG_NO_CONFIG_WRITE=y
-
-# Remove support for configuration blobs to reduce code size by about 1.5 kB.
-#CONFIG_NO_CONFIG_BLOBS=y
-
-# Select program entry point implementation:
-# main = UNIX/POSIX like main() function (default)
-# main_winsvc = Windows service (read parameters from registry)
-# main_none = Very basic example (development use only)
-#CONFIG_MAIN=main
-
-# Select wrapper for operatins system and C library specific functions
-# unix = UNIX/POSIX like systems (default)
-# win32 = Windows systems
-# none = Empty template
-#CONFIG_OS=unix
-
-# Select event loop implementation
-# eloop = select() loop (default)
-# eloop_win = Windows events and WaitForMultipleObject() loop
-# eloop_none = Empty template
-#CONFIG_ELOOP=eloop
-
-# Select layer 2 packet implementation
-# linux = Linux packet socket (default)
-# pcap = libpcap/libdnet/WinPcap
-# freebsd = FreeBSD libpcap
-# winpcap = WinPcap with receive thread
-# ndis = Windows NDISUIO (note: requires CONFIG_USE_NDISUIO=y)
-# none = Empty template
-#CONFIG_L2_PACKET=linux
-
-# PeerKey handshake for Station to Station Link (IEEE 802.11e DLS)
-CONFIG_PEERKEY=y
-
-# IEEE 802.11w (management frame protection)
-# This version is an experimental implementation based on IEEE 802.11w/D1.0
-# draft and is subject to change since the standard has not yet been finalized.
-# Driver support is also needed for IEEE 802.11w.
-CONFIG_IEEE80211W=y
-
-# Select TLS implementation
-# openssl = OpenSSL (default)
-# gnutls = GnuTLS (needed for TLS/IA, see also CONFIG_GNUTLS_EXTRA)
-# internal = Internal TLSv1 implementation (experimental)
-# none = Empty template
-CONFIG_TLS=internal
-
-# Whether to enable TLS/IA support, which is required for EAP-TTLSv1.
-# You need CONFIG_TLS=gnutls for this to have any effect. Please note that
-# even though the core GnuTLS library is released under LGPL, this extra
-# library uses GPL and as such, the terms of GPL apply to the combination
-# of wpa_supplicant and GnuTLS if this option is enabled. BSD license may not
-# apply for distribution of the resulting binary.
-#CONFIG_GNUTLS_EXTRA=y
-
-# If CONFIG_TLS=internal is used, additional library and include paths are
-# needed for LibTomMath. Alternatively, an integrated, minimal version of
-# LibTomMath can be used. See beginning of libtommath.c for details on benefits
-# and drawbacks of this option.
-CONFIG_INTERNAL_LIBTOMMATH=y
-#ifndef CONFIG_INTERNAL_LIBTOMMATH
-#LTM_PATH=/usr/src/libtommath-0.39
-#CFLAGS += -I$(LTM_PATH)
-#LIBS += -L$(LTM_PATH)
-#LIBS_p += -L$(LTM_PATH)
-#endif
-# At the cost of about 4 kB of additional binary size, the internal LibTomMath
-# can be configured to include faster routines for exptmod, sqr, and div to
-# speed up DH and RSA calculation considerably
-CONFIG_INTERNAL_LIBTOMMATH_FAST=y
-
-# Include NDIS event processing through WMI into wpa_supplicant/wpasvc.
-# This is only for Windows builds and requires WMI-related header files and
-# WbemUuid.Lib from Platform SDK even when building with MinGW.
-#CONFIG_NDIS_EVENTS_INTEGRATED=y
-#PLATFORMSDKLIB="/opt/Program Files/Microsoft Platform SDK/Lib"
-
-# Add support for old DBus control interface
-# (fi.epitest.hostap.WPASupplicant)
-#CONFIG_CTRL_IFACE_DBUS=y
-
-# Add support for new DBus control interface
-# (fi.w1.hostap.wpa_supplicant1)
-#CONFIG_CTRL_IFACE_DBUS_NEW=y
-
-# Add introspection support for new DBus control interface
-#CONFIG_CTRL_IFACE_DBUS_INTRO=y
-
-# Add support for loading EAP methods dynamically as shared libraries.
-# When this option is enabled, each EAP method can be either included
-# statically (CONFIG_EAP_<method>=y) or dynamically (CONFIG_EAP_<method>=dyn).
-# Dynamic EAP methods are build as shared objects (eap_*.so) and they need to
-# be loaded in the beginning of the wpa_supplicant configuration file
-# (see load_dynamic_eap parameter in the example file) before being used in
-# the network blocks.
-#
-# Note that some shared parts of EAP methods are included in the main program
-# and in order to be able to use dynamic EAP methods using these parts, the
-# main program must have been build with the EAP method enabled (=y or =dyn).
-# This means that EAP-TLS/PEAP/TTLS/FAST cannot be added as dynamic libraries
-# unless at least one of them was included in the main build to force inclusion
-# of the shared code. Similarly, at least one of EAP-SIM/AKA must be included
-# in the main build to be able to load these methods dynamically.
-#
-# Please also note that using dynamic libraries will increase the total binary
-# size. Thus, it may not be the best option for targets that have limited
-# amount of memory/flash.
-#CONFIG_DYNAMIC_EAP_METHODS=y
-
-# IEEE Std 802.11r-2008 (Fast BSS Transition)
-#CONFIG_IEEE80211R=y
-
-# Add support for writing debug log to a file (/tmp/wpa_supplicant-log-#.txt)
-#CONFIG_DEBUG_FILE=y
-
-# Enable privilege separation (see README 'Privilege separation' for details)
-#CONFIG_PRIVSEP=y
-
-# Enable mitigation against certain attacks against TKIP by delaying Michael
-# MIC error reports by a random amount of time between 0 and 60 seconds
-#CONFIG_DELAYED_MIC_ERROR_REPORT=y
-
-# Enable tracing code for developer debugging
-# This tracks use of memory allocations and other registrations and reports
-# incorrect use with a backtrace of call (or allocation) location.
-#CONFIG_WPA_TRACE=y
-# For BSD, comment out these.
-#LIBS += -lexecinfo
-#LIBS_p += -lexecinfo
-#LIBS_c += -lexecinfo
-
-# Use libbfd to get more details for developer debugging
-# This enables use of libbfd to get more detailed symbols for the backtraces
-# generated by CONFIG_WPA_TRACE=y.
-#CONFIG_WPA_TRACE_BFD=y
-# For BSD, comment out these.
-#LIBS += -lbfd -liberty -lz
-#LIBS_p += -lbfd -liberty -lz
-#LIBS_c += -lbfd -liberty -lz
-
-CONFIG_NO_RANDOM_POOL=y
-NEED_80211_COMMON=y
-
-CONFIG_IBSS_RSN=y
diff --git a/package/hostapd/files/wpa_supplicant-mini.config b/package/hostapd/files/wpa_supplicant-mini.config
deleted file mode 100644
index a33e6f0..0000000
--- a/package/hostapd/files/wpa_supplicant-mini.config
+++ /dev/null
@@ -1,407 +0,0 @@
-# Example wpa_supplicant build time configuration
-#
-# This file lists the configuration options that are used when building the
-# hostapd binary. All lines starting with # are ignored. Configuration option
-# lines must be commented out complete, if they are not to be included, i.e.,
-# just setting VARIABLE=n is not disabling that variable.
-#
-# This file is included in Makefile, so variables like CFLAGS and LIBS can also
-# be modified from here. In most cases, these lines should use += in order not
-# to override previous values of the variables.
-
-
-# Uncomment following two lines and fix the paths if you have installed OpenSSL
-# or GnuTLS in non-default location
-#CFLAGS += -I/usr/local/openssl/include
-#LIBS += -L/usr/local/openssl/lib
-
-# Some Red Hat versions seem to include kerberos header files from OpenSSL, but
-# the kerberos files are not in the default include path. Following line can be
-# used to fix build issues on such systems (krb5.h not found).
-#CFLAGS += -I/usr/include/kerberos
-
-# Example configuration for various cross-compilation platforms
-
-#### sveasoft (e.g., for Linksys WRT54G) ######################################
-#CC=mipsel-uclibc-gcc
-#CC=/opt/brcm/hndtools-mipsel-uclibc/bin/mipsel-uclibc-gcc
-#CFLAGS += -Os
-#CPPFLAGS += -I../src/include -I../../src/router/openssl/include
-#LIBS += -L/opt/brcm/hndtools-mipsel-uclibc-0.9.19/lib -lssl
-###############################################################################
-
-#### openwrt (e.g., for Linksys WRT54G) #######################################
-#CC=mipsel-uclibc-gcc
-#CC=/opt/brcm/hndtools-mipsel-uclibc/bin/mipsel-uclibc-gcc
-#CFLAGS += -Os
-#CPPFLAGS=-I../src/include -I../openssl-0.9.7d/include \
-#	-I../WRT54GS/release/src/include
-#LIBS = -lssl
-###############################################################################
-
-
-# Driver interface for Host AP driver
-CONFIG_DRIVER_HOSTAP=y
-
-# Driver interface for Agere driver
-#CONFIG_DRIVER_HERMES=y
-# Change include directories to match with the local setup
-#CFLAGS += -I../../hcf -I../../include -I../../include/hcf
-#CFLAGS += -I../../include/wireless
-
-# Driver interface for madwifi driver
-# Deprecated; use CONFIG_DRIVER_WEXT=y instead.
-#CONFIG_DRIVER_MADWIFI=y
-# Set include directory to the madwifi source tree
-#CFLAGS += -I../../madwifi
-
-# Driver interface for ndiswrapper
-# Deprecated; use CONFIG_DRIVER_WEXT=y instead.
-#CONFIG_DRIVER_NDISWRAPPER=y
-
-# Driver interface for Atmel driver
-# CONFIG_DRIVER_ATMEL=y
-
-# Driver interface for old Broadcom driver
-# Please note that the newer Broadcom driver ("hybrid Linux driver") supports
-# Linux wireless extensions and does not need (or even work) with the old
-# driver wrapper. Use CONFIG_DRIVER_WEXT=y with that driver.
-#CONFIG_DRIVER_BROADCOM=y
-# Example path for wlioctl.h; change to match your configuration
-#CFLAGS += -I/opt/WRT54GS/release/src/include
-
-# Driver interface for Intel ipw2100/2200 driver
-# Deprecated; use CONFIG_DRIVER_WEXT=y instead.
-#CONFIG_DRIVER_IPW=y
-
-# Driver interface for Ralink driver
-#CONFIG_DRIVER_RALINK=y
-
-# Driver interface for generic Linux wireless extensions
-CONFIG_DRIVER_WEXT=y
-
-# Driver interface for Linux drivers using the nl80211 kernel interface
-CONFIG_DRIVER_NL80211=y
-
-# Driver interface for FreeBSD net80211 layer (e.g., Atheros driver)
-#CONFIG_DRIVER_BSD=y
-#CFLAGS += -I/usr/local/include
-#LIBS += -L/usr/local/lib
-#LIBS_p += -L/usr/local/lib
-#LIBS_c += -L/usr/local/lib
-
-# Driver interface for Windows NDIS
-#CONFIG_DRIVER_NDIS=y
-#CFLAGS += -I/usr/include/w32api/ddk
-#LIBS += -L/usr/local/lib
-# For native build using mingw
-#CONFIG_NATIVE_WINDOWS=y
-# Additional directories for cross-compilation on Linux host for mingw target
-#CFLAGS += -I/opt/mingw/mingw32/include/ddk
-#LIBS += -L/opt/mingw/mingw32/lib
-#CC=mingw32-gcc
-# By default, driver_ndis uses WinPcap for low-level operations. This can be
-# replaced with the following option which replaces WinPcap calls with NDISUIO.
-# However, this requires that WZC is disabled (net stop wzcsvc) before starting
-# wpa_supplicant.
-# CONFIG_USE_NDISUIO=y
-
-# Driver interface for development testing
-#CONFIG_DRIVER_TEST=y
-
-# Include client MLME (management frame processing) for test driver
-# This can be used to test MLME operations in hostapd with the test interface.
-# space.
-#CONFIG_CLIENT_MLME=y
-
-# Driver interface for wired Ethernet drivers
-CONFIG_DRIVER_WIRED=y
-
-# Driver interface for the Broadcom RoboSwitch family
-#CONFIG_DRIVER_ROBOSWITCH=y
-
-# Driver interface for no driver (e.g., WPS ER only)
-#CONFIG_DRIVER_NONE=y
-
-# Enable IEEE 802.1X Supplicant (automatically included if any EAP method is
-# included)
-# CONFIG_IEEE8021X_EAPOL=y
-
-# EAP-MD5
-# CONFIG_EAP_MD5=y
-
-# EAP-MSCHAPv2
-# CONFIG_EAP_MSCHAPV2=y
-
-# EAP-TLS
-# CONFIG_EAP_TLS=y
-
-# EAL-PEAP
-# CONFIG_EAP_PEAP=y
-
-# EAP-TTLS
-# CONFIG_EAP_TTLS=y
-
-# EAP-FAST
-# Note: Default OpenSSL package does not include support for all the
-# functionality needed for EAP-FAST. If EAP-FAST is enabled with OpenSSL,
-# the OpenSSL library must be patched (openssl-0.9.8d-tls-extensions.patch)
-# to add the needed functions.
-#CONFIG_EAP_FAST=y
-
-# EAP-GTC
-# CONFIG_EAP_GTC=y
-
-# EAP-OTP
-# CONFIG_EAP_OTP=y
-
-# EAP-SIM (enable CONFIG_PCSC, if EAP-SIM is used)
-#CONFIG_EAP_SIM=y
-
-# EAP-PSK (experimental; this is _not_ needed for WPA-PSK)
-#CONFIG_EAP_PSK=y
-
-# EAP-PAX
-#CONFIG_EAP_PAX=y
-
-# LEAP
-# CONFIG_EAP_LEAP=y
-
-# EAP-AKA (enable CONFIG_PCSC, if EAP-AKA is used)
-#CONFIG_EAP_AKA=y
-
-# EAP-AKA' (enable CONFIG_PCSC, if EAP-AKA' is used).
-# This requires CONFIG_EAP_AKA to be enabled, too.
-#CONFIG_EAP_AKA_PRIME=y
-
-# Enable USIM simulator (Milenage) for EAP-AKA
-#CONFIG_USIM_SIMULATOR=y
-
-# EAP-SAKE
-#CONFIG_EAP_SAKE=y
-
-# EAP-GPSK
-#CONFIG_EAP_GPSK=y
-# Include support for optional SHA256 cipher suite in EAP-GPSK
-#CONFIG_EAP_GPSK_SHA256=y
-
-# EAP-TNC and related Trusted Network Connect support (experimental)
-#CONFIG_EAP_TNC=y
-
-# Wi-Fi Protected Setup (WPS)
-#CONFIG_WPS=y
-
-# EAP-IKEv2
-#CONFIG_EAP_IKEV2=y
-
-# PKCS#12 (PFX) support (used to read private key and certificate file from
-# a file that usually has extension .p12 or .pfx)
-# CONFIG_PKCS12=y
-
-# Smartcard support (i.e., private key on a smartcard), e.g., with openssl
-# engine.
-# CONFIG_SMARTCARD=y
-
-# PC/SC interface for smartcards (USIM, GSM SIM)
-# Enable this if EAP-SIM or EAP-AKA is included
-#CONFIG_PCSC=y
-
-# Development testing
-#CONFIG_EAPOL_TEST=y
-
-# Select control interface backend for external programs, e.g, wpa_cli:
-# unix = UNIX domain sockets (default for Linux/*BSD)
-# udp = UDP sockets using localhost (127.0.0.1)
-# named_pipe = Windows Named Pipe (default for Windows)
-# y = use default (backwards compatibility)
-# If this option is commented out, control interface is not included in the
-# build.
-CONFIG_CTRL_IFACE=y
-
-# Include support for GNU Readline and History Libraries in wpa_cli.
-# When building a wpa_cli binary for distribution, please note that these
-# libraries are licensed under GPL and as such, BSD license may not apply for
-# the resulting binary.
-#CONFIG_READLINE=y
-
-# Remove debugging code that is printing out debug message to stdout.
-# This can be used to reduce the size of the wpa_supplicant considerably
-# if debugging code is not needed. The size reduction can be around 35%
-# (e.g., 90 kB).
-#CONFIG_NO_STDOUT_DEBUG=y
-
-# Remove WPA support, e.g., for wired-only IEEE 802.1X supplicant, to save
-# 35-50 kB in code size.
-#CONFIG_NO_WPA=y
-
-# Remove WPA2 support. This allows WPA to be used, but removes WPA2 code to
-# save about 1 kB in code size when building only WPA-Personal (no EAP support)
-# or 6 kB if building for WPA-Enterprise.
-#CONFIG_NO_WPA2=y
-
-# Remove IEEE 802.11i/WPA-Personal ASCII passphrase support
-# This option can be used to reduce code size by removing support for
-# converting ASCII passphrases into PSK. If this functionality is removed, the
-# PSK can only be configured as the 64-octet hexstring (e.g., from
-# wpa_passphrase). This saves about 0.5 kB in code size.
-#CONFIG_NO_WPA_PASSPHRASE=y
-
-# Disable scan result processing (ap_mode=1) to save code size by about 1 kB.
-# This can be used if ap_scan=1 mode is never enabled.
-#CONFIG_NO_SCAN_PROCESSING=y
-
-# Select configuration backend:
-# file = text file (e.g., wpa_supplicant.conf; note: the configuration file
-#	path is given on command line, not here; this option is just used to
-#	select the backend that allows configuration files to be used)
-# winreg = Windows registry (see win_example.reg for an example)
-CONFIG_BACKEND=file
-
-# Remove configuration write functionality (i.e., to allow the configuration
-# file to be updated based on runtime configuration changes). The runtime
-# configuration can still be changed, the changes are just not going to be
-# persistent over restarts. This option can be used to reduce code size by
-# about 3.5 kB.
-#CONFIG_NO_CONFIG_WRITE=y
-
-# Remove support for configuration blobs to reduce code size by about 1.5 kB.
-#CONFIG_NO_CONFIG_BLOBS=y
-
-# Select program entry point implementation:
-# main = UNIX/POSIX like main() function (default)
-# main_winsvc = Windows service (read parameters from registry)
-# main_none = Very basic example (development use only)
-#CONFIG_MAIN=main
-
-# Select wrapper for operatins system and C library specific functions
-# unix = UNIX/POSIX like systems (default)
-# win32 = Windows systems
-# none = Empty template
-#CONFIG_OS=unix
-
-# Select event loop implementation
-# eloop = select() loop (default)
-# eloop_win = Windows events and WaitForMultipleObject() loop
-# eloop_none = Empty template
-#CONFIG_ELOOP=eloop
-
-# Select layer 2 packet implementation
-# linux = Linux packet socket (default)
-# pcap = libpcap/libdnet/WinPcap
-# freebsd = FreeBSD libpcap
-# winpcap = WinPcap with receive thread
-# ndis = Windows NDISUIO (note: requires CONFIG_USE_NDISUIO=y)
-# none = Empty template
-#CONFIG_L2_PACKET=linux
-
-# PeerKey handshake for Station to Station Link (IEEE 802.11e DLS)
-# CONFIG_PEERKEY=y
-
-# IEEE 802.11w (management frame protection)
-# This version is an experimental implementation based on IEEE 802.11w/D1.0
-# draft and is subject to change since the standard has not yet been finalized.
-# Driver support is also needed for IEEE 802.11w.
-#CONFIG_IEEE80211W=y
-
-# Select TLS implementation
-# openssl = OpenSSL (default)
-# gnutls = GnuTLS (needed for TLS/IA, see also CONFIG_GNUTLS_EXTRA)
-# internal = Internal TLSv1 implementation (experimental)
-# none = Empty template
-CONFIG_TLS=internal
-
-# Whether to enable TLS/IA support, which is required for EAP-TTLSv1.
-# You need CONFIG_TLS=gnutls for this to have any effect. Please note that
-# even though the core GnuTLS library is released under LGPL, this extra
-# library uses GPL and as such, the terms of GPL apply to the combination
-# of wpa_supplicant and GnuTLS if this option is enabled. BSD license may not
-# apply for distribution of the resulting binary.
-#CONFIG_GNUTLS_EXTRA=y
-
-# If CONFIG_TLS=internal is used, additional library and include paths are
-# needed for LibTomMath. Alternatively, an integrated, minimal version of
-# LibTomMath can be used. See beginning of libtommath.c for details on benefits
-# and drawbacks of this option.
-#CONFIG_INTERNAL_LIBTOMMATH=y
-#ifndef CONFIG_INTERNAL_LIBTOMMATH
-#LTM_PATH=/usr/src/libtommath-0.39
-#CFLAGS += -I$(LTM_PATH)
-#LIBS += -L$(LTM_PATH)
-#LIBS_p += -L$(LTM_PATH)
-#endif
-# At the cost of about 4 kB of additional binary size, the internal LibTomMath
-# can be configured to include faster routines for exptmod, sqr, and div to
-# speed up DH and RSA calculation considerably
-#CONFIG_INTERNAL_LIBTOMMATH_FAST=y
-
-# Include NDIS event processing through WMI into wpa_supplicant/wpasvc.
-# This is only for Windows builds and requires WMI-related header files and
-# WbemUuid.Lib from Platform SDK even when building with MinGW.
-#CONFIG_NDIS_EVENTS_INTEGRATED=y
-#PLATFORMSDKLIB="/opt/Program Files/Microsoft Platform SDK/Lib"
-
-# Add support for old DBus control interface
-# (fi.epitest.hostap.WPASupplicant)
-#CONFIG_CTRL_IFACE_DBUS=y
-
-# Add support for new DBus control interface
-# (fi.w1.hostap.wpa_supplicant1)
-#CONFIG_CTRL_IFACE_DBUS_NEW=y
-
-# Add introspection support for new DBus control interface
-#CONFIG_CTRL_IFACE_DBUS_INTRO=y
-
-# Add support for loading EAP methods dynamically as shared libraries.
-# When this option is enabled, each EAP method can be either included
-# statically (CONFIG_EAP_<method>=y) or dynamically (CONFIG_EAP_<method>=dyn).
-# Dynamic EAP methods are build as shared objects (eap_*.so) and they need to
-# be loaded in the beginning of the wpa_supplicant configuration file
-# (see load_dynamic_eap parameter in the example file) before being used in
-# the network blocks.
-#
-# Note that some shared parts of EAP methods are included in the main program
-# and in order to be able to use dynamic EAP methods using these parts, the
-# main program must have been build with the EAP method enabled (=y or =dyn).
-# This means that EAP-TLS/PEAP/TTLS/FAST cannot be added as dynamic libraries
-# unless at least one of them was included in the main build to force inclusion
-# of the shared code. Similarly, at least one of EAP-SIM/AKA must be included
-# in the main build to be able to load these methods dynamically.
-#
-# Please also note that using dynamic libraries will increase the total binary
-# size. Thus, it may not be the best option for targets that have limited
-# amount of memory/flash.
-#CONFIG_DYNAMIC_EAP_METHODS=y
-
-# IEEE Std 802.11r-2008 (Fast BSS Transition)
-#CONFIG_IEEE80211R=y
-
-# Add support for writing debug log to a file (/tmp/wpa_supplicant-log-#.txt)
-#CONFIG_DEBUG_FILE=y
-
-# Enable privilege separation (see README 'Privilege separation' for details)
-#CONFIG_PRIVSEP=y
-
-# Enable mitigation against certain attacks against TKIP by delaying Michael
-# MIC error reports by a random amount of time between 0 and 60 seconds
-#CONFIG_DELAYED_MIC_ERROR_REPORT=y
-
-# Enable tracing code for developer debugging
-# This tracks use of memory allocations and other registrations and reports
-# incorrect use with a backtrace of call (or allocation) location.
-#CONFIG_WPA_TRACE=y
-# For BSD, comment out these.
-#LIBS += -lexecinfo
-#LIBS_p += -lexecinfo
-#LIBS_c += -lexecinfo
-
-# Use libbfd to get more details for developer debugging
-# This enables use of libbfd to get more detailed symbols for the backtraces
-# generated by CONFIG_WPA_TRACE=y.
-#CONFIG_WPA_TRACE_BFD=y
-# For BSD, comment out these.
-#LIBS += -lbfd -liberty -lz
-#LIBS_p += -lbfd -liberty -lz
-#LIBS_c += -lbfd -liberty -lz
-
-CONFIG_NO_RANDOM_POOL=y
-NEED_80211_COMMON=y
diff --git a/package/hostapd/files/wpa_supplicant-p2p.config b/package/hostapd/files/wpa_supplicant-p2p.config
deleted file mode 100644
index 82e0bf0..0000000
--- a/package/hostapd/files/wpa_supplicant-p2p.config
+++ /dev/null
@@ -1,412 +0,0 @@
-# Example wpa_supplicant build time configuration
-#
-# This file lists the configuration options that are used when building the
-# hostapd binary. All lines starting with # are ignored. Configuration option
-# lines must be commented out complete, if they are not to be included, i.e.,
-# just setting VARIABLE=n is not disabling that variable.
-#
-# This file is included in Makefile, so variables like CFLAGS and LIBS can also
-# be modified from here. In most cases, these lines should use += in order not
-# to override previous values of the variables.
-
-
-# Uncomment following two lines and fix the paths if you have installed OpenSSL
-# or GnuTLS in non-default location
-#CFLAGS += -I/usr/local/openssl/include
-#LIBS += -L/usr/local/openssl/lib
-
-# Some Red Hat versions seem to include kerberos header files from OpenSSL, but
-# the kerberos files are not in the default include path. Following line can be
-# used to fix build issues on such systems (krb5.h not found).
-#CFLAGS += -I/usr/include/kerberos
-
-# Example configuration for various cross-compilation platforms
-
-#### sveasoft (e.g., for Linksys WRT54G) ######################################
-#CC=mipsel-uclibc-gcc
-#CC=/opt/brcm/hndtools-mipsel-uclibc/bin/mipsel-uclibc-gcc
-#CFLAGS += -Os
-#CPPFLAGS += -I../src/include -I../../src/router/openssl/include
-#LIBS += -L/opt/brcm/hndtools-mipsel-uclibc-0.9.19/lib -lssl
-###############################################################################
-
-#### openwrt (e.g., for Linksys WRT54G) #######################################
-#CC=mipsel-uclibc-gcc
-#CC=/opt/brcm/hndtools-mipsel-uclibc/bin/mipsel-uclibc-gcc
-#CFLAGS += -Os
-#CPPFLAGS=-I../src/include -I../openssl-0.9.7d/include \
-#	-I../WRT54GS/release/src/include
-#LIBS = -lssl
-###############################################################################
-
-
-# Driver interface for Host AP driver
-CONFIG_DRIVER_HOSTAP=y
-
-# Driver interface for Agere driver
-#CONFIG_DRIVER_HERMES=y
-# Change include directories to match with the local setup
-#CFLAGS += -I../../hcf -I../../include -I../../include/hcf
-#CFLAGS += -I../../include/wireless
-
-# Driver interface for madwifi driver
-# Deprecated; use CONFIG_DRIVER_WEXT=y instead.
-#CONFIG_DRIVER_MADWIFI=y
-# Set include directory to the madwifi source tree
-#CFLAGS += -I../../madwifi
-
-# Driver interface for ndiswrapper
-# Deprecated; use CONFIG_DRIVER_WEXT=y instead.
-#CONFIG_DRIVER_NDISWRAPPER=y
-
-# Driver interface for Atmel driver
-# CONFIG_DRIVER_ATMEL=y
-
-# Driver interface for old Broadcom driver
-# Please note that the newer Broadcom driver ("hybrid Linux driver") supports
-# Linux wireless extensions and does not need (or even work) with the old
-# driver wrapper. Use CONFIG_DRIVER_WEXT=y with that driver.
-#CONFIG_DRIVER_BROADCOM=y
-# Example path for wlioctl.h; change to match your configuration
-#CFLAGS += -I/opt/WRT54GS/release/src/include
-
-# Driver interface for Intel ipw2100/2200 driver
-# Deprecated; use CONFIG_DRIVER_WEXT=y instead.
-#CONFIG_DRIVER_IPW=y
-
-# Driver interface for Ralink driver
-#CONFIG_DRIVER_RALINK=y
-
-# Driver interface for generic Linux wireless extensions
-CONFIG_DRIVER_WEXT=y
-
-# Driver interface for Linux drivers using the nl80211 kernel interface
-CONFIG_DRIVER_NL80211=y
-
-# Driver interface for FreeBSD net80211 layer (e.g., Atheros driver)
-#CONFIG_DRIVER_BSD=y
-#CFLAGS += -I/usr/local/include
-#LIBS += -L/usr/local/lib
-#LIBS_p += -L/usr/local/lib
-#LIBS_c += -L/usr/local/lib
-
-# Driver interface for Windows NDIS
-#CONFIG_DRIVER_NDIS=y
-#CFLAGS += -I/usr/include/w32api/ddk
-#LIBS += -L/usr/local/lib
-# For native build using mingw
-#CONFIG_NATIVE_WINDOWS=y
-# Additional directories for cross-compilation on Linux host for mingw target
-#CFLAGS += -I/opt/mingw/mingw32/include/ddk
-#LIBS += -L/opt/mingw/mingw32/lib
-#CC=mingw32-gcc
-# By default, driver_ndis uses WinPcap for low-level operations. This can be
-# replaced with the following option which replaces WinPcap calls with NDISUIO.
-# However, this requires that WZC is disabled (net stop wzcsvc) before starting
-# wpa_supplicant.
-# CONFIG_USE_NDISUIO=y
-
-# Driver interface for development testing
-#CONFIG_DRIVER_TEST=y
-
-# Include client MLME (management frame processing) for test driver
-# This can be used to test MLME operations in hostapd with the test interface.
-# space.
-#CONFIG_CLIENT_MLME=y
-
-# Driver interface for wired Ethernet drivers
-CONFIG_DRIVER_WIRED=y
-
-# Driver interface for the Broadcom RoboSwitch family
-#CONFIG_DRIVER_ROBOSWITCH=y
-
-# Driver interface for no driver (e.g., WPS ER only)
-#CONFIG_DRIVER_NONE=y
-
-# Enable IEEE 802.1X Supplicant (automatically included if any EAP method is
-# included)
-CONFIG_IEEE8021X_EAPOL=y
-
-# EAP-MD5
-CONFIG_EAP_MD5=y
-
-# EAP-MSCHAPv2
-CONFIG_EAP_MSCHAPV2=y
-
-# EAP-TLS
-CONFIG_EAP_TLS=y
-
-# EAL-PEAP
-CONFIG_EAP_PEAP=y
-
-# EAP-TTLS
-CONFIG_EAP_TTLS=y
-
-# EAP-FAST
-# Note: Default OpenSSL package does not include support for all the
-# functionality needed for EAP-FAST. If EAP-FAST is enabled with OpenSSL,
-# the OpenSSL library must be patched (openssl-0.9.8d-tls-extensions.patch)
-# to add the needed functions.
-#CONFIG_EAP_FAST=y
-
-# EAP-GTC
-CONFIG_EAP_GTC=y
-
-# EAP-OTP
-CONFIG_EAP_OTP=y
-
-# EAP-SIM (enable CONFIG_PCSC, if EAP-SIM is used)
-#CONFIG_EAP_SIM=y
-
-# EAP-PSK (experimental; this is _not_ needed for WPA-PSK)
-#CONFIG_EAP_PSK=y
-
-# EAP-PAX
-#CONFIG_EAP_PAX=y
-
-# LEAP
-CONFIG_EAP_LEAP=y
-
-# EAP-AKA (enable CONFIG_PCSC, if EAP-AKA is used)
-#CONFIG_EAP_AKA=y
-
-# EAP-AKA' (enable CONFIG_PCSC, if EAP-AKA' is used).
-# This requires CONFIG_EAP_AKA to be enabled, too.
-#CONFIG_EAP_AKA_PRIME=y
-
-# Enable USIM simulator (Milenage) for EAP-AKA
-#CONFIG_USIM_SIMULATOR=y
-
-# EAP-SAKE
-#CONFIG_EAP_SAKE=y
-
-# EAP-GPSK
-#CONFIG_EAP_GPSK=y
-# Include support for optional SHA256 cipher suite in EAP-GPSK
-#CONFIG_EAP_GPSK_SHA256=y
-
-# EAP-TNC and related Trusted Network Connect support (experimental)
-#CONFIG_EAP_TNC=y
-
-# Wi-Fi Protected Setup (WPS)
-CONFIG_WPS=y
-
-# EAP-IKEv2
-#CONFIG_EAP_IKEV2=y
-
-# PKCS#12 (PFX) support (used to read private key and certificate file from
-# a file that usually has extension .p12 or .pfx)
-CONFIG_PKCS12=y
-
-# Smartcard support (i.e., private key on a smartcard), e.g., with openssl
-# engine.
-CONFIG_SMARTCARD=y
-
-# PC/SC interface for smartcards (USIM, GSM SIM)
-# Enable this if EAP-SIM or EAP-AKA is included
-#CONFIG_PCSC=y
-
-# Development testing
-#CONFIG_EAPOL_TEST=y
-
-# Select control interface backend for external programs, e.g, wpa_cli:
-# unix = UNIX domain sockets (default for Linux/*BSD)
-# udp = UDP sockets using localhost (127.0.0.1)
-# named_pipe = Windows Named Pipe (default for Windows)
-# y = use default (backwards compatibility)
-# If this option is commented out, control interface is not included in the
-# build.
-CONFIG_CTRL_IFACE=y
-
-# Include support for GNU Readline and History Libraries in wpa_cli.
-# When building a wpa_cli binary for distribution, please note that these
-# libraries are licensed under GPL and as such, BSD license may not apply for
-# the resulting binary.
-#CONFIG_READLINE=y
-
-# Remove debugging code that is printing out debug message to stdout.
-# This can be used to reduce the size of the wpa_supplicant considerably
-# if debugging code is not needed. The size reduction can be around 35%
-# (e.g., 90 kB).
-#CONFIG_NO_STDOUT_DEBUG=y
-
-# Remove WPA support, e.g., for wired-only IEEE 802.1X supplicant, to save
-# 35-50 kB in code size.
-#CONFIG_NO_WPA=y
-
-# Remove WPA2 support. This allows WPA to be used, but removes WPA2 code to
-# save about 1 kB in code size when building only WPA-Personal (no EAP support)
-# or 6 kB if building for WPA-Enterprise.
-#CONFIG_NO_WPA2=y
-
-# Remove IEEE 802.11i/WPA-Personal ASCII passphrase support
-# This option can be used to reduce code size by removing support for
-# converting ASCII passphrases into PSK. If this functionality is removed, the
-# PSK can only be configured as the 64-octet hexstring (e.g., from
-# wpa_passphrase). This saves about 0.5 kB in code size.
-#CONFIG_NO_WPA_PASSPHRASE=y
-
-# Disable scan result processing (ap_mode=1) to save code size by about 1 kB.
-# This can be used if ap_scan=1 mode is never enabled.
-#CONFIG_NO_SCAN_PROCESSING=y
-
-# Select configuration backend:
-# file = text file (e.g., wpa_supplicant.conf; note: the configuration file
-#	path is given on command line, not here; this option is just used to
-#	select the backend that allows configuration files to be used)
-# winreg = Windows registry (see win_example.reg for an example)
-CONFIG_BACKEND=file
-
-# Remove configuration write functionality (i.e., to allow the configuration
-# file to be updated based on runtime configuration changes). The runtime
-# configuration can still be changed, the changes are just not going to be
-# persistent over restarts. This option can be used to reduce code size by
-# about 3.5 kB.
-#CONFIG_NO_CONFIG_WRITE=y
-
-# Remove support for configuration blobs to reduce code size by about 1.5 kB.
-#CONFIG_NO_CONFIG_BLOBS=y
-
-# Select program entry point implementation:
-# main = UNIX/POSIX like main() function (default)
-# main_winsvc = Windows service (read parameters from registry)
-# main_none = Very basic example (development use only)
-#CONFIG_MAIN=main
-
-# Select wrapper for operatins system and C library specific functions
-# unix = UNIX/POSIX like systems (default)
-# win32 = Windows systems
-# none = Empty template
-#CONFIG_OS=unix
-
-# Select event loop implementation
-# eloop = select() loop (default)
-# eloop_win = Windows events and WaitForMultipleObject() loop
-# eloop_none = Empty template
-#CONFIG_ELOOP=eloop
-
-# Select layer 2 packet implementation
-# linux = Linux packet socket (default)
-# pcap = libpcap/libdnet/WinPcap
-# freebsd = FreeBSD libpcap
-# winpcap = WinPcap with receive thread
-# ndis = Windows NDISUIO (note: requires CONFIG_USE_NDISUIO=y)
-# none = Empty template
-#CONFIG_L2_PACKET=linux
-
-# PeerKey handshake for Station to Station Link (IEEE 802.11e DLS)
-CONFIG_PEERKEY=y
-
-# IEEE 802.11w (management frame protection)
-# This version is an experimental implementation based on IEEE 802.11w/D1.0
-# draft and is subject to change since the standard has not yet been finalized.
-# Driver support is also needed for IEEE 802.11w.
-CONFIG_IEEE80211W=y
-
-# Select TLS implementation
-# openssl = OpenSSL (default)
-# gnutls = GnuTLS (needed for TLS/IA, see also CONFIG_GNUTLS_EXTRA)
-# internal = Internal TLSv1 implementation (experimental)
-# none = Empty template
-CONFIG_TLS=internal
-
-# Whether to enable TLS/IA support, which is required for EAP-TTLSv1.
-# You need CONFIG_TLS=gnutls for this to have any effect. Please note that
-# even though the core GnuTLS library is released under LGPL, this extra
-# library uses GPL and as such, the terms of GPL apply to the combination
-# of wpa_supplicant and GnuTLS if this option is enabled. BSD license may not
-# apply for distribution of the resulting binary.
-#CONFIG_GNUTLS_EXTRA=y
-
-# If CONFIG_TLS=internal is used, additional library and include paths are
-# needed for LibTomMath. Alternatively, an integrated, minimal version of
-# LibTomMath can be used. See beginning of libtommath.c for details on benefits
-# and drawbacks of this option.
-CONFIG_INTERNAL_LIBTOMMATH=y
-#ifndef CONFIG_INTERNAL_LIBTOMMATH
-#LTM_PATH=/usr/src/libtommath-0.39
-#CFLAGS += -I$(LTM_PATH)
-#LIBS += -L$(LTM_PATH)
-#LIBS_p += -L$(LTM_PATH)
-#endif
-# At the cost of about 4 kB of additional binary size, the internal LibTomMath
-# can be configured to include faster routines for exptmod, sqr, and div to
-# speed up DH and RSA calculation considerably
-CONFIG_INTERNAL_LIBTOMMATH_FAST=y
-
-# Include NDIS event processing through WMI into wpa_supplicant/wpasvc.
-# This is only for Windows builds and requires WMI-related header files and
-# WbemUuid.Lib from Platform SDK even when building with MinGW.
-#CONFIG_NDIS_EVENTS_INTEGRATED=y
-#PLATFORMSDKLIB="/opt/Program Files/Microsoft Platform SDK/Lib"
-
-# Add support for old DBus control interface
-# (fi.epitest.hostap.WPASupplicant)
-#CONFIG_CTRL_IFACE_DBUS=y
-
-# Add support for new DBus control interface
-# (fi.w1.hostap.wpa_supplicant1)
-#CONFIG_CTRL_IFACE_DBUS_NEW=y
-
-# Add introspection support for new DBus control interface
-#CONFIG_CTRL_IFACE_DBUS_INTRO=y
-
-# Add support for loading EAP methods dynamically as shared libraries.
-# When this option is enabled, each EAP method can be either included
-# statically (CONFIG_EAP_<method>=y) or dynamically (CONFIG_EAP_<method>=dyn).
-# Dynamic EAP methods are build as shared objects (eap_*.so) and they need to
-# be loaded in the beginning of the wpa_supplicant configuration file
-# (see load_dynamic_eap parameter in the example file) before being used in
-# the network blocks.
-#
-# Note that some shared parts of EAP methods are included in the main program
-# and in order to be able to use dynamic EAP methods using these parts, the
-# main program must have been build with the EAP method enabled (=y or =dyn).
-# This means that EAP-TLS/PEAP/TTLS/FAST cannot be added as dynamic libraries
-# unless at least one of them was included in the main build to force inclusion
-# of the shared code. Similarly, at least one of EAP-SIM/AKA must be included
-# in the main build to be able to load these methods dynamically.
-#
-# Please also note that using dynamic libraries will increase the total binary
-# size. Thus, it may not be the best option for targets that have limited
-# amount of memory/flash.
-#CONFIG_DYNAMIC_EAP_METHODS=y
-
-# IEEE Std 802.11r-2008 (Fast BSS Transition)
-#CONFIG_IEEE80211R=y
-
-# Add support for writing debug log to a file (/tmp/wpa_supplicant-log-#.txt)
-#CONFIG_DEBUG_FILE=y
-
-# Enable privilege separation (see README 'Privilege separation' for details)
-#CONFIG_PRIVSEP=y
-
-# Enable mitigation against certain attacks against TKIP by delaying Michael
-# MIC error reports by a random amount of time between 0 and 60 seconds
-#CONFIG_DELAYED_MIC_ERROR_REPORT=y
-
-# Enable tracing code for developer debugging
-# This tracks use of memory allocations and other registrations and reports
-# incorrect use with a backtrace of call (or allocation) location.
-#CONFIG_WPA_TRACE=y
-# For BSD, comment out these.
-#LIBS += -lexecinfo
-#LIBS_p += -lexecinfo
-#LIBS_c += -lexecinfo
-
-# Use libbfd to get more details for developer debugging
-# This enables use of libbfd to get more detailed symbols for the backtraces
-# generated by CONFIG_WPA_TRACE=y.
-#CONFIG_WPA_TRACE_BFD=y
-# For BSD, comment out these.
-#LIBS += -lbfd -liberty -lz
-#LIBS_p += -lbfd -liberty -lz
-#LIBS_c += -lbfd -liberty -lz
-
-CONFIG_NO_RANDOM_POOL=y
-NEED_80211_COMMON=y
-
-CONFIG_IBSS_RSN=y
-
-CONFIG_P2P=y
-CONFIG_AP=y
diff --git a/package/hostapd/files/wpa_supplicant.sh b/package/hostapd/files/wpa_supplicant.sh
deleted file mode 100644
index bd86801..0000000
--- a/package/hostapd/files/wpa_supplicant.sh
+++ /dev/null
@@ -1,194 +0,0 @@
-wpa_supplicant_setup_vif() {
-	local vif="$1"
-	local driver="$2"
-	local key="$key"
-	local options="$3"
-	local freq=""
-	local ht="$5"
-	local ap_scan=""
-	local scan_ssid="1"
-	[ -n "$4" ] && freq="frequency=$4"
-
-	config_get enc "$vif" encryption
-	config_get key "$vif" key
-
-	local net_cfg bridge
-	config_get bridge "$vif" bridge
-	[ -z "$bridge" ] && {
-		net_cfg="$(find_net_config "$vif")"
-		[ -z "$net_cfg" ] || bridge="$(bridge_interface "$net_cfg")"
-		config_set "$vif" bridge "$bridge"
-	}
-
-	local mode ifname wds modestr=""
-	config_get mode "$vif" mode
-	config_get ifname "$vif" ifname
-	config_get_bool wds "$vif" wds 0
-	[ -z "$bridge" ] || [ "$mode" = ap ] || [ "$mode" = sta -a $wds -eq 1 ] || {
-		echo "wpa_supplicant_setup_vif($ifname): Refusing to bridge $mode mode interface"
-		return 1
-	}
-	[ "$mode" = "adhoc" ] && {
-		modestr="mode=1"
-		scan_ssid="0"
-		ap_scan="ap_scan=2"
-	}
-
-	key_mgmt='NONE'
-	case "$enc" in
-		*none*) ;;
-		*wep*)
-			config_get key "$vif" key
-			key="${key:-1}"
-			case "$key" in
-				[1234])
-					for idx in 1 2 3 4; do
-						local zidx
-						zidx=$(($idx - 1))
-						config_get ckey "$vif" "key${idx}"
-						[ -n "$ckey" ] && \
-							append "wep_key${zidx}" "wep_key${zidx}=$(prepare_key_wep "$ckey")"
-					done
-					wep_tx_keyidx="wep_tx_keyidx=$((key - 1))"
-				;;
-				*)
-					wep_key0="wep_key0=$(prepare_key_wep "$key")"
-					wep_tx_keyidx="wep_tx_keyidx=0"
-				;;
-			esac
-		;;
-		*psk*)
-			key_mgmt='WPA-PSK'
-			# if you want to use PSK with a non-nl80211 driver you
-			# have to use WPA-NONE and wext driver for wpa_s
-			[ "$mode" = "adhoc" -a "$driver" != "nl80211" ] && {
-				key_mgmt='WPA-NONE'
-				driver='wext'
-			}
-			if [ ${#key} -eq 64 ]; then
-				passphrase="psk=${key}"
-			else
-				passphrase="psk=\"${key}\""
-			fi
-			case "$enc" in
-				*psk2*)
-					proto='proto=RSN'
-					config_get ieee80211w "$vif" ieee80211w
-				;;
-				*psk*)
-					proto='proto=WPA'
-				;;
-			esac
-		;;
-		*wpa*|*8021x*)
-			proto='proto=WPA2'
-			key_mgmt='WPA-EAP'
-			config_get ieee80211w "$vif" ieee80211w
-			config_get ca_cert "$vif" ca_cert
-			config_get eap_type "$vif" eap_type
-			ca_cert=${ca_cert:+"ca_cert=\"$ca_cert\""}
-			case "$eap_type" in
-				tls)
-					pairwise='pairwise=CCMP'
-					group='group=CCMP'
-					config_get identity "$vif" identity
-					config_get client_cert "$vif" client_cert
-					config_get priv_key "$vif" priv_key
-					config_get priv_key_pwd "$vif" priv_key_pwd
-					identity="identity=\"$identity\""
-					client_cert="client_cert=\"$client_cert\""
-					priv_key="private_key=\"$priv_key\""
-					priv_key_pwd="private_key_passwd=\"$priv_key_pwd\""
-				;;
-				peap|ttls)
-					config_get auth "$vif" auth
-					config_get identity "$vif" identity
-					config_get password "$vif" password
-					phase2="phase2=\"auth=${auth:-MSCHAPV2}\""
-					identity="identity=\"$identity\""
-					password="${password:+password=\"$password\"}"
-				;;
-			esac
-			eap_type="eap=$(echo $eap_type | tr 'a-z' 'A-Z')"
-		;;
-	esac
-
-	case "$ieee80211w" in
-		[012])
-			ieee80211w="ieee80211w=$ieee80211w"
-		;;
-	esac
-
-	local fixed_freq bssid1 beacon_int brates mrate
-	config_get ifname "$vif" ifname
-	config_get bridge "$vif" bridge
-	config_get ssid "$vif" ssid
-	config_get bssid "$vif" bssid
-	bssid1=${bssid:+"bssid=$bssid"}
-	beacon_int=${beacon_int:+"beacon_int=$beacon_int"}
-
-	local br brval brsub brstr
-	[ -n "$basic_rate_list" ] && {
-		for br in $basic_rate_list; do
-			brval="$(($br / 1000))"
-			brsub="$((($br / 100) % 10))"
-			[ "$brsub" -gt 0 ] && brval="$brval.$brsub"
-			[ -n "$brstr" ] && brstr="$brstr,"
-			brstr="$brstr$brval"
-		done
-		brates=${basic_rate_list:+"rates=$brstr"}
-	}
-
-	local mcval=""
-	[ -n "$mcast_rate" ] && {
-		mcval="$(($mcast_rate / 1000))"
-		mcsub="$(( ($mcast_rate / 100) % 10 ))"
-		[ "$mcsub" -gt 0 ] && mcval="$mcval.$mcsub"
-		mrate=${mcast_rate:+"mcast_rate=$mcval"}
-	}
-
-	local ht_str
-	[ -n "$ht" ] && ht_str="htmode=$ht"
-
-	rm -rf /var/run/wpa_supplicant-$ifname
-	cat > /var/run/wpa_supplicant-$ifname.conf <<EOF
-ctrl_interface=/var/run/wpa_supplicant-$ifname
-$ap_scan
-network={
-	$modestr
-	scan_ssid=$scan_ssid
-	ssid="$ssid"
-	$bssid1
-	key_mgmt=$key_mgmt
-	$proto
-	$freq
-	${fixed:+"fixed_freq=1"}
-	$beacon_int
-	$brates
-	$mrate
-	$ht_str
-	$ieee80211w
-	$passphrase
-	$pairwise
-	$group
-	$eap_type
-	$ca_cert
-	$client_cert
-	$priv_key
-	$priv_key_pwd
-	$phase2
-	$identity
-	$password
-	$wep_key0
-	$wep_key1
-	$wep_key2
-	$wep_key3
-	$wep_tx_keyidx
-}
-EOF
-	if [ -n "$proto" -o "$key_mgmt" == "NONE" ]; then
-		wpa_supplicant ${bridge:+ -b $bridge} -B -P "/var/run/wifi-${ifname}.pid" -D ${driver:-wext} -i "$ifname" -c /var/run/wpa_supplicant-$ifname.conf $options
-	else
-		return 0
-	fi
-}
diff --git a/package/hostapd/files/wps-hotplug.sh b/package/hostapd/files/wps-hotplug.sh
deleted file mode 100644
index 058264a..0000000
--- a/package/hostapd/files/wps-hotplug.sh
+++ /dev/null
@@ -1,8 +0,0 @@
-#!/bin/sh
-
-if [ "$ACTION" = "pressed" -a "$BUTTON" = "wps" ]; then
-	for dir in /var/run/hostapd*; do
-		[ -d "$dir" ] || continue
-		hostapd_cli -p "$dir" wps_pbc
-	done
-fi
diff --git a/package/hostapd/madwifi/include/compat.h b/package/hostapd/madwifi/include/compat.h
deleted file mode 100644
index 09e6397..0000000
--- a/package/hostapd/madwifi/include/compat.h
+++ /dev/null
@@ -1,209 +0,0 @@
-/*-
- * Copyright (c) 2002-2005 Sam Leffler, Errno Consulting
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer,
- *    without modification.
- * 2. Redistributions in binary form must reproduce at minimum a disclaimer
- *    similar to the "NO WARRANTY" disclaimer below ("Disclaimer") and any
- *    redistribution must be conditioned upon including a substantially
- *    similar Disclaimer requirement for further binary redistribution.
- * 3. Neither the names of the above-listed copyright holders nor the names
- *    of any contributors may be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * Alternatively, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") version 2 as published by the Free
- * Software Foundation.
- *
- * NO WARRANTY
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF NONINFRINGEMENT, MERCHANTIBILITY
- * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
- * THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY,
- * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
- * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGES.
- *
- * $Id: compat.h 3310 2008-01-30 20:23:49Z mentor $
- */
-#ifndef _ATH_COMPAT_H_
-#define _ATH_COMPAT_H_
-
-/* Compatibility with older Linux kernels */
-#ifdef __KERNEL__
-#include <linux/types.h>
-#include <linux/time.h>
-#include <linux/netdevice.h>
-#endif
-
-#if !defined(__KERNEL__) || !defined (__bitwise)
-#define __le16 u_int16_t
-#define __le32 u_int32_t
-#define __le64 u_int64_t
-#define __be16 u_int16_t
-#define __be32 u_int32_t
-#define __be64 u_int64_t
-#define __force
-#endif
-
-#ifndef container_of
-#define container_of(ptr, type, member) ({				\
-	    const typeof( ((type *)0)->member ) *__mptr = (ptr);	\
-	    (type *)( (char *)__mptr - offsetof(type,member) );})
-#endif
-
-#ifndef list_for_each_entry_reverse
-#define list_for_each_entry_reverse(pos, head, member)			\
-	for (pos = list_entry((head)->prev, typeof(*pos), member);	\
-	     prefetch(pos->member.prev), &pos->member != (head); 	\
-	     pos = list_entry(pos->member.prev, typeof(*pos), member))
-#endif
-
-#ifndef NETDEV_TX_OK
-#define NETDEV_TX_OK    0
-#define NETDEV_TX_BUSY  1
-#endif
-
-/*
- * BSD/Linux compatibility shims.  These are used mainly to
- * minimize differences when importing necesary BSD code.
- */
-#define	NBBY	8			/* number of bits/byte */
-
-/* roundup() appears in Linux 2.6.18 */
-#include <linux/kernel.h>
-#ifndef roundup
-#define	roundup(x, y)	((((x)+((y)-1))/(y))*(y))  /* to any y */
-#endif
-
-#define	howmany(x, y)	(((x)+((y)-1))/(y))
-
-/* Bit map related macros. */
-#define	setbit(a,i)	((a)[(i)/NBBY] |= 1<<((i)%NBBY))
-#define	clrbit(a,i)	((a)[(i)/NBBY] &= ~(1<<((i)%NBBY)))
-#define	isset(a,i)	((a)[(i)/NBBY] & (1<<((i)%NBBY)))
-#define	isclr(a,i)	(((a)[(i)/NBBY] & (1<<((i)%NBBY))) == 0)
-
-#ifndef __packed
-#define	__packed	__attribute__((__packed__))
-#endif
-
-#define	__offsetof(t,m)	offsetof(t,m)
-
-#ifndef ALIGNED_POINTER
-/*
- * ALIGNED_POINTER is a boolean macro that checks whether an address
- * is valid to fetch data elements of type t from on this architecture.
- * This does not reflect the optimal alignment, just the possibility
- * (within reasonable limits). 
- *
- */
-#define ALIGNED_POINTER(p,t)	1
-#endif
-
-#ifdef __KERNEL__
-#define	KASSERT(exp, msg) do {			\
-	if (unlikely(!(exp))) {			\
-		printk msg;			\
-		BUG();				\
-	}					\
-} while (0)
-#endif /* __KERNEL__ */
-
-/*
- * NetBSD/FreeBSD defines for file version.
- */
-#define	__FBSDID(_s)
-#define	__KERNEL_RCSID(_n,_s)
-
-/*
- * Fixes for Linux API changes
- */
-#ifdef __KERNEL__
-
-#include <linux/version.h>
-
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,38)
-#define AUTOCONF_INCLUDED 1
-#endif
-
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,21)
-#define ATH_REGISTER_SYSCTL_TABLE(t) register_sysctl_table(t, 1)
-#else
-#define ATH_REGISTER_SYSCTL_TABLE(t) register_sysctl_table(t)
-#endif
-
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,9)
-#define __user
-#define __kernel
-#define __iomem
-#endif
-
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,14)
-typedef int gfp_t;
-#endif
-
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,16)
-static inline int timeval_compare(struct timeval *lhs, struct timeval *rhs)
-{
-	if (lhs->tv_sec < rhs->tv_sec)
-		return -1;
-	if (lhs->tv_sec > rhs->tv_sec)
-		return 1;
-	return lhs->tv_usec - rhs->tv_usec;
-}
-#endif
-
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18)
-#define IRQF_SHARED SA_SHIRQ
-#endif
-
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,27)
-#define netdev_priv(_netdev) ((_netdev)->priv)
-#endif
-
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22)
-#define skb_end_pointer(_skb) ((_skb)->end)
-#define skb_tail_pointer(_skb) ((_skb)->tail)
-#define skb_set_network_header(_skb, _offset) \
-	do { (_skb)->nh.raw = (_skb)->data + (_offset); } while(0)
-#define skb_reset_network_header(_skb) \
-	do { (_skb)->nh.raw = (_skb)->data; } while(0)
-#define skb_mac_header(_skb) ((_skb)->mac.raw)
-#define skb_reset_mac_header(_skb) \
-	do { (_skb)->mac.raw = (_skb)->data; } while(0)
-#endif
-
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24)
-#define CTL_AUTO -2
-#define DEV_ATH 9
-#else
-#define CTL_AUTO CTL_UNNUMBERED
-#define DEV_ATH CTL_UNNUMBERED
-#endif
-
-/* __skb_append got a third parameter in 2.6.14 */
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,14)
-#define __skb_queue_after(_list, _old, _new)	__skb_append(_old, _new)
-#elif LINUX_VERSION_CODE < KERNEL_VERSION(2,6,25)
-#define __skb_queue_after(_list, _old, _new)	__skb_append(_old, _new, _list)
-#endif
-
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,33)
-#define CTLNAME(x)	.ctl_name	= x,
-#else
-#define CTLNAME(x)
-#endif
-
-#endif /* __KERNEL__ */
-
-#endif /* _ATH_COMPAT_H_ */
diff --git a/package/hostapd/madwifi/net80211/_ieee80211.h b/package/hostapd/madwifi/net80211/_ieee80211.h
deleted file mode 100644
index 2d2a06f..0000000
--- a/package/hostapd/madwifi/net80211/_ieee80211.h
+++ /dev/null
@@ -1,325 +0,0 @@
-/*-
- * Copyright (c) 2001 Atsushi Onoe
- * Copyright (c) 2002-2005 Sam Leffler, Errno Consulting
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * Alternatively, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") version 2 as published by the Free
- * Software Foundation.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- *
- * $Id: _ieee80211.h 3207 2008-01-18 21:25:05Z mtaylor $
- */
-#ifndef _NET80211__IEEE80211_H_
-#define _NET80211__IEEE80211_H_
-
-enum ieee80211_phytype {
-	IEEE80211_T_DS,			/* direct sequence spread spectrum */
-	IEEE80211_T_FH,			/* frequency hopping */
-	IEEE80211_T_OFDM,		/* frequency division multiplexing */
-	IEEE80211_T_TURBO,		/* high rate OFDM, aka turbo mode */
-};
-#define	IEEE80211_T_CCK	IEEE80211_T_DS	/* more common nomenclature */
-
-/* XXX: not really a mode; there are really multiple PHYs */
-enum ieee80211_phymode {
-	IEEE80211_MODE_AUTO	= 0,	/* autoselect */
-	IEEE80211_MODE_11A	= 1,	/* 5GHz, OFDM */
-	IEEE80211_MODE_11B	= 2,	/* 2GHz, CCK */
-	IEEE80211_MODE_11G	= 3,	/* 2GHz, OFDM */
-	IEEE80211_MODE_FH	= 4,	/* 2GHz, GFSK */
-	IEEE80211_MODE_TURBO_A	= 5,	/* 5GHz, OFDM, 2x clock dynamic turbo */
-	IEEE80211_MODE_TURBO_G	= 6,	/* 2GHz, OFDM, 2x clock  dynamic turbo*/
-};
-#define	IEEE80211_MODE_MAX	(IEEE80211_MODE_TURBO_G+1)
-
-enum ieee80211_opmode {
-	IEEE80211_M_STA		= 1,	/* infrastructure station */
-	IEEE80211_M_IBSS 	= 0,	/* IBSS (adhoc) station */
-	IEEE80211_M_AHDEMO	= 3,	/* Old lucent compatible adhoc demo */
-	IEEE80211_M_HOSTAP	= 6,	/* Software Access Point */
-	IEEE80211_M_MONITOR	= 8,	/* Monitor mode */
-	IEEE80211_M_WDS		= 2	/* WDS link */
-};
-
-/*
- * True if this mode will send beacon on a regular interval, like AP
- * or IBSS
- */
-#define IEEE80211_IS_MODE_BEACON(_opmode) \
-	((_opmode == IEEE80211_M_IBSS) || \
-	 (_opmode == IEEE80211_M_HOSTAP))
-
-/*
- * True if this mode must behave like a DFS master, ie do Channel
- * Check Availability and In Service Monitoring. We need to make sure
- * that all modes cannot send data without being authorized. Such
- * enforcement is not done in monitor mode however.
- */
-
-#define IEEE80211_IS_MODE_DFS_MASTER(_opmode) \
-	((_opmode == IEEE80211_M_IBSS) || \
-	 (_opmode == IEEE80211_M_AHDEMO) || \
-	 (_opmode == IEEE80211_M_HOSTAP) || \
-	 (_opmode == IEEE80211_M_WDS))
-
-/*
- * 802.11g protection mode.
- */
-enum ieee80211_protmode {
-	IEEE80211_PROT_NONE	= 0,	/* no protection */
-	IEEE80211_PROT_CTSONLY	= 1,	/* CTS to self */
-	IEEE80211_PROT_RTSCTS	= 2,	/* RTS-CTS */
-};
-
-/*
- * Authentication mode.
- */
-enum ieee80211_authmode {
-	IEEE80211_AUTH_NONE	= 0,
-	IEEE80211_AUTH_OPEN	= 1,	/* open */
-	IEEE80211_AUTH_SHARED	= 2,	/* shared-key */
-	IEEE80211_AUTH_8021X	= 3,	/* 802.1x */
-	IEEE80211_AUTH_AUTO	= 4,	/* auto-select/accept */
-	/* NB: these are used only for ioctls */
-	IEEE80211_AUTH_WPA	= 5,	/* WPA/RSN w/ 802.1x/PSK */
-};
-
-/*
- * Roaming mode is effectively who controls the operation
- * of the 802.11 state machine when operating as a station.
- * State transitions are controlled either by the driver
- * (typically when management frames are processed by the
- * hardware/firmware), the host (auto/normal operation of
- * the 802.11 layer), or explicitly through ioctl requests
- * when applications like wpa_supplicant want control.
- */
-enum ieee80211_roamingmode {
-	IEEE80211_ROAMING_DEVICE= 0,	/* driver/hardware control */
-	IEEE80211_ROAMING_AUTO	= 1,	/* 802.11 layer control */
-	IEEE80211_ROAMING_MANUAL= 2,	/* application control */
-};
-
-/*
- * Scanning mode controls station scanning work; this is
- * used only when roaming mode permits the host to select
- * the bss to join/channel to use.
- */
-enum ieee80211_scanmode {
-	IEEE80211_SCAN_DEVICE	= 0,	/* driver/hardware control */
-	IEEE80211_SCAN_BEST	= 1,	/* 802.11 layer selects best */
-	IEEE80211_SCAN_FIRST	= 2,	/* take first suitable candidate */
-};
-
-enum ieee80211_scanflags {
-	IEEE80211_NOSCAN_DEFAULT = (1 << 0),
-	IEEE80211_NOSCAN_SET     = (1 << 1),
-};
-
-/*
- * Channels are specified by frequency and attributes.
- */
-struct ieee80211_channel {
-	u_int16_t ic_freq;	/* setting in MHz */
-	u_int16_t ic_flags;	/* see below */
-	u_int8_t ic_ieee;	/* IEEE channel number */
-	int8_t ic_maxregpower;	/* maximum regulatory tx power in dBm */
-	int8_t ic_maxpower;	/* maximum tx power in dBm */
-	int8_t ic_minpower;	/* minimum tx power in dBm */
-	u_int8_t ic_scanflags;
-	u_int8_t ic_idletime; /* phy idle time in % */
-};
-
-#define	IEEE80211_CHAN_MAX	255
-#define	IEEE80211_CHAN_BYTES	32	/* howmany(IEEE80211_CHAN_MAX, NBBY) */
-#define	IEEE80211_CHAN_ANY	0xffff	/* token for ``any channel'' */
-#define	IEEE80211_CHAN_ANYC 	((struct ieee80211_channel *) IEEE80211_CHAN_ANY)
-
-#define	IEEE80211_RADAR_CHANCHANGE_TBTT_COUNT	0
-#define IEEE80211_DEFAULT_CHANCHANGE_TBTT_COUNT	3
-
-#define	IEEE80211_RADAR_TEST_MUTE_CHAN	36	/* Move to channel 36 for mute test */
-
-/* bits 0-3 are for private use by drivers */
-/* channel attributes */
-#define	IEEE80211_CHAN_TURBO	0x0010	/* Turbo channel */
-#define	IEEE80211_CHAN_CCK	0x0020	/* CCK channel */
-#define	IEEE80211_CHAN_OFDM	0x0040	/* OFDM channel */
-#define	IEEE80211_CHAN_2GHZ	0x0080	/* 2 GHz spectrum channel. */
-#define	IEEE80211_CHAN_5GHZ	0x0100	/* 5 GHz spectrum channel */
-#define	IEEE80211_CHAN_PASSIVE	0x0200	/* Only passive scan allowed */
-#define	IEEE80211_CHAN_DYN	0x0400	/* Dynamic CCK-OFDM channel */
-#define	IEEE80211_CHAN_GFSK	0x0800	/* GFSK channel (FHSS PHY) */
-#define IEEE80211_CHAN_RADAR	0x1000	/* Radar found on channel */
-#define	IEEE80211_CHAN_STURBO	0x2000	/* 11a static turbo channel only */
-#define	IEEE80211_CHAN_HALF	0x4000	/* Half rate channel */
-#define	IEEE80211_CHAN_QUARTER	0x8000	/* Quarter rate channel */
-
-/*
- * Useful combinations of channel characteristics.
- */
-#define	IEEE80211_CHAN_FHSS \
-	(IEEE80211_CHAN_2GHZ | IEEE80211_CHAN_GFSK)
-#define	IEEE80211_CHAN_A \
-	(IEEE80211_CHAN_5GHZ | IEEE80211_CHAN_OFDM)
-#define	IEEE80211_CHAN_B \
-	(IEEE80211_CHAN_2GHZ | IEEE80211_CHAN_CCK)
-#define	IEEE80211_CHAN_PUREG \
-	(IEEE80211_CHAN_2GHZ | IEEE80211_CHAN_OFDM)
-#define	IEEE80211_CHAN_G \
-	(IEEE80211_CHAN_2GHZ | IEEE80211_CHAN_DYN)
-#define IEEE80211_CHAN_108A \
-	(IEEE80211_CHAN_5GHZ | IEEE80211_CHAN_OFDM | IEEE80211_CHAN_TURBO)
-#define	IEEE80211_CHAN_108G \
-	(IEEE80211_CHAN_2GHZ | IEEE80211_CHAN_OFDM | IEEE80211_CHAN_TURBO)
-#define	IEEE80211_CHAN_ST \
-	(IEEE80211_CHAN_108A | IEEE80211_CHAN_STURBO)
-
-#define	IEEE80211_CHAN_ALL \
-	(IEEE80211_CHAN_2GHZ | IEEE80211_CHAN_5GHZ | IEEE80211_CHAN_GFSK | \
-	 IEEE80211_CHAN_CCK | IEEE80211_CHAN_OFDM | IEEE80211_CHAN_DYN)
-#define	IEEE80211_CHAN_ALLTURBO \
-	(IEEE80211_CHAN_ALL | IEEE80211_CHAN_TURBO | IEEE80211_CHAN_STURBO)
-
-#define	IEEE80211_IS_CHAN_FHSS(_c) \
-	(((_c)->ic_flags & IEEE80211_CHAN_FHSS) == IEEE80211_CHAN_FHSS)
-#define	IEEE80211_IS_CHAN_A(_c) \
-	(((_c)->ic_flags & IEEE80211_CHAN_A) == IEEE80211_CHAN_A)
-#define	IEEE80211_IS_CHAN_B(_c) \
-	(((_c)->ic_flags & IEEE80211_CHAN_B) == IEEE80211_CHAN_B)
-#define	IEEE80211_IS_CHAN_PUREG(_c) \
-	(((_c)->ic_flags & IEEE80211_CHAN_PUREG) == IEEE80211_CHAN_PUREG)
-#define	IEEE80211_IS_CHAN_G(_c) \
-	(((_c)->ic_flags & IEEE80211_CHAN_G) == IEEE80211_CHAN_G)
-#define	IEEE80211_IS_CHAN_ANYG(_c) \
-	(IEEE80211_IS_CHAN_PUREG(_c) || IEEE80211_IS_CHAN_G(_c))
-#define	IEEE80211_IS_CHAN_ST(_c) \
-	(((_c)->ic_flags & IEEE80211_CHAN_ST) == IEEE80211_CHAN_ST)
-#define	IEEE80211_IS_CHAN_108A(_c) \
-	(((_c)->ic_flags & IEEE80211_CHAN_108A) == IEEE80211_CHAN_108A)
-#define	IEEE80211_IS_CHAN_108G(_c) \
-	(((_c)->ic_flags & IEEE80211_CHAN_108G) == IEEE80211_CHAN_108G)
-
-#define	IEEE80211_IS_CHAN_2GHZ(_c) \
-	(((_c)->ic_flags & IEEE80211_CHAN_2GHZ) != 0)
-#define	IEEE80211_IS_CHAN_5GHZ(_c) \
-	(((_c)->ic_flags & IEEE80211_CHAN_5GHZ) != 0)
-#define	IEEE80211_IS_CHAN_OFDM(_c) \
-	(((_c)->ic_flags & IEEE80211_CHAN_OFDM) != 0)
-#define	IEEE80211_IS_CHAN_CCK(_c) \
-	(((_c)->ic_flags & IEEE80211_CHAN_CCK) != 0)
-#define	IEEE80211_IS_CHAN_GFSK(_c) \
-	(((_c)->ic_flags & IEEE80211_CHAN_GFSK) != 0)
-#define	IEEE80211_IS_CHAN_TURBO(_c) \
-	(((_c)->ic_flags & IEEE80211_CHAN_TURBO) != 0)
-#define	IEEE80211_IS_CHAN_STURBO(_c) \
-	(((_c)->ic_flags & IEEE80211_CHAN_STURBO) != 0)
-#define	IEEE80211_IS_CHAN_DTURBO(_c) \
-	(((_c)->ic_flags & \
-	(IEEE80211_CHAN_TURBO | IEEE80211_CHAN_STURBO)) == IEEE80211_CHAN_TURBO)
-#define	IEEE80211_IS_CHAN_HALF(_c) \
-	(((_c)->ic_flags & IEEE80211_CHAN_HALF) != 0)
-#define	IEEE80211_IS_CHAN_QUARTER(_c) \
-	(((_c)->ic_flags & IEEE80211_CHAN_QUARTER) != 0)
-
-#define	IEEE80211_IS_CHAN_RADAR(_c) \
-	(((_c)->ic_flags & IEEE80211_CHAN_RADAR) != 0)
-#define	IEEE80211_IS_CHAN_PASSIVE(_c) \
-	(((_c)->ic_flags & IEEE80211_CHAN_PASSIVE) != 0)
-#define	IEEE80211_ARE_CHANS_SAME_MODE(_a, _b) \
-	(((_a)->ic_flags & IEEE80211_CHAN_ALLTURBO) == ((_b)->ic_flags & IEEE80211_CHAN_ALLTURBO))
-
-/* ni_chan encoding for FH phy */
-#define	IEEE80211_FH_CHANMOD		80
-#define	IEEE80211_FH_CHAN(set,pat)	(((set) - 1) * IEEE80211_FH_CHANMOD + (pat))
-#define	IEEE80211_FH_CHANSET(chan)	((chan) / IEEE80211_FH_CHANMOD + 1)
-#define	IEEE80211_FH_CHANPAT(chan)	((chan) % IEEE80211_FH_CHANMOD)
-
-/*
- * Spectrum Management (IEEE 802.11h-2003)
- */
-
-/* algorithm for (re)association based on supported channels
- * (the one mentioned in 11.6.1 as out of scope of .11h) */
-enum ieee80211_sc_algorithm {
-	IEEE80211_SC_NONE,
-	/*
-	 * Do not disallow anyone from associating. When needed, channel will
-	 * be switched to the most suitable channel, no matter client stations
-	 * support it or not.
-	 */
-
-	IEEE80211_SC_LOOSE,
-	/*
-	 * Do not disallow anyone from associating. When needed, channel will
-	 * be switched to a suitable channel, which will be chosen taking
-	 * ni->ni_suppchans and ic->ic_sc_sldg under consideration.
-	 */
-
-	IEEE80211_SC_TIGHT,
-	/*
-	 * Allow to associate if there are at least ic->ic_mincom channels
-	 * common to the associating station and all of the already associated
-	 * stations. If the number of new common channels is less than
-	 * required, consider disassociating some other STAs. Such a
-	 * disassociation will be performed if (and only if) the association we
-	 * are currently considering would be then possible and the count of
-	 * the resultant set of common channels (ic_chan_nodes[i] ==
-	 * ic_cn_total) would increase by some amount. Whether the number of
-	 * the new channels that could be gained is enough to sacrifice a
-	 * number of STAs is determined by the ic->ic_slcg parameter.
-	 */
-
-	IEEE80211_SC_STRICT
-	/*
-	 * Basically the same behavior as IEEE80211_SC_TIGHT, except that if a
-	 * station does not specify Supported Channels, then it is denied to
-	 * associate.
-	 */
-};
-
-/*
- * 802.11 rate set.
- */
-#define	IEEE80211_RATE_SIZE	8		/* 802.11 standard */
-#define	IEEE80211_RATE_MAXSIZE	15		/* max rates we'll handle */
-#define	IEEE80211_SANITISE_RATESIZE(_rsz) \
-	((_rsz > IEEE80211_RATE_MAXSIZE) ? IEEE80211_RATE_MAXSIZE : _rsz)
-
-struct ieee80211_rateset {
-	u_int8_t rs_nrates;
-	u_int8_t rs_rates[IEEE80211_RATE_MAXSIZE];
-};
-
-struct ieee80211_roam {
-	int8_t rssi11a;		/* rssi thresh for 11a bss */
-	int8_t rssi11b;		/* for 11g sta in 11b bss */
-	int8_t rssi11bOnly;	/* for 11b sta */
-	u_int8_t pad1;
-	u_int8_t rate11a;	/* rate thresh for 11a bss */
-	u_int8_t rate11b;	/* for 11g sta in 11b bss */
-	u_int8_t rate11bOnly;	/* for 11b sta */
-	u_int8_t pad2;
-};
-#endif /* _NET80211__IEEE80211_H_ */
diff --git a/package/hostapd/madwifi/net80211/ieee80211.h b/package/hostapd/madwifi/net80211/ieee80211.h
deleted file mode 100644
index a39d4b9..0000000
--- a/package/hostapd/madwifi/net80211/ieee80211.h
+++ /dev/null
@@ -1,997 +0,0 @@
-/*-
- * Copyright (c) 2001 Atsushi Onoe
- * Copyright (c) 2002-2005 Sam Leffler, Errno Consulting
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * Alternatively, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") version 2 as published by the Free
- * Software Foundation.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- *
- * $Id: ieee80211.h 3268 2008-01-26 20:48:11Z mtaylor $
- */
-#ifndef _NET80211_IEEE80211_H_
-#define _NET80211_IEEE80211_H_
-
-/*
- * 802.11 protocol definitions.
- */
-
-#define	IEEE80211_ADDR_LEN		6		/* size of 802.11 address */
-/* is 802.11 address multicast/broadcast? */
-#define	IEEE80211_IS_MULTICAST(_a)	(*(_a) & 0x01)
-
-/* IEEE 802.11 PLCP header */
-struct ieee80211_plcp_hdr {
-	u_int16_t i_sfd;
-	u_int8_t i_signal;
-	u_int8_t i_service;
-	u_int16_t i_length;
-	u_int16_t i_crc;
-} __packed;
-
-#define IEEE80211_PLCP_SFD      0xF3A0
-#define IEEE80211_PLCP_SERVICE  0x00
-
-/*
- * generic definitions for IEEE 802.11 frames
- */
-struct ieee80211_frame {
-	u_int8_t i_fc[2];
-	__le16 i_dur;
-	u_int8_t i_addr1[IEEE80211_ADDR_LEN];
-	u_int8_t i_addr2[IEEE80211_ADDR_LEN];
-	u_int8_t i_addr3[IEEE80211_ADDR_LEN];
-	u_int8_t i_seq[2];
-	/* possibly followed by addr4[IEEE80211_ADDR_LEN]; */
-	/* see below */
-} __packed;
-
-struct ieee80211_qosframe {
-	u_int8_t i_fc[2];
-	__le16 i_dur;
-	u_int8_t i_addr1[IEEE80211_ADDR_LEN];
-	u_int8_t i_addr2[IEEE80211_ADDR_LEN];
-	u_int8_t i_addr3[IEEE80211_ADDR_LEN];
-	u_int8_t i_seq[2];
-	u_int8_t i_qos[2];
-	/* possibly followed by addr4[IEEE80211_ADDR_LEN]; */
-	/* see below */
-} __packed;
-
-struct ieee80211_qoscntl {
-	u_int8_t i_qos[2];
-};
-
-struct ieee80211_frame_addr4 {
-	u_int8_t i_fc[2];
-	__le16 i_dur;
-	u_int8_t i_addr1[IEEE80211_ADDR_LEN];
-	u_int8_t i_addr2[IEEE80211_ADDR_LEN];
-	u_int8_t i_addr3[IEEE80211_ADDR_LEN];
-	u_int8_t i_seq[2];
-	u_int8_t i_addr4[IEEE80211_ADDR_LEN];
-} __packed;
-
-
-struct ieee80211_qosframe_addr4 {
-	u_int8_t i_fc[2];
-	__le16 i_dur;
-	u_int8_t i_addr1[IEEE80211_ADDR_LEN];
-	u_int8_t i_addr2[IEEE80211_ADDR_LEN];
-	u_int8_t i_addr3[IEEE80211_ADDR_LEN];
-	u_int8_t i_seq[2];
-	u_int8_t i_addr4[IEEE80211_ADDR_LEN];
-	u_int8_t i_qos[2];
-} __packed;
-
-struct ieee80211_ctlframe_addr2 {
-	u_int8_t i_fc[2];
-	__le16 i_aidordur; /* AID or duration */
-	u_int8_t i_addr1[IEEE80211_ADDR_LEN];
-	u_int8_t i_addr2[IEEE80211_ADDR_LEN];
-} __packed;
-
-#define	IEEE80211_FC0_VERSION_MASK		0x03
-#define	IEEE80211_FC0_VERSION_SHIFT		0
-#define	IEEE80211_FC0_VERSION_0			0x00
-#define	IEEE80211_FC0_TYPE_MASK			0x0c
-#define	IEEE80211_FC0_TYPE_SHIFT		2
-#define	IEEE80211_FC0_TYPE_MGT			0x00
-#define	IEEE80211_FC0_TYPE_CTL			0x04
-#define	IEEE80211_FC0_TYPE_DATA			0x08
-
-#define	IEEE80211_FC0_SUBTYPE_MASK		0xf0
-#define	IEEE80211_FC0_SUBTYPE_SHIFT		4
-/* for TYPE_MGT */
-#define	IEEE80211_FC0_SUBTYPE_ASSOC_REQ		0x00
-#define	IEEE80211_FC0_SUBTYPE_ASSOC_RESP	0x10
-#define	IEEE80211_FC0_SUBTYPE_REASSOC_REQ	0x20
-#define	IEEE80211_FC0_SUBTYPE_REASSOC_RESP	0x30
-#define	IEEE80211_FC0_SUBTYPE_PROBE_REQ		0x40
-#define	IEEE80211_FC0_SUBTYPE_PROBE_RESP	0x50
-#define	IEEE80211_FC0_SUBTYPE_BEACON		0x80
-#define	IEEE80211_FC0_SUBTYPE_ATIM		0x90
-#define	IEEE80211_FC0_SUBTYPE_DISASSOC		0xa0
-#define	IEEE80211_FC0_SUBTYPE_AUTH		0xb0
-#define	IEEE80211_FC0_SUBTYPE_DEAUTH		0xc0
-#define IEEE80211_FC0_SUBTYPE_ACTION		0xd0
-/* for TYPE_CTL */
-#define	IEEE80211_FC0_SUBTYPE_PS_POLL		0xa0
-#define	IEEE80211_FC0_SUBTYPE_RTS		0xb0
-#define	IEEE80211_FC0_SUBTYPE_CTS		0xc0
-#define	IEEE80211_FC0_SUBTYPE_ACK		0xd0
-#define	IEEE80211_FC0_SUBTYPE_CF_END		0xe0
-#define	IEEE80211_FC0_SUBTYPE_CF_END_ACK	0xf0
-/* for TYPE_DATA (bit combination) */
-#define	IEEE80211_FC0_SUBTYPE_DATA		0x00
-#define	IEEE80211_FC0_SUBTYPE_CF_ACK		0x10
-#define	IEEE80211_FC0_SUBTYPE_CF_POLL		0x20
-#define	IEEE80211_FC0_SUBTYPE_CF_ACPL		0x30
-#define	IEEE80211_FC0_SUBTYPE_NODATA		0x40
-#define	IEEE80211_FC0_SUBTYPE_CFACK		0x50
-#define	IEEE80211_FC0_SUBTYPE_CFPOLL		0x60
-#define	IEEE80211_FC0_SUBTYPE_CF_ACK_CF_ACK	0x70
-#define	IEEE80211_FC0_SUBTYPE_QOS		0x80
-#define	IEEE80211_FC0_SUBTYPE_QOS_NULL		0xc0
-
-#define	IEEE80211_FC1_DIR_MASK			0x03
-#define	IEEE80211_FC1_DIR_NODS			0x00	/* STA->STA */
-#define	IEEE80211_FC1_DIR_TODS			0x01	/* STA->AP  */
-#define	IEEE80211_FC1_DIR_FROMDS		0x02	/* AP ->STA */
-#define	IEEE80211_FC1_DIR_DSTODS		0x03	/* AP ->AP  */
-
-#define	IEEE80211_FC1_MORE_FRAG			0x04
-#define	IEEE80211_FC1_RETRY			0x08
-#define	IEEE80211_FC1_PWR_MGT			0x10
-#define	IEEE80211_FC1_MORE_DATA			0x20
-#define	IEEE80211_FC1_PROT			0x40
-#define	IEEE80211_FC1_ORDER			0x80
-
-#define	IEEE80211_SEQ_FRAG_MASK			0x000f
-#define	IEEE80211_SEQ_FRAG_SHIFT		0
-#define	IEEE80211_SEQ_SEQ_MASK			0xfff0
-#define	IEEE80211_SEQ_SEQ_SHIFT			4
-
-#define	IEEE80211_NWID_LEN			32
-
-#define	IEEE80211_QOS_TXOP			0x00ff
-/* bit 8 is reserved */
-#define	IEEE80211_QOS_ACKPOLICY			0x60
-#define	IEEE80211_QOS_ACKPOLICY_S		5
-#define	IEEE80211_QOS_EOSP			0x10
-#define	IEEE80211_QOS_EOSP_S			4
-#define	IEEE80211_QOS_TID			0x0f
-
-#define IEEE80211_FRM_HAS_BODY(_wh)			\
-	(((_wh)->i_fc[0] & IEEE80211_FC0_TYPE_MASK) !=	\
-			IEEE80211_FC0_TYPE_CTL)
-
-/*
- * Country/Region Codes from MS WINNLS.H
- * Numbering from ISO 3166
- * XXX belongs elsewhere
- */
-enum CountryCode {
-	CTRY_ALBANIA              = 8,       /* Albania */
-	CTRY_ALGERIA              = 12,      /* Algeria */
-	CTRY_ARGENTINA            = 32,      /* Argentina */
-	CTRY_ARMENIA              = 51,      /* Armenia */
-	CTRY_AUSTRALIA            = 36,      /* Australia */
-	CTRY_AUSTRIA              = 40,      /* Austria */
-	CTRY_AZERBAIJAN           = 31,      /* Azerbaijan */
-	CTRY_BAHRAIN              = 48,      /* Bahrain */
-	CTRY_BELARUS              = 112,     /* Belarus */
-	CTRY_BELGIUM              = 56,      /* Belgium */
-	CTRY_BELIZE               = 84,      /* Belize */
-	CTRY_BOLIVIA              = 68,      /* Bolivia */
-	CTRY_BRAZIL               = 76,      /* Brazil */
-	CTRY_BRUNEI_DARUSSALAM    = 96,      /* Brunei Darussalam */
-	CTRY_BULGARIA             = 100,     /* Bulgaria */
-	CTRY_CANADA               = 124,     /* Canada */
-	CTRY_CHILE                = 152,     /* Chile */
-	CTRY_CHINA                = 156,     /* People's Republic of China */
-	CTRY_COLOMBIA             = 170,     /* Colombia */
-	CTRY_COSTA_RICA           = 188,     /* Costa Rica */
-	CTRY_CROATIA              = 191,     /* Croatia */
-	CTRY_CYPRUS               = 196,
-	CTRY_CZECH                = 203,     /* Czech Republic */
-	CTRY_DENMARK              = 208,     /* Denmark */
-	CTRY_DOMINICAN_REPUBLIC   = 214,     /* Dominican Republic */
-	CTRY_ECUADOR              = 218,     /* Ecuador */
-	CTRY_EGYPT                = 818,     /* Egypt */
-	CTRY_EL_SALVADOR          = 222,     /* El Salvador */
-	CTRY_ESTONIA              = 233,     /* Estonia */
-	CTRY_FAEROE_ISLANDS       = 234,     /* Faeroe Islands */
-	CTRY_FINLAND              = 246,     /* Finland */
-	CTRY_FRANCE               = 250,     /* France */
-	CTRY_FRANCE2              = 255,     /* France2 */
-	CTRY_GEORGIA              = 268,     /* Georgia */
-	CTRY_GERMANY              = 276,     /* Germany */
-	CTRY_GREECE               = 300,     /* Greece */
-	CTRY_GUATEMALA            = 320,     /* Guatemala */
-	CTRY_HONDURAS             = 340,     /* Honduras */
-	CTRY_HONG_KONG            = 344,     /* Hong Kong S.A.R., P.R.C. */
-	CTRY_HUNGARY              = 348,     /* Hungary */
-	CTRY_ICELAND              = 352,     /* Iceland */
-	CTRY_INDIA                = 356,     /* India */
-	CTRY_INDONESIA            = 360,     /* Indonesia */
-	CTRY_IRAN                 = 364,     /* Iran */
-	CTRY_IRAQ                 = 368,     /* Iraq */
-	CTRY_IRELAND              = 372,     /* Ireland */
-	CTRY_ISRAEL               = 376,     /* Israel */
-	CTRY_ITALY                = 380,     /* Italy */
-	CTRY_JAMAICA              = 388,     /* Jamaica */
-	CTRY_JAPAN                = 392,     /* Japan */
-	CTRY_JAPAN1               = 393,     /* Japan (JP1) */
-	CTRY_JAPAN2               = 394,     /* Japan (JP0) */
-	CTRY_JAPAN3               = 395,     /* Japan (JP1-1) */
-	CTRY_JAPAN4               = 396,     /* Japan (JE1) */
-	CTRY_JAPAN5               = 397,     /* Japan (JE2) */
-	CTRY_JAPAN6               = 399,	 /* Japan (JP6) */
-	CTRY_JAPAN7               = 900,	 /* Japan */
-	CTRY_JAPAN8               = 901,	 /* Japan */
-	CTRY_JAPAN9               = 902,	 /* Japan */
-	CTRY_JAPAN10	      = 903,	 /* Japan */
-	CTRY_JAPAN11	      = 904,	 /* Japan */
-	CTRY_JAPAN12	      = 905,	 /* Japan */
-	CTRY_JAPAN13	      = 906,	 /* Japan */
-	CTRY_JAPAN14	      = 907,	 /* Japan */
-	CTRY_JAPAN15	      = 908,	 /* Japan */
-	CTRY_JAPAN16	      = 909,	 /* Japan */
-	CTRY_JAPAN17	      = 910,	 /* Japan */
-	CTRY_JAPAN18	      = 911,	 /* Japan */
-	CTRY_JAPAN19	      = 912,	 /* Japan */
-	CTRY_JAPAN20	      = 913,	 /* Japan */
-	CTRY_JAPAN21	      = 914,	 /* Japan */
-	CTRY_JAPAN22	      = 915,	 /* Japan */
-	CTRY_JAPAN23	      = 916,	 /* Japan */
-	CTRY_JAPAN24	      = 917,	 /* Japan */
-	CTRY_JAPAN25	      = 918,	 /* Japan */
-	CTRY_JAPAN26	      = 919,	 /* Japan */
-	CTRY_JAPAN27	      = 920,	 /* Japan */
-	CTRY_JAPAN28	      = 921,	 /* Japan */
-	CTRY_JAPAN29	      = 922,	 /* Japan */
-	CTRY_JAPAN30	      = 923,	 /* Japan */
-	CTRY_JAPAN31	      = 924,	 /* Japan */
-	CTRY_JAPAN32	      = 925,	 /* Japan */
-	CTRY_JAPAN33	      = 926,	 /* Japan */
-	CTRY_JAPAN34	      = 927,	 /* Japan */
-	CTRY_JAPAN35	      = 928,	 /* Japan */
-	CTRY_JAPAN36	      = 929,	 /* Japan */
-	CTRY_JAPAN37	      = 930,	 /* Japan */
-	CTRY_JAPAN38	      = 931,	 /* Japan */
-	CTRY_JAPAN39	      = 932,	 /* Japan */
-	CTRY_JAPAN40	      = 933,	 /* Japan */
-	CTRY_JAPAN41	      = 934,	 /* Japan */
-	CTRY_JAPAN42	      = 935,	 /* Japan */
-	CTRY_JAPAN43	      = 936,	 /* Japan */
-	CTRY_JAPAN44	      = 937,	 /* Japan */
-	CTRY_JAPAN45	      = 938,	 /* Japan */
-	CTRY_JAPAN46	      = 939,	 /* Japan */
-	CTRY_JAPAN47	      = 940,	 /* Japan */
-	CTRY_JAPAN48	      = 941,	 /* Japan */
-	CTRY_JORDAN               = 400,     /* Jordan */
-	CTRY_KAZAKHSTAN           = 398,     /* Kazakhstan */
-	CTRY_KENYA                = 404,     /* Kenya */
-	CTRY_KOREA_NORTH          = 408,     /* North Korea */
-	CTRY_KOREA_ROC            = 410,     /* South Korea */
-	CTRY_KOREA_ROC2           = 411,     /* South Korea */
-	CTRY_KUWAIT               = 414,     /* Kuwait */
-	CTRY_LATVIA               = 428,     /* Latvia */
-	CTRY_LEBANON              = 422,     /* Lebanon */
-	CTRY_LIBYA                = 434,     /* Libya */
-	CTRY_LIECHTENSTEIN        = 438,     /* Liechtenstein */
-	CTRY_LITHUANIA            = 440,     /* Lithuania */
-	CTRY_LUXEMBOURG           = 442,     /* Luxembourg */
-	CTRY_MACAU                = 446,     /* Macau */
-	CTRY_MACEDONIA            = 807,     /* the Former Yugoslav Republic of Macedonia */
-	CTRY_MALAYSIA             = 458,     /* Malaysia */
-	CTRY_MEXICO               = 484,     /* Mexico */
-	CTRY_MONACO               = 492,     /* Principality of Monaco */
-	CTRY_MOROCCO              = 504,     /* Morocco */
-	CTRY_NETHERLANDS          = 528,     /* Netherlands */
-	CTRY_NEW_ZEALAND          = 554,     /* New Zealand */
-	CTRY_NICARAGUA            = 558,     /* Nicaragua */
-	CTRY_NORWAY               = 578,     /* Norway */
-	CTRY_OMAN                 = 512,     /* Oman */
-	CTRY_PAKISTAN             = 586,     /* Islamic Republic of Pakistan */
-	CTRY_PANAMA               = 591,     /* Panama */
-	CTRY_PARAGUAY             = 600,     /* Paraguay */
-	CTRY_PERU                 = 604,     /* Peru */
-	CTRY_PHILIPPINES          = 608,     /* Republic of the Philippines */
-	CTRY_POLAND               = 616,     /* Poland */
-	CTRY_PORTUGAL             = 620,     /* Portugal */
-	CTRY_PUERTO_RICO          = 630,     /* Puerto Rico */
-	CTRY_QATAR                = 634,     /* Qatar */
-	CTRY_ROMANIA              = 642,     /* Romania */
-	CTRY_RUSSIA               = 643,     /* Russia */
-	CTRY_SAUDI_ARABIA         = 682,     /* Saudi Arabia */
-	CTRY_SINGAPORE            = 702,     /* Singapore */
-	CTRY_SLOVAKIA             = 703,     /* Slovak Republic */
-	CTRY_SLOVENIA             = 705,     /* Slovenia */
-	CTRY_SOUTH_AFRICA         = 710,     /* South Africa */
-	CTRY_SPAIN                = 724,     /* Spain */
-	CTRY_SWEDEN               = 752,     /* Sweden */
-	CTRY_SWITZERLAND          = 756,     /* Switzerland */
-	CTRY_SYRIA                = 760,     /* Syria */
-	CTRY_TAIWAN               = 158,     /* Taiwan */
-	CTRY_THAILAND             = 764,     /* Thailand */
-	CTRY_TRINIDAD_Y_TOBAGO    = 780,     /* Trinidad y Tobago */
-	CTRY_TUNISIA              = 788,     /* Tunisia */
-	CTRY_TURKEY               = 792,     /* Turkey */
-	CTRY_UAE                  = 784,     /* U.A.E. */
-	CTRY_UKRAINE              = 804,     /* Ukraine */
-	CTRY_UNITED_KINGDOM       = 826,     /* United Kingdom */
-	CTRY_UNITED_STATES        = 840,     /* United States */
-	CTRY_UNITED_STATES_FCC49  = 842,     /* United States (Public Safety)*/
-	CTRY_URUGUAY              = 858,     /* Uruguay */
-	CTRY_UZBEKISTAN           = 860,     /* Uzbekistan */
-	CTRY_VENEZUELA            = 862,     /* Venezuela */
-	CTRY_VIET_NAM             = 704,     /* Viet Nam */
-	CTRY_YEMEN                = 887,     /* Yemen */
-	CTRY_ZIMBABWE             = 716      /* Zimbabwe */
-};
-
-/* 
- * Generic information element
- */
-struct ieee80211_ie {
-	u_int8_t id;
-	u_int8_t len;
-	u_int8_t info[0];
-} __packed;
-
-/* 
- * Country information element.
- */
-#define IEEE80211_COUNTRY_MAX_TRIPLETS (83)
-struct ieee80211_ie_country {
-	u_int8_t country_id;
-	u_int8_t country_len;
-	u_int8_t country_str[3];
-	u_int8_t country_triplet[IEEE80211_COUNTRY_MAX_TRIPLETS * 3];
-} __packed;
-
-/*
- * Power Constraint information element.
- */
-struct ieee80211_ie_pwrcnstr {
-	u_int8_t pc_id;			/* IEEE80211_ELEMID_PWRCNSTR */
-	u_int8_t pc_len;		/* == 2 */
-	u_int8_t pc_lpc;		/* Local Power Constraint [dB] */
-} __packed;
-
-/*
- * Power Capability information element.
- */
-struct ieee80211_ie_pwrcap {
-	u_int8_t pc_id;			/* IEEE80211_ELEMID_PWRCAP */
-	u_int8_t pc_len;		/* == 2 */
-	int8_t pc_mintxpow;		/* Minimum Transmit Power Capability [dBm] */
-	int8_t pc_maxtxpow;		/* Maximum Transmit Power Capability [dBm] */
-} __packed;
-
-/*
- * Supported Channels information element.
- */
-#define IEEE80211_SUPPCHAN_MAX_PAIRS (127)
-struct ieee80211_ie_sc {
-	u_int8_t sc_id;			/* IEEE80211_ELEMID_SUPPCHAN */
-	u_int8_t sc_len;		/* == 2 * number of sc_subband elements */
-	struct {
-		u_int8_t sc_first;	/* First Channel Number */
-		u_int8_t sc_number;	/* Number of Channels */
-	} __packed sc_subband[IEEE80211_SUPPCHAN_MAX_PAIRS];
-} __packed;
-
-/*
- * Channel Switch Announcement information element.
- */
-struct ieee80211_ie_csa {
-	u_int8_t csa_id;	/* IEEE80211_ELEMID_CHANSWITCHANN */
-	u_int8_t csa_len;	/* == 3 */
-	u_int8_t csa_mode;	/* Channel Switch Mode: 1 == stop transmission until CS */
-	u_int8_t csa_chan;	/* New Channel Number */
-	u_int8_t csa_count;	/* TBTTs until Channel Switch happens */
-} __packed;
-
-/* minimal Channel Switch Count in the initial announcement */
-#define IEEE80211_CSA_PROTECTION_PERIOD 3
-
-/* maximum allowed deviance of measurement of intervals between CSA in Beacons */
-#define IEEE80211_CSA_SANITY_THRESHOLD 100
-
-
-/* does frame have QoS sequence control data */
-#define	IEEE80211_QOS_HAS_SEQ(wh) \
-	(((wh)->i_fc[0] & \
-	  (IEEE80211_FC0_TYPE_MASK | IEEE80211_FC0_SUBTYPE_QOS)) == \
-	  (IEEE80211_FC0_TYPE_DATA | IEEE80211_FC0_SUBTYPE_QOS))
-
-#define WME_QOSINFO_COUNT	0x0f  /* Mask for Param Set Count field */
-/*
- * WME/802.11e information element.
- */
-struct ieee80211_ie_wme {
-	u_int8_t wme_id;		/* IEEE80211_ELEMID_VENDOR */
-	u_int8_t wme_len;	/* length in bytes */
-	u_int8_t wme_oui[3];	/* 0x00, 0x50, 0xf2 */
-	u_int8_t wme_type;	/* OUI type */
-	u_int8_t wme_subtype;	/* OUI subtype */
-	u_int8_t wme_version;	/* spec revision */
-	u_int8_t wme_info;	/* QoS info */
-} __packed;
-
-/*
- * WME/802.11e Tspec Element
- */
-struct ieee80211_wme_tspec {
-	u_int8_t ts_id;
-	u_int8_t ts_len;
-	u_int8_t ts_oui[3];
-	u_int8_t ts_oui_type;
-	u_int8_t ts_oui_subtype;
-	u_int8_t ts_version;
-	u_int8_t ts_tsinfo[3];
-	u_int8_t ts_nom_msdu[2];
-	u_int8_t ts_max_msdu[2];
-	u_int8_t ts_min_svc[4];
-	u_int8_t ts_max_svc[4];
-	u_int8_t ts_inactv_intv[4];
-	u_int8_t ts_susp_intv[4];
-	u_int8_t ts_start_svc[4];
-	u_int8_t ts_min_rate[4];
-	u_int8_t ts_mean_rate[4];
-	u_int8_t ts_max_burst[4];
-	u_int8_t ts_min_phy[4];
-	u_int8_t ts_peak_rate[4];
-	u_int8_t ts_delay[4];
-	u_int8_t ts_surplus[2];
-	u_int8_t ts_medium_time[2];
-} __packed;
-
-/*
- * WME AC parameter field
- */
-
-struct ieee80211_wme_acparams {
-	u_int8_t acp_aci_aifsn;
-	u_int8_t acp_logcwminmax;
-	u_int16_t acp_txop;
-} __packed;
-
-#define IEEE80211_WME_PARAM_LEN 24
-#define WME_NUM_AC		4	/* 4 AC categories */
-
-#define WME_PARAM_ACI		0x60	/* Mask for ACI field */
-#define WME_PARAM_ACI_S		5	/* Shift for ACI field */
-#define WME_PARAM_ACM		0x10	/* Mask for ACM bit */
-#define WME_PARAM_ACM_S		4	/* Shift for ACM bit */
-#define WME_PARAM_AIFSN		0x0f	/* Mask for aifsn field */
-#define WME_PARAM_AIFSN_S	0	/* Shift for aifsn field */
-#define WME_PARAM_LOGCWMIN	0x0f	/* Mask for CwMin field (in log) */
-#define WME_PARAM_LOGCWMIN_S	0	/* Shift for CwMin field */
-#define WME_PARAM_LOGCWMAX	0xf0	/* Mask for CwMax field (in log) */
-#define WME_PARAM_LOGCWMAX_S	4	/* Shift for CwMax field */
-
-#define WME_AC_TO_TID(_ac) (       \
-	((_ac) == WME_AC_VO) ? 6 : \
-	((_ac) == WME_AC_VI) ? 5 : \
-	((_ac) == WME_AC_BK) ? 1 : \
-	0)
-
-#define TID_TO_WME_AC(_tid) (      \
-	((_tid) < 1) ? WME_AC_BE : \
-	((_tid) < 3) ? WME_AC_BK : \
-	((_tid) < 6) ? WME_AC_VI : \
-	WME_AC_VO)
-
-/*
- * WME Parameter Element
- */
-
-struct ieee80211_wme_param {
-	u_int8_t param_id;
-	u_int8_t param_len;
-	u_int8_t param_oui[3];
-	u_int8_t param_oui_type;
-	u_int8_t param_oui_sybtype;
-	u_int8_t param_version;
-	u_int8_t param_qosInfo;
-	u_int8_t param_reserved;
-	struct ieee80211_wme_acparams	params_acParams[WME_NUM_AC];
-} __packed;
-
-/*
- * WME U-APSD qos info field defines
- */
-#define WME_CAPINFO_UAPSD_EN			0x00000080
-#define WME_CAPINFO_UAPSD_VO			0x00000001
-#define WME_CAPINFO_UAPSD_VI			0x00000002
-#define WME_CAPINFO_UAPSD_BK			0x00000004
-#define WME_CAPINFO_UAPSD_BE			0x00000008
-#define WME_CAPINFO_UAPSD_ACFLAGS_SHIFT		0
-#define WME_CAPINFO_UAPSD_ACFLAGS_MASK		0xF
-#define WME_CAPINFO_UAPSD_MAXSP_SHIFT		5
-#define WME_CAPINFO_UAPSD_MAXSP_MASK		0x3
-#define WME_CAPINFO_IE_OFFSET			8
-#define WME_UAPSD_MAXSP(_qosinfo)					\
-		(((_qosinfo) >> WME_CAPINFO_UAPSD_MAXSP_SHIFT) & 	\
-		 WME_CAPINFO_UAPSD_MAXSP_MASK)
-#define WME_UAPSD_AC_ENABLED(_ac, _qosinfo)				\
-		((1 << (3 - (_ac))) & (					\
-		 ((_qosinfo) >> WME_CAPINFO_UAPSD_ACFLAGS_SHIFT) &	\
-		 WME_CAPINFO_UAPSD_ACFLAGS_MASK))
-
-/*
- * Atheros Advanced Capability information element.
- */
-struct ieee80211_ie_athAdvCap {
-	u_int8_t athAdvCap_id;		/* IEEE80211_ELEMID_VENDOR */
-	u_int8_t athAdvCap_len;		/* length in bytes */
-	u_int8_t athAdvCap_oui[3];	/* 0x00, 0x03, 0x7f */
-	u_int8_t athAdvCap_type;	/* OUI type */
-	u_int8_t athAdvCap_subtype;	/* OUI subtype */
-	u_int8_t athAdvCap_version;	/* spec revision */
-	u_int8_t athAdvCap_capability;	/* Capability info */
-	u_int16_t athAdvCap_defKeyIndex;
-} __packed;
-
-/*
- * Atheros XR information element.
- */
-struct ieee80211_xr_param {
-	u_int8_t param_id;
-	u_int8_t param_len;
-	u_int8_t param_oui[3];
-	u_int8_t param_oui_type;
-	u_int8_t param_oui_sybtype;
-	u_int8_t param_version;
-	u_int8_t param_Info;
-	u_int8_t param_base_bssid[IEEE80211_ADDR_LEN];
-	u_int8_t param_xr_bssid[IEEE80211_ADDR_LEN];
-	u_int16_t param_xr_beacon_interval;
-	u_int8_t param_base_ath_capability;
-	u_int8_t param_xr_ath_capability;
-} __packed;
-
-/* Atheros capabilities */
-#define IEEE80211_ATHC_TURBOP	0x0001		/* Turbo Prime */
-#define IEEE80211_ATHC_COMP	0x0002		/* Compression */
-#define IEEE80211_ATHC_FF	0x0004		/* Fast Frames */
-#define IEEE80211_ATHC_XR	0x0008		/* Xtended Range support */
-#define IEEE80211_ATHC_AR	0x0010		/* Advanced Radar support */
-#define IEEE80211_ATHC_BURST	0x0020		/* Bursting - not negotiated */
-#define IEEE80211_ATHC_WME	0x0040		/* CWMin tuning */
-#define IEEE80211_ATHC_BOOST	0x0080		/* Boost */
-
-/*
- * Management Notification Frame
- */
-struct ieee80211_mnf {
-	u_int8_t mnf_category;
-	u_int8_t mnf_action;
-	u_int8_t mnf_dialog;
-	u_int8_t mnf_status;
-} __packed;
-#define	MNF_SETUP_REQ	0
-#define	MNF_SETUP_RESP	1
-#define	MNF_TEARDOWN	2
-
-/*
- * Control frames.
- */
-struct ieee80211_frame_min {
-	u_int8_t i_fc[2];
-	__le16 i_dur;
-	u_int8_t i_addr1[IEEE80211_ADDR_LEN];
-	u_int8_t i_addr2[IEEE80211_ADDR_LEN];
-	/* FCS */
-} __packed;
-
-struct ieee80211_frame_rts {
-	u_int8_t i_fc[2];
-	__le16 i_dur;
-	u_int8_t i_ra[IEEE80211_ADDR_LEN];
-	u_int8_t i_ta[IEEE80211_ADDR_LEN];
-	/* FCS */
-} __packed;
-
-struct ieee80211_frame_cts {
-	u_int8_t i_fc[2];
-	__le16 i_dur;
-	u_int8_t i_ra[IEEE80211_ADDR_LEN];
-	/* FCS */
-} __packed;
-
-struct ieee80211_frame_ack {
-	u_int8_t i_fc[2];
-	__le16 i_dur;
-	u_int8_t i_ra[IEEE80211_ADDR_LEN];
-	/* FCS */
-} __packed;
-
-struct ieee80211_frame_pspoll {
-	u_int8_t i_fc[2];
-	u_int8_t i_aid[2];
-	u_int8_t i_bssid[IEEE80211_ADDR_LEN];
-	u_int8_t i_ta[IEEE80211_ADDR_LEN];
-	/* FCS */
-} __packed;
-
-struct ieee80211_frame_cfend {		/* NB: also CF-End+CF-Ack */
-	u_int8_t i_fc[2];
-	__le16 i_dur;	/* should be zero */
-	u_int8_t i_ra[IEEE80211_ADDR_LEN];
-	u_int8_t i_bssid[IEEE80211_ADDR_LEN];
-	/* FCS */
-} __packed;
-
-/*
- * BEACON management packets
- *
- *	octet timestamp[8]
- *	octet beacon interval[2]
- *	octet capability information[2]
- *	information element
- *		octet elemid
- *		octet length
- *		octet information[length]
- */
-
-typedef u_int8_t *ieee80211_mgt_beacon_t;
-
-#define	IEEE80211_BEACON_INTERVAL(beacon) \
-	((beacon)[8] | ((beacon)[9] << 8))
-#define	IEEE80211_BEACON_CAPABILITY(beacon) \
-	((beacon)[10] | ((beacon)[11] << 8))
-
-#define	IEEE80211_CAPINFO_ESS			0x0001
-#define	IEEE80211_CAPINFO_IBSS			0x0002
-#define	IEEE80211_CAPINFO_CF_POLLABLE		0x0004
-#define	IEEE80211_CAPINFO_CF_POLLREQ		0x0008
-#define	IEEE80211_CAPINFO_PRIVACY		0x0010
-#define	IEEE80211_CAPINFO_SHORT_PREAMBLE	0x0020
-#define	IEEE80211_CAPINFO_PBCC			0x0040
-#define	IEEE80211_CAPINFO_CHNL_AGILITY		0x0080
-/* bits 8-9 are reserved (8 now for spectrum management) */
-#define IEEE80211_CAPINFO_SPECTRUM_MGMT		0x0100
-#define	IEEE80211_CAPINFO_SHORT_SLOTTIME	0x0400
-#define	IEEE80211_CAPINFO_RSN			0x0800
-/* bit 12 is reserved */
-#define	IEEE80211_CAPINFO_DSSSOFDM		0x2000
-/* bits 14-15 are reserved */
-
-/*
- * 802.11i/WPA information element (maximally sized).
- */
-struct ieee80211_ie_wpa {
-	u_int8_t wpa_id;			/* IEEE80211_ELEMID_VENDOR */
-	u_int8_t wpa_len;		/* length in bytes */
-	u_int8_t wpa_oui[3];		/* 0x00, 0x50, 0xf2 */
-	u_int8_t wpa_type;		/* OUI type */
-	u_int16_t wpa_version;		/* spec revision */
-	u_int32_t wpa_mcipher[1];	/* multicast/group key cipher */
-	u_int16_t wpa_uciphercnt;	/* # pairwise key ciphers */
-	u_int32_t wpa_uciphers[8];	/* ciphers */
-	u_int16_t wpa_authselcnt;	/* authentication selector cnt*/
-	u_int32_t wpa_authsels[8];	/* selectors */
-	u_int16_t wpa_caps;		/* 802.11i capabilities */
-	u_int16_t wpa_pmkidcnt;		/* 802.11i pmkid count */
-	u_int16_t wpa_pmkids[8];	/* 802.11i pmkids */
-} __packed;
-
-/*
- * Management information element payloads.
- */
-
-enum {
-	IEEE80211_ELEMID_SSID		= 0,
-	IEEE80211_ELEMID_RATES		= 1,
-	IEEE80211_ELEMID_FHPARMS	= 2,
-	IEEE80211_ELEMID_DSPARMS	= 3,
-	IEEE80211_ELEMID_CFPARMS	= 4,
-	IEEE80211_ELEMID_TIM		= 5,
-	IEEE80211_ELEMID_IBSSPARMS	= 6,
-	IEEE80211_ELEMID_COUNTRY	= 7,
-	IEEE80211_ELEMID_HOPPATRNPARMS  = 8,
-	IEEE80211_ELEMID_HOPPATRNTABLE  = 9,
-	IEEE80211_ELEMID_REQINFO	= 10,
-	IEEE80211_ELEMID_QBSSLOAD       = 11,
-	IEEE80211_ELEMID_EDCAPARAM      = 12,
-	IEEE80211_ELEMID_TSPEC		= 13,
-	IEEE80211_ELEMID_TRAFCLASS      = 14,
-	IEEE80211_ELEMID_SCHEDULE       = 15,
-	IEEE80211_ELEMID_CHALLENGE	= 16,
-	/* 17-31 reserved for challenge text extension */
-	IEEE80211_ELEMID_PWRCNSTR	= 32,
-	IEEE80211_ELEMID_PWRCAP		= 33,
-	IEEE80211_ELEMID_TPCREQ		= 34,
-	IEEE80211_ELEMID_TPCREP		= 35,
-	IEEE80211_ELEMID_SUPPCHAN	= 36,
-	IEEE80211_ELEMID_CHANSWITCHANN	= 37,
-	IEEE80211_ELEMID_MEASREQ	= 38,
-	IEEE80211_ELEMID_MEASREP	= 39,
-	IEEE80211_ELEMID_QUIET		= 40,
-	IEEE80211_ELEMID_IBSSDFS	= 41,
-	IEEE80211_ELEMID_ERP		= 42,
-	IEEE80211_ELEMID_TSDELAY	= 43,
-	IEEE80211_ELEMID_TCLASSPROC     = 44,
-	IEEE80211_ELEMID_QOS		= 46,
-	IEEE80211_ELEMID_RSN		= 48,
-	/* 49 reserved */
-	IEEE80211_ELEMID_XRATES		= 50,
-	/* 128-129 proprietary elements used by Agere chipsets */
-	IEEE80211_ELEMID_AGERE1		= 128,
-	IEEE80211_ELEMID_AGERE2		= 129,
-	IEEE80211_ELEMID_TPC		= 150,
-	IEEE80211_ELEMID_CCKM		= 156,
-	IEEE80211_ELEMID_VENDOR		= 221,	/* vendor private */
-};
-
-#define IEEE80211_CHANSWITCHANN_BYTES 	5
-#define BITCTL_BUFD_MCAST       	1
-#define BITCTL_BUFD_UCAST_AID_MASK 	((u_int8_t)~(BITCTL_BUFD_MCAST))
-#define BITCTL_BUFD_UCAST_AID_SHIFT 	1
-
-struct ieee80211_tim_ie {
-	u_int8_t	tim_ie;			/* IEEE80211_ELEMID_TIM */
-	u_int8_t	tim_len;
-	u_int8_t	tim_count;		/* DTIM count */
-	u_int8_t	tim_period;		/* DTIM period */
-	u_int8_t	tim_bitctl;		/* bitmap control */
-	u_int8_t	tim_bitmap[1];		/* variable-length bitmap */
-} __packed;
-
-struct ieee80211_country_ie {
-	u_int8_t	ie;			/* IEEE80211_ELEMID_COUNTRY */
-	u_int8_t	len;
-	u_int8_t	cc[3];			/* ISO CC+(I)ndoor/(O)utdoor */
-	struct {
-		u_int8_t schan;			/* starting channel */
-		u_int8_t nchan;			/* number channels */
-		u_int8_t maxtxpwr;		/* tx power cap */
-	} __packed band[4];			/* up to 4 sub bands */
-} __packed;
-
-#define IEEE80211_CHALLENGE_LEN		128
-
-#define IEEE80211_SUPPCHAN_LEN		26
-
-#define	IEEE80211_RATE_BASIC		0x80
-#define	IEEE80211_RATE_VAL		0x7f
-
-/* EPR information element flags */
-#define	IEEE80211_ERP_NON_ERP_PRESENT	0x01
-#define	IEEE80211_ERP_USE_PROTECTION	0x02
-#define	IEEE80211_ERP_LONG_PREAMBLE	0x04
-
-/* Atheros private advanced capabilities info */
-#define	ATHEROS_CAP_TURBO_PRIME		0x01
-#define	ATHEROS_CAP_COMPRESSION		0x02
-#define	ATHEROS_CAP_FAST_FRAME		0x04
-/* bits 3-6 reserved */
-#define	ATHEROS_CAP_BOOST		0x80
-
-#define	ATH_OUI			0x7f0300		/* Atheros OUI */
-#define	ATH_OUI_TYPE		0x01
-#define	ATH_OUI_SUBTYPE		0x01
-#define	ATH_OUI_VERSION		0x00
-#define	ATH_OUI_TYPE_XR		0x03
-#define	ATH_OUI_SUBTYPE_XR	0x01
-#define	ATH_OUI_VER_XR		0x00
-
-#define	WPA_OUI			0xf25000
-#define	WPA_OUI_TYPE		0x01
-#define	WPA_VERSION		1		/* current supported version */
-
-#define	WPA_CSE_NULL		0x00
-#define	WPA_CSE_WEP40		0x01
-#define	WPA_CSE_TKIP		0x02
-#define	WPA_CSE_CCMP		0x04
-#define	WPA_CSE_WEP104		0x05
-
-#define	WPA_ASE_NONE		0x00
-#define	WPA_ASE_8021X_UNSPEC	0x01
-#define	WPA_ASE_8021X_PSK	0x02
-
-#define	RSN_OUI			0xac0f00
-#define	RSN_VERSION		1		/* current supported version */
-
-#define	RSN_CSE_NULL		0x00
-#define	RSN_CSE_WEP40		0x01
-#define	RSN_CSE_TKIP		0x02
-#define	RSN_CSE_WRAP		0x03
-#define	RSN_CSE_CCMP		0x04
-#define	RSN_CSE_WEP104		0x05
-
-#define	RSN_ASE_NONE		0x00
-#define	RSN_ASE_8021X_UNSPEC	0x01
-#define	RSN_ASE_8021X_PSK	0x02
-
-#define	RSN_CAP_PREAUTH		0x01
-
-#define	WME_OUI			0xf25000
-#define	WME_OUI_TYPE		0x02
-#define	WME_INFO_OUI_SUBTYPE	0x00
-#define	WME_PARAM_OUI_SUBTYPE	0x01
-#define	WME_VERSION		1
-
-/* WME stream classes */
-#define	WME_AC_BE	0		/* best effort */
-#define	WME_AC_BK	1		/* background */
-#define	WME_AC_VI	2		/* video */
-#define	WME_AC_VO	3		/* voice */
-
-/*
- * AUTH management packets
- *
- *	octet algo[2]
- *	octet seq[2]
- *	octet status[2]
- *	octet chal.id
- *	octet chal.length
- *	octet chal.text[253]
- */
-
-typedef u_int8_t *ieee80211_mgt_auth_t;
-
-#define	IEEE80211_AUTH_ALGORITHM(auth) \
-	((auth)[0] | ((auth)[1] << 8))
-#define	IEEE80211_AUTH_TRANSACTION(auth) \
-	((auth)[2] | ((auth)[3] << 8))
-#define	IEEE80211_AUTH_STATUS(auth) \
-	((auth)[4] | ((auth)[5] << 8))
-
-#define	IEEE80211_AUTH_ALG_OPEN		0x0000
-#define	IEEE80211_AUTH_ALG_SHARED	0x0001
-#define	IEEE80211_AUTH_ALG_LEAP		0x0080
-
-enum {
-	IEEE80211_AUTH_OPEN_REQUEST		= 1,
-	IEEE80211_AUTH_OPEN_RESPONSE		= 2,
-};
-
-enum {
-	IEEE80211_AUTH_SHARED_REQUEST		= 1,
-	IEEE80211_AUTH_SHARED_CHALLENGE		= 2,
-	IEEE80211_AUTH_SHARED_RESPONSE		= 3,
-	IEEE80211_AUTH_SHARED_PASS		= 4,
-};
-
-/*
- * Reason codes
- *
- * Unlisted codes are reserved
- */
-
-enum {
-	IEEE80211_REASON_UNSPECIFIED		= 1,
-	IEEE80211_REASON_AUTH_EXPIRE		= 2,
-	IEEE80211_REASON_AUTH_LEAVE		= 3,
-	IEEE80211_REASON_ASSOC_EXPIRE		= 4,
-	IEEE80211_REASON_ASSOC_TOOMANY		= 5,
-	IEEE80211_REASON_NOT_AUTHED		= 6,
-	IEEE80211_REASON_NOT_ASSOCED		= 7,
-	IEEE80211_REASON_ASSOC_LEAVE		= 8,
-	IEEE80211_REASON_ASSOC_NOT_AUTHED	= 9,
-
-	IEEE80211_REASON_PWRCAP_UNACCEPTABLE	= 10,
-	IEEE80211_REASON_SUPPCHAN_UNACCEPTABLE	= 11,
-	IEEE80211_REASON_RSN_REQUIRED		= 11,
-	IEEE80211_REASON_RSN_INCONSISTENT	= 12,
-	IEEE80211_REASON_IE_INVALID		= 13,
-	IEEE80211_REASON_MIC_FAILURE		= 14,
-
-	IEEE80211_STATUS_SUCCESS		= 0,
-	IEEE80211_STATUS_UNSPECIFIED		= 1,
-	IEEE80211_STATUS_CAPINFO		= 10,
-	IEEE80211_STATUS_NOT_ASSOCED		= 11,
-	IEEE80211_STATUS_OTHER			= 12,
-	IEEE80211_STATUS_ALG			= 13,
-	IEEE80211_STATUS_SEQUENCE		= 14,
-	IEEE80211_STATUS_CHALLENGE		= 15,
-	IEEE80211_STATUS_TIMEOUT		= 16,
-	IEEE80211_STATUS_TOOMANY		= 17,
-	IEEE80211_STATUS_BASIC_RATE		= 18,
-	IEEE80211_STATUS_SP_REQUIRED		= 19,
-	IEEE80211_STATUS_PBCC_REQUIRED		= 20,
-	IEEE80211_STATUS_CA_REQUIRED		= 21,
-	IEEE80211_STATUS_SM_REQUIRED		= 22,
-	IEEE80211_STATUS_PWRCAP_UNACCEPTABLE	= 23,
-	IEEE80211_STATUS_SUPPCHAN_UNACCEPTABLE	= 24,
-	IEEE80211_STATUS_TOO_MANY_STATIONS	= 22,
-	IEEE80211_STATUS_RATES			= 23,
-	IEEE80211_STATUS_SHORTSLOT_REQUIRED	= 25,
-	IEEE80211_STATUS_DSSSOFDM_REQUIRED	= 26,
-};
-
-#define	IEEE80211_WEP_KEYLEN		5	/* 40bit */
-#define	IEEE80211_WEP_IVLEN		3	/* 24bit */
-#define	IEEE80211_WEP_KIDLEN		1	/* 1 octet */
-#define	IEEE80211_WEP_CRCLEN		4	/* CRC-32 */
-#define	IEEE80211_WEP_NKID		4	/* number of key ids */
-
-/*
- * 802.11i defines an extended IV for use with non-WEP ciphers.
- * When the EXTIV bit is set in the key id byte an additional
- * 4 bytes immediately follow the IV for TKIP.  For CCMP the
- * EXTIV bit is likewise set but the 8 bytes represent the
- * CCMP header rather than IV+extended-IV.
- */
-#define	IEEE80211_WEP_EXTIV		0x20
-#define	IEEE80211_WEP_EXTIVLEN		4	/* extended IV length */
-#define	IEEE80211_WEP_MICLEN		8	/* trailing MIC */
-
-#define	IEEE80211_CRC_LEN		4
-
-/*
- * Maximum acceptable MTU is:
- *	IEEE80211_MAX_LEN - WEP overhead - CRC -
- *		QoS overhead - RSN/WPA overhead
- * Min is arbitrarily chosen > IEEE80211_MIN_LEN.  The default
- * mtu is Ethernet-compatible; it's set by ether_ifattach.
- */
-#define	IEEE80211_MTU_MAX		2290
-#define	IEEE80211_MTU_MIN		32
-
-#define	IEEE80211_MAX_LEN		(2300 + IEEE80211_CRC_LEN + \
-	(IEEE80211_WEP_IVLEN + IEEE80211_WEP_KIDLEN + IEEE80211_WEP_CRCLEN))
-#define	IEEE80211_ACK_LEN \
-	(sizeof(struct ieee80211_frame_ack) + IEEE80211_CRC_LEN)
-#define	IEEE80211_MIN_LEN \
-	(sizeof(struct ieee80211_frame_min) + IEEE80211_CRC_LEN)
-
-/*
- * The 802.11 spec says at most 2007 stations may be
- * associated at once.  For most APs this is way more
- * than is feasible so we use a default of 128.  This
- * number may be overridden by the driver and/or by
- * user configuration.
- */
-#define	IEEE80211_AID_MAX		2007
-#define	IEEE80211_AID_DEF		128
-
-#define	IEEE80211_AID(b)	((b) &~ 0xc000)
-
-/* 
- * RTS frame length parameters.  The default is specified in
- * the 802.11 spec.  The max may be wrong for jumbo frames.
- */
-#define	IEEE80211_RTS_DEFAULT		512
-#define	IEEE80211_RTS_MIN		1
-#define	IEEE80211_RTS_MAX		2346
-
-/* 
- * Regulatory extension identifier for country IE.
- */
-#define IEEE80211_REG_EXT_ID		201
-
-/*
- * IEEE 802.11 timer synchronization function (TSF) timestamp length
- */
-#define IEEE80211_TSF_LEN		8
-
-#endif /* _NET80211_IEEE80211_H_ */
diff --git a/package/hostapd/madwifi/net80211/ieee80211_crypto.h b/package/hostapd/madwifi/net80211/ieee80211_crypto.h
deleted file mode 100644
index b34f359..0000000
--- a/package/hostapd/madwifi/net80211/ieee80211_crypto.h
+++ /dev/null
@@ -1,207 +0,0 @@
-/*-
- * Copyright (c) 2001 Atsushi Onoe
- * Copyright (c) 2002-2005 Sam Leffler, Errno Consulting
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * Alternatively, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") version 2 as published by the Free
- * Software Foundation.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- *
- * $Id: ieee80211_crypto.h 3068 2007-12-21 17:46:02Z mentor $
- */
-#ifndef _NET80211_IEEE80211_CRYPTO_H_
-#define _NET80211_IEEE80211_CRYPTO_H_
-
-/*
- * 802.11 protocol crypto-related definitions.
- */
-#define	IEEE80211_KEYBUF_SIZE	16
-#define	IEEE80211_MICBUF_SIZE	(8 + 8)		/* space for both TX & RX keys */
-#define IEEE80211_TID_SIZE	17		/* total number of TIDs */
-
-/*
- * Old WEP-style key.  Deprecated.
- */
-struct ieee80211_wepkey {
-	u_int wk_len;				/* key length in bytes */
-	u_int8_t wk_key[IEEE80211_KEYBUF_SIZE];
-};
-
-struct ieee80211_cipher;
-
-/*
- * Crypto key state.  There is sufficient room for all supported
- * ciphers (see below).  The underlying ciphers are handled
- * separately through loadable cipher modules that register with
- * the generic crypto support.  A key has a reference to an instance
- * of the cipher; any per-key state is hung off wk_private by the
- * cipher when it is attached.  Ciphers are automatically called
- * to detach and cleanup any such state when the key is deleted.
- *
- * The generic crypto support handles encap/decap of cipher-related
- * frame contents for both hardware- and software-based implementations.
- * A key requiring software crypto support is automatically flagged and
- * the cipher is expected to honor this and do the necessary work.
- * Ciphers such as TKIP may also support mixed hardware/software
- * encrypt/decrypt and MIC processing.
- */
-
-typedef u_int16_t ieee80211_keyix_t;
-
-/* XXX pack better? */
-/* XXX 48-bit rsc/tsc */
-struct ieee80211_key {
-	u_int8_t wk_keylen;		/* key length in bytes */
-	u_int8_t wk_flags;
-#define	IEEE80211_KEY_XMIT	0x01	/* key used for xmit */
-#define	IEEE80211_KEY_RECV	0x02	/* key used for recv */
-#define	IEEE80211_KEY_GROUP	0x04	/* key used for WPA group operation */
-#define	IEEE80211_KEY_SWCRYPT	0x10	/* host-based encrypt/decrypt */
-#define	IEEE80211_KEY_SWMIC	0x20	/* host-based enmic/demic */
-	ieee80211_keyix_t wk_keyix;	/* key index */
-	u_int8_t wk_key[IEEE80211_KEYBUF_SIZE+IEEE80211_MICBUF_SIZE];
-#define	wk_txmic	wk_key+IEEE80211_KEYBUF_SIZE+0	/* XXX can't () right */
-#define	wk_rxmic	wk_key+IEEE80211_KEYBUF_SIZE+8	/* XXX can't () right */
-	u_int64_t wk_keyrsc[IEEE80211_TID_SIZE];	/* key receive sequence counter */
-	u_int64_t wk_keytsc;		/* key transmit sequence counter */
-	const struct ieee80211_cipher *wk_cipher;
-	void *wk_private;		/* private cipher state */
-};
-#define	IEEE80211_KEY_COMMON 		/* common flags passed in by apps */\
-	(IEEE80211_KEY_XMIT | IEEE80211_KEY_RECV | IEEE80211_KEY_GROUP)
-
-/*
- * NB: these values are ordered carefully; there are lots of
- * of implications in any reordering.  In particular beware
- * that 4 is not used to avoid conflicting with IEEE80211_F_PRIVACY.
- */
-#define	IEEE80211_CIPHER_WEP		0
-#define	IEEE80211_CIPHER_TKIP		1
-#define	IEEE80211_CIPHER_AES_OCB	2
-#define	IEEE80211_CIPHER_AES_CCM	3
-#define	IEEE80211_CIPHER_CKIP		5
-#define	IEEE80211_CIPHER_NONE		6	/* pseudo value */
-
-#define	IEEE80211_CIPHER_MAX		(IEEE80211_CIPHER_NONE + 1)
-
-#define	IEEE80211_KEYIX_NONE	((ieee80211_keyix_t)-1)
-
-#if defined(__KERNEL__) || defined(_KERNEL)
-
-struct ieee80211com;
-struct ieee80211vap;
-struct ieee80211_node;
-struct sk_buff;
-
-void ieee80211_crypto_attach(struct ieee80211com *);
-void ieee80211_crypto_detach(struct ieee80211com *);
-void ieee80211_crypto_vattach(struct ieee80211vap *);
-void ieee80211_crypto_vdetach(struct ieee80211vap *);
-int ieee80211_crypto_newkey(struct ieee80211vap *, int, int,
-	struct ieee80211_key *);
-int ieee80211_crypto_delkey(struct ieee80211vap *, struct ieee80211_key *,
-	struct ieee80211_node *);
-int ieee80211_crypto_setkey(struct ieee80211vap *, struct ieee80211_key *,
-	const u_int8_t macaddr[IEEE80211_ADDR_LEN], struct ieee80211_node *);
-void ieee80211_crypto_delglobalkeys(struct ieee80211vap *);
-
-/*
- * Template for a supported cipher.  Ciphers register with the
- * crypto code and are typically loaded as separate modules
- * (the null cipher is always present).
- * XXX may need refcnts
- */
-struct ieee80211_cipher {
-	const char *ic_name;		/* printable name */
-	u_int ic_cipher;		/* IEEE80211_CIPHER_* */
-	u_int ic_header;		/* size of privacy header (bytes) */
-	u_int ic_trailer;		/* size of privacy trailer (bytes) */
-	u_int ic_miclen;		/* size of mic trailer (bytes) */
-	void *(*ic_attach)(struct ieee80211vap *, struct ieee80211_key *);
-	void (*ic_detach)(struct ieee80211_key *);
-	int (*ic_setkey)(struct ieee80211_key *);
-	int (*ic_encap)(struct ieee80211_key *, struct sk_buff *, u_int8_t);
-	int (*ic_decap)(struct ieee80211_key *, struct sk_buff *, int);
-	int (*ic_enmic)(struct ieee80211_key *, struct sk_buff *, int);
-	int (*ic_demic)(struct ieee80211_key *, struct sk_buff *, int, int);
-};
-extern const struct ieee80211_cipher ieee80211_cipher_none;
-
-void ieee80211_crypto_register(const struct ieee80211_cipher *);
-void ieee80211_crypto_unregister(const struct ieee80211_cipher *);
-int ieee80211_crypto_available(struct ieee80211vap*, u_int);
-
-struct ieee80211_key *ieee80211_crypto_encap(struct ieee80211_node *,
-	struct sk_buff *);
-struct ieee80211_key *ieee80211_crypto_decap(struct ieee80211_node *,
-	struct sk_buff *, int);
-
-/*
- * Check and remove any MIC.
- */
-static __inline int
-ieee80211_crypto_demic(struct ieee80211vap *vap, struct ieee80211_key *k,
-	struct sk_buff *skb, int hdrlen, int force)
-{
-	const struct ieee80211_cipher *cip = k->wk_cipher;
-	return (cip->ic_miclen > 0 ? cip->ic_demic(k, skb, hdrlen, force) : 1);
-}
-
-/*
- * Add any MIC.
- */
-static __inline int
-ieee80211_crypto_enmic(struct ieee80211vap *vap, struct ieee80211_key *k,
-	struct sk_buff *skb, int force)
-{
-	const struct ieee80211_cipher *cip = k->wk_cipher;
-	return (cip->ic_miclen > 0 ? cip->ic_enmic(k, skb, force) : 1);
-}
-
-/* 
- * Reset key state to an unused state.  The crypto
- * key allocation mechanism ensures other state (e.g.
- * key data) is properly setup before a key is used.
- */
-static __inline void
-ieee80211_crypto_resetkey(struct ieee80211vap *vap, struct ieee80211_key *k,
-	ieee80211_keyix_t ix)
-{
-	k->wk_cipher = &ieee80211_cipher_none;;
-	k->wk_private = k->wk_cipher->ic_attach(vap, k);
-	k->wk_keyix = ix;
-	k->wk_flags = IEEE80211_KEY_XMIT | IEEE80211_KEY_RECV;
-}
-
-/*
- * Crypto-related notification methods.
- */
-void ieee80211_notify_replay_failure(struct ieee80211vap *,
-	const struct ieee80211_frame *, const struct ieee80211_key *,
-	u_int64_t rsc);
-void ieee80211_notify_michael_failure(struct ieee80211vap *,
-	const struct ieee80211_frame *, ieee80211_keyix_t keyix);
-#endif /* defined(__KERNEL__) || defined(_KERNEL) */
-#endif /* _NET80211_IEEE80211_CRYPTO_H_ */
diff --git a/package/hostapd/madwifi/net80211/ieee80211_ioctl.h b/package/hostapd/madwifi/net80211/ieee80211_ioctl.h
deleted file mode 100644
index 204303b..0000000
--- a/package/hostapd/madwifi/net80211/ieee80211_ioctl.h
+++ /dev/null
@@ -1,715 +0,0 @@
-/*-
- * Copyright (c) 2001 Atsushi Onoe
- * Copyright (c) 2002-2005 Sam Leffler, Errno Consulting
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * Alternatively, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") version 2 as published by the Free
- * Software Foundation.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- *
- * $Id: ieee80211_ioctl.h 3314 2008-01-30 23:50:16Z mtaylor $
- */
-#ifndef _NET80211_IEEE80211_IOCTL_H_
-#define _NET80211_IEEE80211_IOCTL_H_
-
-/*
- * IEEE 802.11 ioctls.
- */
-#include <net80211/_ieee80211.h>
-#include <net80211/ieee80211.h>
-#include <net80211/ieee80211_crypto.h>
-
-/*
- * Per/node (station) statistics available when operating as an AP.
- */
-struct ieee80211_nodestats {
-	u_int32_t ns_rx_data;		/* rx data frames */
-	u_int32_t ns_rx_mgmt;		/* rx management frames */
-	u_int32_t ns_rx_ctrl;		/* rx control frames */
-	u_int32_t ns_rx_ucast;		/* rx unicast frames */
-	u_int32_t ns_rx_mcast;		/* rx multi/broadcast frames */
-	u_int64_t ns_rx_bytes;		/* rx data count (bytes) */
-	u_int64_t ns_rx_beacons;		/* rx beacon frames */
-	u_int32_t ns_rx_proberesp;	/* rx probe response frames */
-
-	u_int32_t ns_rx_dup;		/* rx discard because it's a dup */
-	u_int32_t ns_rx_noprivacy;	/* rx w/ wep but privacy off */
-	u_int32_t ns_rx_wepfail;		/* rx wep processing failed */
-	u_int32_t ns_rx_demicfail;	/* rx demic failed */
-	u_int32_t ns_rx_decap;		/* rx decapsulation failed */
-	u_int32_t ns_rx_defrag;		/* rx defragmentation failed */
-	u_int32_t ns_rx_disassoc;	/* rx disassociation */
-	u_int32_t ns_rx_deauth;		/* rx deauthentication */
-	u_int32_t ns_rx_decryptcrc;	/* rx decrypt failed on crc */
-	u_int32_t ns_rx_unauth;		/* rx on unauthorized port */
-	u_int32_t ns_rx_unencrypted;	/* rx unecrypted w/ privacy */
-
-	u_int32_t ns_tx_data;		/* tx data frames */
-	u_int32_t ns_tx_mgmt;		/* tx management frames */
-	u_int32_t ns_tx_ucast;		/* tx unicast frames */
-	u_int32_t ns_tx_mcast;		/* tx multi/broadcast frames */
-	u_int64_t ns_tx_bytes;		/* tx data count (bytes) */
-	u_int32_t ns_tx_probereq;	/* tx probe request frames */
-	u_int32_t ns_tx_uapsd;		/* tx on uapsd queue */
-
-	u_int32_t ns_tx_novlantag;	/* tx discard due to no tag */
-	u_int32_t ns_tx_vlanmismatch;	/* tx discard due to of bad tag */
-
-	u_int32_t ns_tx_eosplost;	/* uapsd EOSP retried out */
-
-	u_int32_t ns_ps_discard;		/* ps discard due to of age */
-
-	u_int32_t ns_uapsd_triggers;	/* uapsd triggers */
-
-	/* MIB-related state */
-	u_int32_t ns_tx_assoc;		/* [re]associations */
-	u_int32_t ns_tx_assoc_fail;	/* [re]association failures */
-	u_int32_t ns_tx_auth;		/* [re]authentications */
-	u_int32_t ns_tx_auth_fail;	/* [re]authentication failures*/
-	u_int32_t ns_tx_deauth;		/* deauthentications */
-	u_int32_t ns_tx_deauth_code;	/* last deauth reason */
-	u_int32_t ns_tx_disassoc;	/* disassociations */
-	u_int32_t ns_tx_disassoc_code;	/* last disassociation reason */
-	u_int32_t ns_psq_drops;		/* power save queue drops */
-};
-
-/*
- * Summary statistics.
- */
-struct ieee80211_stats {
-	u_int32_t is_rx_badversion;	/* rx frame with bad version */
-	u_int32_t is_rx_tooshort;	/* rx frame too short */
-	u_int32_t is_rx_wrongbss;	/* rx from wrong bssid */
-	u_int32_t is_rx_dup;		/* rx discard due to it's a dup */
-	u_int32_t is_rx_wrongdir;	/* rx w/ wrong direction */
-	u_int32_t is_rx_mcastecho;	/* rx discard due to of mcast echo */
-	u_int32_t is_rx_mcastdisabled;	/* rx discard due to of mcast disabled */
-	u_int32_t is_rx_notassoc;	/* rx discard due to sta !assoc */
-	u_int32_t is_rx_noprivacy;	/* rx w/ wep but privacy off */
-	u_int32_t is_rx_unencrypted;	/* rx w/o wep and privacy on */
-	u_int32_t is_rx_wepfail;		/* rx wep processing failed */
-	u_int32_t is_rx_decap;		/* rx decapsulation failed */
-	u_int32_t is_rx_mgtdiscard;	/* rx discard mgt frames */
-	u_int32_t is_rx_ctl;		/* rx discard ctrl frames */
-	u_int32_t is_rx_beacon;		/* rx beacon frames */
-	u_int32_t is_rx_rstoobig;	/* rx rate set truncated */
-	u_int32_t is_rx_elem_missing;	/* rx required element missing*/
-	u_int32_t is_rx_elem_toobig;	/* rx element too big */
-	u_int32_t is_rx_elem_toosmall;	/* rx element too small */
-	u_int32_t is_rx_elem_unknown;	/* rx element unknown */
-	u_int32_t is_rx_badchan;		/* rx frame w/ invalid chan */
-	u_int32_t is_rx_chanmismatch;	/* rx frame chan mismatch */
-	u_int32_t is_rx_nodealloc;	/* rx frame dropped */
-	u_int32_t is_rx_ssidmismatch;	/* rx frame ssid mismatch  */
-	u_int32_t is_rx_auth_unsupported;/* rx w/ unsupported auth alg */
-	u_int32_t is_rx_auth_fail;	/* rx sta auth failure */
-	u_int32_t is_rx_auth_countermeasures;/* rx auth discard due to CM */
-	u_int32_t is_rx_assoc_bss;	/* rx assoc from wrong bssid */
-	u_int32_t is_rx_assoc_notauth;	/* rx assoc w/o auth */
-	u_int32_t is_rx_assoc_capmismatch;/* rx assoc w/ cap mismatch */
-	u_int32_t is_rx_assoc_norate;	/* rx assoc w/ no rate match */
-	u_int32_t is_rx_assoc_badwpaie;	/* rx assoc w/ bad WPA IE */
-	u_int32_t is_rx_assoc_badscie;	/* rx assoc w/ bad SC IE */
-	u_int32_t is_rx_deauth;		/* rx deauthentication */
-	u_int32_t is_rx_disassoc;	/* rx disassociation */
-	u_int32_t is_rx_badsubtype;	/* rx frame w/ unknown subtype*/
-	u_int32_t is_rx_nobuf;		/* rx failed for lack of buf */
-	u_int32_t is_rx_decryptcrc;	/* rx decrypt failed on crc */
-	u_int32_t is_rx_ahdemo_mgt;	/* rx discard ahdemo mgt frame*/
-	u_int32_t is_rx_bad_auth;	/* rx bad auth request */
-	u_int32_t is_rx_unauth;		/* rx on unauthorized port */
-	u_int32_t is_rx_badkeyid;	/* rx w/ incorrect keyid */
-	u_int32_t is_rx_ccmpreplay;	/* rx seq# violation (CCMP) */
-	u_int32_t is_rx_ccmpformat;	/* rx format bad (CCMP) */
-	u_int32_t is_rx_ccmpmic;		/* rx MIC check failed (CCMP) */
-	u_int32_t is_rx_tkipreplay;	/* rx seq# violation (TKIP) */
-	u_int32_t is_rx_tkipformat;	/* rx format bad (TKIP) */
-	u_int32_t is_rx_tkipmic;		/* rx MIC check failed (TKIP) */
-	u_int32_t is_rx_tkipicv;		/* rx ICV check failed (TKIP) */
-	u_int32_t is_rx_badcipher;	/* rx failed due to of key type */
-	u_int32_t is_rx_nocipherctx;	/* rx failed due to key !setup */
-	u_int32_t is_rx_acl;		/* rx discard due to of acl policy */
-	u_int32_t is_rx_ffcnt;		/* rx fast frames */
-	u_int32_t is_rx_badathtnl;   	/* driver key alloc failed */
-	u_int32_t is_tx_nobuf;		/* tx failed for lack of buf */
-	u_int32_t is_tx_nonode;		/* tx failed for no node */
-	u_int32_t is_tx_unknownmgt;	/* tx of unknown mgt frame */
-	u_int32_t is_tx_badcipher;	/* tx failed due to of key type */
-	u_int32_t is_tx_nodefkey;	/* tx failed due to no defkey */
-	u_int32_t is_tx_noheadroom;	/* tx failed due to no space */
-	u_int32_t is_tx_ffokcnt;		/* tx fast frames sent success */
-	u_int32_t is_tx_fferrcnt;	/* tx fast frames sent success */
-	u_int32_t is_scan_active;	/* active scans started */
-	u_int32_t is_scan_passive;	/* passive scans started */
-	u_int32_t is_node_timeout;	/* nodes timed out inactivity */
-	u_int32_t is_node_fdisassoc;	/* forced node disassociation */
-	u_int32_t is_crypto_nomem;	/* no memory for crypto ctx */
-	u_int32_t is_crypto_tkip;	/* tkip crypto done in s/w */
-	u_int32_t is_crypto_tkipenmic;	/* tkip en-MIC done in s/w */
-	u_int32_t is_crypto_tkipdemic;	/* tkip de-MIC done in s/w */
-	u_int32_t is_crypto_tkipcm;	/* tkip counter measures */
-	u_int32_t is_crypto_ccmp;	/* ccmp crypto done in s/w */
-	u_int32_t is_crypto_wep;		/* wep crypto done in s/w */
-	u_int32_t is_crypto_setkey_cipher;/* cipher rejected key */
-	u_int32_t is_crypto_setkey_nokey;/* no key index for setkey */
-	u_int32_t is_crypto_delkey;	/* driver key delete failed */
-	u_int32_t is_crypto_badcipher;	/* unknown cipher */
-	u_int32_t is_crypto_nocipher;	/* cipher not available */
-	u_int32_t is_crypto_attachfail;	/* cipher attach failed */
-	u_int32_t is_crypto_swfallback;	/* cipher fallback to s/w */
-	u_int32_t is_crypto_keyfail;	/* driver key alloc failed */
-	u_int32_t is_crypto_enmicfail;	/* en-MIC failed */
-	u_int32_t is_ibss_capmismatch;	/* merge failed-cap mismatch */
-	u_int32_t is_ibss_norate;	/* merge failed-rate mismatch */
-	u_int32_t is_ps_unassoc;		/* ps-poll for unassoc. sta */
-	u_int32_t is_ps_badaid;		/* ps-poll w/ incorrect aid */
-	u_int32_t is_ps_qempty;		/* ps-poll w/ nothing to send */
-};
-
-/*
- * Max size of optional information elements.  We artificially
- * constrain this; it's limited only by the max frame size (and
- * the max parameter size of the wireless extensions).
- */
-#define	IEEE80211_MAX_OPT_IE	256
-
-/*
- * WPA/RSN get/set key request.  Specify the key/cipher
- * type and whether the key is to be used for sending and/or
- * receiving.  The key index should be set only when working
- * with global keys (use IEEE80211_KEYIX_NONE for ``no index'').
- * Otherwise a unicast/pairwise key is specified by the bssid
- * (on a station) or mac address (on an ap).  They key length
- * must include any MIC key data; otherwise it should be no
- more than IEEE80211_KEYBUF_SIZE.
- */
-struct ieee80211req_key {
-	u_int8_t ik_type;		/* key/cipher type */
-	u_int8_t ik_pad;
-	ieee80211_keyix_t ik_keyix;	/* key index */
-	u_int8_t ik_keylen;		/* key length in bytes */
-	u_int8_t ik_flags;
-/* NB: IEEE80211_KEY_XMIT and IEEE80211_KEY_RECV defined elsewhere */
-#define	IEEE80211_KEY_DEFAULT	0x80	/* default xmit key */
-	u_int8_t ik_macaddr[IEEE80211_ADDR_LEN];
-	u_int64_t ik_keyrsc;		/* key receive sequence counter */
-	u_int64_t ik_keytsc;		/* key transmit sequence counter */
-	u_int8_t ik_keydata[IEEE80211_KEYBUF_SIZE+IEEE80211_MICBUF_SIZE];
-};
-
-/*
- * Delete a key either by index or address.  Set the index
- * to IEEE80211_KEYIX_NONE when deleting a unicast key.
- */
-struct ieee80211req_del_key {
-	/* NB: This is different to ieee80211_keyix_t, but this is OK as 
-	 * values are unique over the low order bits. */
-	u_int8_t idk_keyix;	/* key index */
-	u_int8_t idk_macaddr[IEEE80211_ADDR_LEN];
-};
-
-/*
- * MLME state manipulation request.  IEEE80211_MLME_ASSOC
- * only makes sense when operating as a station.  The other
- * requests can be used when operating as a station or an
- * ap (to effect a station).
- */
-struct ieee80211req_mlme {
-	u_int8_t im_op;			/* operation to perform */
-#define	IEEE80211_MLME_ASSOC		1	/* associate station */
-#define	IEEE80211_MLME_DISASSOC		2	/* disassociate station */
-#define	IEEE80211_MLME_DEAUTH		3	/* deauthenticate station */
-#define	IEEE80211_MLME_AUTHORIZE	4	/* authorize station */
-#define	IEEE80211_MLME_UNAUTHORIZE	5	/* unauthorize station */
-#define IEEE80211_MLME_CLEAR_STATS	6	/* clear station statistic */
-	u_int8_t im_ssid_len;		/* length of optional ssid */
-	u_int16_t im_reason;		/* 802.11 reason code */
-	u_int8_t im_macaddr[IEEE80211_ADDR_LEN];
-	u_int8_t im_ssid[IEEE80211_NWID_LEN];
-};
-
-/* 
- * MAC ACL operations.
- */
-enum {
-	IEEE80211_MACCMD_POLICY_OPEN	= 0,	/* set policy: no ACLs */
-	IEEE80211_MACCMD_POLICY_ALLOW	= 1,	/* set policy: allow traffic */
-	IEEE80211_MACCMD_POLICY_DENY	= 2,	/* set policy: deny traffic */
-	IEEE80211_MACCMD_FLUSH		= 3,	/* flush ACL database */
-	IEEE80211_MACCMD_DETACH		= 4,	/* detach ACL policy */
-};
-
-/*
- * Set the active channel list.  Note this list is
- * intersected with the available channel list in
- * calculating the set of channels actually used in
- * scanning.
- */
-struct ieee80211req_chanlist {
-	u_int8_t ic_channels[IEEE80211_CHAN_BYTES];
-};
-
-/*
- * Get the active channel list info.
- */
-struct ieee80211req_chaninfo {
-	u_int ic_nchans;
-	struct ieee80211_channel ic_chans[IEEE80211_CHAN_MAX];
-};
-
-/*
- * Retrieve the WPA/RSN information element for an associated station.
- */
-struct ieee80211req_wpaie {
-	u_int8_t	wpa_macaddr[IEEE80211_ADDR_LEN];
-	u_int8_t	wpa_ie[IEEE80211_MAX_OPT_IE];
-	u_int8_t	rsn_ie[IEEE80211_MAX_OPT_IE];
-};
-
-/*
- * Retrieve per-node statistics.
- */
-struct ieee80211req_sta_stats {
-	union {
-		/* NB: explicitly force 64-bit alignment */
-		u_int8_t macaddr[IEEE80211_ADDR_LEN];
-		u_int64_t pad;
-	} is_u;
-	struct ieee80211_nodestats is_stats;
-};
-
-/*
- * Station information block; the mac address is used
- * to retrieve other data like stats, unicast key, etc.
- */
-struct ieee80211req_sta_info {
-	u_int16_t isi_len;		/* length (mult of 4) */
-	u_int16_t isi_freq;		/* MHz */
-	u_int16_t isi_flags;		/* channel flags */
-	u_int16_t isi_state;		/* state flags */
-	u_int8_t isi_authmode;		/* authentication algorithm */
-	u_int8_t isi_rssi;
-	int8_t isi_noise;
-	u_int16_t isi_capinfo;		/* capabilities */
-	u_int8_t isi_athflags;		/* Atheros capabilities */
-	u_int8_t isi_erp;		/* ERP element */
-	u_int8_t isi_macaddr[IEEE80211_ADDR_LEN];
-	u_int8_t isi_nrates;		/* negotiated rates */
-	u_int8_t isi_rates[IEEE80211_RATE_MAXSIZE];
-	u_int8_t isi_txrate;		/* index to isi_rates[] */
-	u_int16_t isi_ie_len;		/* IE length */
-	u_int16_t isi_associd;		/* assoc response */
-	u_int16_t isi_txpower;		/* current tx power */
-	u_int16_t isi_vlan;		/* vlan tag */
-	u_int16_t isi_txseqs[17];	/* seq to be transmitted */
-	u_int16_t isi_rxseqs[17];	/* seq previous for qos frames*/
-	u_int16_t isi_inact;		/* inactivity timer */
-	u_int8_t isi_uapsd;		/* UAPSD queues */
-	u_int8_t isi_opmode;		/* sta operating mode */
-
-	/* XXX frag state? */
-	/* variable length IE data */
-};
-
-enum {
-	IEEE80211_STA_OPMODE_NORMAL,
-	IEEE80211_STA_OPMODE_XR
-};
-
-/*
- * Retrieve per-station information; to retrieve all
- * specify a mac address of ff:ff:ff:ff:ff:ff.
- */
-struct ieee80211req_sta_req {
-	union {
-		/* NB: explicitly force 64-bit alignment */
-		u_int8_t macaddr[IEEE80211_ADDR_LEN];
-		u_int64_t pad;
-	} is_u;
-	struct ieee80211req_sta_info info[1];	/* variable length */
-};
-
-/*
- * Get/set per-station tx power cap.
- */
-struct ieee80211req_sta_txpow {
-	u_int8_t	it_macaddr[IEEE80211_ADDR_LEN];
-	u_int8_t	it_txpow;
-};
-
-/*
- * WME parameters are set and return using i_val and i_len.
- * i_val holds the value itself.  i_len specifies the AC
- * and, as appropriate, then high bit specifies whether the
- * operation is to be applied to the BSS or ourself.
- */
-#define	IEEE80211_WMEPARAM_SELF	0x0000		/* parameter applies to self */
-#define	IEEE80211_WMEPARAM_BSS	0x8000		/* parameter applies to BSS */
-#define	IEEE80211_WMEPARAM_VAL	0x7fff		/* parameter value */
-
-/*
- * Scan result data returned for IEEE80211_IOC_SCAN_RESULTS.
- */
-struct ieee80211req_scan_result {
-	u_int16_t isr_len;		/* length (mult of 4) */
-	u_int16_t isr_freq;		/* MHz */
-	u_int16_t isr_flags;		/* channel flags */
-	u_int8_t isr_noise;
-	u_int8_t isr_rssi;
-	u_int8_t isr_intval;		/* beacon interval */
-	u_int16_t isr_capinfo;		/* capabilities */
-	u_int8_t isr_erp;		/* ERP element */
-	u_int8_t isr_bssid[IEEE80211_ADDR_LEN];
-	u_int8_t isr_nrates;
-	u_int8_t isr_rates[IEEE80211_RATE_MAXSIZE];
-	u_int8_t isr_ssid_len;		/* SSID length */
-	u_int8_t isr_ie_len;		/* IE length */
-	u_int8_t isr_pad[5];
-	/* variable length SSID followed by IE data */
-};
-
-#ifdef __FreeBSD__
-/*
- * FreeBSD-style ioctls.
- */
-/* the first member must be matched with struct ifreq */
-struct ieee80211req {
-	char i_name[IFNAMSIZ];	/* if_name, e.g. "wi0" */
-	u_int16_t i_type;	/* req type */
-	int16_t 	i_val;		/* Index or simple value */
-	int16_t 	i_len;		/* Index or simple value */
-	void *i_data;		/* Extra data */
-};
-#define	SIOCS80211		 _IOW('i', 234, struct ieee80211req)
-#define	SIOCG80211		_IOWR('i', 235, struct ieee80211req)
-#define	SIOCG80211STATS		_IOWR('i', 236, struct ifreq)
-#define	SIOC80211IFCREATE	_IOWR('i', 237, struct ifreq)
-#define	SIOC80211IFDESTROY	 _IOW('i', 238, struct ifreq)
-
-#define IEEE80211_IOC_SSID		1
-#define IEEE80211_IOC_NUMSSIDS		2
-#define IEEE80211_IOC_WEP		3
-#define 	IEEE80211_WEP_NOSUP		-1
-#define 	IEEE80211_WEP_OFF		0
-#define 	IEEE80211_WEP_ON		1
-#define 	IEEE80211_WEP_MIXED		2
-#define IEEE80211_IOC_WEPKEY		4
-#define IEEE80211_IOC_NUMWEPKEYS	5
-#define IEEE80211_IOC_WEPTXKEY		6
-#define IEEE80211_IOC_AUTHMODE		7
-#define IEEE80211_IOC_STATIONNAME	8
-#define IEEE80211_IOC_CHANNEL		9
-#define IEEE80211_IOC_POWERSAVE		10
-#define 	IEEE80211_POWERSAVE_NOSUP	-1
-#define 	IEEE80211_POWERSAVE_OFF		0
-#define 	IEEE80211_POWERSAVE_CAM		1
-#define 	IEEE80211_POWERSAVE_PSP		2
-#define 	IEEE80211_POWERSAVE_PSP_CAM	3
-#define 	IEEE80211_POWERSAVE_ON		IEEE80211_POWERSAVE_CAM
-#define IEEE80211_IOC_POWERSAVESLEEP	11
-#define	IEEE80211_IOC_RTSTHRESHOLD	12
-#define IEEE80211_IOC_PROTMODE		13
-#define 	IEEE80211_PROTMODE_OFF		0
-#define 	IEEE80211_PROTMODE_CTS		1
-#define 	IEEE80211_PROTMODE_RTSCTS	2
-#define	IEEE80211_IOC_TXPOWER		14	/* global tx power limit */
-#define	IEEE80211_IOC_BSSID		15
-#define	IEEE80211_IOC_ROAMING		16	/* roaming mode */
-#define	IEEE80211_IOC_PRIVACY		17	/* privacy invoked */
-#define	IEEE80211_IOC_DROPUNENCRYPTED	18	/* discard unencrypted frames */
-#define	IEEE80211_IOC_WPAKEY		19
-#define	IEEE80211_IOC_DELKEY		20
-#define	IEEE80211_IOC_MLME		21
-#define	IEEE80211_IOC_OPTIE		22	/* optional info. element */
-#define	IEEE80211_IOC_SCAN_REQ		23
-#define	IEEE80211_IOC_SCAN_RESULTS	24
-#define	IEEE80211_IOC_COUNTERMEASURES	25	/* WPA/TKIP countermeasures */
-#define	IEEE80211_IOC_WPA		26	/* WPA mode (0,1,2) */
-#define	IEEE80211_IOC_CHANLIST		27	/* channel list */
-#define	IEEE80211_IOC_WME		28	/* WME mode (on, off) */
-#define	IEEE80211_IOC_HIDESSID		29	/* hide SSID mode (on, off) */
-#define IEEE80211_IOC_APBRIDGE		30	/* AP inter-sta bridging */
-#define	IEEE80211_IOC_MCASTCIPHER	31	/* multicast/default cipher */
-#define	IEEE80211_IOC_MCASTKEYLEN	32	/* multicast key length */
-#define	IEEE80211_IOC_UCASTCIPHERS	33	/* unicast cipher suites */
-#define	IEEE80211_IOC_UCASTCIPHER	34	/* unicast cipher */
-#define	IEEE80211_IOC_UCASTKEYLEN	35	/* unicast key length */
-#define	IEEE80211_IOC_DRIVER_CAPS	36	/* driver capabilities */
-#define	IEEE80211_IOC_KEYMGTALGS	37	/* key management algorithms */
-#define	IEEE80211_IOC_RSNCAPS		38	/* RSN capabilities */
-#define	IEEE80211_IOC_WPAIE		39	/* WPA information element */
-#define	IEEE80211_IOC_STA_STATS		40	/* per-station statistics */
-#define	IEEE80211_IOC_MACCMD		41	/* MAC ACL operation */
-#define	IEEE80211_IOC_TXPOWMAX		43	/* max tx power for channel */
-#define	IEEE80211_IOC_STA_TXPOW		44	/* per-station tx power limit */
-#define	IEEE80211_IOC_STA_INFO		45	/* station/neighbor info */
-#define	IEEE80211_IOC_WME_CWMIN		46	/* WME: ECWmin */
-#define	IEEE80211_IOC_WME_CWMAX		47	/* WME: ECWmax */
-#define	IEEE80211_IOC_WME_AIFS		48	/* WME: AIFSN */
-#define	IEEE80211_IOC_WME_TXOPLIMIT	49	/* WME: txops limit */
-#define	IEEE80211_IOC_WME_ACM		50	/* WME: ACM (bss only) */
-#define	IEEE80211_IOC_WME_ACKPOLICY	51	/* WME: ACK policy (!bss only)*/
-#define	IEEE80211_IOC_DTIM_PERIOD	52	/* DTIM period (beacons) */
-#define	IEEE80211_IOC_BEACON_INTERVAL	53	/* beacon interval (ms) */
-#define	IEEE80211_IOC_ADDMAC		54	/* add sta to MAC ACL table */
-#define	IEEE80211_IOC_SETMAC		55	/* set interface wds mac addr */
-#define	IEEE80211_IOC_FF		56	/* ATH fast frames (on, off) */
-#define	IEEE80211_IOC_TURBOP		57	/* ATH turbo' (on, off) */
-#define	IEEE80211_IOC_APPIEBUF		58	/* IE in the management frame */
-#define	IEEE80211_IOC_FILTERFRAME	59	/* management frame filter */
-
-/*
- * Scan result data returned for IEEE80211_IOC_SCAN_RESULTS.
- */
-struct ieee80211req_scan_result {
-	u_int16_t isr_len;		/* length (mult of 4) */
-	u_int16_t isr_freq;		/* MHz */
-	u_int16_t isr_flags;		/* channel flags */
-	u_int8_t isr_noise;
-	u_int8_t isr_rssi;
-	u_int8_t isr_intval;		/* beacon interval */
-	u_int16_t isr_capinfo;		/* capabilities */
-	u_int8_t isr_erp;		/* ERP element */
-	u_int8_t isr_bssid[IEEE80211_ADDR_LEN];
-	u_int8_t isr_nrates;
-	u_int8_t isr_rates[IEEE80211_RATE_MAXSIZE];
-	u_int8_t isr_ssid_len;		/* SSID length */
-	u_int8_t isr_ie_len;		/* IE length */
-	u_int8_t isr_pad[5];
-	/* variable length SSID followed by IE data */
-};
-
-#endif /* __FreeBSD__ */
-
-#ifdef __linux__
-/*
- * Wireless Extensions API, private ioctl interfaces.
- *
- * NB: Even-numbered ioctl numbers have set semantics and are privileged!
- *     (regardless of the incorrect comment in wireless.h!)
- */
-#ifdef __KERNEL__
-#include <linux/if.h>
-#endif
-/* The maximum size of a iwpriv structure is IW_PRIV_SIZE_MASK, which was 
- * exceeded for some time by chaninfo ioctl.  These macros change the size 
- * encoding for anything larger than IW_PRIV_SIZE_MASK from bytes to 4-byte
- * multiples so that the padded size fits under IW_PRIV_SIZE_MASK. */
-#define IW_PRIV_BLOB_LENGTH_ENCODING(_SIZE) \
-	(((_SIZE) == ((_SIZE) & IW_PRIV_SIZE_MASK)) ? \
-		(_SIZE) : \
-		(((_SIZE) / sizeof(uint32_t)) + \
-			(((_SIZE) == (((_SIZE) / sizeof(uint32_t)) * sizeof(int))) ? \
-				0 : 1)))
-#define IW_PRIV_BLOB_TYPE_ENCODING(_SIZE) \
-	(((_SIZE) == ((_SIZE) & IW_PRIV_SIZE_MASK)) ? \
-		(IW_PRIV_TYPE_BYTE | (_SIZE)) : \
-		(IW_PRIV_TYPE_INT  | IW_PRIV_BLOB_LENGTH_ENCODING((_SIZE))))
-
-#define	IEEE80211_IOCTL_SETPARAM	(SIOCIWFIRSTPRIV+0)
-#define	IEEE80211_IOCTL_GETPARAM	(SIOCIWFIRSTPRIV+1)
-#define	IEEE80211_IOCTL_SETMODE		(SIOCIWFIRSTPRIV+2)
-#define	IEEE80211_IOCTL_GETMODE		(SIOCIWFIRSTPRIV+3)
-#define	IEEE80211_IOCTL_SETWMMPARAMS	(SIOCIWFIRSTPRIV+4)
-#define	IEEE80211_IOCTL_GETWMMPARAMS	(SIOCIWFIRSTPRIV+5)
-#define	IEEE80211_IOCTL_SETCHANLIST	(SIOCIWFIRSTPRIV+6)
-#define	IEEE80211_IOCTL_GETCHANLIST	(SIOCIWFIRSTPRIV+7)
-#define	IEEE80211_IOCTL_CHANSWITCH	(SIOCIWFIRSTPRIV+8)
-#define	IEEE80211_IOCTL_GET_APPIEBUF	(SIOCIWFIRSTPRIV+9)
-#define	IEEE80211_IOCTL_SET_APPIEBUF	(SIOCIWFIRSTPRIV+10)
-#define	IEEE80211_IOCTL_READREG		(SIOCIWFIRSTPRIV+11)
-#define	IEEE80211_IOCTL_FILTERFRAME	(SIOCIWFIRSTPRIV+12)
-#define	IEEE80211_IOCTL_GETCHANINFO	(SIOCIWFIRSTPRIV+13)
-#define	IEEE80211_IOCTL_SETOPTIE	(SIOCIWFIRSTPRIV+14)
-#define	IEEE80211_IOCTL_GETOPTIE	(SIOCIWFIRSTPRIV+15)
-#define	IEEE80211_IOCTL_SETMLME		(SIOCIWFIRSTPRIV+16)
-#define	IEEE80211_IOCTL_RADAR		(SIOCIWFIRSTPRIV+17)
-#define	IEEE80211_IOCTL_SETKEY		(SIOCIWFIRSTPRIV+18)
-#define	IEEE80211_IOCTL_WRITEREG	(SIOCIWFIRSTPRIV+19)
-#define	IEEE80211_IOCTL_DELKEY		(SIOCIWFIRSTPRIV+20)
-#define	IEEE80211_IOCTL_HALMAP		(SIOCIWFIRSTPRIV+21)
-#define	IEEE80211_IOCTL_ADDMAC		(SIOCIWFIRSTPRIV+22)
-#define	IEEE80211_IOCTL_DELMAC		(SIOCIWFIRSTPRIV+24)
-#define	IEEE80211_IOCTL_WDSADDMAC	(SIOCIWFIRSTPRIV+25)
-#define	IEEE80211_IOCTL_WDSSETMAC	(SIOCIWFIRSTPRIV+26)
-#define	IEEE80211_IOCTL_KICKMAC		(SIOCIWFIRSTPRIV+30)
-#define	IEEE80211_IOCTL_SETSCANLIST	(SIOCIWFIRSTPRIV+31)
-
-enum {
-	IEEE80211_WMMPARAMS_CWMIN       = 1,
-	IEEE80211_WMMPARAMS_CWMAX       = 2,
-	IEEE80211_WMMPARAMS_AIFS       	= 3,
-	IEEE80211_WMMPARAMS_TXOPLIMIT	= 4,
-	IEEE80211_WMMPARAMS_ACM		= 5,
-	IEEE80211_WMMPARAMS_NOACKPOLICY	= 6,
-};
-enum {
-	IEEE80211_PARAM_TURBO			= 1,	/* turbo mode */
-	IEEE80211_PARAM_MODE			= 2,	/* phy mode (11a, 11b, etc.) */
-	IEEE80211_PARAM_AUTHMODE		= 3,	/* authentication mode */
-	IEEE80211_PARAM_PROTMODE		= 4,	/* 802.11g protection */
-	IEEE80211_PARAM_MCASTCIPHER		= 5,	/* multicast/default cipher */
-	IEEE80211_PARAM_MCASTKEYLEN		= 6,	/* multicast key length */
-	IEEE80211_PARAM_UCASTCIPHERS		= 7,	/* unicast cipher suites */
-	IEEE80211_PARAM_UCASTCIPHER		= 8,	/* unicast cipher */
-	IEEE80211_PARAM_UCASTKEYLEN		= 9,	/* unicast key length */
-	IEEE80211_PARAM_WPA			= 10,	/* WPA mode (0,1,2) */
-	IEEE80211_PARAM_ROAMING			= 12,	/* roaming mode */
-	IEEE80211_PARAM_PRIVACY			= 13,	/* privacy invoked */
-	IEEE80211_PARAM_COUNTERMEASURES		= 14,	/* WPA/TKIP countermeasures */
-	IEEE80211_PARAM_DROPUNENCRYPTED		= 15,	/* discard unencrypted frames */
-	IEEE80211_PARAM_DRIVER_CAPS		= 16,	/* driver capabilities */
-	IEEE80211_PARAM_MACCMD			= 17,	/* MAC ACL operation */
-	IEEE80211_PARAM_WMM			= 18,	/* WMM mode (on, off) */
-	IEEE80211_PARAM_HIDESSID		= 19,	/* hide SSID mode (on, off) */
-	IEEE80211_PARAM_APBRIDGE    		= 20,   /* AP inter-sta bridging */
-	IEEE80211_PARAM_KEYMGTALGS		= 21,	/* key management algorithms */
-	IEEE80211_PARAM_RSNCAPS			= 22,	/* RSN capabilities */
-	IEEE80211_PARAM_INACT			= 23,	/* station inactivity timeout */
-	IEEE80211_PARAM_INACT_AUTH		= 24,	/* station auth inact timeout */
-	IEEE80211_PARAM_INACT_INIT		= 25,	/* station init inact timeout */
-	IEEE80211_PARAM_ABOLT			= 26,	/* Atheros Adv. Capabilities */
-	IEEE80211_PARAM_INACT_TICK		= 27,	/* station inactivity timer tick (seconds) */
-	IEEE80211_PARAM_DTIM_PERIOD		= 28,	/* DTIM period (beacons) */
-	IEEE80211_PARAM_BEACON_INTERVAL		= 29,	/* beacon interval (ms) */
-	IEEE80211_PARAM_DOTH			= 30,	/* 11.h is on/off */
-	IEEE80211_PARAM_PWRTARGET		= 31,	/* Current Channel Pwr Constraint */
-	IEEE80211_PARAM_GENREASSOC		= 32,	/* Generate a reassociation request */
-	IEEE80211_PARAM_COMPRESSION		= 33,	/* compression */
-	IEEE80211_PARAM_FF			= 34,	/* fast frames support  */
-	IEEE80211_PARAM_XR			= 35,	/* XR support */
-	IEEE80211_PARAM_BURST			= 36,	/* burst mode */
-	IEEE80211_PARAM_PUREG			= 37,	/* pure 11g (no 11b stations) */
-	IEEE80211_PARAM_AR			= 38,	/* AR support */
-	IEEE80211_PARAM_WDS			= 39,	/* Enable 4 address processing */
-	IEEE80211_PARAM_BGSCAN			= 40,	/* bg scanning (on, off) */
-	IEEE80211_PARAM_BGSCAN_IDLE		= 41,	/* bg scan idle threshold */
-	IEEE80211_PARAM_BGSCAN_INTERVAL		= 42,	/* bg scan interval */
-	IEEE80211_PARAM_MCAST_RATE		= 43,	/* Multicast Tx Rate */
-	IEEE80211_PARAM_COVERAGE_CLASS		= 44,	/* coverage class */
-	IEEE80211_PARAM_COUNTRY_IE		= 45,	/* enable country IE */
-	IEEE80211_PARAM_SCANVALID		= 46,	/* scan cache valid threshold */
-	IEEE80211_PARAM_ROAM_RSSI_11A		= 47,	/* rssi threshold in 11a */
-	IEEE80211_PARAM_ROAM_RSSI_11B		= 48,	/* rssi threshold in 11b */
-	IEEE80211_PARAM_ROAM_RSSI_11G		= 49,	/* rssi threshold in 11g */
-	IEEE80211_PARAM_ROAM_RATE_11A		= 50,	/* tx rate threshold in 11a */
-	IEEE80211_PARAM_ROAM_RATE_11B		= 51,	/* tx rate threshold in 11b */
-	IEEE80211_PARAM_ROAM_RATE_11G		= 52,	/* tx rate threshold in 11g */
-	IEEE80211_PARAM_UAPSDINFO		= 53,	/* value for qos info field */
-	IEEE80211_PARAM_SLEEP			= 54,	/* force sleep/wake */
-	IEEE80211_PARAM_QOSNULL			= 55,	/* force sleep/wake */
-	IEEE80211_PARAM_PSPOLL			= 56,	/* force ps-poll generation (sta only) */
-	IEEE80211_PARAM_EOSPDROP		= 57,	/* force uapsd EOSP drop (ap only) */
-	IEEE80211_PARAM_MARKDFS			= 58,	/* mark a dfs interference channel when found */
-	IEEE80211_PARAM_REGCLASS		= 59,	/* enable regclass ids in country IE */
-	IEEE80211_PARAM_DROPUNENC_EAPOL		= 60,	/* drop unencrypted eapol frames */
-	IEEE80211_PARAM_SHPREAMBLE		= 61,	/* Short Preamble */
-	IEEE80211_PARAM_DUMPREGS		= 62,	/* Pretty printed dump of Atheros hardware registers */
-	IEEE80211_PARAM_DOTH_ALGORITHM		= 63,	/* spectrum management algorithm */
-	IEEE80211_PARAM_DOTH_MINCOM   		= 64,	/* minimum number of common channels */
-	IEEE80211_PARAM_DOTH_SLCG		= 65,	/* permil of Stations Lost per Channel Gained */
-	IEEE80211_PARAM_DOTH_SLDG		= 66,	/* permil of Stations Lost per rssi Db Gained */
-	IEEE80211_PARAM_TXCONT			= 67,	/* continuous transmit mode (boolean) */
-	IEEE80211_PARAM_TXCONT_RATE		= 68,	/* continuous transmit mode data rate (in mbit/sec) - will use closest match from current rate table */
-	IEEE80211_PARAM_TXCONT_POWER		= 69,	/* power level in units of 0.5dBm */
-	IEEE80211_PARAM_DFS_TESTMODE		= 70,	/* do not perform DFS actions (i.e. markng DFS and channel change on interference), just report them via debug. */
-	IEEE80211_PARAM_DFS_CACTIME		= 71,	/* how long do we wait for chan availability
-							   scans ?
-							   FCC requires 60s, so that is the default. */
-	IEEE80211_PARAM_DFS_EXCLPERIOD		= 72,	/* DFS no-occupancy limit - how long do we stay
-							   off a channel once radar is detected?
-							   FCC requires 30m, so that is the default. */
-	IEEE80211_PARAM_BEACON_MISS_THRESH	= 73,	/* Beacon miss threshold (in beacons) */
-	IEEE80211_PARAM_BEACON_MISS_THRESH_MS	= 74,	/* Beacon miss threshold (in ms) */
-	IEEE80211_PARAM_MAXRATE			= 75,	/* Maximum rate (by table index) */
-	IEEE80211_PARAM_MINRATE			= 76,	/* Minimum rate (by table index) */
-	IEEE80211_PARAM_PROTMODE_RSSI		= 77,	/* RSSI Threshold for enabling protection mode */
-	IEEE80211_PARAM_PROTMODE_TIMEOUT	= 78,	/* Timeout for expiring protection mode */
-	IEEE80211_PARAM_BGSCAN_THRESH		= 79,	/* bg scan rssi threshold */
-	IEEE80211_PARAM_RSSI_DIS_THR	= 80,	/* rssi threshold for disconnection */
-	IEEE80211_PARAM_RSSI_DIS_COUNT	= 81,	/* counter for rssi threshold */
-	IEEE80211_PARAM_WDS_SEP			= 82,	/* move wds stations into separate interfaces */
-	IEEE80211_PARAM_MAXASSOC		= 83,	/* maximum associated stations */
-	IEEE80211_PARAM_PROBEREQ		= 84,	/* enable handling of probe requests */
-	IEEE80211_PARAM_BEACON_TXP		= 85,	/* set beacon tx power */
-};
-
-#define	SIOCG80211STATS			(SIOCDEVPRIVATE+2)
-/* NB: require in+out parameters so cannot use wireless extensions, yech */
-#define	IEEE80211_IOCTL_GETKEY		(SIOCDEVPRIVATE+3)
-#define	IEEE80211_IOCTL_GETWPAIE	(SIOCDEVPRIVATE+4)
-#define	IEEE80211_IOCTL_STA_STATS	(SIOCDEVPRIVATE+5)
-#define	IEEE80211_IOCTL_STA_INFO	(SIOCDEVPRIVATE+6)
-#define	SIOC80211IFCREATE		(SIOCDEVPRIVATE+7)
-#define	SIOC80211IFDESTROY	 	(SIOCDEVPRIVATE+8)
-#define	IEEE80211_IOCTL_SCAN_RESULTS	(SIOCDEVPRIVATE+9)
-
-struct ieee80211_clone_params {
-	char icp_name[IFNAMSIZ];		/* device name */
-	u_int16_t icp_opmode;			/* operating mode */
-	u_int16_t icp_flags;			/* see below */
-#define	IEEE80211_CLONE_BSSID	0x0001		/* allocate unique mac/bssid */
-#define	IEEE80211_NO_STABEACONS	0x0002		/* Do not setup the station beacon timers */
-};
-
-/* APPIEBUF related definitions */
-
-/* Management frame type to which application IE is added */
-enum {
-	IEEE80211_APPIE_FRAME_BEACON		= 0,
-	IEEE80211_APPIE_FRAME_PROBE_REQ		= 1,
-	IEEE80211_APPIE_FRAME_PROBE_RESP	= 2,
-	IEEE80211_APPIE_FRAME_ASSOC_REQ		= 3,
-	IEEE80211_APPIE_FRAME_ASSOC_RESP	= 4,
-	IEEE80211_APPIE_NUM_OF_FRAME		= 5
-};
-
-struct ieee80211req_getset_appiebuf {
-	u_int32_t	app_frmtype;		/* management frame type for which buffer is added */
-	u_int32_t	app_buflen;		/* application-supplied buffer length */
-	u_int8_t	app_buf[0];		/* application-supplied IE(s) */
-};
-
-/* Flags ORed by application to set filter for receiving management frames */
-enum {
-	IEEE80211_FILTER_TYPE_BEACON		= 1<<0,
-	IEEE80211_FILTER_TYPE_PROBE_REQ		= 1<<1,
-	IEEE80211_FILTER_TYPE_PROBE_RESP	= 1<<2,
-	IEEE80211_FILTER_TYPE_ASSOC_REQ		= 1<<3,
-	IEEE80211_FILTER_TYPE_ASSOC_RESP	= 1<<4,
-	IEEE80211_FILTER_TYPE_AUTH		= 1<<5,
-	IEEE80211_FILTER_TYPE_DEAUTH		= 1<<6,
-	IEEE80211_FILTER_TYPE_DISASSOC		= 1<<7,
-	IEEE80211_FILTER_TYPE_ALL		= 0xFF	/* used to check the valid filter bits */
-};
-
-struct ieee80211req_set_filter {
-	u_int32_t app_filterype;		/* management frame filter type */
-};
-
-
-#endif /* __linux__ */
-
-#endif /* _NET80211_IEEE80211_IOCTL_H_ */
diff --git a/package/hostapd/patches/100-madwifi_key_fixes.patch b/package/hostapd/patches/100-madwifi_key_fixes.patch
deleted file mode 100644
index dcd6d10..0000000
--- a/package/hostapd/patches/100-madwifi_key_fixes.patch
+++ /dev/null
@@ -1,34 +0,0 @@
---- a/src/drivers/driver_madwifi.c
-+++ b/src/drivers/driver_madwifi.c
-@@ -450,7 +450,9 @@ wpa_driver_madwifi_set_key(const char *i
- 
- 	memset(&wk, 0, sizeof(wk));
- 	wk.ik_type = cipher;
--	wk.ik_flags = IEEE80211_KEY_RECV | IEEE80211_KEY_XMIT;
-+	wk.ik_flags = IEEE80211_KEY_RECV;
-+	if (set_tx)
-+		wk.ik_flags |= IEEE80211_KEY_XMIT;
- 	if (addr == NULL || is_broadcast_ether_addr(addr)) {
- 		memset(wk.ik_macaddr, 0xff, IEEE80211_ADDR_LEN);
- 		wk.ik_keyix = key_idx;
-@@ -462,6 +464,20 @@ wpa_driver_madwifi_set_key(const char *i
- 	wk.ik_keylen = key_len;
- 	memcpy(wk.ik_keydata, key, key_len);
- 
-+#ifdef WORDS_BIGENDIAN
-+#define WPA_KEY_RSC_LEN 8
-+	{
-+		size_t i;
-+		u8 tmp[WPA_KEY_RSC_LEN];
-+		os_memset(tmp, 0, sizeof(tmp));
-+		for (i = 0; i < seq_len; i++)
-+			tmp[WPA_KEY_RSC_LEN - i - 1] = seq[i];
-+		os_memcpy(&wk.ik_keyrsc, tmp, WPA_KEY_RSC_LEN);
-+	}
-+#else /* WORDS_BIGENDIAN */
-+	os_memcpy(&wk.ik_keyrsc, seq, seq_len);
-+#endif /* WORDS_BIGENDIAN */
-+
- 	ret = set80211priv(drv, IEEE80211_IOCTL_SETKEY, &wk, sizeof(wk));
- 	if (ret < 0) {
- 		wpa_printf(MSG_DEBUG, "%s: Failed to set key (addr %s"
diff --git a/package/hostapd/patches/110-bool_fix.patch b/package/hostapd/patches/110-bool_fix.patch
deleted file mode 100644
index 9f82b0b..0000000
--- a/package/hostapd/patches/110-bool_fix.patch
+++ /dev/null
@@ -1,14 +0,0 @@
---- a/src/ap/ieee802_1x.c
-+++ b/src/ap/ieee802_1x.c
-@@ -1933,9 +1933,9 @@ void ieee802_1x_notify_pre_auth(struct e
- }
- 
- 
--static const char * bool_txt(Boolean bool)
-+static const char * bool_txt(Boolean bool_val)
- {
--	return bool ? "TRUE" : "FALSE";
-+	return bool_val ? "TRUE" : "FALSE";
- }
- 
- 
diff --git a/package/hostapd/patches/120-daemonize_fix.patch b/package/hostapd/patches/120-daemonize_fix.patch
deleted file mode 100644
index 20a1eb3..0000000
--- a/package/hostapd/patches/120-daemonize_fix.patch
+++ /dev/null
@@ -1,97 +0,0 @@
---- a/src/utils/os_unix.c
-+++ b/src/utils/os_unix.c
-@@ -9,6 +9,7 @@
- #include "includes.h"
- 
- #include <time.h>
-+#include <fcntl.h>
- 
- #ifdef ANDROID
- #include <sys/capability.h>
-@@ -154,59 +155,46 @@ int os_gmtime(os_time_t t, struct os_tm 
- 	return 0;
- }
- 
--
--#ifdef __APPLE__
--#include <fcntl.h>
--static int os_daemon(int nochdir, int noclose)
-+int os_daemonize(const char *pid_file)
- {
--	int devnull;
-+	int pid = 0, i, devnull;
- 
--	if (chdir("/") < 0)
--		return -1;
-+#if defined(__uClinux__) || defined(__sun__)
-+	return -1;
-+#else /* defined(__uClinux__) || defined(__sun__) */
- 
--	devnull = open("/dev/null", O_RDWR);
--	if (devnull < 0)
-+#ifndef __APPLE__
-+	pid = fork();
-+	if (pid < 0)
- 		return -1;
-+#endif
- 
--	if (dup2(devnull, STDIN_FILENO) < 0) {
--		close(devnull);
--		return -1;
-+	if (pid > 0) {
-+		if (pid_file) {
-+			FILE *f = fopen(pid_file, "w");
-+			if (f) {
-+				fprintf(f, "%u\n", pid);
-+				fclose(f);
-+			}
-+		}
-+		_exit(0);
- 	}
- 
--	if (dup2(devnull, STDOUT_FILENO) < 0) {
--		close(devnull);
-+	if (setsid() < 0)
- 		return -1;
--	}
- 
--	if (dup2(devnull, STDERR_FILENO) < 0) {
--		close(devnull);
-+	if (chdir("/") < 0)
- 		return -1;
--	}
--
--	return 0;
--}
--#else /* __APPLE__ */
--#define os_daemon daemon
--#endif /* __APPLE__ */
- 
--
--int os_daemonize(const char *pid_file)
--{
--#if defined(__uClinux__) || defined(__sun__)
--	return -1;
--#else /* defined(__uClinux__) || defined(__sun__) */
--	if (os_daemon(0, 0)) {
--		perror("daemon");
-+	devnull = open("/dev/null", O_RDWR);
-+	if (devnull < 0)
- 		return -1;
--	}
- 
--	if (pid_file) {
--		FILE *f = fopen(pid_file, "w");
--		if (f) {
--			fprintf(f, "%u\n", getpid());
--			fclose(f);
--		}
--	}
-+	for (i = 0; i <= STDERR_FILENO; i++)
-+		dup2(devnull, i);
-+
-+	if (devnull > 2)
-+		close(devnull);
- 
- 	return -0;
- #endif /* defined(__uClinux__) || defined(__sun__) */
diff --git a/package/hostapd/patches/130-wds_sta_del_fix.patch b/package/hostapd/patches/130-wds_sta_del_fix.patch
deleted file mode 100644
index 06b6906..0000000
--- a/package/hostapd/patches/130-wds_sta_del_fix.patch
+++ /dev/null
@@ -1,13 +0,0 @@
---- a/src/drivers/driver_nl80211.c
-+++ b/src/drivers/driver_nl80211.c
-@@ -9083,8 +9083,8 @@ static int i802_set_wds_sta(void *priv, 
- 					name);
- 
- 		i802_set_sta_vlan(priv, addr, bss->ifname, 0);
--		return wpa_driver_nl80211_if_remove(priv, WPA_IF_AP_VLAN,
--						    name);
-+		nl80211_remove_iface(drv, if_nametoindex(name));
-+		return 0;
- 	}
- }
- 
diff --git a/package/hostapd/patches/200-multicall.patch b/package/hostapd/patches/200-multicall.patch
deleted file mode 100644
index 2289f51..0000000
--- a/package/hostapd/patches/200-multicall.patch
+++ /dev/null
@@ -1,246 +0,0 @@
---- a/hostapd/Makefile
-+++ b/hostapd/Makefile
-@@ -14,6 +14,7 @@ CFLAGS += -I../src/utils
- # CFLAGS += -DUSE_KERNEL_HEADERS -I/usr/src/linux/include
- 
- -include .config
-+-include $(if $(MULTICALL), ../wpa_supplicant/.config)
- 
- ifndef CONFIG_OS
- ifdef CONFIG_NATIVE_WINDOWS
-@@ -200,10 +201,14 @@ ifdef CONFIG_IEEE80211AC
- CFLAGS += -DCONFIG_IEEE80211AC
- endif
- 
-+ifndef MULTICALL
-+CFLAGS += -DNO_SUPPLICANT
-+endif
-+
- include ../src/drivers/drivers.mak
--OBJS += $(DRV_AP_OBJS)
--CFLAGS += $(DRV_AP_CFLAGS)
--LDFLAGS += $(DRV_AP_LDFLAGS)
-+OBJS += $(sort $(DRV_AP_OBJS) $(if $(MULTICALL),$(DRV_WPA_OBJS)))
-+CFLAGS += $(DRV_AP_CFLAGS) $(if $(MULTICALL),$(DRV_WPA_CFLAGS))
-+LDFLAGS += $(DRV_AP_LDFLAGS) $(if $(MULTICALL),$(DRV_WPA_LDFLAGS))
- LIBS += $(DRV_AP_LIBS)
- 
- ifdef CONFIG_L2_PACKET
-@@ -890,6 +895,12 @@ install: all
- 
- BCHECK=../src/drivers/build.hostapd
- 
-+hostapd_multi.a: $(BCHECK) $(OBJS)
-+	$(Q)$(CC) -c -o hostapd_multi.o -Dmain=hostapd_main $(CFLAGS) main.c
-+	@$(E) "  CC " $<
-+	@rm -f $@
-+	@$(AR) cr $@ hostapd_multi.o $(OBJS)
-+
- hostapd: $(BCHECK) $(OBJS)
- 	$(Q)$(CC) $(LDFLAGS) -o hostapd $(OBJS) $(LIBS)
- 	@$(E) "  LD " $@
-@@ -928,6 +939,12 @@ HOBJS += ../src/crypto/aes-internal.o
- HOBJS += ../src/crypto/aes-internal-enc.o
- endif
- 
-+dump_cflags:
-+	@echo -n $(CFLAGS) " "
-+
-+dump_ldflags:
-+	@echo -n $(LDFLAGS) $(LIBS) $(EXTRALIBS) " "
-+
- nt_password_hash: $(NOBJS)
- 	$(Q)$(CC) $(LDFLAGS) -o nt_password_hash $(NOBJS) $(LIBS_n)
- 	@$(E) "  LD " $@
---- a/wpa_supplicant/Makefile
-+++ b/wpa_supplicant/Makefile
-@@ -14,6 +14,7 @@ CFLAGS += -I../src
- CFLAGS += -I../src/utils
- 
- -include .config
-+-include $(if $(MULTICALL),../hostapd/.config)
- 
- BINALL=wpa_supplicant wpa_cli
- 
-@@ -727,6 +728,10 @@ ifdef CONFIG_DYNAMIC_EAP_METHODS
- CFLAGS += -DCONFIG_DYNAMIC_EAP_METHODS
- LIBS += -ldl -rdynamic
- endif
-+else
-+  ifdef MULTICALL
-+    OBJS += ../src/eap_common/eap_common.o
-+  endif
- endif
- 
- ifdef CONFIG_AP
-@@ -735,9 +740,11 @@ NEED_EAP_COMMON=y
- NEED_RSN_AUTHENTICATOR=y
- CFLAGS += -DCONFIG_AP
- OBJS += ap.o
-+ifndef MULTICALL
- CFLAGS += -DCONFIG_NO_RADIUS
- CFLAGS += -DCONFIG_NO_ACCOUNTING
- CFLAGS += -DCONFIG_NO_VLAN
-+endif
- OBJS += ../src/ap/hostapd.o
- OBJS += ../src/ap/wpa_auth_glue.o
- OBJS += ../src/ap/utils.o
-@@ -799,10 +806,18 @@ endif
- ifdef CONFIG_HS20
- OBJS += ../src/ap/hs20.o
- endif
-+else
-+  ifdef MULTICALL
-+    OBJS += ../src/eap_server/eap_server.o
-+    OBJS += ../src/eap_server/eap_server_identity.o
-+    OBJS += ../src/eap_server/eap_server_methods.o
-+  endif
- endif
- 
- ifdef NEED_RSN_AUTHENTICATOR
-+ifndef MULTICALL
- CFLAGS += -DCONFIG_NO_RADIUS
-+endif
- NEED_AES_WRAP=y
- OBJS += ../src/ap/wpa_auth.o
- OBJS += ../src/ap/wpa_auth_ie.o
-@@ -1551,6 +1566,12 @@ wpa_priv: $(BCHECK) $(OBJS_priv)
- 
- $(OBJS_c) $(OBJS_t) $(OBJS_t2) $(OBJS) $(BCHECK) $(EXTRA_progs): .config
- 
-+wpa_supplicant_multi.a: .config $(BCHECK) $(OBJS) $(EXTRA_progs)
-+	$(Q)$(CC) -c -o wpa_supplicant_multi.o -Dmain=wpa_supplicant_main $(CFLAGS) main.c
-+	@$(E) "  CC " $<
-+	@rm -f $@
-+	@$(AR) cr $@ wpa_supplicant_multi.o $(OBJS)
-+
- wpa_supplicant: $(BCHECK) $(OBJS) $(EXTRA_progs)
- 	$(Q)$(LDO) $(LDFLAGS) -o wpa_supplicant $(OBJS) $(LIBS) $(EXTRALIBS)
- 	@$(E) "  LD " $@
-@@ -1625,6 +1646,12 @@ eap_eke.so: ../src/eap_peer/eap_eke.c ..
- %@.service: %.service.arg.in
- 	sed -e 's|\@BINDIR\@|$(BINDIR)|g' $< >$@
- 
-+dump_cflags:
-+	@echo -n $(CFLAGS) " "
-+
-+dump_ldflags:
-+	@echo -n $(LDFLAGS) $(LIBS) $(EXTRALIBS) " "
-+
- wpa_supplicant.exe: wpa_supplicant
- 	mv -f $< $@
- wpa_cli.exe: wpa_cli
---- a/src/drivers/driver.h
-+++ b/src/drivers/driver.h
-@@ -4079,8 +4079,8 @@ union wpa_event_data {
-  * Driver wrapper code should call this function whenever an event is received
-  * from the driver.
-  */
--void wpa_supplicant_event(void *ctx, enum wpa_event_type event,
--			  union wpa_event_data *data);
-+extern void (*wpa_supplicant_event)(void *ctx, enum wpa_event_type event,
-+				    union wpa_event_data *data);
- 
- 
- /*
---- a/src/ap/drv_callbacks.c
-+++ b/src/ap/drv_callbacks.c
-@@ -844,8 +844,8 @@ static void hostapd_event_dfs_nop_finish
- #endif /* NEED_AP_MLME */
- 
- 
--void wpa_supplicant_event(void *ctx, enum wpa_event_type event,
--			  union wpa_event_data *data)
-+void hostapd_wpa_event(void *ctx, enum wpa_event_type event,
-+		       union wpa_event_data *data)
- {
- 	struct hostapd_data *hapd = ctx;
- #ifndef CONFIG_NO_STDOUT_DEBUG
---- a/wpa_supplicant/wpa_priv.c
-+++ b/wpa_supplicant/wpa_priv.c
-@@ -817,8 +817,8 @@ static void wpa_priv_send_ft_response(st
- }
- 
- 
--void wpa_supplicant_event(void *ctx, enum wpa_event_type event,
--			  union wpa_event_data *data)
-+static void supplicant_event(void *ctx, enum wpa_event_type event,
-+			     union wpa_event_data *data)
- {
- 	struct wpa_priv_interface *iface = ctx;
- 
-@@ -960,6 +960,7 @@ int main(int argc, char *argv[])
- 	if (os_program_init())
- 		return -1;
- 
-+	wpa_supplicant_event = supplicant_event;
- 	wpa_priv_fd_workaround();
- 
- 	for (;;) {
---- a/wpa_supplicant/events.c
-+++ b/wpa_supplicant/events.c
-@@ -2710,8 +2710,8 @@ static void wpa_supplicant_update_channe
- }
- 
- 
--void wpa_supplicant_event(void *ctx, enum wpa_event_type event,
--			  union wpa_event_data *data)
-+void supplicant_event(void *ctx, enum wpa_event_type event,
-+		      union wpa_event_data *data)
- {
- 	struct wpa_supplicant *wpa_s = ctx;
- 
---- a/wpa_supplicant/wpa_supplicant.c
-+++ b/wpa_supplicant/wpa_supplicant.c
-@@ -3138,6 +3138,9 @@ static void wpa_supplicant_deinit_iface(
- 	os_free(wpa_s);
- }
- 
-+extern void supplicant_event(void *ctx, enum wpa_event_type event,
-+			     union wpa_event_data *data);
-+
- 
- /**
-  * wpa_supplicant_add_iface - Add a new network interface
-@@ -3329,6 +3332,7 @@ struct wpa_global * wpa_supplicant_init(
- 	wpa_msg_register_ifname_cb(wpa_supplicant_msg_ifname_cb);
- #endif /* CONFIG_NO_WPA_MSG */
- 
-+	wpa_supplicant_event = supplicant_event;
- 	wpa_debug_open_file(params->wpa_debug_file_path);
- 	if (params->wpa_debug_syslog)
- 		wpa_debug_open_syslog();
---- a/hostapd/main.c
-+++ b/hostapd/main.c
-@@ -511,6 +511,9 @@ static int hostapd_get_ctrl_iface_group(
- 	return 0;
- }
- 
-+void hostapd_wpa_event(void *ctx, enum wpa_event_type event,
-+                       union wpa_event_data *data);
-+
- 
- int main(int argc, char *argv[])
- {
-@@ -541,6 +544,7 @@ int main(int argc, char *argv[])
- 	interfaces.global_iface_name = NULL;
- 	interfaces.global_ctrl_sock = -1;
- 
-+	wpa_supplicant_event = hostapd_wpa_event;
- 	for (;;) {
- 		c = getopt(argc, argv, "b:Bde:f:hKP:Ttvg:G:");
- 		if (c < 0)
---- a/src/drivers/drivers.c
-+++ b/src/drivers/drivers.c
-@@ -7,7 +7,11 @@
-  */
- 
- #include "includes.h"
-+#include "common.h"
-+#include "driver.h"
- 
-+void (*wpa_supplicant_event)(void *ctx, enum wpa_event_type event,
-+			     union wpa_event_data *data);
- 
- #ifdef CONFIG_DRIVER_WEXT
- extern struct wpa_driver_ops wpa_driver_wext_ops; /* driver_wext.c */
diff --git a/package/hostapd/patches/300-noscan.patch b/package/hostapd/patches/300-noscan.patch
deleted file mode 100644
index 17e7661..0000000
--- a/package/hostapd/patches/300-noscan.patch
+++ /dev/null
@@ -1,32 +0,0 @@
---- a/hostapd/config_file.c
-+++ b/hostapd/config_file.c
-@@ -2412,6 +2412,8 @@ static int hostapd_config_fill(struct ho
- 			}
- #endif /* CONFIG_IEEE80211W */
- #ifdef CONFIG_IEEE80211N
-+		} else if (os_strcmp(buf, "noscan") == 0) {
-+			conf->noscan = atoi(pos);
- 		} else if (os_strcmp(buf, "ieee80211n") == 0) {
- 			conf->ieee80211n = atoi(pos);
- 		} else if (os_strcmp(buf, "ht_capab") == 0) {
---- a/src/ap/ap_config.h
-+++ b/src/ap/ap_config.h
-@@ -527,6 +527,7 @@ struct hostapd_config {
- 
- 	int ht_op_mode_fixed;
- 	u16 ht_capab;
-+	int noscan;
- 	int ieee80211n;
- 	int secondary_channel;
- 	int require_ht;
---- a/src/ap/hw_features.c
-+++ b/src/ap/hw_features.c
-@@ -577,7 +577,7 @@ static int ieee80211n_check_40mhz(struct
- {
- 	struct wpa_driver_scan_params params;
- 
--	if (!iface->conf->secondary_channel)
-+	if (!iface->conf->secondary_channel || iface->conf->noscan)
- 		return 0; /* HT40 not used */
- 
- 	hostapd_set_state(iface, HAPD_IFACE_HT_SCAN);
diff --git a/package/hostapd/patches/310-rescan_immediately.patch b/package/hostapd/patches/310-rescan_immediately.patch
deleted file mode 100644
index 043f07c..0000000
--- a/package/hostapd/patches/310-rescan_immediately.patch
+++ /dev/null
@@ -1,11 +0,0 @@
---- a/wpa_supplicant/wpa_supplicant.c
-+++ b/wpa_supplicant/wpa_supplicant.c
-@@ -2488,7 +2488,7 @@ static struct wpa_supplicant * wpa_suppl
- 	if (wpa_s == NULL)
- 		return NULL;
- 	wpa_s->scan_req = INITIAL_SCAN_REQ;
--	wpa_s->scan_interval = 5;
-+	wpa_s->scan_interval = 1;
- 	wpa_s->new_connection = 1;
- 	wpa_s->parent = wpa_s;
- 	wpa_s->sched_scanning = 0;
diff --git a/package/hostapd/patches/320-optional_rfkill.patch b/package/hostapd/patches/320-optional_rfkill.patch
deleted file mode 100644
index 7ec51b1..0000000
--- a/package/hostapd/patches/320-optional_rfkill.patch
+++ /dev/null
@@ -1,261 +0,0 @@
---- a/src/drivers/driver_nl80211.c
-+++ b/src/drivers/driver_nl80211.c
-@@ -254,7 +254,9 @@ struct wpa_driver_nl80211_data {
- 	int if_removed;
- 	int if_disabled;
- 	int ignore_if_down_event;
-+#ifdef CONFIG_RFKILL
- 	struct rfkill_data *rfkill;
-+#endif
- 	struct wpa_driver_capa capa;
- 	u8 *extended_capa, *extended_capa_mask;
- 	unsigned int extended_capa_len;
-@@ -3630,7 +3632,7 @@ static int wpa_driver_nl80211_init_nl(st
- 	return 0;
- }
- 
--
-+#ifdef CONFIG_RFKILL
- static void wpa_driver_nl80211_rfkill_blocked(void *ctx)
- {
- 	wpa_printf(MSG_DEBUG, "nl80211: RFKILL blocked");
-@@ -3652,6 +3654,7 @@ static void wpa_driver_nl80211_rfkill_un
- 	}
- 	/* rtnetlink ifup handler will report interface as enabled */
- }
-+#endif /* CONFIG_RFKILL */
- 
- 
- static void wpa_driver_nl80211_handle_eapol_tx_status(int sock,
-@@ -3740,7 +3743,9 @@ static void * wpa_driver_nl80211_drv_ini
- 					  const u8 *set_addr)
- {
- 	struct wpa_driver_nl80211_data *drv;
-+#ifdef CONFIG_RFKILL
- 	struct rfkill_config *rcfg;
-+#endif
- 	struct i802_bss *bss;
- 
- 	if (global_priv == NULL)
-@@ -3778,6 +3783,7 @@ static void * wpa_driver_nl80211_drv_ini
- 	if (nl80211_init_bss(bss))
- 		goto failed;
- 
-+#ifdef CONFIG_RFKILL
- 	rcfg = os_zalloc(sizeof(*rcfg));
- 	if (rcfg == NULL)
- 		goto failed;
-@@ -3790,6 +3796,7 @@ static void * wpa_driver_nl80211_drv_ini
- 		wpa_printf(MSG_DEBUG, "nl80211: RFKILL status not available");
- 		os_free(rcfg);
- 	}
-+#endif /* CONFIG_RFKILL */
- 
- 	if (linux_iface_up(drv->global->ioctl_sock, ifname) > 0)
- 		drv->start_iface_up = 1;
-@@ -4116,10 +4123,12 @@ static void nl80211_mgmt_unsubscribe(str
- }
- 
- 
-+#ifdef CONFIG_RFKILL
- static void wpa_driver_nl80211_send_rfkill(void *eloop_ctx, void *timeout_ctx)
- {
- 	wpa_supplicant_event(timeout_ctx, EVENT_INTERFACE_DISABLED, NULL);
- }
-+#endif /* CONFIG_RFKILL */
- 
- 
- static void nl80211_del_p2pdev(struct i802_bss *bss)
-@@ -4246,13 +4255,16 @@ wpa_driver_nl80211_finish_drv_init(struc
- 	}
- 
- 	if (linux_set_iface_flags(drv->global->ioctl_sock, bss->ifname, 1)) {
-+#ifdef CONFIG_RFKILL
- 		if (rfkill_is_blocked(drv->rfkill)) {
- 			wpa_printf(MSG_DEBUG, "nl80211: Could not yet enable "
- 				   "interface '%s' due to rfkill",
- 				   bss->ifname);
- 			drv->if_disabled = 1;
- 			send_rfkill_event = 1;
--		} else {
-+		} else
-+#endif
-+		{
- 			wpa_printf(MSG_ERROR, "nl80211: Could not set "
- 				   "interface '%s' UP", bss->ifname);
- 			return -1;
-@@ -4268,8 +4280,10 @@ wpa_driver_nl80211_finish_drv_init(struc
- 		return -1;
- 
- 	if (send_rfkill_event) {
-+#ifdef CONFIG_RFKILL
- 		eloop_register_timeout(0, 0, wpa_driver_nl80211_send_rfkill,
- 				       drv, drv->ctx);
-+#endif
- 	}
- 
- 	return 0;
-@@ -4347,7 +4361,9 @@ static void wpa_driver_nl80211_deinit(st
- 
- 	netlink_send_oper_ifla(drv->global->netlink, drv->ifindex, 0,
- 			       IF_OPER_UP);
-+#ifdef CONFIG_RFKILL
- 	rfkill_deinit(drv->rfkill);
-+#endif
- 
- 	eloop_cancel_timeout(wpa_driver_nl80211_scan_timeout, drv, drv->ctx);
- 
---- a/src/drivers/driver_wext.c
-+++ b/src/drivers/driver_wext.c
-@@ -740,7 +740,7 @@ static void wpa_driver_wext_event_rtm_de
- 	}
- }
- 
--
-+#ifdef CONFIG_RFKILL
- static void wpa_driver_wext_rfkill_blocked(void *ctx)
- {
- 	wpa_printf(MSG_DEBUG, "WEXT: RFKILL blocked");
-@@ -762,7 +762,7 @@ static void wpa_driver_wext_rfkill_unblo
- 	}
- 	/* rtnetlink ifup handler will report interface as enabled */
- }
--
-+#endif /* CONFIG_RFKILL */
- 
- static void wext_get_phy_name(struct wpa_driver_wext_data *drv)
- {
-@@ -808,7 +808,9 @@ void * wpa_driver_wext_init(void *ctx, c
- {
- 	struct wpa_driver_wext_data *drv;
- 	struct netlink_config *cfg;
-+#ifdef CONFIG_RFKILL
- 	struct rfkill_config *rcfg;
-+#endif
- 	char path[128];
- 	struct stat buf;
- 
-@@ -843,6 +845,7 @@ void * wpa_driver_wext_init(void *ctx, c
- 		goto err2;
- 	}
- 
-+#ifdef CONFIG_RFKILL
- 	rcfg = os_zalloc(sizeof(*rcfg));
- 	if (rcfg == NULL)
- 		goto err3;
-@@ -855,6 +858,7 @@ void * wpa_driver_wext_init(void *ctx, c
- 		wpa_printf(MSG_DEBUG, "WEXT: RFKILL status not available");
- 		os_free(rcfg);
- 	}
-+#endif /* CONFIG_RFKILL */
- 
- 	drv->mlme_sock = -1;
- 
-@@ -872,7 +876,9 @@ void * wpa_driver_wext_init(void *ctx, c
- 	return drv;
- 
- err3:
-+#ifdef CONFIG_RFKILL
- 	rfkill_deinit(drv->rfkill);
-+#endif
- 	netlink_deinit(drv->netlink);
- err2:
- 	close(drv->ioctl_sock);
-@@ -882,10 +888,12 @@ err1:
- }
- 
- 
-+#ifdef CONFIG_RFKILL
- static void wpa_driver_wext_send_rfkill(void *eloop_ctx, void *timeout_ctx)
- {
- 	wpa_supplicant_event(timeout_ctx, EVENT_INTERFACE_DISABLED, NULL);
- }
-+#endif /* CONFIG_RFKILL */
- 
- 
- static int wpa_driver_wext_finish_drv_init(struct wpa_driver_wext_data *drv)
-@@ -893,13 +901,16 @@ static int wpa_driver_wext_finish_drv_in
- 	int send_rfkill_event = 0;
- 
- 	if (linux_set_iface_flags(drv->ioctl_sock, drv->ifname, 1) < 0) {
-+#ifdef CONFIG_RFKILL
- 		if (rfkill_is_blocked(drv->rfkill)) {
- 			wpa_printf(MSG_DEBUG, "WEXT: Could not yet enable "
- 				   "interface '%s' due to rfkill",
- 				   drv->ifname);
- 			drv->if_disabled = 1;
- 			send_rfkill_event = 1;
--		} else {
-+		} else
-+#endif
-+		{
- 			wpa_printf(MSG_ERROR, "WEXT: Could not set "
- 				   "interface '%s' UP", drv->ifname);
- 			return -1;
-@@ -947,8 +958,10 @@ static int wpa_driver_wext_finish_drv_in
- 			       1, IF_OPER_DORMANT);
- 
- 	if (send_rfkill_event) {
-+#ifdef CONFIG_RFKILL
- 		eloop_register_timeout(0, 0, wpa_driver_wext_send_rfkill,
- 				       drv, drv->ctx);
-+#endif
- 	}
- 
- 	return 0;
-@@ -978,7 +991,9 @@ void wpa_driver_wext_deinit(void *priv)
- 
- 	netlink_send_oper_ifla(drv->netlink, drv->ifindex, 0, IF_OPER_UP);
- 	netlink_deinit(drv->netlink);
-+#ifdef CONFIG_RFKILL
- 	rfkill_deinit(drv->rfkill);
-+#endif
- 
- 	if (drv->mlme_sock >= 0)
- 		eloop_unregister_read_sock(drv->mlme_sock);
---- a/src/drivers/drivers.mak
-+++ b/src/drivers/drivers.mak
-@@ -25,7 +25,6 @@ NEED_SME=y
- NEED_AP_MLME=y
- NEED_NETLINK=y
- NEED_LINUX_IOCTL=y
--NEED_RFKILL=y
- 
- ifdef CONFIG_LIBNL32
-   DRV_LIBS += -lnl-3
-@@ -109,7 +108,6 @@ DRV_WPA_CFLAGS += -DCONFIG_DRIVER_WEXT
- CONFIG_WIRELESS_EXTENSION=y
- NEED_NETLINK=y
- NEED_LINUX_IOCTL=y
--NEED_RFKILL=y
- endif
- 
- ifdef CONFIG_DRIVER_NDIS
-@@ -135,7 +133,6 @@ endif
- ifdef CONFIG_WIRELESS_EXTENSION
- DRV_WPA_CFLAGS += -DCONFIG_WIRELESS_EXTENSION
- DRV_WPA_OBJS += ../src/drivers/driver_wext.o
--NEED_RFKILL=y
- endif
- 
- ifdef NEED_NETLINK
-@@ -148,6 +145,7 @@ endif
- 
- ifdef NEED_RFKILL
- DRV_OBJS += ../src/drivers/rfkill.o
-+DRV_WPA_CFLAGS += -DCONFIG_RFKILL
- endif
- 
- ifdef CONFIG_VLAN_NETLINK
---- a/src/drivers/driver_wext.h
-+++ b/src/drivers/driver_wext.h
-@@ -22,7 +22,9 @@ struct wpa_driver_wext_data {
- 	int ifindex2;
- 	int if_removed;
- 	int if_disabled;
-+#ifdef CONFIG_RFKILL
- 	struct rfkill_data *rfkill;
-+#endif
- 	u8 *assoc_req_ies;
- 	size_t assoc_req_ies_len;
- 	u8 *assoc_resp_ies;
diff --git a/package/hostapd/patches/330-nl80211_fix_set_freq.patch b/package/hostapd/patches/330-nl80211_fix_set_freq.patch
deleted file mode 100644
index a505a60..0000000
--- a/package/hostapd/patches/330-nl80211_fix_set_freq.patch
+++ /dev/null
@@ -1,20 +0,0 @@
---- a/src/drivers/driver_nl80211.c
-+++ b/src/drivers/driver_nl80211.c
-@@ -6860,7 +6860,7 @@ static int wpa_driver_nl80211_set_freq(s
- 
- 	nl80211_cmd(drv, msg, 0, NL80211_CMD_SET_WIPHY);
- 
--	NLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, drv->ifindex);
-+	NLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, bss->ifindex);
- 	if (nl80211_put_freq_params(msg, freq) < 0)
- 		goto nla_put_failure;
- 
-@@ -11322,7 +11322,7 @@ static int nl80211_switch_channel(void *
- 		return -ENOMEM;
- 
- 	nl80211_cmd(drv, msg, 0, NL80211_CMD_CHANNEL_SWITCH);
--	NLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, drv->ifindex);
-+	NLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, bss->ifindex);
- 	NLA_PUT_U32(msg, NL80211_ATTR_CH_SWITCH_COUNT, settings->cs_count);
- 	ret = nl80211_put_freq_params(msg, &settings->freq_params);
- 	if (ret)
diff --git a/package/hostapd/patches/340-reload_freq_change.patch b/package/hostapd/patches/340-reload_freq_change.patch
deleted file mode 100644
index 9316794..0000000
--- a/package/hostapd/patches/340-reload_freq_change.patch
+++ /dev/null
@@ -1,29 +0,0 @@
---- a/src/ap/hostapd.c
-+++ b/src/ap/hostapd.c
-@@ -72,6 +72,16 @@ static void hostapd_reload_bss(struct ho
- #endif /* CONFIG_NO_RADIUS */
- 
- 	ssid = &hapd->conf->ssid;
-+
-+	hostapd_set_freq(hapd, hapd->iconf->hw_mode, hapd->iface->freq,
-+			 hapd->iconf->channel,
-+			 hapd->iconf->ieee80211n,
-+			 hapd->iconf->ieee80211ac,
-+			 hapd->iconf->secondary_channel,
-+			 hapd->iconf->vht_oper_chwidth,
-+			 hapd->iconf->vht_oper_centr_freq_seg0_idx,
-+			 hapd->iconf->vht_oper_centr_freq_seg1_idx);
-+
- 	if (!ssid->wpa_psk_set && ssid->wpa_psk && !ssid->wpa_psk->next &&
- 	    ssid->wpa_passphrase_set && ssid->wpa_passphrase) {
- 		/*
-@@ -172,6 +182,9 @@ int hostapd_reload_config(struct hostapd
- 	oldconf = hapd->iconf;
- 	iface->conf = newconf;
- 
-+	if (iface->conf->channel)
-+		iface->freq = hostapd_hw_get_freq(hapd, iface->conf->channel);
-+
- 	for (j = 0; j < iface->num_bss; j++) {
- 		hapd = iface->bss[j];
- 		hapd->iconf = newconf;
diff --git a/package/hostapd/patches/350-nl80211_del_beacon_bss.patch b/package/hostapd/patches/350-nl80211_del_beacon_bss.patch
deleted file mode 100644
index 885922c..0000000
--- a/package/hostapd/patches/350-nl80211_del_beacon_bss.patch
+++ /dev/null
@@ -1,50 +0,0 @@
---- a/src/drivers/driver_nl80211.c
-+++ b/src/drivers/driver_nl80211.c
-@@ -4290,18 +4290,20 @@ wpa_driver_nl80211_finish_drv_init(struc
- }
- 
- 
--static int wpa_driver_nl80211_del_beacon(struct wpa_driver_nl80211_data *drv)
-+static int wpa_driver_nl80211_del_bss_beacon(struct i802_bss *bss)
- {
-+	struct wpa_driver_nl80211_data *drv = bss->drv;
- 	struct nl_msg *msg;
- 
- 	msg = nlmsg_alloc();
- 	if (!msg)
- 		return -ENOMEM;
- 
-+	bss->beacon_set = 0;
- 	wpa_printf(MSG_DEBUG, "nl80211: Remove beacon (ifindex=%d)",
--		   drv->ifindex);
-+		   bss->ifindex);
- 	nl80211_cmd(drv, msg, 0, NL80211_CMD_DEL_BEACON);
--	NLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, drv->ifindex);
-+	NLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, bss->ifindex);
- 
- 	return send_and_recv_msgs(drv, msg, NULL, NULL);
-  nla_put_failure:
-@@ -4309,6 +4311,15 @@ static int wpa_driver_nl80211_del_beacon
- 	return -ENOBUFS;
- }
- 
-+static int wpa_driver_nl80211_del_beacon(struct wpa_driver_nl80211_data *drv)
-+{
-+	struct i802_bss *bss;
-+
-+	for (bss = drv->first_bss; bss; bss = bss->next)
-+		wpa_driver_nl80211_del_bss_beacon(bss);
-+
-+	return 0;
-+}
- 
- /**
-  * wpa_driver_nl80211_deinit - Deinitialize nl80211 driver interface
-@@ -9911,7 +9922,6 @@ static int wpa_driver_nl80211_stop_ap(vo
- 	if (!is_ap_interface(drv->nlmode))
- 		return -1;
- 	wpa_driver_nl80211_del_beacon(drv);
--	bss->beacon_set = 0;
- 	return 0;
- }
- 
diff --git a/package/hostapd/patches/360-ctrl_iface_reload.patch b/package/hostapd/patches/360-ctrl_iface_reload.patch
deleted file mode 100644
index 170d4f2..0000000
--- a/package/hostapd/patches/360-ctrl_iface_reload.patch
+++ /dev/null
@@ -1,98 +0,0 @@
---- a/hostapd/ctrl_iface.c
-+++ b/hostapd/ctrl_iface.c
-@@ -34,6 +34,7 @@
- #include "wps/wps.h"
- #include "config_file.h"
- #include "ctrl_iface.h"
-+#include "config_file.h"
- 
- 
- struct wpa_ctrl_dst {
-@@ -44,6 +45,7 @@ struct wpa_ctrl_dst {
- 	int errors;
- };
- 
-+static char *reload_opts = NULL;
- 
- static void hostapd_ctrl_iface_send(struct hostapd_data *hapd, int level,
- 				    const char *buf, size_t len);
-@@ -153,6 +155,68 @@ static int hostapd_ctrl_iface_new_sta(st
- 	return 0;
- }
- 
-+static int hostapd_ctrl_iface_set_down(struct hostapd_data *hapd)
-+{
-+	if (hapd->driver->stop_ap)
-+		hapd->driver->stop_ap(hapd->drv_priv);
-+	return 0;
-+}
-+
-+static char *get_option(char *opt, char *str)
-+{
-+	int len = strlen(str);
-+
-+	if (!strncmp(opt, str, len))
-+		return opt + len;
-+	else
-+		return NULL;
-+}
-+
-+static struct hostapd_config *hostapd_ctrl_iface_config_read(const char *fname)
-+{
-+	struct hostapd_config *conf;
-+	char *opt, *val;
-+
-+	conf = hostapd_config_read(fname);
-+	if (!conf)
-+		return NULL;
-+
-+	for (opt = strtok(reload_opts, " ");
-+	     opt;
-+		 opt = strtok(NULL, " ")) {
-+
-+		if ((val = get_option(opt, "channel=")))
-+			conf->channel = atoi(val);
-+		else if ((val = get_option(opt, "ht_capab=")))
-+			conf->ht_capab = atoi(val);
-+		else if ((val = get_option(opt, "ht_capab_mask=")))
-+			conf->ht_capab &= atoi(val);
-+		else if ((val = get_option(opt, "sec_chan=")))
-+			conf->secondary_channel = atoi(val);
-+		else if ((val = get_option(opt, "hw_mode=")))
-+			conf->hw_mode = atoi(val);
-+		else if ((val = get_option(opt, "ieee80211n=")))
-+			conf->ieee80211n = atoi(val);
-+		else
-+			break;
-+	}
-+
-+	return conf;
-+}
-+
-+static int hostapd_ctrl_iface_update(struct hostapd_data *hapd, char *txt)
-+{
-+	struct hostapd_config * (*config_read_cb)(const char *config_fname);
-+	struct hostapd_iface *iface = hapd->iface;
-+
-+	config_read_cb = iface->interfaces->config_read_cb;
-+	iface->interfaces->config_read_cb = hostapd_ctrl_iface_config_read;
-+	reload_opts = txt;
-+
-+	hostapd_reload_config(iface);
-+
-+	iface->interfaces->config_read_cb = config_read_cb;
-+}
- 
- #ifdef CONFIG_IEEE80211W
- #ifdef NEED_AP_MLME
-@@ -1199,6 +1263,10 @@ static void hostapd_ctrl_iface_receive(i
- 				reply_len += res;
- 		}
- #endif /* CONFIG_NO_RADIUS */
-+	} else if (os_strcmp(buf, "DOWN") == 0) {
-+		hostapd_ctrl_iface_set_down(hapd);
-+	} else if (os_strncmp(buf, "UPDATE ", 7) == 0) {
-+		hostapd_ctrl_iface_update(hapd, buf + 7);
- 	} else if (os_strcmp(buf, "STA-FIRST") == 0) {
- 		reply_len = hostapd_ctrl_iface_sta_first(hapd, reply,
- 							 reply_size);
diff --git a/package/hostapd/patches/370-ap_sta_support.patch b/package/hostapd/patches/370-ap_sta_support.patch
deleted file mode 100644
index a3d0572..0000000
--- a/package/hostapd/patches/370-ap_sta_support.patch
+++ /dev/null
@@ -1,222 +0,0 @@
---- a/wpa_supplicant/wpa_supplicant_i.h
-+++ b/wpa_supplicant/wpa_supplicant_i.h
-@@ -96,6 +96,11 @@ struct wpa_interface {
- 	const char *ifname;
- 
- 	/**
-+	 * hostapd_ctrl - path to hostapd control socket for notification
-+	 */
-+	const char *hostapd_ctrl;
-+
-+	/**
- 	 * bridge_ifname - Optional bridge interface name
- 	 *
- 	 * If the driver interface (ifname) is included in a Linux bridge
-@@ -325,6 +330,8 @@ struct wpa_supplicant {
- #endif /* CONFIG_CTRL_IFACE_DBUS_NEW */
- 	char bridge_ifname[16];
- 
-+	struct wpa_ctrl *hostapd;
-+
- 	char *confname;
- 	char *confanother;
- 	struct wpa_config *conf;
---- a/wpa_supplicant/Makefile
-+++ b/wpa_supplicant/Makefile
-@@ -13,6 +13,10 @@ PKG_CONFIG ?= pkg-config
- CFLAGS += -I../src
- CFLAGS += -I../src/utils
- 
-+ifdef MULTICALL
-+CFLAGS += -DMULTICALL
-+endif
-+
- -include .config
- -include $(if $(MULTICALL),../hostapd/.config)
- 
-@@ -76,6 +80,8 @@ OBJS_c = wpa_cli.o ../src/common/wpa_ctr
- OBJS_c += ../src/utils/wpa_debug.o
- OBJS_c += ../src/utils/common.o
- 
-+OBJS += ../src/common/wpa_ctrl.o
-+
- ifndef CONFIG_OS
- ifdef CONFIG_NATIVE_WINDOWS
- CONFIG_OS=win32
---- a/wpa_supplicant/wpa_supplicant.c
-+++ b/wpa_supplicant/wpa_supplicant.c
-@@ -109,6 +109,46 @@ extern int wpa_debug_show_keys;
- extern int wpa_debug_timestamp;
- extern struct wpa_driver_ops *wpa_drivers[];
- 
-+static int hostapd_stop(struct wpa_supplicant *wpa_s)
-+{
-+	const char *cmd = "DOWN";
-+	char buf[256];
-+	int len = sizeof(buf);
-+
-+	if (wpa_ctrl_request(wpa_s->hostapd, cmd, os_strlen(cmd), buf, &len, NULL) < 0) {
-+		wpa_printf(MSG_ERROR, "\nFailed to stop hostapd AP interfaces\n");
-+		return -1;
-+	}
-+	return 0;
-+}
-+
-+static int hostapd_reload(struct wpa_supplicant *wpa_s, struct wpa_bss *bss)
-+{
-+	char *cmd = NULL;
-+	char buf[256];
-+	int len = sizeof(buf);
-+	enum hostapd_hw_mode hw_mode;
-+	u8 channel;
-+	int ret;
-+
-+	if (!bss)
-+		return;
-+
-+	hw_mode = ieee80211_freq_to_chan(bss->freq, &channel);
-+	if (asprintf(&cmd, "UPDATE channel=%d sec_chan=0 hw_mode=%d ieee80211n=%d",
-+		     channel, hw_mode, !!bss->ht_capab) < 0)
-+		return -1;
-+
-+	ret = wpa_ctrl_request(wpa_s->hostapd, cmd, os_strlen(cmd), buf, &len, NULL);
-+	free(cmd);
-+
-+	if (ret < 0) {
-+		wpa_printf(MSG_ERROR, "\nFailed to reload hostapd AP interfaces\n");
-+		return -1;
-+	}
-+	return 0;
-+}
-+
- /* Configure default/group WEP keys for static WEP */
- int wpa_set_wep_keys(struct wpa_supplicant *wpa_s, struct wpa_ssid *ssid)
- {
-@@ -685,8 +725,12 @@ void wpa_supplicant_set_state(struct wpa
- #endif /* CONFIG_P2P */
- 
- 		sme_sched_obss_scan(wpa_s, 1);
-+		if (wpa_s->hostapd)
-+			hostapd_reload(wpa_s, wpa_s->current_bss);
- 	} else if (state == WPA_DISCONNECTED || state == WPA_ASSOCIATING ||
- 		   state == WPA_ASSOCIATED) {
-+		if (wpa_s->hostapd)
-+			hostapd_stop(wpa_s);
- 		wpa_s->new_connection = 1;
- 		wpa_drv_set_operstate(wpa_s, 0);
- #ifndef IEEE8021X_EAPOL
-@@ -2906,6 +2950,20 @@ static int wpa_supplicant_init_iface(str
- 			   sizeof(wpa_s->bridge_ifname));
- 	}
- 
-+	if (iface->hostapd_ctrl) {
-+		char *cmd = "DOWN";
-+		char buf[256];
-+		int len = sizeof(buf);
-+
-+		wpa_s->hostapd = wpa_ctrl_open(iface->hostapd_ctrl);
-+		if (!wpa_s->hostapd) {
-+			wpa_printf(MSG_ERROR, "\nFailed to connect to hostapd\n");
-+			return -1;
-+		}
-+		if (hostapd_stop(wpa_s) < 0)
-+			return -1;
-+	}
-+
- 	/* RSNA Supplicant Key Management - INITIALIZE */
- 	eapol_sm_notify_portEnabled(wpa_s->eapol, FALSE);
- 	eapol_sm_notify_portValid(wpa_s->eapol, FALSE);
-@@ -3125,6 +3183,11 @@ static void wpa_supplicant_deinit_iface(
- 	if (terminate)
- 		wpa_msg(wpa_s, MSG_INFO, WPA_EVENT_TERMINATING);
- 
-+	if (wpa_s->hostapd) {
-+		wpa_ctrl_close(wpa_s->hostapd);
-+		wpa_s->hostapd = NULL;
-+	}
-+
- 	if (wpa_s->ctrl_iface) {
- 		wpa_supplicant_ctrl_iface_deinit(wpa_s->ctrl_iface);
- 		wpa_s->ctrl_iface = NULL;
---- a/wpa_supplicant/bss.c
-+++ b/wpa_supplicant/bss.c
-@@ -11,6 +11,7 @@
- #include "utils/common.h"
- #include "utils/eloop.h"
- #include "common/ieee802_11_defs.h"
-+#include "common/ieee802_11_common.h"
- #include "drivers/driver.h"
- #include "wpa_supplicant_i.h"
- #include "config.h"
-@@ -245,6 +246,9 @@ static void calculate_update_time(const 
- static void wpa_bss_copy_res(struct wpa_bss *dst, struct wpa_scan_res *src,
- 			     struct os_time *fetch_time)
- {
-+	struct ieee80211_ht_capabilities *capab;
-+	struct ieee802_11_elems elems;
-+
- 	dst->flags = src->flags;
- 	os_memcpy(dst->bssid, src->bssid, ETH_ALEN);
- 	dst->freq = src->freq;
-@@ -255,6 +259,12 @@ static void wpa_bss_copy_res(struct wpa_
- 	dst->level = src->level;
- 	dst->tsf = src->tsf;
- 
-+	memset(&elems, 0, sizeof(elems));
-+	ieee802_11_parse_elems((u8 *) (src + 1), src->ie_len, &elems, 0);
-+	capab = (struct ieee80211_ht_capabilities *) elems.ht_capabilities;
-+	if (capab)
-+		dst->ht_capab = le_to_host16(capab->ht_capabilities_info);
-+
- 	calculate_update_time(fetch_time, src->age, &dst->last_update);
- }
- 
---- a/wpa_supplicant/main.c
-+++ b/wpa_supplicant/main.c
-@@ -27,7 +27,7 @@ static void usage(void)
- 	       "  wpa_supplicant [-BddhKLqqstuvW] [-P<pid file>] "
- 	       "[-g<global ctrl>] \\\n"
- 	       "        [-G<group>] \\\n"
--	       "        -i<ifname> -c<config file> [-C<ctrl>] [-D<driver>] "
-+	       "        -i<ifname> -c<config file> [-C<ctrl>] [-D<driver>] [-H<hostapd path>] "
- 	       "[-p<driver_param>] \\\n"
- 	       "        [-b<br_ifname>] [-f<debug file>] [-e<entropy file>] "
- 	       "\\\n"
-@@ -72,6 +72,7 @@ static void usage(void)
- #endif /* CONFIG_DEBUG_LINUX_TRACING */
- 	printf("  -t = include timestamp in debug messages\n"
- 	       "  -h = show this help text\n"
-+		   "  -H = connect to a hostapd instance to manage state changes\n"
- 	       "  -L = show license (BSD)\n"
- 	       "  -o = override driver parameter for new interfaces\n"
- 	       "  -O = override ctrl_interface parameter for new interfaces\n"
-@@ -160,7 +161,7 @@ int main(int argc, char *argv[])
- 
- 	for (;;) {
- 		c = getopt(argc, argv,
--			   "b:Bc:C:D:de:f:g:G:hi:I:KLNo:O:p:P:qsTtuvW");
-+			   "b:Bc:C:D:de:f:g:G:hH:i:I:KLNo:O:p:P:qsTtuvW");
- 		if (c < 0)
- 			break;
- 		switch (c) {
-@@ -207,6 +208,9 @@ int main(int argc, char *argv[])
- 			usage();
- 			exitcode = 0;
- 			goto out;
-+		case 'H':
-+			iface->hostapd_ctrl = optarg;
-+			break;
- 		case 'i':
- 			iface->ifname = optarg;
- 			break;
---- a/wpa_supplicant/bss.h
-+++ b/wpa_supplicant/bss.h
-@@ -69,6 +69,8 @@ struct wpa_bss {
- 	u8 ssid[32];
- 	/** Length of SSID */
- 	size_t ssid_len;
-+	/** HT caapbilities */
-+	u16 ht_capab;
- 	/** Frequency of the channel in MHz (e.g., 2412 = channel 1) */
- 	int freq;
- 	/** Beacon interval in TUs (host byte order) */
diff --git a/package/hostapd/patches/380-disable_ctrl_iface_mib.patch b/package/hostapd/patches/380-disable_ctrl_iface_mib.patch
deleted file mode 100644
index 27f21bd..0000000
--- a/package/hostapd/patches/380-disable_ctrl_iface_mib.patch
+++ /dev/null
@@ -1,168 +0,0 @@
---- a/hostapd/Makefile
-+++ b/hostapd/Makefile
-@@ -144,6 +144,9 @@ endif
- ifdef CONFIG_NO_CTRL_IFACE
- CFLAGS += -DCONFIG_NO_CTRL_IFACE
- else
-+ifdef CONFIG_CTRL_IFACE_MIB
-+CFLAGS += -DCONFIG_CTRL_IFACE_MIB
-+endif
- OBJS += ctrl_iface.o
- OBJS += ../src/ap/ctrl_iface_ap.o
- endif
---- a/hostapd/ctrl_iface.c
-+++ b/hostapd/ctrl_iface.c
-@@ -1234,6 +1234,7 @@ static void hostapd_ctrl_iface_receive(i
- 	} else if (os_strcmp(buf, "STATUS") == 0) {
- 		reply_len = hostapd_ctrl_iface_status(hapd, reply,
- 						      reply_size);
-+#ifdef CONFIG_CTRL_IFACE_MIB
- 	} else if (os_strcmp(buf, "MIB") == 0) {
- 		reply_len = ieee802_11_get_mib(hapd, reply, reply_size);
- 		if (reply_len >= 0) {
-@@ -1263,10 +1264,12 @@ static void hostapd_ctrl_iface_receive(i
- 				reply_len += res;
- 		}
- #endif /* CONFIG_NO_RADIUS */
-+#endif
- 	} else if (os_strcmp(buf, "DOWN") == 0) {
- 		hostapd_ctrl_iface_set_down(hapd);
- 	} else if (os_strncmp(buf, "UPDATE ", 7) == 0) {
- 		hostapd_ctrl_iface_update(hapd, buf + 7);
-+#ifdef CONFIG_CTRL_IFACE_MIB
- 	} else if (os_strcmp(buf, "STA-FIRST") == 0) {
- 		reply_len = hostapd_ctrl_iface_sta_first(hapd, reply,
- 							 reply_size);
-@@ -1276,6 +1279,7 @@ static void hostapd_ctrl_iface_receive(i
- 	} else if (os_strncmp(buf, "STA-NEXT ", 9) == 0) {
- 		reply_len = hostapd_ctrl_iface_sta_next(hapd, buf + 9, reply,
- 							reply_size);
-+#endif
- 	} else if (os_strcmp(buf, "ATTACH") == 0) {
- 		if (hostapd_ctrl_iface_attach(hapd, &from, fromlen))
- 			reply_len = -1;
---- a/wpa_supplicant/Makefile
-+++ b/wpa_supplicant/Makefile
-@@ -778,6 +778,9 @@ ifdef CONFIG_WNM
- OBJS += ../src/ap/wnm_ap.o
- endif
- ifdef CONFIG_CTRL_IFACE
-+ifdef CONFIG_CTRL_IFACE_MIB
-+CFLAGS += -DCONFIG_CTRL_IFACE_MIB
-+endif
- OBJS += ../src/ap/ctrl_iface_ap.o
- endif
- 
---- a/wpa_supplicant/ctrl_iface.c
-+++ b/wpa_supplicant/ctrl_iface.c
-@@ -5262,6 +5262,7 @@ char * wpa_supplicant_ctrl_iface_process
- 			reply_len = -1;
- 	} else if (os_strncmp(buf, "NOTE ", 5) == 0) {
- 		wpa_printf(MSG_INFO, "NOTE: %s", buf + 5);
-+#ifdef CONFIG_CTRL_IFACE_MIB
- 	} else if (os_strcmp(buf, "MIB") == 0) {
- 		reply_len = wpa_sm_get_mib(wpa_s->wpa, reply, reply_size);
- 		if (reply_len >= 0) {
-@@ -5273,6 +5274,7 @@ char * wpa_supplicant_ctrl_iface_process
- 			else
- 				reply_len += res;
- 		}
-+#endif
- 	} else if (os_strncmp(buf, "STATUS", 6) == 0) {
- 		reply_len = wpa_supplicant_ctrl_iface_status(
- 			wpa_s, buf + 6, reply, reply_size);
-@@ -5687,6 +5689,7 @@ char * wpa_supplicant_ctrl_iface_process
- 		reply_len = wpa_supplicant_ctrl_iface_bss(
- 			wpa_s, buf + 4, reply, reply_size);
- #ifdef CONFIG_AP
-+#ifdef CONFIG_CTRL_IFACE_MIB
- 	} else if (os_strcmp(buf, "STA-FIRST") == 0) {
- 		reply_len = ap_ctrl_iface_sta_first(wpa_s, reply, reply_size);
- 	} else if (os_strncmp(buf, "STA ", 4) == 0) {
-@@ -5695,6 +5698,7 @@ char * wpa_supplicant_ctrl_iface_process
- 	} else if (os_strncmp(buf, "STA-NEXT ", 9) == 0) {
- 		reply_len = ap_ctrl_iface_sta_next(wpa_s, buf + 9, reply,
- 						   reply_size);
-+#endif
- 	} else if (os_strncmp(buf, "DEAUTHENTICATE ", 15) == 0) {
- 		if (ap_ctrl_iface_sta_deauthenticate(wpa_s, buf + 15))
- 			reply_len = -1;
---- a/src/ap/ctrl_iface_ap.c
-+++ b/src/ap/ctrl_iface_ap.c
-@@ -20,6 +20,7 @@
- #include "ctrl_iface_ap.h"
- #include "ap_drv_ops.h"
- 
-+#ifdef CONFIG_CTRL_IFACE_MIB
- 
- static int hostapd_get_sta_conn_time(struct sta_info *sta,
- 				     char *buf, size_t buflen)
-@@ -129,6 +130,7 @@ int hostapd_ctrl_iface_sta_next(struct h
- 	return hostapd_ctrl_iface_sta_mib(hapd, sta->next, buf, buflen);
- }
- 
-+#endif
- 
- #ifdef CONFIG_P2P_MANAGER
- static int p2p_manager_disconnect(struct hostapd_data *hapd, u16 stype,
-@@ -423,3 +425,4 @@ int hostapd_parse_csa_settings(const cha
- 
- 	return 0;
- }
-+
---- a/src/ap/ieee802_1x.c
-+++ b/src/ap/ieee802_1x.c
-@@ -1938,6 +1938,7 @@ static const char * bool_txt(Boolean boo
- 	return bool_val ? "TRUE" : "FALSE";
- }
- 
-+#ifdef CONFIG_CTRL_IFACE_MIB
- 
- int ieee802_1x_get_mib(struct hostapd_data *hapd, char *buf, size_t buflen)
- {
-@@ -2090,6 +2091,7 @@ int ieee802_1x_get_mib_sta(struct hostap
- 	return len;
- }
- 
-+#endif
- 
- static void ieee802_1x_finished(struct hostapd_data *hapd,
- 				struct sta_info *sta, int success)
---- a/src/ap/wpa_auth.c
-+++ b/src/ap/wpa_auth.c
-@@ -2708,6 +2708,7 @@ static const char * wpa_bool_txt(int boo
- 	return bool ? "TRUE" : "FALSE";
- }
- 
-+#ifdef CONFIG_CTRL_IFACE_MIB
- 
- #define RSN_SUITE "%02x-%02x-%02x-%d"
- #define RSN_SUITE_ARG(s) \
-@@ -2852,7 +2853,7 @@ int wpa_get_mib_sta(struct wpa_state_mac
- 
- 	return len;
- }
--
-+#endif
- 
- void wpa_auth_countermeasures_start(struct wpa_authenticator *wpa_auth)
- {
---- a/src/rsn_supp/wpa.c
-+++ b/src/rsn_supp/wpa.c
-@@ -1844,6 +1844,8 @@ static u32 wpa_key_mgmt_suite(struct wpa
- }
- 
- 
-+#ifdef CONFIG_CTRL_IFACE_MIB
-+
- #define RSN_SUITE "%02x-%02x-%02x-%d"
- #define RSN_SUITE_ARG(s) \
- ((s) >> 24) & 0xff, ((s) >> 16) & 0xff, ((s) >> 8) & 0xff, (s) & 0xff
-@@ -1927,6 +1929,7 @@ int wpa_sm_get_mib(struct wpa_sm *sm, ch
- 
- 	return (int) len;
- }
-+#endif
- #endif /* CONFIG_CTRL_IFACE */
- 
- 
diff --git a/package/hostapd/patches/390-wpa_ie_cap_workaround.patch b/package/hostapd/patches/390-wpa_ie_cap_workaround.patch
deleted file mode 100644
index 00a3222..0000000
--- a/package/hostapd/patches/390-wpa_ie_cap_workaround.patch
+++ /dev/null
@@ -1,56 +0,0 @@
---- a/src/common/wpa_common.c
-+++ b/src/common/wpa_common.c
-@@ -959,6 +959,31 @@ const char * wpa_key_mgmt_txt(int key_mg
- }
- 
- 
-+static void wpa_fixup_wpa_ie_rsn(u8 *assoc_ie, const u8 *wpa_msg_ie,
-+				 size_t rsn_ie_len)
-+{
-+	int pos, count;
-+
-+	pos = sizeof(struct rsn_ie_hdr) + RSN_SELECTOR_LEN;
-+	if (rsn_ie_len < pos + 2)
-+		return;
-+
-+	count = WPA_GET_LE16(wpa_msg_ie + pos);
-+	pos += 2 + count * RSN_SELECTOR_LEN;
-+	if (rsn_ie_len < pos + 2)
-+		return;
-+
-+	count = WPA_GET_LE16(wpa_msg_ie + pos);
-+	pos += 2 + count * RSN_SELECTOR_LEN;
-+	if (rsn_ie_len < pos + 2)
-+		return;
-+
-+	if (!assoc_ie[pos] && !assoc_ie[pos + 1] &&
-+	    (wpa_msg_ie[pos] || wpa_msg_ie[pos + 1]))
-+		memcpy(&assoc_ie[pos], &wpa_msg_ie[pos], 2);
-+}
-+
-+
- int wpa_compare_rsn_ie(int ft_initial_assoc,
- 		       const u8 *ie1, size_t ie1len,
- 		       const u8 *ie2, size_t ie2len)
-@@ -966,8 +991,19 @@ int wpa_compare_rsn_ie(int ft_initial_as
- 	if (ie1 == NULL || ie2 == NULL)
- 		return -1;
- 
--	if (ie1len == ie2len && os_memcmp(ie1, ie2, ie1len) == 0)
--		return 0; /* identical IEs */
-+	if (ie1len == ie2len) {
-+		u8 *ie_tmp;
-+
-+		if (os_memcmp(ie1, ie2, ie1len) == 0)
-+			return 0; /* identical IEs */
-+
-+		ie_tmp = alloca(ie1len);
-+		memcpy(ie_tmp, ie1, ie1len);
-+		wpa_fixup_wpa_ie_rsn(ie_tmp, ie2, ie1len);
-+
-+		if (os_memcmp(ie_tmp, ie2, ie1len) == 0)
-+			return 0; /* only mismatch in RSN capabilties */
-+	}
- 
- #ifdef CONFIG_IEEE80211R
- 	if (ft_initial_assoc) {
diff --git a/package/hostapd/patches/400-terminate_on_setup_failure.patch b/package/hostapd/patches/400-terminate_on_setup_failure.patch
deleted file mode 100644
index 0d9065a..0000000
--- a/package/hostapd/patches/400-terminate_on_setup_failure.patch
+++ /dev/null
@@ -1,85 +0,0 @@
---- a/src/ap/hostapd.c
-+++ b/src/ap/hostapd.c
-@@ -1103,13 +1103,8 @@ int hostapd_setup_interface_complete(str
- 	size_t j;
- 	u8 *prev_addr;
- 
--	if (err) {
--		wpa_printf(MSG_ERROR, "Interface initialization failed");
--		hostapd_set_state(iface, HAPD_IFACE_DISABLED);
--		if (iface->interfaces && iface->interfaces->terminate_on_error)
--			eloop_terminate();
--		return -1;
--	}
-+	if (err)
-+		goto error;
- 
- 	wpa_printf(MSG_DEBUG, "Completing interface initialization");
- 	if (iface->conf->channel) {
-@@ -1140,7 +1135,7 @@ int hostapd_setup_interface_complete(str
- 				     hapd->iconf->vht_oper_centr_freq_seg1_idx)) {
- 			wpa_printf(MSG_ERROR, "Could not set channel for "
- 				   "kernel driver");
--			return -1;
-+			goto error;
- 		}
- 	}
- 
-@@ -1151,7 +1146,7 @@ int hostapd_setup_interface_complete(str
- 			hostapd_logger(hapd, NULL, HOSTAPD_MODULE_IEEE80211,
- 				       HOSTAPD_LEVEL_WARNING,
- 				       "Failed to prepare rates table.");
--			return -1;
-+			goto error;
- 		}
- 	}
- 
-@@ -1159,14 +1154,14 @@ int hostapd_setup_interface_complete(str
- 	    hostapd_set_rts(hapd, hapd->iconf->rts_threshold)) {
- 		wpa_printf(MSG_ERROR, "Could not set RTS threshold for "
- 			   "kernel driver");
--		return -1;
-+		goto error;
- 	}
- 
- 	if (hapd->iconf->fragm_threshold > -1 &&
- 	    hostapd_set_frag(hapd, hapd->iconf->fragm_threshold)) {
- 		wpa_printf(MSG_ERROR, "Could not set fragmentation threshold "
- 			   "for kernel driver");
--		return -1;
-+		goto error;
- 	}
- 
- 	prev_addr = hapd->own_addr;
-@@ -1176,7 +1171,7 @@ int hostapd_setup_interface_complete(str
- 		if (j)
- 			os_memcpy(hapd->own_addr, prev_addr, ETH_ALEN);
- 		if (hostapd_setup_bss(hapd, j == 0))
--			return -1;
-+			goto error;
- 		if (hostapd_mac_comp_empty(hapd->conf->bssid) == 0)
- 			prev_addr = hapd->own_addr;
- 	}
-@@ -1191,7 +1186,7 @@ int hostapd_setup_interface_complete(str
- 	if (hostapd_driver_commit(hapd) < 0) {
- 		wpa_printf(MSG_ERROR, "%s: Failed to commit driver "
- 			   "configuration", __func__);
--		return -1;
-+		goto error;
- 	}
- 
- 	/*
-@@ -1216,6 +1211,13 @@ int hostapd_setup_interface_complete(str
- 		iface->interfaces->terminate_on_error--;
- 
- 	return 0;
-+
-+error:
-+	wpa_printf(MSG_ERROR, "Interface initialization failed");
-+	hostapd_set_state(iface, HAPD_IFACE_DISABLED);
-+	if (iface->interfaces && iface->interfaces->terminate_on_error)
-+		eloop_terminate();
-+	return -1;
- }
- 
- 
diff --git a/package/hostapd/patches/410-bring_down_interface.patch b/package/hostapd/patches/410-bring_down_interface.patch
deleted file mode 100644
index 31033a0..0000000
--- a/package/hostapd/patches/410-bring_down_interface.patch
+++ /dev/null
@@ -1,25 +0,0 @@
---- a/src/drivers/driver_nl80211.c
-+++ b/src/drivers/driver_nl80211.c
-@@ -8480,12 +8480,7 @@ static int wpa_driver_nl80211_set_mode(s
- 			/* Try to set the mode again while the interface is
- 			 * down */
- 			ret = nl80211_set_mode(drv, drv->ifindex, nlmode);
--			if (ret == -EACCES)
--				break;
--			res = i802_set_iface_flags(bss, 1);
--			if (res && !ret)
--				ret = -1;
--			else if (ret != -EBUSY)
-+			if (ret != -EBUSY)
- 				break;
- 		} else
- 			wpa_printf(MSG_DEBUG, "nl80211: Failed to set "
-@@ -8498,6 +8493,8 @@ static int wpa_driver_nl80211_set_mode(s
- 			   "interface is down");
- 		drv->nlmode = nlmode;
- 		drv->ignore_if_down_event = 1;
-+		if (i802_set_iface_flags(bss, 1))
-+			ret = -1;
- 	}
- 
- done:
diff --git a/package/hostapd/patches/420-fix_wps_pin_crash.patch b/package/hostapd/patches/420-fix_wps_pin_crash.patch
deleted file mode 100644
index 130bd53..0000000
--- a/package/hostapd/patches/420-fix_wps_pin_crash.patch
+++ /dev/null
@@ -1,12 +0,0 @@
---- a/hostapd/ctrl_iface.c
-+++ b/hostapd/ctrl_iface.c
-@@ -480,6 +480,9 @@ static int hostapd_ctrl_iface_wps_ap_pin
- 	char *pos;
- 	const char *pin_txt;
- 
-+	if (!hapd->wps)
-+		return -1;
-+
- 	pos = os_strchr(txt, ' ');
- 	if (pos)
- 		*pos++ = '\0';
diff --git a/package/hostapd/patches/430-wps_single_auth_enc_type.patch b/package/hostapd/patches/430-wps_single_auth_enc_type.patch
deleted file mode 100644
index 6e86658..0000000
--- a/package/hostapd/patches/430-wps_single_auth_enc_type.patch
+++ /dev/null
@@ -1,25 +0,0 @@
---- a/src/ap/wps_hostapd.c
-+++ b/src/ap/wps_hostapd.c
-@@ -1069,11 +1069,9 @@ int hostapd_init_wps(struct hostapd_data
- 
- 		if (conf->rsn_pairwise & WPA_CIPHER_CCMP)
- 			wps->encr_types |= WPS_ENCR_AES;
--		if (conf->rsn_pairwise & WPA_CIPHER_TKIP)
-+		else if (conf->rsn_pairwise & WPA_CIPHER_TKIP)
- 			wps->encr_types |= WPS_ENCR_TKIP;
--	}
--
--	if (conf->wpa & WPA_PROTO_WPA) {
-+	} else if (conf->wpa & WPA_PROTO_WPA) {
- 		if (conf->wpa_key_mgmt & WPA_KEY_MGMT_PSK)
- 			wps->auth_types |= WPS_AUTH_WPAPSK;
- 		if (conf->wpa_key_mgmt & WPA_KEY_MGMT_IEEE8021X)
-@@ -1081,7 +1079,7 @@ int hostapd_init_wps(struct hostapd_data
- 
- 		if (conf->wpa_pairwise & WPA_CIPHER_CCMP)
- 			wps->encr_types |= WPS_ENCR_AES;
--		if (conf->wpa_pairwise & WPA_CIPHER_TKIP)
-+		else if (conf->wpa_pairwise & WPA_CIPHER_TKIP)
- 			wps->encr_types |= WPS_ENCR_TKIP;
- 	}
- 
diff --git a/package/hostapd/patches/440-dynamic_20_40_mhz.patch b/package/hostapd/patches/440-dynamic_20_40_mhz.patch
deleted file mode 100644
index 905ec2c..0000000
--- a/package/hostapd/patches/440-dynamic_20_40_mhz.patch
+++ /dev/null
@@ -1,206 +0,0 @@
---- a/hostapd/config_file.c
-+++ b/hostapd/config_file.c
-@@ -2422,6 +2422,10 @@ static int hostapd_config_fill(struct ho
- 					   "ht_capab", line);
- 				errors++;
- 			}
-+		} else if (os_strcmp(buf, "dynamic_ht40") == 0) {
-+			conf->dynamic_ht40 = atoi(pos);
-+			if (conf->dynamic_ht40 == 1)
-+				conf->dynamic_ht40 = 1500;
- 		} else if (os_strcmp(buf, "require_ht") == 0) {
- 			conf->require_ht = atoi(pos);
- 		} else if (os_strcmp(buf, "obss_interval") == 0) {
---- a/src/ap/ap_config.h
-+++ b/src/ap/ap_config.h
-@@ -531,6 +531,7 @@ struct hostapd_config {
- 	int ieee80211n;
- 	int secondary_channel;
- 	int require_ht;
-+	int dynamic_ht40;
- 	int obss_interval;
- 	u32 vht_capab;
- 	int ieee80211ac;
---- a/src/ap/hostapd.c
-+++ b/src/ap/hostapd.c
-@@ -23,6 +23,7 @@
- #include "beacon.h"
- #include "iapp.h"
- #include "ieee802_1x.h"
-+#include "ieee802_11.h"
- #include "ieee802_11_auth.h"
- #include "vlan_init.h"
- #include "wpa_auth.h"
-@@ -332,6 +333,7 @@ static void hostapd_cleanup(struct hosta
- static void hostapd_cleanup_iface_partial(struct hostapd_iface *iface)
- {
- 	wpa_printf(MSG_DEBUG, "%s(%p)", __func__, iface);
-+	hostapd_deinit_ht(iface);
- 	hostapd_free_hw_features(iface->hw_features, iface->num_hw_features);
- 	iface->hw_features = NULL;
- 	os_free(iface->current_rates);
---- a/src/ap/hostapd.h
-+++ b/src/ap/hostapd.h
-@@ -326,6 +326,9 @@ struct hostapd_iface {
- 	/* Overlapping BSS information */
- 	int olbc_ht;
- 
-+	int force_20mhz;
-+	struct os_time last_20mhz_trigger;
-+
- 	u16 ht_op_mode;
- 
- 	/* surveying helpers */
---- a/src/ap/ieee802_11.c
-+++ b/src/ap/ieee802_11.c
-@@ -1538,6 +1538,9 @@ static void handle_beacon(struct hostapd
- 					     sizeof(mgmt->u.beacon)), &elems,
- 				      0);
- 
-+	if (!elems.ht_capabilities)
-+		hostapd_trigger_20mhz(hapd->iface);
-+
- 	ap_list_process_beacon(hapd->iface, mgmt, &elems, fi);
- }
- 
---- a/src/ap/ieee802_11.h
-+++ b/src/ap/ieee802_11.h
-@@ -82,4 +82,17 @@ int hostapd_update_time_adv(struct hosta
- void hostapd_client_poll_ok(struct hostapd_data *hapd, const u8 *addr);
- u8 * hostapd_eid_bss_max_idle_period(struct hostapd_data *hapd, u8 *eid);
- 
-+#ifdef CONFIG_IEEE80211N
-+void hostapd_trigger_20mhz(struct hostapd_iface *iface);
-+void hostapd_deinit_ht(struct hostapd_iface *iface);
-+
-+#else
-+static inline void hostapd_deinit_ht(struct hostapd_iface *iface)
-+{
-+}
-+static inline void hostapd_trigger_20mhz(struct hostapd_iface *iface)
-+{
-+}
-+#endif /* CONFIG_IEEE80211N */
-+
- #endif /* IEEE802_11_H */
---- a/src/ap/ieee802_11_ht.c
-+++ b/src/ap/ieee802_11_ht.c
-@@ -20,9 +20,11 @@
- #include "drivers/driver.h"
- #include "hostapd.h"
- #include "ap_config.h"
-+#include "ap_drv_ops.h"
- #include "sta_info.h"
- #include "beacon.h"
- #include "ieee802_11.h"
-+#include "utils/eloop.h"
- 
- 
- u8 * hostapd_eid_ht_capabilities(struct hostapd_data *hapd, u8 *eid)
-@@ -86,12 +88,15 @@ u8 * hostapd_eid_ht_operation(struct hos
- 
- 	oper->control_chan = hapd->iconf->channel;
- 	oper->operation_mode = host_to_le16(hapd->iface->ht_op_mode);
--	if (hapd->iconf->secondary_channel == 1)
--		oper->ht_param |= HT_INFO_HT_PARAM_SECONDARY_CHNL_ABOVE |
--			HT_INFO_HT_PARAM_REC_TRANS_CHNL_WIDTH;
--	if (hapd->iconf->secondary_channel == -1)
--		oper->ht_param |= HT_INFO_HT_PARAM_SECONDARY_CHNL_BELOW |
--			HT_INFO_HT_PARAM_REC_TRANS_CHNL_WIDTH;
-+
-+	if (!hapd->iface->force_20mhz) {
-+		if (hapd->iconf->secondary_channel == 1)
-+			oper->ht_param |= HT_INFO_HT_PARAM_SECONDARY_CHNL_ABOVE |
-+				HT_INFO_HT_PARAM_REC_TRANS_CHNL_WIDTH;
-+		if (hapd->iconf->secondary_channel == -1)
-+			oper->ht_param |= HT_INFO_HT_PARAM_SECONDARY_CHNL_BELOW |
-+				HT_INFO_HT_PARAM_REC_TRANS_CHNL_WIDTH;
-+	}
- 
- 	pos += sizeof(*oper);
- 
-@@ -286,3 +291,84 @@ void hostapd_get_ht_capab(struct hostapd
- 
- 	neg_ht_cap->ht_capabilities_info = host_to_le16(cap);
- }
-+
-+static void hostapd_set_force_20mhz(struct hostapd_iface *iface);
-+
-+static void hostapd_restore_40mhz(void *eloop_data, void *user_ctx)
-+{
-+	struct hostapd_iface *iface = eloop_data;
-+	struct os_time time;
-+	int timeout;
-+
-+	if (!iface->last_20mhz_trigger.sec)
-+	    return;
-+
-+	os_get_time(&time);
-+	timeout = iface->last_20mhz_trigger.sec + iface->conf->dynamic_ht40 -
-+		  time.sec;
-+
-+	if (timeout > 0) {
-+		eloop_register_timeout(timeout, 0, hostapd_restore_40mhz,
-+				       iface, NULL);
-+		return;
-+	}
-+
-+	iface->last_20mhz_trigger.sec = 0;
-+	iface->last_20mhz_trigger.usec = 0;
-+
-+	iface->force_20mhz = 0;
-+	hostapd_set_force_20mhz(iface);
-+}
-+
-+static void hostapd_set_force_20mhz(struct hostapd_iface *iface)
-+{
-+	int secondary_channel;
-+	int i;
-+
-+	ieee802_11_set_beacons(iface);
-+
-+	for (i = 0; i < iface->num_bss; i++) {
-+		struct hostapd_data *hapd = iface->bss[i];
-+
-+		if (iface->force_20mhz)
-+			secondary_channel = 0;
-+		else
-+			secondary_channel = hapd->iconf->secondary_channel;
-+
-+		if (hostapd_set_freq(hapd, hapd->iconf->hw_mode, iface->freq,
-+				     hapd->iconf->channel,
-+				     hapd->iconf->ieee80211n,
-+				     hapd->iconf->ieee80211ac,
-+				     secondary_channel,
-+				     hapd->iconf->vht_oper_chwidth,
-+				     hapd->iconf->vht_oper_centr_freq_seg0_idx,
-+				     hapd->iconf->vht_oper_centr_freq_seg1_idx)) {
-+			wpa_printf(MSG_ERROR, "Could not set channel for "
-+				   "kernel driver");
-+		}
-+	}
-+}
-+
-+void hostapd_deinit_ht(struct hostapd_iface *iface)
-+{
-+	eloop_cancel_timeout(hostapd_restore_40mhz, iface, NULL);
-+}
-+
-+void hostapd_trigger_20mhz(struct hostapd_iface *iface)
-+{
-+	if (!iface->conf->dynamic_ht40)
-+		return;
-+
-+	if (!iface->force_20mhz) {
-+		iface->force_20mhz = 1;
-+		hostapd_set_force_20mhz(iface);
-+	}
-+
-+	if (!iface->last_20mhz_trigger.sec) {
-+		eloop_cancel_timeout(hostapd_restore_40mhz, iface, NULL);
-+		eloop_register_timeout(iface->conf->dynamic_ht40, 0,
-+				       hostapd_restore_40mhz, iface, NULL);
-+	}
-+
-+	os_get_time(&iface->last_20mhz_trigger);
-+}
diff --git a/package/hostapd/patches/450-limit_debug_messages.patch b/package/hostapd/patches/450-limit_debug_messages.patch
deleted file mode 100644
index aaea941..0000000
--- a/package/hostapd/patches/450-limit_debug_messages.patch
+++ /dev/null
@@ -1,213 +0,0 @@
---- a/src/utils/wpa_debug.c
-+++ b/src/utils/wpa_debug.c
-@@ -201,7 +201,7 @@ void wpa_debug_close_linux_tracing(void)
-  *
-  * Note: New line '\n' is added to the end of the text when printing to stdout.
-  */
--void wpa_printf(int level, const char *fmt, ...)
-+void _wpa_printf(int level, const char *fmt, ...)
- {
- 	va_list ap;
- 
-@@ -248,8 +248,8 @@ void wpa_printf(int level, const char *f
- }
- 
- 
--static void _wpa_hexdump(int level, const char *title, const u8 *buf,
--			 size_t len, int show)
-+void _wpa_hexdump(int level, const char *title, const u8 *buf,
-+		  size_t len, int show)
- {
- 	size_t i;
- 
-@@ -375,20 +375,9 @@ static void _wpa_hexdump(int level, cons
- #endif /* CONFIG_ANDROID_LOG */
- }
- 
--void wpa_hexdump(int level, const char *title, const u8 *buf, size_t len)
--{
--	_wpa_hexdump(level, title, buf, len, 1);
--}
--
--
--void wpa_hexdump_key(int level, const char *title, const u8 *buf, size_t len)
--{
--	_wpa_hexdump(level, title, buf, len, wpa_debug_show_keys);
--}
- 
--
--static void _wpa_hexdump_ascii(int level, const char *title, const u8 *buf,
--			       size_t len, int show)
-+void _wpa_hexdump_ascii(int level, const char *title, const u8 *buf,
-+			size_t len, int show)
- {
- 	size_t i, llen;
- 	const u8 *pos = buf;
-@@ -495,19 +484,6 @@ static void _wpa_hexdump_ascii(int level
- }
- 
- 
--void wpa_hexdump_ascii(int level, const char *title, const u8 *buf, size_t len)
--{
--	_wpa_hexdump_ascii(level, title, buf, len, 1);
--}
--
--
--void wpa_hexdump_ascii_key(int level, const char *title, const u8 *buf,
--			   size_t len)
--{
--	_wpa_hexdump_ascii(level, title, buf, len, wpa_debug_show_keys);
--}
--
--
- #ifdef CONFIG_DEBUG_FILE
- static char *last_path = NULL;
- #endif /* CONFIG_DEBUG_FILE */
-@@ -591,7 +567,7 @@ void wpa_msg_register_ifname_cb(wpa_msg_
- }
- 
- 
--void wpa_msg(void *ctx, int level, const char *fmt, ...)
-+void _wpa_msg(void *ctx, int level, const char *fmt, ...)
- {
- 	va_list ap;
- 	char *buf;
-@@ -625,7 +601,7 @@ void wpa_msg(void *ctx, int level, const
- }
- 
- 
--void wpa_msg_ctrl(void *ctx, int level, const char *fmt, ...)
-+void _wpa_msg_ctrl(void *ctx, int level, const char *fmt, ...)
- {
- 	va_list ap;
- 	char *buf;
---- a/src/utils/wpa_debug.h
-+++ b/src/utils/wpa_debug.h
-@@ -43,6 +43,17 @@ int wpa_debug_open_file(const char *path
- int wpa_debug_reopen_file(void);
- void wpa_debug_close_file(void);
- 
-+/* internal */
-+void _wpa_hexdump(int level, const char *title, const u8 *buf,
-+		  size_t len, int show);
-+void _wpa_hexdump_ascii(int level, const char *title, const u8 *buf,
-+			size_t len, int show);
-+extern int wpa_debug_show_keys;
-+
-+#ifndef CONFIG_MSG_MIN_PRIORITY
-+#define CONFIG_MSG_MIN_PRIORITY 0
-+#endif
-+
- /**
-  * wpa_debug_printf_timestamp - Print timestamp for debug output
-  *
-@@ -63,9 +74,15 @@ void wpa_debug_print_timestamp(void);
-  *
-  * Note: New line '\n' is added to the end of the text when printing to stdout.
-  */
--void wpa_printf(int level, const char *fmt, ...)
-+void _wpa_printf(int level, const char *fmt, ...)
- PRINTF_FORMAT(2, 3);
- 
-+#define wpa_printf(level, ...)						\
-+	do {								\
-+		if (level >= CONFIG_MSG_MIN_PRIORITY)			\
-+			_wpa_printf(level, __VA_ARGS__);		\
-+	} while(0)
-+
- /**
-  * wpa_hexdump - conditional hex dump
-  * @level: priority level (MSG_*) of the message
-@@ -77,7 +94,13 @@ PRINTF_FORMAT(2, 3);
-  * output may be directed to stdout, stderr, and/or syslog based on
-  * configuration. The contents of buf is printed out has hex dump.
-  */
--void wpa_hexdump(int level, const char *title, const u8 *buf, size_t len);
-+static inline void wpa_hexdump(int level, const char *title, const u8 *buf, size_t len)
-+{
-+	if (level < CONFIG_MSG_MIN_PRIORITY)
-+		return;
-+
-+	_wpa_hexdump(level, title, buf, len, 1);
-+}
- 
- static inline void wpa_hexdump_buf(int level, const char *title,
- 				   const struct wpabuf *buf)
-@@ -99,7 +122,13 @@ static inline void wpa_hexdump_buf(int l
-  * like wpa_hexdump(), but by default, does not include secret keys (passwords,
-  * etc.) in debug output.
-  */
--void wpa_hexdump_key(int level, const char *title, const u8 *buf, size_t len);
-+static inline void wpa_hexdump_key(int level, const char *title, const u8 *buf, size_t len)
-+{
-+	if (level < CONFIG_MSG_MIN_PRIORITY)
-+		return;
-+
-+	_wpa_hexdump(level, title, buf, len, wpa_debug_show_keys);
-+}
- 
- static inline void wpa_hexdump_buf_key(int level, const char *title,
- 				       const struct wpabuf *buf)
-@@ -121,8 +150,14 @@ static inline void wpa_hexdump_buf_key(i
-  * the hex numbers and ASCII characters (for printable range) are shown. 16
-  * bytes per line will be shown.
-  */
--void wpa_hexdump_ascii(int level, const char *title, const u8 *buf,
--		       size_t len);
-+static inline void wpa_hexdump_ascii(int level, const char *title,
-+				     const u8 *buf, size_t len)
-+{
-+	if (level < CONFIG_MSG_MIN_PRIORITY)
-+		return;
-+
-+	_wpa_hexdump_ascii(level, title, buf, len, 1);
-+}
- 
- /**
-  * wpa_hexdump_ascii_key - conditional hex dump, hide keys
-@@ -138,8 +173,14 @@ void wpa_hexdump_ascii(int level, const 
-  * bytes per line will be shown. This works like wpa_hexdump_ascii(), but by
-  * default, does not include secret keys (passwords, etc.) in debug output.
-  */
--void wpa_hexdump_ascii_key(int level, const char *title, const u8 *buf,
--			   size_t len);
-+static inline void wpa_hexdump_ascii_key(int level, const char *title,
-+					 const u8 *buf, size_t len)
-+{
-+	if (level < CONFIG_MSG_MIN_PRIORITY)
-+		return;
-+
-+	_wpa_hexdump_ascii(level, title, buf, len, wpa_debug_show_keys);
-+}
- 
- /*
-  * wpa_dbg() behaves like wpa_msg(), but it can be removed from build to reduce
-@@ -174,7 +215,12 @@ void wpa_hexdump_ascii_key(int level, co
-  *
-  * Note: New line '\n' is added to the end of the text when printing to stdout.
-  */
--void wpa_msg(void *ctx, int level, const char *fmt, ...) PRINTF_FORMAT(3, 4);
-+void _wpa_msg(void *ctx, int level, const char *fmt, ...) PRINTF_FORMAT(3, 4);
-+#define wpa_msg(ctx, level, ...)					\
-+	do {								\
-+		if (level >= CONFIG_MSG_MIN_PRIORITY)			\
-+			_wpa_msg(ctx, level, __VA_ARGS__);		\
-+	} while(0)
- 
- /**
-  * wpa_msg_ctrl - Conditional printf for ctrl_iface monitors
-@@ -188,8 +234,13 @@ void wpa_msg(void *ctx, int level, const
-  * attached ctrl_iface monitors. In other words, it can be used for frequent
-  * events that do not need to be sent to syslog.
-  */
--void wpa_msg_ctrl(void *ctx, int level, const char *fmt, ...)
-+void _wpa_msg_ctrl(void *ctx, int level, const char *fmt, ...)
- PRINTF_FORMAT(3, 4);
-+#define wpa_msg_ctrl(ctx, level, ...)					\
-+	do {								\
-+		if (level >= CONFIG_MSG_MIN_PRIORITY)			\
-+			_wpa_msg_ctrl(ctx, level, __VA_ARGS__);		\
-+	} while(0)
- 
- /**
-  * wpa_msg_global - Global printf for ctrl_iface monitors
diff --git a/package/hostapd/patches/460-indicate-features.patch b/package/hostapd/patches/460-indicate-features.patch
deleted file mode 100644
index 7a44da1..0000000
--- a/package/hostapd/patches/460-indicate-features.patch
+++ /dev/null
@@ -1,82 +0,0 @@
---- a/hostapd/main.c
-+++ b/hostapd/main.c
-@@ -14,6 +14,7 @@
- 
- #include "utils/common.h"
- #include "utils/eloop.h"
-+#include "utils/build_features.h"
- #include "crypto/random.h"
- #include "crypto/tls.h"
- #include "common/version.h"
-@@ -546,7 +547,7 @@ int main(int argc, char *argv[])
- 
- 	wpa_supplicant_event = hostapd_wpa_event;
- 	for (;;) {
--		c = getopt(argc, argv, "b:Bde:f:hKP:Ttvg:G:");
-+		c = getopt(argc, argv, "b:Bde:f:hKP:Ttg:G:v::");
- 		if (c < 0)
- 			break;
- 		switch (c) {
-@@ -583,6 +584,8 @@ int main(int argc, char *argv[])
- 			break;
- #endif /* CONFIG_DEBUG_LINUX_TRACING */
- 		case 'v':
-+			if (optarg)
-+				exit(!has_feature(optarg));
- 			show_version();
- 			exit(1);
- 			break;
---- a/wpa_supplicant/main.c
-+++ b/wpa_supplicant/main.c
-@@ -12,6 +12,7 @@
- #endif /* __linux__ */
- 
- #include "common.h"
-+#include "build_features.h"
- #include "wpa_supplicant_i.h"
- #include "driver_i.h"
- #include "p2p_supplicant.h"
-@@ -161,7 +162,7 @@ int main(int argc, char *argv[])
- 
- 	for (;;) {
- 		c = getopt(argc, argv,
--			   "b:Bc:C:D:de:f:g:G:hH:i:I:KLNo:O:p:P:qsTtuvW");
-+			   "b:Bc:C:D:de:f:g:G:hH:i:I:KLNo:O:p:P:qsTtuv::W");
- 		if (c < 0)
- 			break;
- 		switch (c) {
-@@ -259,8 +260,12 @@ int main(int argc, char *argv[])
- 			break;
- #endif /* CONFIG_DBUS */
- 		case 'v':
--			printf("%s\n", wpa_supplicant_version);
--			exitcode = 0;
-+			if (optarg) {
-+				exitcode = !has_feature(optarg);
-+			} else {
-+				printf("%s\n", wpa_supplicant_version);
-+				exitcode = 0;
-+			}
- 			goto out;
- 		case 'W':
- 			params.wait_for_monitor++;
---- /dev/null
-+++ b/src/utils/build_features.h
-@@ -0,0 +1,17 @@
-+#ifndef BUILD_FEATURES_H
-+#define BUILD_FEATURES_H
-+
-+static inline int has_feature(const char *feat)
-+{
-+#ifdef IEEE8021X_EAPOL
-+	if (!strcmp(feat, "eap"))
-+		return 1;
-+#endif
-+#ifdef IEEE80211N
-+	if (!strcmp(feat, "11n"))
-+		return 1;
-+#endif
-+	return 0;
-+}
-+
-+#endif /* BUILD_FEATURES_H */
diff --git a/package/hostapd/patches/470-hostapd_cli_ifdef.patch b/package/hostapd/patches/470-hostapd_cli_ifdef.patch
deleted file mode 100644
index 5ac0fdd..0000000
--- a/package/hostapd/patches/470-hostapd_cli_ifdef.patch
+++ /dev/null
@@ -1,50 +0,0 @@
---- a/hostapd/hostapd_cli.c
-+++ b/hostapd/hostapd_cli.c
-@@ -67,7 +67,6 @@ static const char *commands_help =
- #ifdef CONFIG_IEEE80211W
- "   sa_query <addr>      send SA Query to a station\n"
- #endif /* CONFIG_IEEE80211W */
--#ifdef CONFIG_WPS
- "   wps_pin <uuid> <pin> [timeout] [addr]  add WPS Enrollee PIN\n"
- "   wps_check_pin <PIN>  verify PIN checksum\n"
- "   wps_pbc              indicate button pushed to initiate PBC\n"
-@@ -80,7 +79,6 @@ static const char *commands_help =
- "   wps_ap_pin <cmd> [params..]  enable/disable AP PIN\n"
- "   wps_config <SSID> <auth> <encr> <key>  configure AP\n"
- "   wps_get_status       show current WPS status\n"
--#endif /* CONFIG_WPS */
- "   get_config           show current configuration\n"
- "   help                 show this usage help\n"
- "   interface [ifname]   show interfaces/select interface\n"
-@@ -352,7 +350,6 @@ static int hostapd_cli_cmd_sa_query(stru
- #endif /* CONFIG_IEEE80211W */
- 
- 
--#ifdef CONFIG_WPS
- static int hostapd_cli_cmd_wps_pin(struct wpa_ctrl *ctrl, int argc,
- 				   char *argv[])
- {
-@@ -578,7 +575,6 @@ static int hostapd_cli_cmd_wps_config(st
- 			 ssid_hex, argv[1]);
- 	return wpa_ctrl_command(ctrl, buf);
- }
--#endif /* CONFIG_WPS */
- 
- 
- static int hostapd_cli_cmd_disassoc_imminent(struct wpa_ctrl *ctrl, int argc,
-@@ -903,7 +899,6 @@ static struct hostapd_cli_cmd hostapd_cl
- #ifdef CONFIG_IEEE80211W
- 	{ "sa_query", hostapd_cli_cmd_sa_query },
- #endif /* CONFIG_IEEE80211W */
--#ifdef CONFIG_WPS
- 	{ "wps_pin", hostapd_cli_cmd_wps_pin },
- 	{ "wps_check_pin", hostapd_cli_cmd_wps_check_pin },
- 	{ "wps_pbc", hostapd_cli_cmd_wps_pbc },
-@@ -917,7 +912,6 @@ static struct hostapd_cli_cmd hostapd_cl
- 	{ "wps_ap_pin", hostapd_cli_cmd_wps_ap_pin },
- 	{ "wps_config", hostapd_cli_cmd_wps_config },
- 	{ "wps_get_status", hostapd_cli_cmd_wps_get_status },
--#endif /* CONFIG_WPS */
- 	{ "disassoc_imminent", hostapd_cli_cmd_disassoc_imminent },
- 	{ "ess_disassoc", hostapd_cli_cmd_ess_disassoc },
- 	{ "get_config", hostapd_cli_cmd_get_config },
diff --git a/package/hostapd/patches/471-wpa_cli_ifdef.patch b/package/hostapd/patches/471-wpa_cli_ifdef.patch
deleted file mode 100644
index cc84444..0000000
--- a/package/hostapd/patches/471-wpa_cli_ifdef.patch
+++ /dev/null
@@ -1,13 +0,0 @@
---- a/wpa_supplicant/wpa_cli.c
-+++ b/wpa_supplicant/wpa_cli.c
-@@ -26,6 +26,10 @@
- #endif /* ANDROID */
- 
- 
-+#ifndef CONFIG_P2P
-+#define CONFIG_P2P
-+#endif
-+
- static const char *wpa_cli_version =
- "wpa_cli v" VERSION_STR "\n"
- "Copyright (c) 2004-2013, Jouni Malinen <j@w1.fi> and contributors";
diff --git a/package/hostapd/patches/480-max_num_sta_probe.patch b/package/hostapd/patches/480-max_num_sta_probe.patch
deleted file mode 100644
index e5ca8b4..0000000
--- a/package/hostapd/patches/480-max_num_sta_probe.patch
+++ /dev/null
@@ -1,13 +0,0 @@
---- a/src/ap/beacon.c
-+++ b/src/ap/beacon.c
-@@ -501,6 +501,10 @@ void handle_probe_req(struct hostapd_dat
- 		return;
- 	}
- 
-+	if (!sta && hapd->num_sta >= hapd->conf->max_num_sta)
-+		wpa_printf(MSG_MSGDUMP, "Probe Request from " MACSTR " ignored,"
-+			   " too many connected stations.", MAC2STR(mgmt->sa));
-+
- #ifdef CONFIG_INTERWORKING
- 	if (elems.interworking && elems.interworking_len >= 1) {
- 		u8 ant = elems.interworking[0] & 0x0f;
diff --git a/package/hostapd/patches/490-scan_wait.patch b/package/hostapd/patches/490-scan_wait.patch
deleted file mode 100644
index 61715d6..0000000
--- a/package/hostapd/patches/490-scan_wait.patch
+++ /dev/null
@@ -1,66 +0,0 @@
---- a/hostapd/main.c
-+++ b/hostapd/main.c
-@@ -33,6 +33,8 @@
- extern int wpa_debug_level;
- extern int wpa_debug_show_keys;
- extern int wpa_debug_timestamp;
-+static int daemonize = 0;
-+static char *pid_file = NULL;
- 
- extern struct wpa_driver_ops *wpa_drivers[];
- 
-@@ -147,6 +149,14 @@ static void hostapd_logger_cb(void *ctx,
- }
- #endif /* CONFIG_NO_HOSTAPD_LOGGER */
- 
-+static void hostapd_setup_complete_cb(void *ctx)
-+{
-+	if (daemonize && os_daemonize(pid_file)) {
-+		perror("daemon");
-+		return;
-+	}
-+	daemonize = 0;
-+}
- 
- /**
-  * hostapd_driver_init - Preparate driver interface
-@@ -165,6 +175,8 @@ static int hostapd_driver_init(struct ho
- 		return -1;
- 	}
- 
-+	hapd->setup_complete_cb = hostapd_setup_complete_cb;
-+
- 	/* Initialize the driver interface */
- 	if (!(b[0] | b[1] | b[2] | b[3] | b[4] | b[5]))
- 		b = NULL;
-@@ -381,8 +393,6 @@ static void hostapd_global_deinit(const 
- #endif /* CONFIG_NATIVE_WINDOWS */
- 
- 	eap_server_unregister_methods();
--
--	os_daemonize_terminate(pid_file);
- }
- 
- 
-@@ -408,11 +418,6 @@ static int hostapd_global_run(struct hap
- 	}
- #endif /* EAP_SERVER_TNC */
- 
--	if (daemonize && os_daemonize(pid_file)) {
--		perror("daemon");
--		return -1;
--	}
--
- 	eloop_run();
- 
- 	return 0;
-@@ -521,8 +526,7 @@ int main(int argc, char *argv[])
- 	struct hapd_interfaces interfaces;
- 	int ret = 1;
- 	size_t i, j;
--	int c, debug = 0, daemonize = 0;
--	char *pid_file = NULL;
-+	int c, debug = 0;
- 	const char *log_file = NULL;
- 	const char *entropy_file = NULL;
- 	char **bss_config = NULL, **tmp_bss;
diff --git a/package/hostapd/patches/500-wpa_supplicant-add-new-config-params-to-be-used-with.patch b/package/hostapd/patches/500-wpa_supplicant-add-new-config-params-to-be-used-with.patch
deleted file mode 100644
index 544151e..0000000
--- a/package/hostapd/patches/500-wpa_supplicant-add-new-config-params-to-be-used-with.patch
+++ /dev/null
@@ -1,209 +0,0 @@
-From 4bb69d15477e0f2b00e166845341dc933de47c58 Mon Sep 17 00:00:00 2001
-From: Antonio Quartulli <ordex@autistici.org>
-Date: Sun, 3 Jun 2012 18:22:56 +0200
-Subject: [PATCHv2 601/602] wpa_supplicant: add new config params to be used
- with the ibss join command
-
-Signed-hostap: Antonio Quartulli <ordex@autistici.org>
----
- src/drivers/driver.h            |    6 +++
- wpa_supplicant/config.c         |   96 +++++++++++++++++++++++++++++++++++++++
- wpa_supplicant/config_ssid.h    |    6 +++
- wpa_supplicant/wpa_supplicant.c |   23 +++++++---
- 4 files changed, 124 insertions(+), 7 deletions(-)
-
---- a/src/drivers/driver.h
-+++ b/src/drivers/driver.h
-@@ -19,6 +19,7 @@
- 
- #define WPA_SUPPLICANT_DRIVER_VERSION 4
- 
-+#include "drivers/nl80211_copy.h"
- #include "common/defs.h"
- #include "utils/list.h"
- 
-@@ -404,6 +405,11 @@ struct wpa_driver_associate_params {
- 	 */
- 	int freq;
- 
-+	int beacon_interval;
-+	int fixed_freq;
-+	unsigned char rates[NL80211_MAX_SUPP_RATES];
-+	int mcast_rate;
-+
- 	/**
- 	 * bg_scan_period - Background scan period in seconds, 0 to disable
- 	 * background scan, or -1 to indicate no change to default driver
---- a/wpa_supplicant/config.c
-+++ b/wpa_supplicant/config.c
-@@ -14,6 +14,7 @@
- #include "rsn_supp/wpa.h"
- #include "eap_peer/eap.h"
- #include "p2p/p2p.h"
-+#include "drivers/nl80211_copy.h"
- #include "config.h"
- 
- 
-@@ -1512,6 +1513,97 @@ static char * wpa_config_write_psk_list(
- 
- #endif /* CONFIG_P2P */
- 
-+static int wpa_config_parse_mcast_rate(const struct parse_data *data,
-+				       struct wpa_ssid *ssid, int line,
-+				       const char *value)
-+{
-+	ssid->mcast_rate = (int)(strtod(value, NULL) * 10);
-+
-+	return 0;
-+}
-+
-+#ifndef NO_CONFIG_WRITE
-+static char * wpa_config_write_mcast_rate(const struct parse_data *data,
-+					  struct wpa_ssid *ssid)
-+{
-+	char *value;
-+	int res;
-+
-+	if (!ssid->mcast_rate == 0)
-+		return NULL;
-+
-+	value = os_malloc(6); /* longest: 300.0 */
-+	if (value == NULL)
-+		return NULL;
-+	res = os_snprintf(value, 5, "%.1f", (double)ssid->mcast_rate / 10);
-+	if (res < 0) {
-+		os_free(value);
-+		return NULL;
-+	}
-+	return value;
-+}
-+#endif /* NO_CONFIG_WRITE */
-+
-+static int wpa_config_parse_rates(const struct parse_data *data,
-+				  struct wpa_ssid *ssid, int line,
-+				  const char *value)
-+{
-+	int i;
-+	char *pos, *r, *sptr, *end;
-+	double rate;
-+
-+	pos = (char *)value;
-+	r = strtok_r(pos, ",", &sptr);
-+	i = 0;
-+	while (pos && i < NL80211_MAX_SUPP_RATES) {
-+		rate = 0.0;
-+		if (r)
-+			rate = strtod(r, &end);
-+		ssid->rates[i] = rate * 2;
-+		if (*end != '\0' || rate * 2 != ssid->rates[i])
-+			return 1;
-+
-+		i++;
-+		r = strtok_r(NULL, ",", &sptr);
-+	}
-+
-+	return 0;
-+}
-+
-+#ifndef NO_CONFIG_WRITE
-+static char * wpa_config_write_rates(const struct parse_data *data,
-+				     struct wpa_ssid *ssid)
-+{
-+	char *value, *pos;
-+	int res, i;
-+
-+	if (ssid->rates[0] <= 0)
-+		return NULL;
-+
-+	value = os_malloc(6 * NL80211_MAX_SUPP_RATES + 1);
-+	if (value == NULL)
-+		return NULL;
-+	pos = value;
-+	for (i = 0; i < NL80211_MAX_SUPP_RATES - 1; i++) {
-+		res = os_snprintf(pos, 6, "%.1f,", (double)ssid->rates[i] / 2);
-+		if (res < 0) {
-+			os_free(value);
-+			return NULL;
-+		}
-+		pos += res;
-+	}
-+	res = os_snprintf(pos, 6, "%.1f",
-+			  (double)ssid->rates[NL80211_MAX_SUPP_RATES - 1] / 2);
-+	if (res < 0) {
-+		os_free(value);
-+		return NULL;
-+	}
-+
-+	value[6 * NL80211_MAX_SUPP_RATES] = '\0';
-+	return value;
-+}
-+#endif /* NO_CONFIG_WRITE */
-+
- /* Helper macros for network block parser */
- 
- #ifdef OFFSET
-@@ -1715,6 +1807,9 @@ static const struct parse_data ssid_fiel
- 	{ INT(ap_max_inactivity) },
- 	{ INT(dtim_period) },
- 	{ INT(beacon_int) },
-+	{ INT_RANGE(fixed_freq, 0, 1) },
-+	{ FUNC(rates) },
-+	{ FUNC(mcast_rate) },
- };
- 
- #undef OFFSET
---- a/wpa_supplicant/config_ssid.h
-+++ b/wpa_supplicant/config_ssid.h
-@@ -12,6 +12,7 @@
- #include "common/defs.h"
- #include "utils/list.h"
- #include "eap_peer/eap_config.h"
-+#include "drivers/nl80211_copy.h"
- 
- #define MAX_SSID_LEN 32
- 
-@@ -620,6 +621,10 @@ struct wpa_ssid {
- 	 * dereferences since it may not be updated in all cases.
- 	 */
- 	void *parent_cred;
-+
-+	int fixed_freq;
-+	unsigned char rates[NL80211_MAX_SUPP_RATES];
-+	double mcast_rate;
- };
- 
- #endif /* CONFIG_SSID_H */
---- a/wpa_supplicant/wpa_supplicant.c
-+++ b/wpa_supplicant/wpa_supplicant.c
-@@ -1623,15 +1623,24 @@ void wpa_supplicant_associate(struct wpa
- 		params.ssid_len = ssid->ssid_len;
- 	}
- 
--	if (ssid->mode == WPAS_MODE_IBSS && ssid->bssid_set &&
--	    wpa_s->conf->ap_scan == 2) {
--		params.bssid = ssid->bssid;
--		params.fixed_bssid = 1;
-+	if (ssid->mode == WPAS_MODE_IBSS) {
-+		if (ssid->bssid_set && wpa_s->conf->ap_scan == 2) {
-+			params.bssid = ssid->bssid;
-+			params.fixed_bssid = 1;
-+		}
-+		if (ssid->frequency > 0 && params.freq == 0)
-+			/* Initial channel for IBSS */
-+			params.freq = ssid->frequency;
-+		params.fixed_freq = ssid->fixed_freq;
-+		params.beacon_interval = ssid->beacon_int;
-+		i = 0;
-+		while (i < NL80211_MAX_SUPP_RATES) {
-+			params.rates[i] = ssid->rates[i];
-+			i++;
-+		}
-+		params.mcast_rate = ssid->mcast_rate;
- 	}
- 
--	if (ssid->mode == WPAS_MODE_IBSS && ssid->frequency > 0 &&
--	    params.freq == 0)
--		params.freq = ssid->frequency; /* Initial channel for IBSS */
- 	params.wpa_ie = wpa_ie;
- 	params.wpa_ie_len = wpa_ie_len;
- 	params.pairwise_suite = cipher_pairwise;
diff --git a/package/hostapd/patches/501-driver_nl80211-use-new-parameters-during-ibss-join.patch b/package/hostapd/patches/501-driver_nl80211-use-new-parameters-during-ibss-join.patch
deleted file mode 100644
index 565bbc9..0000000
--- a/package/hostapd/patches/501-driver_nl80211-use-new-parameters-during-ibss-join.patch
+++ /dev/null
@@ -1,59 +0,0 @@
-From ffc4445958a3ed4064f2e1bf73fa478a61c5cf7b Mon Sep 17 00:00:00 2001
-From: Antonio Quartulli <ordex@autistici.org>
-Date: Sun, 3 Jun 2012 18:42:25 +0200
-Subject: [PATCHv2 602/602] driver_nl80211: use new parameters during ibss join
-
-Signed-hostap: Antonio Quartulli <ordex@autistici.org>
----
- src/drivers/driver_nl80211.c |   33 ++++++++++++++++++++++++++++++++-
- 1 file changed, 32 insertions(+), 1 deletion(-)
-
---- a/src/drivers/driver_nl80211.c
-+++ b/src/drivers/driver_nl80211.c
-@@ -7903,7 +7903,7 @@ static int wpa_driver_nl80211_ibss(struc
- 				   struct wpa_driver_associate_params *params)
- {
- 	struct nl_msg *msg;
--	int ret = -1;
-+	int ret = -1, i;
- 	int count = 0;
- 
- 	wpa_printf(MSG_DEBUG, "nl80211: Join IBSS (ifindex=%d)", drv->ifindex);
-@@ -7936,6 +7936,37 @@ retry:
- 	wpa_printf(MSG_DEBUG, "  * freq=%d", params->freq);
- 	NLA_PUT_U32(msg, NL80211_ATTR_WIPHY_FREQ, params->freq);
- 
-+	if (params->fixed_freq) {
-+		wpa_printf(MSG_DEBUG, "  * fixed_freq");
-+		NLA_PUT_FLAG(msg, NL80211_ATTR_FREQ_FIXED);
-+	}
-+
-+	if (params->beacon_interval > 0) {
-+		wpa_printf(MSG_DEBUG, "  * beacon_interval=%d",
-+			   params->beacon_interval);
-+		NLA_PUT_U32(msg, NL80211_ATTR_BEACON_INTERVAL,
-+			    params->beacon_interval);
-+	}
-+
-+	if (params->rates[0] > 0) {
-+		wpa_printf(MSG_DEBUG, "  * basic_rates:");
-+		i = 0;
-+		while (i < NL80211_MAX_SUPP_RATES &&
-+		       params->rates[i] > 0) {
-+			wpa_printf(MSG_DEBUG, "    %.1f",
-+				   (double)params->rates[i] / 2);
-+			i++;
-+		}
-+		NLA_PUT(msg, NL80211_ATTR_BSS_BASIC_RATES, i,
-+			params->rates);
-+	}
-+
-+	if (params->mcast_rate > 0) {
-+		wpa_printf(MSG_DEBUG, "  * mcast_rates=%.1f",
-+			   (double)params->mcast_rate / 10);
-+		NLA_PUT_U32(msg, NL80211_ATTR_MCAST_RATE, params->mcast_rate);
-+	}
-+
- 	ret = nl80211_set_conn_keys(params, msg);
- 	if (ret)
- 		goto nla_put_failure;
diff --git a/package/hostapd/patches/502-wpa_s-support-htmode-param.patch b/package/hostapd/patches/502-wpa_s-support-htmode-param.patch
deleted file mode 100644
index adb20a2..0000000
--- a/package/hostapd/patches/502-wpa_s-support-htmode-param.patch
+++ /dev/null
@@ -1,156 +0,0 @@
-From b9329c5dfeed7d5c55d2117d8dfe326fc40c8fb1 Mon Sep 17 00:00:00 2001
-From: Antonio Quartulli <ordex@autistici.org>
-Date: Tue, 3 Jul 2012 00:36:24 +0200
-Subject: [PATCH] wpa_s: support htmode param
-
-possible values are HT20, HT40-, HT40+ and NOHT
-
-Signed-off-by: Antonio Quartulli <ordex@autistici.org>
----
- src/drivers/driver.h            |    2 ++
- src/drivers/driver_nl80211.c    |   16 ++++++++++
- wpa_supplicant/config.c         |   66 +++++++++++++++++++++++++++++++++++++++
- wpa_supplicant/config_ssid.h    |    2 ++
- wpa_supplicant/wpa_supplicant.c |    2 ++
- 5 files changed, 88 insertions(+)
-
---- a/src/drivers/driver.h
-+++ b/src/drivers/driver.h
-@@ -409,6 +409,8 @@ struct wpa_driver_associate_params {
- 	int fixed_freq;
- 	unsigned char rates[NL80211_MAX_SUPP_RATES];
- 	int mcast_rate;
-+	int ht_set;
-+	unsigned int htmode;
- 
- 	/**
- 	 * bg_scan_period - Background scan period in seconds, 0 to disable
---- a/src/drivers/driver_nl80211.c
-+++ b/src/drivers/driver_nl80211.c
-@@ -7967,6 +7967,22 @@ retry:
- 		NLA_PUT_U32(msg, NL80211_ATTR_MCAST_RATE, params->mcast_rate);
- 	}
- 
-+	if (params->ht_set) {
-+		switch(params->htmode) {
-+			case NL80211_CHAN_HT20:
-+				wpa_printf(MSG_DEBUG, "  * ht=HT20");
-+				break;
-+			case NL80211_CHAN_HT40PLUS:
-+				wpa_printf(MSG_DEBUG, "  * ht=HT40+");
-+				break;
-+			case NL80211_CHAN_HT40MINUS:
-+				wpa_printf(MSG_DEBUG, "  * ht=HT40-");
-+				break;
-+		}
-+		NLA_PUT_U32(msg, NL80211_ATTR_WIPHY_CHANNEL_TYPE,
-+			    params->htmode);
-+	}
-+
- 	ret = nl80211_set_conn_keys(params, msg);
- 	if (ret)
- 		goto nla_put_failure;
---- a/wpa_supplicant/config.c
-+++ b/wpa_supplicant/config.c
-@@ -1544,6 +1544,71 @@ static char * wpa_config_write_mcast_rat
- }
- #endif /* NO_CONFIG_WRITE */
- 
-+static int wpa_config_parse_htmode(const struct parse_data *data,
-+				   struct wpa_ssid *ssid, int line,
-+				   const char *value)
-+{
-+	int i;
-+	static const struct {
-+		const char *name;
-+		unsigned int val;
-+	} htmap[] = {
-+		{ .name = "HT20", .val = NL80211_CHAN_HT20, },
-+		{ .name = "HT40+", .val = NL80211_CHAN_HT40PLUS, },
-+		{ .name = "HT40-", .val = NL80211_CHAN_HT40MINUS, },
-+		{ .name = "NOHT", .val = NL80211_CHAN_NO_HT, },
-+	};
-+	ssid->ht_set = 0;;
-+	for (i = 0; i < 4; i++) {
-+		if (strcasecmp(htmap[i].name, value) == 0) {
-+			ssid->htmode = htmap[i].val;
-+			ssid->ht_set = 1;
-+			break;
-+		}
-+	}
-+
-+	return 0;
-+}
-+
-+#ifndef NO_CONFIG_WRITE
-+static char * wpa_config_write_htmode(const struct parse_data *data,
-+				      struct wpa_ssid *ssid)
-+{
-+	char *value;
-+	int res;
-+
-+	value = os_malloc(6); /* longest: HT40+ */
-+	if (value == NULL)
-+		return NULL;
-+
-+	switch(ssid->htmode) {
-+		case NL80211_CHAN_HT20:
-+			res = os_snprintf(value, 4, "HT20");
-+			break;
-+		case NL80211_CHAN_HT40PLUS:
-+			res = os_snprintf(value, 5, "HT40+");
-+			break;
-+		case NL80211_CHAN_HT40MINUS:
-+			res = os_snprintf(value, 5, "HT40-");
-+			break;
-+		case NL80211_CHAN_NO_HT:
-+			res = os_snprintf(value, 4, "NOHT");
-+			break;
-+		default:
-+			os_free(value);
-+			return NULL;
-+	}
-+
-+	if (res < 0) {
-+		os_free(value);
-+		return NULL;
-+	}
-+
-+	return value;
-+}
-+#endif /* NO_CONFIG_WRITE */
-+
-+
- static int wpa_config_parse_rates(const struct parse_data *data,
- 				  struct wpa_ssid *ssid, int line,
- 				  const char *value)
-@@ -1810,6 +1875,7 @@ static const struct parse_data ssid_fiel
- 	{ INT_RANGE(fixed_freq, 0, 1) },
- 	{ FUNC(rates) },
- 	{ FUNC(mcast_rate) },
-+	{ FUNC(htmode) },
- };
- 
- #undef OFFSET
---- a/wpa_supplicant/config_ssid.h
-+++ b/wpa_supplicant/config_ssid.h
-@@ -625,6 +625,8 @@ struct wpa_ssid {
- 	int fixed_freq;
- 	unsigned char rates[NL80211_MAX_SUPP_RATES];
- 	double mcast_rate;
-+	int ht_set;
-+	unsigned int htmode;
- };
- 
- #endif /* CONFIG_SSID_H */
---- a/wpa_supplicant/wpa_supplicant.c
-+++ b/wpa_supplicant/wpa_supplicant.c
-@@ -1639,6 +1639,8 @@ void wpa_supplicant_associate(struct wpa
- 			i++;
- 		}
- 		params.mcast_rate = ssid->mcast_rate;
-+		params.ht_set = ssid->ht_set;
-+		params.htmode = ssid->htmode;
- 	}
- 
- 	params.wpa_ie = wpa_ie;
diff --git a/package/hostapd/patches/510-wpa_supplicant_p2p_parse_ifcomb.patch b/package/hostapd/patches/510-wpa_supplicant_p2p_parse_ifcomb.patch
deleted file mode 100644
index fe72ee2..0000000
--- a/package/hostapd/patches/510-wpa_supplicant_p2p_parse_ifcomb.patch
+++ /dev/null
@@ -1,18 +0,0 @@
---- a/src/drivers/driver_nl80211.c
-+++ b/src/drivers/driver_nl80211.c
-@@ -3157,10 +3157,12 @@ static int wiphy_info_iface_comb_process
- 	}
- 
- 	if (combination_has_p2p && combination_has_mgd) {
--		info->p2p_concurrent = 1;
--		info->num_multichan_concurrent =
-+		int num_channels =
- 			nla_get_u32(tb_comb[NL80211_IFACE_COMB_NUM_CHANNELS]);
--		return 1;
-+
-+		info->p2p_concurrent = 1;
-+		if (info->num_multichan_concurrent < num_channels)
-+			info->num_multichan_concurrent = num_channels;
- 	}
- 
- 	return 0;
diff --git a/package/mac80211/Makefile b/package/mac80211/Makefile
deleted file mode 100644
index d9149d9..0000000
--- a/package/mac80211/Makefile
+++ /dev/null
@@ -1,1856 +0,0 @@
-#
-# Copyright (C) 2007-2013 OpenWrt.org
-#
-# This is free software, licensed under the GNU General Public License v2.
-# See /LICENSE for more information.
-#
-
-include $(TOPDIR)/rules.mk
-include $(INCLUDE_DIR)/kernel.mk
-
-PKG_NAME:=mac80211
-
-PKG_VERSION:=2014-01-23.1
-PKG_RELEASE:=1
-PKG_SOURCE_URL:=http://mirror2.openwrt.org/sources
-PKG_BACKPORT_VERSION:=
-PKG_MD5SUM:=8db16edbdaf4abc2e9c2f3b6c86736a6
-
-PKG_SOURCE:=compat-wireless-$(PKG_VERSION)$(PKG_BACKPORT_VERSION).tar.bz2
-PKG_BUILD_DIR:=$(KERNEL_BUILD_DIR)/compat-wireless-$(PKG_VERSION)
-PKG_BUILD_PARALLEL:=1
-
-PKG_MAINTAINER:=Felix Fietkau <nbd@openwrt.org>
-
-PKG_DRIVERS = \
-	adm8211 ath5k libertas-usb libertas-sd p54-common p54-pci p54-usb p54-spi \
-	rt2x00-lib rt2x00-pci rt2x00-usb rt2800-lib rt2400-pci rt2500-pci \
-	rt2500-usb rt61-pci rt73-usb rt2800-mmio rt2800-pci rt2800-usb rt2800-soc \
-	rtl8180 rtl8187 zd1211rw mac80211-hwsim carl9170 b43 b43legacy \
-	ath9k-common ath9k ath9k-htc ath10k ath net-libipw net-ipw2100 net-ipw2200 \
-	mwl8k net-hermes net-hermes-pci net-hermes-plx net-hermes-pcmcia \
-	iwl-legacy iwl3945 iwl4965 iwlagn wlcore wl12xx wl18xx lib80211 \
-	rtlwifi rtlwifi-pci rtlwifi-usb rtl8192c-common rtl8192ce rtl8192se \
-	rtl8192de rtl8192cu
-
-PKG_CONFIG_DEPENDS:= \
-	CONFIG_PACKAGE_kmod-mac80211 \
-	$(patsubst %,CONFIG_PACKAGE_kmod-%,$(PKG_DRIVERS)) \
-	CONFIG_PACKAGE_MAC80211_DEBUGFS \
-	CONFIG_PACKAGE_MAC80211_MESH \
-	CONFIG_PACKAGE_ATH_DEBUG \
-	CONFIG_PACKAGE_B43_DEBUG \
-	CONFIG_PACKAGE_B43_PIO \
-	CONFIG_PACKAGE_B43_N_PHY \
-	CONFIG_PACKAGE_RTLWIFI_DEBUG \
-	CONFIG_ATH_USER_REGD \
-
-include $(INCLUDE_DIR)/package.mk
-
-WMENU:=Wireless Drivers
-
-define KernelPackage/mac80211/Default
-  SUBMENU:=$(WMENU)
-  URL:=http://linuxwireless.org/
-  MAINTAINER:=Felix Fietkau <nbd@openwrt.org>
-  DEPENDS:=@(!(TARGET_avr32||TARGET_ps3||TARGET_pxcab)||BROKEN)
-endef
-
-define KernelPackage/cfg80211
-  $(call KernelPackage/mac80211/Default)
-  TITLE:=cfg80211 - wireless configuration API
-  DEPENDS+= +iw
-  FILES:= \
-	$(PKG_BUILD_DIR)/compat/compat.ko \
-	$(PKG_BUILD_DIR)/net/wireless/cfg80211.ko
-  AUTOLOAD:=$(call AutoLoad,20,compat cfg80211)
-endef
-
-define KernelPackage/cfg80211/description
-cfg80211 is the Linux wireless LAN (802.11) configuration API.
-endef
-
-define KernelPackage/mac80211
-  $(call KernelPackage/mac80211/Default)
-  TITLE:=Linux 802.11 Wireless Networking Stack
-  DEPENDS+= +kmod-crypto-core +kmod-crypto-arc4 +kmod-crypto-aes +kmod-cfg80211
-  KCONFIG:=\
-	CONFIG_AVERAGE=y
-  FILES:= $(PKG_BUILD_DIR)/net/mac80211/mac80211.ko
-  AUTOLOAD:=$(call AutoLoad,21,mac80211)
-  MENU:=1
-endef
-
-define KernelPackage/mac80211/config
-  if PACKAGE_kmod-mac80211
-
-	config PACKAGE_MAC80211_DEBUGFS
-		bool "Export mac80211 internals in DebugFS"
-		select KERNEL_DEBUG_FS
-		select KERNEL_RELAY if PACKAGE_kmod-ath9k-common
-		default y
-		help
-		  Select this to see extensive information about
-		  the internal state of mac80211 in debugfs.
-
-	config PACKAGE_MAC80211_MESH
-		bool "Enable 802.11s mesh support"
-		default y
-
-  endif
-endef
-
-define KernelPackage/mac80211/description
-Generic IEEE 802.11 Networking Stack (mac80211)
-endef
-
-PKG_LINUX_FIRMWARE_NAME:=linux-firmware
-PKG_LINUX_FIRMWARE_VERSION:=7d0c7a8cfd78388d90cc784a185b19dcbdbce824
-PKG_LINUX_FIRMWARE_SOURCE:=$(PKG_LINUX_FIRMWARE_NAME)-$(PKG_LINUX_FIRMWARE_VERSION).tar.bz2
-PKG_LINUX_FIRMWARE_PROTO:=git
-PKG_LINUX_FIRMWARE_SOURCE_URL:=git://git.kernel.org/pub/scm/linux/kernel/git/firmware/linux-firmware.git
-PKG_LINUX_FIRMWARE_SUBDIR:=$(PKG_LINUX_FIRMWARE_NAME)-$(PKG_LINUX_FIRMWARE_VERSION)
-PKG_LINUX_FIRMWARE_MIRROR_MD5SUM:=837a1a9456c1ec8b428cc0b2b08a331b
-
-define Download/linux-firmware
-  FILE:=$(PKG_LINUX_FIRMWARE_SOURCE)
-  URL:=$(PKG_LINUX_FIRMWARE_SOURCE_URL)
-  MD5SUM:=$(PKG_LINUX_FIRMWARE_MD5SUM)
-  PROTO:=$(PKG_LINUX_FIRMWARE_PROTO)
-  VERSION:=$(PKG_LINUX_FIRMWARE_VERSION)
-  SUBDIR:=$(PKG_LINUX_FIRMWARE_SUBDIR)
-  MIRROR_MD5SUM:=$(PKG_LINUX_FIRMWARE_MIRROR_MD5SUM)
-endef
-$(eval $(call Download,linux-firmware))
-
-PKG_ATH10K_LINUX_FIRMWARE_NAME:=ath10k-firmware
-PKG_ATH10K_LINUX_FIRMWARE_VERSION:=d86e78e5c6be34329936c8bd73a212700437be2e
-PKG_ATH10K_LINUX_FIRMWARE_SOURCE:=$(PKG_ATH10K_LINUX_FIRMWARE_NAME)-$(PKG_ATH10K_LINUX_FIRMWARE_VERSION).tar.bz2
-PKG_ATH10K_LINUX_FIRMWARE_PROTO:=git
-PKG_ATH10K_LINUX_FIRMWARE_SOURCE_URL:=https://github.com/kvalo/ath10k-firmware.git
-PKG_ATH10K_LINUX_FIRMWARE_SUBDIR:=$(PKG_ATH10K_LINUX_FIRMWARE_NAME)-$(PKG_ATH10K_LINUX_FIRMWARE_VERSION)
-#PKG_ATH10K_LINUX_FIRMWARE_MIRROR_MD5SUM:=?
-
-define Download/ath10k-firmware
-  FILE:=$(PKG_ATH10K_LINUX_FIRMWARE_SOURCE)
-  URL:=$(PKG_ATH10K_LINUX_FIRMWARE_SOURCE_URL)
-  PROTO:=$(PKG_ATH10K_LINUX_FIRMWARE_PROTO)
-  VERSION:=$(PKG_ATH10K_LINUX_FIRMWARE_VERSION)
-  SUBDIR:=$(PKG_ATH10K_LINUX_FIRMWARE_SUBDIR)
-  #MIRROR_MD5SUM:=$(PKG_ATH10K_LINUX_FIRMWARE_MIRROR_MD5SUM)
-endef
-$(eval $(call Download,ath10k-firmware))
-
-# Prism54 drivers
-P54PCIFW:=2.13.12.0.arm
-P54USBFW:=2.13.24.0.lm87.arm
-P54SPIFW:=2.13.0.0.a.13.14.arm
-
-define Download/p54usb
-  FILE:=$(P54USBFW)
-  URL:=http://daemonizer.de/prism54/prism54-fw/fw-usb
-  MD5SUM:=8e8ab005a4f8f0123bcdc51bc25b47f6
-endef
-$(eval $(call Download,p54usb))
-
-define Download/p54pci
-  FILE:=$(P54PCIFW)
-  URL:=http://daemonizer.de/prism54/prism54-fw/fw-softmac
-  MD5SUM:=ff7536af2092b1c4b21315bd103ef4c4
-endef
-$(eval $(call Download,p54pci))
-
-define Download/p54spi
-  FILE:=$(P54SPIFW)
-  URL:=http://daemonizer.de/prism54/prism54-fw/stlc4560
-  MD5SUM:=42661f8ecbadd88012807493f596081d
-endef
-$(eval $(call Download,p54spi))
-
-define KernelPackage/p54/Default
-  $(call KernelPackage/mac80211/Default)
-  TITLE:=Prism54 Drivers
-endef
-
-define KernelPackage/p54/description
-  Kernel module for Prism54 chipsets (mac80211)
-endef
-
-define KernelPackage/p54-common
-  $(call KernelPackage/p54/Default)
-  DEPENDS+= @PCI_SUPPORT||@USB_SUPPORT||@TARGET_omap24xx +kmod-mac80211 +kmod-lib-crc-ccitt
-  TITLE+= (COMMON)
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/p54/p54common.ko
-  AUTOLOAD:=$(call AutoLoad,30,p54common)
-endef
-
-define KernelPackage/p54-pci
-  $(call KernelPackage/p54/Default)
-  TITLE+= (PCI)
-  DEPENDS+= @PCI_SUPPORT +kmod-p54-common
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/p54/p54pci.ko
-  AUTOLOAD:=$(call AutoLoad,31,p54pci)
-endef
-
-define KernelPackage/p54-usb
-  $(call KernelPackage/p54/Default)
-  TITLE+= (USB)
-  DEPENDS+= @USB_SUPPORT +kmod-usb-core +kmod-p54-common
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/p54/p54usb.ko
-  AUTOLOAD:=$(call AutoLoad,31,p54usb)
-endef
-
-define KernelPackage/p54-spi
-  $(call KernelPackage/p54/Default)
-  TITLE+= (SPI)
-  DEPENDS+= @TARGET_omap24xx +kmod-p54-common
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/p54/p54spi.ko
-  AUTOLOAD:=$(call AutoLoad,31,p54spi)
-endef
-
-define KernelPackage/rt2x00/Default
-  $(call KernelPackage/mac80211/Default)
-  TITLE:=Ralink Drivers for RT2x00 cards
-endef
-
-define KernelPackage/rt2x00-lib
-$(call KernelPackage/rt2x00/Default)
-  DEPENDS+= @(PCI_SUPPORT||USB_SUPPORT||TARGET_ramips) +kmod-mac80211 +kmod-lib-crc-itu-t
-  TITLE+= (LIB)
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/rt2x00/rt2x00lib.ko
-  AUTOLOAD:=$(call AutoLoad,24,rt2x00lib)
-  MENU:=1
-endef
-
-define KernelPackage/rt2x00-lib/config
-  if PACKAGE_kmod-rt2x00-lib
-
-	config PACKAGE_RT2X00_LIB_DEBUGFS
-		bool "Enable rt2x00 debugfs support"
-		depends on PACKAGE_MAC80211_DEBUGFS
-		help
-		  Enable creation of debugfs files for the rt2x00 drivers.
-		  These debugfs files support both reading and writing of the
-		  most important register types of the rt2x00 hardware.
-
-	config PACKAGE_RT2X00_DEBUG
-		bool "Enable rt2x00 debug output"
-		help
-		  Enable debugging output for all rt2x00 modules
-
-  endif
-endef
-
-define KernelPackage/rt2x00-mmio
-$(call KernelPackage/rt2x00/Default)
-  DEPENDS+= @(PCI_SUPPORT||TARGET_ramips) +kmod-rt2x00-lib +kmod-eeprom-93cx6
-  HIDDEN:=1
-  TITLE+= (MMIO)
-  FILES:= $(PKG_BUILD_DIR)/drivers/net/wireless/rt2x00/rt2x00mmio.ko
-  AUTOLOAD:=$(call AutoLoad,25,rt2x00mmio)
-endef
-
-define KernelPackage/rt2x00-pci
-$(call KernelPackage/rt2x00/Default)
-  DEPENDS+= @PCI_SUPPORT +kmod-rt2x00-mmio +kmod-rt2x00-lib
-  HIDDEN:=1
-  TITLE+= (PCI)
-  FILES:= $(PKG_BUILD_DIR)/drivers/net/wireless/rt2x00/rt2x00pci.ko
-  AUTOLOAD:=$(call AutoLoad,26,rt2x00pci)
-endef
-
-define KernelPackage/rt2x00-usb
-$(call KernelPackage/rt2x00/Default)
-  DEPENDS+= @USB_SUPPORT +kmod-rt2x00-lib +kmod-usb-core
-  HIDDEN:=1
-  TITLE+= (USB)
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/rt2x00/rt2x00usb.ko
-  AUTOLOAD:=$(call AutoLoad,26,rt2x00usb)
-endef
-
-define KernelPackage/rt2800-lib
-$(call KernelPackage/rt2x00/Default)
-  DEPENDS+= @(PCI_SUPPORT||USB_SUPPORT||TARGET_ramips) +kmod-rt2x00-lib +kmod-lib-crc-ccitt +@DRIVER_11N_SUPPORT
-  HIDDEN:=1
-  TITLE+= (rt2800 LIB)
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/rt2x00/rt2800lib.ko
-  AUTOLOAD:=$(call AutoLoad,27,rt2800lib)
-endef
-
-define KernelPackage/rt2400-pci
-$(call KernelPackage/rt2x00/Default)
-  DEPENDS+= @PCI_SUPPORT +kmod-rt2x00-pci
-  TITLE+= (RT2400 PCI)
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/rt2x00/rt2400pci.ko
-  AUTOLOAD:=$(call AutoLoad,27,rt2400pci)
-endef
-
-define KernelPackage/rt2500-pci
-$(call KernelPackage/rt2x00/Default)
-  DEPENDS+= @PCI_SUPPORT +kmod-rt2x00-pci
-  TITLE+= (RT2500 PCI)
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/rt2x00/rt2500pci.ko
-  AUTOLOAD:=$(call AutoLoad,27,rt2500pci)
-endef
-
-define KernelPackage/rt2500-usb
-$(call KernelPackage/rt2x00/Default)
-  DEPENDS+= @USB_SUPPORT +kmod-rt2x00-usb
-  TITLE+= (RT2500 USB)
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/rt2x00/rt2500usb.ko
-  AUTOLOAD:=$(call AutoLoad,27,rt2500usb)
-endef
-
-define KernelPackage/rt61-pci
-$(call KernelPackage/rt2x00/Default)
-  DEPENDS+= @PCI_SUPPORT +kmod-rt2x00-pci
-  TITLE+= (RT2x61 PCI)
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/rt2x00/rt61pci.ko
-  AUTOLOAD:=$(call AutoLoad,27,rt61pci)
-endef
-
-define KernelPackage/rt73-usb
-  $(call KernelPackage/rt2x00/Default)
-  DEPENDS+= @USB_SUPPORT +kmod-rt2x00-usb
-  TITLE+= (RT73 USB)
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/rt2x00/rt73usb.ko
-  AUTOLOAD:=$(call AutoLoad,27,rt73usb)
-endef
-
-define KernelPackage/rt2800-mmio
-$(call KernelPackage/rt2x00/Default)
-  TITLE += (RT28xx/RT3xxx MMIO)
-  DEPENDS += +kmod-rt2800-lib +kmod-rt2x00-mmio
-  HIDDEN:=1
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/rt2x00/rt2800mmio.ko
-  AUTOLOAD:=$(call AutoLoad,28,rt2800mmio)
-endef
-
-define KernelPackage/rt2800-soc
-$(call KernelPackage/rt2x00/Default)
-  DEPENDS += @TARGET_ramips_rt305x +kmod-rt2800-mmio +kmod-rt2800-lib
-  TITLE += (RT28xx/RT3xxx SoC)
-  FILES := \
-	$(PKG_BUILD_DIR)/drivers/net/wireless/rt2x00/rt2x00soc.ko \
-	$(PKG_BUILD_DIR)/drivers/net/wireless/rt2x00/rt2800soc.ko
-  AUTOLOAD:=$(call AutoLoad,29,rt2x00soc rt2800soc)
-endef
-
-define KernelPackage/rt2800-pci
-$(call KernelPackage/rt2x00/Default)
-  DEPENDS+= @PCI_SUPPORT +kmod-rt2x00-pci +kmod-rt2800-lib +kmod-rt2800-mmio
-  TITLE+= (RT2860 PCI)
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/rt2x00/rt2800pci.ko
-  AUTOLOAD:=$(call AutoLoad,29,rt2800pci)
-endef
-
-define KernelPackage/rt2800-usb
-$(call KernelPackage/rt2x00/Default)
-  DEPENDS+= @USB_SUPPORT +kmod-rt2x00-usb +kmod-rt2800-lib +kmod-lib-crc-ccitt
-  TITLE+= (RT2870 USB)
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/rt2x00/rt2800usb.ko
-  AUTOLOAD:=$(call AutoLoad,28,rt2800usb)
-endef
-
-define KernelPackage/rtl818x/Default
-  $(call KernelPackage/mac80211/Default)
-  TITLE:=Realtek Drivers for RTL818x devices
-  URL:=http://wireless.kernel.org/en/users/Drivers/rtl8187
-  DEPENDS+= +kmod-eeprom-93cx6 +kmod-mac80211
-endef
-
-define KernelPackage/rtl8180
-  $(call KernelPackage/rtl818x/Default)
-  DEPENDS+= @PCI_SUPPORT
-  TITLE+= (RTL8180 PCI)
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/rtl818x/rtl8180/rtl8180.ko
-  AUTOLOAD:=$(call AutoLoad,27,rtl8180)
-endef
-
-define KernelPackage/rtl8187
-$(call KernelPackage/rtl818x/Default)
-  DEPENDS+= @USB_SUPPORT +kmod-usb-core
-  TITLE+= (RTL8187 USB)
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/rtl818x/rtl8187/rtl8187.ko
-  AUTOLOAD:=$(call AutoLoad,27,rtl8187)
-endef
-
-define KernelPackage/rtlwifi/config
-	menu "Configuration"
-		depends on PACKAGE_kmod-rtlwifi
-
-	config PACKAGE_RTLWIFI_DEBUG
-		bool "Realtek wireless debugging"
-		help
-		  Say Y, if you want to debug realtek wireless drivers.
-
-	endmenu
-endef
-
-define KernelPackage/rtlwifi
-  $(call KernelPackage/mac80211/Default)
-  TITLE:=Realtek common driver part
-  DEPENDS+= @(PCI_SUPPORT||USB_SUPPORT) +kmod-mac80211 +@DRIVER_11N_SUPPORT
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/rtlwifi/rtlwifi.ko
-  AUTOLOAD:=$(call AutoLoad,60,rtlwifi)
-  MENU:=1
-endef
-
-define KernelPackage/rtlwifi-pci
-  $(call KernelPackage/mac80211/Default)
-  TITLE:=Realtek common driver part (PCI support)
-  DEPENDS+= @PCI_SUPPORT +kmod-rtlwifi
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/rtlwifi/rtl_pci.ko
-  AUTOLOAD:=$(call AutoLoad,61,rtl_pci)
-  HIDDEN:=1
-endef
-
-define KernelPackage/rtlwifi-usb
-  $(call KernelPackage/mac80211/Default)
-  TITLE:=Realtek common driver part (USB support)
-  DEPENDS+= @USB_SUPPORT +kmod-usb-core +kmod-rtlwifi
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/rtlwifi/rtl_usb.ko
-  AUTOLOAD:=$(call AutoLoad,61,rtl_usb)
-  HIDDEN:=1
-endef
-
-define KernelPackage/rtl8192c-common
-  $(call KernelPackage/mac80211/Default)
-  TITLE:=Realtek RTL8192CE/RTL8192CU common support module
-  DEPENDS+= +kmod-rtlwifi
-  FILES:= $(PKG_BUILD_DIR)/drivers/net/wireless/rtlwifi/rtl8192c/rtl8192c-common.ko
-  AUTOLOAD:=$(call AutoLoad,62,rtl8192c-common)
-  HIDDEN:=1
-endef
-
-define KernelPackage/rtl8192ce
-  $(call KernelPackage/mac80211/Default)
-  TITLE:=Realtek RTL8192CE/RTL8188CE support
-  DEPENDS+= +kmod-rtlwifi-pci +kmod-rtl8192c-common
-  FILES:= $(PKG_BUILD_DIR)/drivers/net/wireless/rtlwifi/rtl8192ce/rtl8192ce.ko
-  AUTOLOAD:=$(call AutoLoad,63,rtl8192ce)
-endef
-
-define KernelPackage/rtl8192ce/install
-	$(INSTALL_DIR) $(1)/lib/firmware/rtlwifi
-	$(INSTALL_DATA) $(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/rtlwifi/rtl8192cfw.bin $(1)/lib/firmware/rtlwifi
-endef
-
-define KernelPackage/rtl8192se
-  $(call KernelPackage/mac80211/Default)
-  TITLE:=Realtek RTL8192SE/RTL8191SE support
-  DEPENDS+= +kmod-rtlwifi-pci
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/rtlwifi/rtl8192se/rtl8192se.ko
-  AUTOLOAD:=$(call AutoLoad,63,rtl8192se)
-endef
-
-define KernelPackage/rtl8192se/install
-	$(INSTALL_DIR) $(1)/lib/firmware/rtlwifi
-	$(INSTALL_DATA) $(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/rtlwifi/rtl8192sefw.bin $(1)/lib/firmware/rtlwifi
-endef
-
-define KernelPackage/rtl8192de
-  $(call KernelPackage/mac80211/Default)
-  TITLE:=Realtek RTL8192DE/RTL8188DE support
-  DEPENDS+= +kmod-rtlwifi-pci
-  FILES:= $(PKG_BUILD_DIR)/drivers/net/wireless/rtlwifi/rtl8192de/rtl8192de.ko
-  AUTOLOAD:=$(call AutoLoad,63,rtl8192de)
-endef
-
-define KernelPackage/rtl8192de/install
-	$(INSTALL_DIR) $(1)/lib/firmware/rtlwifi
-	$(INSTALL_DATA) $(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/rtlwifi/rtl8192defw.bin $(1)/lib/firmware/rtlwifi
-endef
-
-define KernelPackage/rtl8192cu
-  $(call KernelPackage/mac80211/Default)
-  TITLE:=Realtek RTL8192CU/RTL8188CU support
-  DEPENDS+= +kmod-rtlwifi-usb +kmod-rtl8192c-common
-  FILES:= $(PKG_BUILD_DIR)/drivers/net/wireless/rtlwifi/rtl8192cu/rtl8192cu.ko
-  AUTOLOAD:=$(call AutoLoad,63,rtl8192cu)
-endef
-
-define KernelPackage/rtl8192cu/install
-	$(INSTALL_DIR) $(1)/lib/firmware/rtlwifi
-	$(INSTALL_DATA) $(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/rtlwifi/rtl8192cufw.bin $(1)/lib/firmware/rtlwifi
-endef
-
-ZD1211FW_NAME:=zd1211-firmware
-ZD1211FW_VERSION:=1.4
-define Download/zd1211rw
-  FILE:=$(ZD1211FW_NAME)-$(ZD1211FW_VERSION).tar.bz2
-  URL:=@SF/zd1211/
-  MD5SUM:=19f28781d76569af8551c9d11294c870
-endef
-$(eval $(call Download,zd1211rw))
-
-define KernelPackage/zd1211rw
-  $(call KernelPackage/mac80211/Default)
-  TITLE:=Zydas ZD1211 support
-  DEPENDS+= @USB_SUPPORT +kmod-usb-core +kmod-mac80211
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/zd1211rw/zd1211rw.ko
-  AUTOLOAD:=$(call AutoLoad,60,zd1211rw)
-endef
-
-define KernelPackage/adm8211
-  $(call KernelPackage/mac80211/Default)
-  TITLE:=ADMTek 8211 support
-  DEPENDS+=@PCI_SUPPORT +kmod-mac80211 +kmod-eeprom-93cx6
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/adm8211.ko
-  AUTOLOAD:=$(call AutoLoad,60,adm8211)
-endef
-
-define KernelPackage/ath/config
-  if PACKAGE_kmod-ath
-	config ATH_USER_REGD
-		bool "Force Atheros drivers to respect the user's regdomain settings"
-		help
-		  Atheros' idea of regulatory handling is that the EEPROM of the card defines
-		  the regulatory limits and the user is only allowed to restrict the settings
-		  even further, even if the country allows frequencies or power levels that
-		  are forbidden by the EEPROM settings.
-
-		  Select this option if you want the driver to respect the user's decision about
-		  regulatory settings.
-
-	config PACKAGE_ATH_DEBUG
-		bool "Atheros wireless debugging"
-		help
-		  Say Y, if you want to debug atheros wireless drivers.
-		  Right now only ath9k makes use of this.
-  endif
-endef
-
-define KernelPackage/ath
-  $(call KernelPackage/mac80211/Default)
-  TITLE:=Atheros common driver part
-  DEPENDS+= @PCI_SUPPORT||USB_SUPPORT||TARGET_ar71xx||TARGET_atheros +kmod-mac80211
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/ath/ath.ko
-  AUTOLOAD:=$(call AutoLoad,26,ath)
-  MENU:=1
-endef
-
-define KernelPackage/ath/description
- This module contains some common parts needed by Atheros Wireless drivers.
-endef
-
-define KernelPackage/ath5k
-  $(call KernelPackage/mac80211/Default)
-  TITLE:=Atheros 5xxx wireless cards support
-  URL:=http://linuxwireless.org/en/users/Drivers/ath5k
-  DEPENDS+= @PCI_SUPPORT||@TARGET_atheros +kmod-ath
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/ath/ath5k/ath5k.ko
-  AUTOLOAD:=$(call AutoLoad,27,ath5k)
-endef
-
-define KernelPackage/ath5k/description
- This module adds support for wireless adapters based on
- Atheros 5xxx chipset.
-endef
-
-define KernelPackage/ath9k-common
-  $(call KernelPackage/mac80211/Default)
-  TITLE:=Atheros 802.11n wireless devices (common code for ath9k and ath9k_htc)
-  URL:=http://linuxwireless.org/en/users/Drivers/ath9k
-  DEPENDS+= @PCI_SUPPORT||USB_SUPPORT||TARGET_ar71xx +kmod-ath +@DRIVER_11N_SUPPORT
-  FILES:= \
-	$(PKG_BUILD_DIR)/drivers/net/wireless/ath/ath9k/ath9k_common.ko \
-	$(PKG_BUILD_DIR)/drivers/net/wireless/ath/ath9k/ath9k_hw.ko
-  AUTOLOAD:=$(call AutoLoad,27,ath9k_hw ath9k_common)
-endef
-
-define KernelPackage/ath9k
-  $(call KernelPackage/mac80211/Default)
-  TITLE:=Atheros 802.11n PCI wireless cards support
-  URL:=http://linuxwireless.org/en/users/Drivers/ath9k
-  DEPENDS+= @PCI_SUPPORT||TARGET_ar71xx +kmod-ath9k-common
-  FILES:= \
-	$(PKG_BUILD_DIR)/drivers/net/wireless/ath/ath9k/ath9k.ko
-  AUTOLOAD:=$(call AutoLoad,28,ath9k)
-endef
-
-define KernelPackage/ath9k/description
-This module adds support for wireless adapters based on
-Atheros IEEE 802.11n AR5008 and AR9001 family of chipsets.
-endef
-
-define KernelPackage/ath9k-htc
-  $(call KernelPackage/mac80211/Default)
-  TITLE:=Atheros 802.11n USB device support
-  URL:=http://linuxwireless.org/en/users/Drivers/ath9k
-  DEPENDS+= @USB_SUPPORT +kmod-ath9k-common +kmod-usb-core
-  FILES:= \
-	$(PKG_BUILD_DIR)/drivers/net/wireless/ath/ath9k/ath9k_htc.ko
-  AUTOLOAD:=$(call AutoLoad,55,ath9k_htc)
-endef
-
-define KernelPackage/ath9k-htc/description
-This module adds support for wireless adapters based on
-Atheros USB AR9271 and AR7010 family of chipsets.
-endef
-
-define KernelPackage/ath10k
-  $(call KernelPackage/mac80211/Default)
-  TITLE:=Atheros 802.11ac wireless cards support
-  URL:=http://wireless.kernel.org/en/users/Drivers/ath10k
-  DEPENDS+= @PCI_SUPPORT +kmod-ath +@DRIVER_11N_SUPPORT
-  FILES:= \
-	$(PKG_BUILD_DIR)/drivers/net/wireless/ath/ath10k/ath10k_core.ko \
-	$(PKG_BUILD_DIR)/drivers/net/wireless/ath/ath10k/ath10k_pci.ko
-  AUTOLOAD:=$(call AutoLoad,55,ath10k_core ath10k_pci)
-endef
-
-define KernelPackage/ath10k/description
-This module adds support for wireless adapters based on
-Atheros IEEE 802.11ac family of chipsets. For now only
-PCI is supported.
-endef
-
-define KernelPackage/carl9170
-  $(call KernelPackage/mac80211/Default)
-  TITLE:=Driver for Atheros AR9170 USB sticks
-  DEPENDS:=@USB_SUPPORT +kmod-mac80211 +kmod-ath +kmod-usb-core +kmod-input-core +@DRIVER_11N_SUPPORT
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/ath/carl9170/carl9170.ko
-  AUTOLOAD:=$(call AutoLoad,60,carl9170)
-endef
-
-define KernelPackage/lib80211
-  $(call KernelPackage/mac80211/Default)
-  TITLE:=802.11 Networking stack
-  DEPENDS:=+kmod-cfg80211
-  FILES:= \
-	$(PKG_BUILD_DIR)/net/wireless/lib80211.ko \
-	$(PKG_BUILD_DIR)/net/wireless/lib80211_crypt_wep.ko \
-	$(PKG_BUILD_DIR)/net/wireless/lib80211_crypt_ccmp.ko \
-	$(PKG_BUILD_DIR)/net/wireless/lib80211_crypt_tkip.ko
-  AUTOLOAD:=$(call AutoLoad,21, \
-	lib80211 \
-	lib80211_crypt_wep \
-	lib80211_crypt_ccmp \
-	lib80211_crypt_tkip \
-  )
-endef
-
-define KernelPackage/lib80211/description
- Kernel modules for 802.11 Networking stack
- Includes:
- - lib80211
- - lib80211_crypt_wep
- - lib80211_crypt_tkip
- - lib80211_crytp_ccmp
-endef
-
-define KernelPackage/libertas-usb
-  $(call KernelPackage/mac80211/Default)
-  DEPENDS+= @USB_SUPPORT +kmod-cfg80211 +kmod-usb-core +kmod-lib80211 +@DRIVER_WEXT_SUPPORT
-  TITLE:=Marvell 88W8015 Wireless Driver
-  FILES:= \
-	$(PKG_BUILD_DIR)/drivers/net/wireless/libertas/libertas.ko \
-	$(PKG_BUILD_DIR)/drivers/net/wireless/libertas/usb8xxx.ko
-  AUTOLOAD:=$(call AutoLoad,27,libertas usb8xxx)
-endef
-
-define KernelPackage/libertas-sd
-  $(call KernelPackage/mac80211/Default)
-  DEPENDS+= +kmod-cfg80211 +kmod-lib80211 +kmod-mmc +@DRIVER_WEXT_SUPPORT
-  TITLE:=Marvell 88W8686 Wireless Driver
-  FILES:= \
-	$(PKG_BUILD_DIR)/drivers/net/wireless/libertas/libertas.ko \
-	$(PKG_BUILD_DIR)/drivers/net/wireless/libertas/libertas_sdio.ko
-  AUTOLOAD:=$(call AutoLoad,91,libertas libertas_sdio)
-endef
-
-define KernelPackage/mac80211-hwsim
-  $(call KernelPackage/mac80211/Default)
-  TITLE:=mac80211 HW simulation device
-  DEPENDS+= +kmod-mac80211
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/mac80211_hwsim.ko
-  AUTOLOAD:=$(call AutoLoad,60,mac80211_hwsim)
-endef
-
-define KernelPackage/net-libipw
-  $(call KernelPackage/mac80211/Default)
-  TITLE:=libipw for ipw2100 and ipw2200
-  DEPENDS:=@PCI_SUPPORT +kmod-crypto-core +kmod-crypto-arc4 +kmod-crypto-aes +kmod-crypto-michael-mic +kmod-lib80211 +kmod-cfg80211 +@DRIVER_WEXT_SUPPORT
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/ipw2x00/libipw.ko
-  AUTOLOAD:=$(call AutoLoad,49,libipw)
-endef
-
-define KernelPackage/net-libipw/description
- Hardware independent IEEE 802.11 networking stack for ipw2100 and ipw2200.
-endef
-
-IPW2100_NAME:=ipw2100-fw
-IPW2100_VERSION:=1.3
-
-define Download/net-ipw2100
-  URL:=http://bughost.org/firmware/
-  FILE:=$(IPW2100_NAME)-$(IPW2100_VERSION).tgz
-  MD5SUM=46aa75bcda1a00efa841f9707bbbd113
-endef
-$(eval $(call Download,net-ipw2100))
-
-define KernelPackage/net-ipw2100
-  $(call KernelPackage/mac80211/Default)
-  TITLE:=Intel IPW2100 driver
-  DEPENDS:=@PCI_SUPPORT +kmod-net-libipw
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/ipw2x00/ipw2100.ko
-  AUTOLOAD:=$(call AutoLoad,50,ipw2100)
-endef
-
-define KernelPackage/net-ipw2100/description
- Kernel support for Intel IPW2100
- Includes:
- - ipw2100
-endef
-
-IPW2200_NAME:=ipw2200-fw
-IPW2200_VERSION:=3.1
-
-define Download/net-ipw2200
-  URL:=http://bughost.org/firmware/
-  FILE:=$(IPW2200_NAME)-$(IPW2200_VERSION).tgz
-  MD5SUM=eaba788643c7cc7483dd67ace70f6e99
-endef
-$(eval $(call Download,net-ipw2200))
-
-define KernelPackage/net-ipw2200
-  $(call KernelPackage/mac80211/Default)
-  TITLE:=Intel IPW2200 driver
-  DEPENDS:=@PCI_SUPPORT +kmod-net-libipw
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/ipw2x00/ipw2200.ko
-  AUTOLOAD:=$(call AutoLoad,50,ipw2200)
-endef
-
-define KernelPackage/net-ipw2200/description
- Kernel support for Intel IPW2200
- Includes:
- - ipw2200
-endef
-
-
-define KernelPackage/net-hermes
-  $(call KernelPackage/mac80211/Default)
-  TITLE:=Hermes 802.11b chipset support
-  DEPENDS:=@PCI_SUPPORT||PCMCIA_SUPPORT +kmod-cfg80211 +@DRIVER_WEXT_SUPPORT
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/orinoco/orinoco.ko
-  AUTOLOAD:=$(call AutoLoad,50,orinoco)
-endef
-
-define KernelPackage/net-hermes/description
- Kernel support for Hermes 802.11b chipsets
-endef
-
-define KernelPackage/net-hermes-pci
-  $(call KernelPackage/mac80211/Default)
-  TITLE:=Intersil Prism 2.5 PCI support
-  DEPENDS:=@PCI_SUPPORT +kmod-net-hermes
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/orinoco/orinoco_pci.ko
-  AUTOLOAD:=$(call AutoLoad,55,orinoco_pci)
-endef
-
-define KernelPackage/net-hermes-pci/description
- Kernel modules for Intersil Prism 2.5 PCI support
-endef
-
-define KernelPackage/net-hermes-plx
-  $(call KernelPackage/mac80211/Default)
-  TITLE:=PLX9052 based PCI adaptor
-  DEPENDS:=@PCI_SUPPORT +kmod-net-hermes
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/orinoco/orinoco_plx.ko
-  AUTOLOAD:=$(call AutoLoad,55,orinoco_plx)
-endef
-
-define KernelPackage/net-hermes-plx/description
- Kernel modules for Hermes in PLX9052 based PCI adaptors
-endef
-
-define KernelPackage/net-hermes-pcmcia
-  $(call KernelPackage/mac80211/Default)
-  TITLE:=Hermes based PCMCIA adaptors
-  DEPENDS:=@PCMCIA_SUPPORT +kmod-net-hermes @BROKEN
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/orinoco/orinoco_cs.ko
-  AUTOLOAD:=$(call AutoLoad,55,orinoco_cs)
-endef
-
-define KernelPackage/net-hermes-pcmcia/description
- Kernel modules for Hermes based PCMCIA adaptors
-endef
-
-define KernelPackage/iwlagn
-  $(call KernelPackage/mac80211/Default)
-  DEPENDS:= +kmod-mac80211 @PCI_SUPPORT +@DRIVER_11N_SUPPORT
-  TITLE:=Intel AGN Wireless support
-  FILES:= \
-	$(PKG_BUILD_DIR)/drivers/net/wireless/iwlwifi/iwlwifi.ko \
-	$(PKG_BUILD_DIR)/drivers/net/wireless/iwlwifi/dvm/iwldvm.ko
-  AUTOLOAD:=$(call AutoLoad,60,iwlwifi iwldvm)
-  MENU:=1
-endef
-
-define KernelPackage/iwlagn/description
- iwlagn kernel module for Intel 5000/5150/1000/6000/6050/6005/6030/100 support
-endef
-
-define KernelPackage/iwlagn/config
-  if PACKAGE_kmod-iwlagn
-
-	config IWL5000_FW
-		bool "Intel 5000 Firmware"
-		default y
-		help
-		  Download and install firmware for:
-		    Intel Wireless WiFi 5100AGN, 5300AGN, and 5350AGN
-
-	config IWL5150_FW
-		bool "Intel 5150 Firmware"
-		default y
-		help
-		  Download and install firmware for:
-		    Intel Wireless WiFi 5150AGN
-
-	config IWL1000_FW
-		bool "Intel 1000 Firmware"
-		default y
-		help
-		  Download and install firmware for:
-		    Intel Centrino Wireless-N 1000
-
-	config IWL6000_FW
-		bool "Intel 6000 Firmware"
-		default y
-		help
-		  Download and install firmware for:
-		    Intel Centrino Ultimate-N 6300 and Advanced-N 6200
-
-	config IWL6050_FW
-		bool "Intel 6050 Firmware"
-		default y
-		help
-		  Download and install firmware for:
-		    Intel Centrino Advanced-N + WiMAX 6250 and Wireless-N + WiMAX 6150
-
-	config IWL6005_FW
-		bool "Intel 6005 Firmware"
-		default y
-		help
-		  Download and install firmware for:
-		    Intel Centrino Advanced-N 6205
-
-	config IWL6030_FW
-		bool "Intel 6030 Firmware"
-		default y
-		help
-		  Download and install firmware for:
-		    Intel Centrino Advanced-N 6230, Wireless-N 1030, Wireless-N 130 and Advanced-N 6235
-
-	config IWL100_FW
-		bool "Intel 100 Firmware"
-		default y
-		help
-		  Download and install firmware for:
-		    Intel Centrino Wireless-N 100
-
-	config IWL2000_FW
-		bool "Intel 2000 Firmware"
-		default y
-		help
-		  Download and install firmware for:
-		    Intel Centrino Wireless-N 2200
-
-	config IWL2030_FW
-		bool "Intel 2030 Firmware"
-		default y
-		help
-		  Download and install firmware for:
-		    Intel Centrino Wireless-N 2230
-
-	config IWL105_FW
-		bool "Intel 105 Firmware"
-		default y
-		help
-		  Download and install firmware for:
-		    Intel Centrino Wireless-N 105
-
-	config IWL135_FW
-		bool "Intel 135 Firmware"
-		default y
-		help
-		  Download and install firmware for:
-		    Intel Centrino Wireless-N 135
-  endif
-endef
-
-define KernelPackage/iwl-legacy
-  $(call KernelPackage/mac80211/Default)
-  DEPENDS:= +kmod-mac80211 @PCI_SUPPORT
-  TITLE:=Intel legacy Wireless support
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/iwlegacy/iwlegacy.ko
-  AUTOLOAD:=$(call AutoLoad,60,iwlegacy)
-endef
-
-define KernelPackage/iwl-legacy/description
- iwl-legacy kernel module for legacy Intel wireless support
-endef
-
-define KernelPackage/iwl3945
-  $(call KernelPackage/mac80211/Default)
-  DEPENDS:= +kmod-mac80211 +kmod-iwl-legacy
-  TITLE:=Intel iwl3945 Wireless support
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/iwlegacy/iwl3945.ko
-  AUTOLOAD:=$(call AutoLoad,61,iwl3945)
-endef
-
-define KernelPackage/iwl3945/description
- iwl3945 kernel module for Intel 3945 support
-endef
-
-define KernelPackage/iwl4965
-  $(call KernelPackage/mac80211/Default)
-  DEPENDS:= +kmod-mac80211 +kmod-iwl-legacy +@DRIVER_11N_SUPPORT
-  TITLE:=Intel iwl4965 Wireless support
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/iwlegacy/iwl4965.ko
-  AUTOLOAD:=$(call AutoLoad,61,iwl4965)
-endef
-
-define KernelPackage/iwl4965/description
- iwl4965 kernel module for Intel 4965 support
-endef
-
-
-define KernelPackage/mwl8k
-  $(call KernelPackage/mac80211/Default)
-  TITLE:=Driver for Marvell TOPDOG 802.11 Wireless cards
-  URL:=http://wireless.kernel.org/en/users/Drivers/mwl8k
-  DEPENDS+= @PCI_SUPPORT +kmod-mac80211 +@DRIVER_11N_SUPPORT
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/mwl8k.ko
-  AUTOLOAD:=$(call AutoLoad,27,mwl8k)
-endef
-
-define KernelPackage/mwl8k/description
- Kernel modules for Marvell TOPDOG 802.11 Wireless cards
-endef
-
-
-define KernelPackage/wlcore
-  $(call KernelPackage/mac80211/Default)
-  TITLE:=TI common driver part
-  DEPENDS+= @TARGET_omap +kmod-mac80211 +@DRIVER_11N_SUPPORT
-  FILES:= \
-	$(PKG_BUILD_DIR)/drivers/net/wireless/ti/wlcore/wlcore.ko \
-	$(PKG_BUILD_DIR)/drivers/net/wireless/ti/wlcore/wlcore_sdio.ko
-  AUTOLOAD:=$(call AutoLoad,61,wlcore wlcore_sdio)
-endef
-
-define KernelPackage/wlcore/description
- This module contains some common parts needed by TI Wireless drivers.
-endef
-
-define KernelPackage/wl12xx
-  $(call KernelPackage/mac80211/Default)
-  TITLE:=Driver for TI WL12xx
-  URL:=http://wireless.kernel.org/en/users/Drivers/wl12xx
-  DEPENDS+= +kmod-wlcore
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/ti/wl12xx/wl12xx.ko
-  AUTOLOAD:=$(call AutoLoad,62,wl12xx)
-endef
-
-define KernelPackage/wl12xx/description
- Kernel modules for TI WL12xx
-endef
-
-define KernelPackage/wl18xx
-  $(call KernelPackage/mac80211/Default)
-  TITLE:=Driver for TI WL18xx
-  URL:=http://wireless.kernel.org/en/users/Drivers/wl18xx
-  DEPENDS+= +kmod-wlcore
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/ti/wl18xx/wl18xx.ko
-  AUTOLOAD:=$(call AutoLoad,62,wl18xx)
-endef
-
-define KernelPackage/wl18xx/description
- Kernel modules for TI WL18xx
-endef
-
-
-#Broadcom firmware
-ifneq ($(CONFIG_B43_FW_5_10),)
-  PKG_B43_FWV4_NAME:=broadcom-wl
-  PKG_B43_FWV4_VERSION:=5.10.56.27.3
-  PKG_B43_FWV4_OBJECT:=$(PKG_B43_FWV4_NAME)-$(PKG_B43_FWV4_VERSION)/driver/wl_apsta/wl_prebuilt.o
-  PKG_B43_FWV4_SOURCE:=$(PKG_B43_FWV4_NAME)-$(PKG_B43_FWV4_VERSION)_mipsel.tar.bz2
-  PKG_B43_FWV4_SOURCE_URL:=http://mirror2.openwrt.org/sources/
-  PKG_B43_FWV4_MD5SUM:=3363e3a6b3d9d73c49dea870c7834eac
-else
-ifneq ($(CONFIG_B43_FW_4_178),)
-  PKG_B43_FWV4_NAME:=broadcom-wl
-  PKG_B43_FWV4_VERSION:=4.178.10.4
-  PKG_B43_FWV4_OBJECT:=$(PKG_B43_FWV4_NAME)-$(PKG_B43_FWV4_VERSION)/linux/wl_apsta.o
-  PKG_B43_FWV4_SOURCE:=$(PKG_B43_FWV4_NAME)-$(PKG_B43_FWV4_VERSION).tar.bz2
-  PKG_B43_FWV4_SOURCE_URL:=http://mirror2.openwrt.org/sources/
-  PKG_B43_FWV4_MD5SUM:=14477e8cbbb91b11896affac9b219fdb
-else
-ifneq ($(CONFIG_B43_FW_5_100_138),)
-  PKG_B43_FWV4_NAME:=broadcom-wl
-  PKG_B43_FWV4_VERSION:=5.100.138
-  PKG_B43_FWV4_OBJECT:=$(PKG_B43_FWV4_NAME)-$(PKG_B43_FWV4_VERSION)/linux/wl_apsta.o
-  PKG_B43_FWV4_SOURCE:=$(PKG_B43_FWV4_NAME)-$(PKG_B43_FWV4_VERSION).tar.bz2
-  PKG_B43_FWV4_SOURCE_URL:=http://www.lwfinger.com/b43-firmware/
-  PKG_B43_FWV4_MD5SUM:=f4e357b09eaf5d8b1f1920cf3493a555
-else
-  PKG_B43_FWV4_NAME:=broadcom-wl
-  PKG_B43_FWV4_VERSION:=4.150.10.5
-  PKG_B43_FWV4_OBJECT:=$(PKG_B43_FWV4_NAME)-$(PKG_B43_FWV4_VERSION)/driver/wl_apsta_mimo.o
-  PKG_B43_FWV4_SOURCE:=$(PKG_B43_FWV4_NAME)-$(PKG_B43_FWV4_VERSION).tar.bz2
-  PKG_B43_FWV4_SOURCE_URL:=http://mirror2.openwrt.org/sources/
-  PKG_B43_FWV4_MD5SUM:=0c6ba9687114c6b598e8019e262d9a60
-endif
-endif
-endif
-ifneq ($(CONFIG_B43_OPENFIRMWARE),)
-  PKG_B43_FWV4_NAME:=broadcom-wl
-  PKG_B43_FWV4_VERSION:=5.2
-  PKG_B43_FWV4_OBJECT:=openfwwf-$(PKG_B43_FWV4_VERSION)
-  PKG_B43_FWV4_SOURCE:=openfwwf-$(PKG_B43_FWV4_VERSION).tar.gz
-  PKG_B43_FWV4_SOURCE_URL:=http://www.ing.unibs.it/openfwwf/firmware/
-  PKG_B43_FWV4_MD5SUM:=e045a135453274e439ae183f8498b0fa
-endif
-
-
-PKG_B43_FWV3_NAME:=wl_apsta
-PKG_B43_FWV3_VERSION:=3.130.20.0
-PKG_B43_FWV3_SOURCE:=$(PKG_B43_FWV3_NAME)-$(PKG_B43_FWV3_VERSION).o
-PKG_B43_FWV3_SOURCE_URL:=http://downloads.openwrt.org/sources/
-PKG_B43_FWV3_MD5SUM:=e08665c5c5b66beb9c3b2dd54aa80cb3
-
-define Download/b43
-  FILE:=$(PKG_B43_FWV4_SOURCE)
-  URL:=$(PKG_B43_FWV4_SOURCE_URL)
-  MD5SUM:=$(PKG_B43_FWV4_MD5SUM)
-endef
-$(eval $(call Download,b43))
-
-define Download/b43legacy
-  FILE:=$(PKG_B43_FWV3_SOURCE)
-  URL:=$(PKG_B43_FWV3_SOURCE_URL)
-  MD5SUM:=$(PKG_B43_FWV3_MD5SUM)
-endef
-$(eval $(call Download,b43legacy))
-
-
-define KernelPackage/b43
-  $(call KernelPackage/mac80211/Default)
-  TITLE:=Broadcom 43xx wireless support
-  URL:=http://linuxwireless.org/en/users/Drivers/b43
-  KCONFIG:= \
-  	CONFIG_HW_RANDOM=y
-  DEPENDS+= +kmod-mac80211 +!TARGET_brcm47xx:kmod-bcma +!(TARGET_brcm47xx||TARGET_brcm63xx):kmod-ssb
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/b43/b43.ko
-  AUTOLOAD:=$(call AutoLoad,30,b43)
-  MENU:=1
-endef
-
-define KernelPackage/b43/config
-  if PACKAGE_kmod-b43
-
-	choice
-		prompt "b43 firmware version"
-		default B43_FW_5_100_138
-		help
-		  This option allows you to select the version of the b43 firmware.
-
-	config B43_FW_4_150
-		bool "Firmware 410.2160 from driver 4.150.10.5 (old stable)"
-		help
-		  Stable firmware for BCM43xx devices.
-
-		  If unsure, select this.
-
-	config B43_FW_4_178
-		bool "Firmware 478.104 from driver 4.178.10.4"
-		help
-		  Experimental firmware for BCM43xx devices.
-
-		  This firmware is not tested as much as the "stable" firmware.
-
-		  If unsure, select the "stable" firmware.
-
-	config B43_FW_5_10
-		bool "Firmware 508.1084 from driver 5.10.56.27"
-		help
-		  Newer experimental firmware for BCM43xx devices.
-
-		  This firmware is mostly untested. It is needed for some N-PHY devices.
-
-		  If unsure, select the "stable" firmware.
-
-	config B43_FW_5_100_138
-		bool "Firmware 666.2 from driver 5.100.138 (stable)"
-		help
-		  Newer experimental firmware for BCM43xx devices.
-
-		  This firmware is mostly untested. It is needed for some N-PHY devices.
-
-		  If unsure, select the "stable" firmware.
-
-	config B43_OPENFIRMWARE
-		bool "Open FirmWare for WiFi networks"
-		help
-		  Opensource firmware for BCM43xx devices.
-
-		  Do _not_ select this, unless you know what you are doing.
-		  The Opensource firmware is not suitable for embedded devices, yet.
-		  It does not support QoS, which is bad for AccessPoints.
-		  It does not support hardware crypto acceleration, which is a showstopper
-		  for embedded devices with low CPU resources.
-
-		  If unsure, select the "stable" firmware.
-
-	endchoice
-
-	config B43_FW_SQUASH
-		bool "Remove unnecessary firmware files"
-		depends on !B43_OPENFIRMWARE
-		default y
-		help
-		  This options allows you to remove unnecessary b43 firmware files
-		  from the final rootfs image. This can reduce the rootfs size by
-		  up to 200k.
-
-		  If unsure, say Y.
-
-	config B43_FW_SQUASH_COREREVS
-		string "Core revisions to include"
-		depends on B43_FW_SQUASH
-		default "5,6,7,8,9,10,11,13,15,16,29"
-		help
-		  This is a comma seperated list of core revision numbers.
-
-		  Example (keep files for rev5 only):
-		    5
-
-		  Example (keep files for rev5 and rev11):
-		    5,11
-
-	config B43_FW_SQUASH_PHYTYPES
-		string "PHY types to include"
-		depends on B43_FW_SQUASH
-		default "G,LP,N,HT"
-		help
-		  This is a comma seperated list of PHY types:
-		    A  => A-PHY
-		    AG => Dual A-PHY G-PHY
-		    G  => G-PHY
-		    LP => LP-PHY
-		    N  => N-PHY
-		    HT  => HT-PHY
-		    LCN  => LCN-PHY
-
-		  Example (keep files for G-PHY only):
-		    G
-
-		  Example (keep files for G-PHY and N-PHY):
-		    G,N
-
-	config PACKAGE_B43_DEBUG
-		bool "Enable debug output and debugfs for b43"
-		default n
-		help
-		  Enable additional debug output and runtime sanity checks for b43
-		  and enables the debugfs interface.
-
-		  If unsure, say N.
-
-	config PACKAGE_B43_PIO
-		bool "Enable support for PIO transfer mode"
-		default n
-		help
-		  Enable support for using PIO instead of DMA. Unless you have DMA
-		  transfer problems you don't need this.
-
-		  If unsure, say N.
-
-	config PACKAGE_B43_PHY_N
-		bool "Enable support for N-PHYs"
-		default y
-		help
-		  Enable support for N-PHY. This includes support for the following devices:
-		  PCI: BCM4321, BCM4322, BCM43222, BCM43224, BCM43225
-		  SoC: BCM4716, BCM4717, BCM4718
-
-		  Currently only 11g speed is available.
-
-		  If unsure, say Y.
-
-	config PACKAGE_B43_PHY_HT
-		bool "Enable support for HT-PHYs"
-		default y
-		help
-		  Enable support for HT-PHY. This includes support for the following devices:
-		  PCI: BCM4331
-
-		  Currently only 11g speed is available.
-
-		  If unsure, say Y.
-
-	config PACKAGE_B43_PHY_LCN
-		bool "Enable support for LCN-PHYs"
-		depends on BROKEN
-		default n
-		help
-		  Currently broken.
-
-		  If unsure, say N.
-
-  endif
-endef
-
-define KernelPackage/b43/description
-Kernel module for Broadcom 43xx wireless support (mac80211 stack) new
-endef
-
-define KernelPackage/b43legacy
-  $(call KernelPackage/mac80211/Default)
-  TITLE:=Broadcom 43xx-legacy wireless support
-  URL:=http://linuxwireless.org/en/users/Drivers/b43
-  KCONFIG:= \
-  	CONFIG_HW_RANDOM=y
-  DEPENDS+= +kmod-mac80211 +!(TARGET_brcm47xx||TARGET_brcm63xx):kmod-ssb
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/b43legacy/b43legacy.ko
-  AUTOLOAD:=$(call AutoLoad,30,b43legacy)
-  MENU:=1
-endef
-
-define KernelPackage/b43legacy/config
-  if PACKAGE_kmod-b43legacy
-
-	config B43LEGACY_FW_SQUASH
-		bool "Remove unnecessary firmware files"
-		default y
-		help
-		  This options allows you to remove unnecessary b43legacy firmware files
-		  from the final rootfs image. This can reduce the rootfs size by
-		  up to 50k.
-
-		  If unsure, say Y.
-
-	config B43LEGACY_FW_SQUASH_COREREVS
-		string "Core revisions to include"
-		depends on B43LEGACY_FW_SQUASH
-		default "1,2,3,4"
-		help
-		  This is a comma seperated list of core revision numbers.
-
-		  Example (keep files for rev4 only):
-		    4
-
-		  Example (keep files for rev2 and rev4):
-		    2,4
-
-  endif
-endef
-
-define KernelPackage/b43legacy/description
-Kernel module for Broadcom 43xx-legacy wireless support (mac80211 stack) new
-endef
-
-
-define KernelPackage/brcmutil
-  $(call KernelPackage/mac80211/Default)
-  TITLE:=Broadcom IEEE802.11n common driver parts
-  URL:=http://linuxwireless.org/en/users/Drivers/brcm80211
-  DEPENDS+=@PCI_SUPPORT||USB_SUPPORT
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/brcm80211/brcmutil/brcmutil.ko
-  AUTOLOAD:=$(call AutoLoad,30,brcmutil)
-  MENU:=1
-endef
-
-define KernelPackage/brcmutil/description
- This module contains some common parts needed by Broadcom Wireless drivers brcmsmac and brcmfmac.
-endef
-
-define KernelPackage/brcmutil/config
-  if PACKAGE_kmod-brcmutil
-
-	config PACKAGE_BRCM80211_DEBUG
-		bool "Broadcom wireless driver debugging"
-		help
-		  Say Y, if you want to debug brcmsmac and brcmfmac wireless driver.
-
-  endif
-endef
-
-PKG_BRCMSMAC_FW_NAME:=broadcom-wl
-PKG_BRCMSMAC_FW_VERSION:=5.100.138
-PKG_BRCMSMAC_FW_OBJECT:=$(PKG_BRCMSMAC_FW_NAME)-$(PKG_BRCMSMAC_FW_VERSION)/linux/wl_apsta.o
-PKG_BRCMSMAC_FW_SOURCE:=$(PKG_BRCMSMAC_FW_NAME)-$(PKG_BRCMSMAC_FW_VERSION).tar.bz2
-PKG_BRCMSMAC_FW_SOURCE_URL:=http://www.lwfinger.com/b43-firmware/
-PKG_BRCMSMAC_FW_MD5SUM:=f4e357b09eaf5d8b1f1920cf3493a555
-
-define Download/brcmsmac
-  FILE:=$(PKG_BRCMSMAC_FW_SOURCE)
-  URL:=$(PKG_BRCMSMAC_FW_SOURCE_URL)
-  MD5SUM:=$(PKG_BRCMSMAC_FW_MD5SUM)
-endef
-$(eval $(call Download,brcmsmac))
-
-define KernelPackage/brcmsmac
-  $(call KernelPackage/mac80211/Default)
-  TITLE:=Broadcom IEEE802.11n PCIe SoftMAC WLAN driver
-  URL:=http://linuxwireless.org/en/users/Drivers/brcm80211
-  DEPENDS+= +kmod-mac80211 +@DRIVER_11N_SUPPORT +!TARGET_brcm47xx:kmod-bcma +kmod-lib-cordic +kmod-lib-crc8 +kmod-brcmutil
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/brcm80211/brcmsmac/brcmsmac.ko
-  AUTOLOAD:=$(call AutoLoad,31,brcmsmac)
-  MENU:=1
-endef
-
-define KernelPackage/brcmsmac/description
- Kernel module for Broadcom IEEE802.11n PCIe Wireless cards
-endef
-
-define KernelPackage/brcmsmac/config
-  if PACKAGE_kmod-brcmsmac
-
-	config BRCMSMAC_USE_FW_FROM_WL
-		bool "Use firmware extracted from broadcom proprietary driver"
-		default y
-		help
-		  Instead of using the official brcmsmac firmware a firmware
-		  version 666.2 extracted from the proprietary Broadcom driver
-		  is used. This is needed to get core rev 17 used in bcm4716
-		  to work.
-
-		  If unsure, say Y.
-
-  endif
-endef
-
-
-define KernelPackage/brcmfmac
-  $(call KernelPackage/mac80211/Default)
-  TITLE:=Broadcom IEEE802.11n USB FullMAC WLAN driver
-  URL:=http://linuxwireless.org/en/users/Drivers/brcm80211
-  DEPENDS+= @USB_SUPPORT +kmod-usb-core +kmod-cfg80211 +@DRIVER_11N_SUPPORT +kmod-brcmutil
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/brcm80211/brcmfmac/brcmfmac.ko
-  AUTOLOAD:=$(call AutoLoad,60,brcmfmac)
-endef
-
-define KernelPackage/brcmfmac/description
- Kernel module for Broadcom IEEE802.11n USB Wireless cards
-endef
-
-config_package=$(if $(CONFIG_PACKAGE_kmod-$(1)),m)
-
-config-y:= \
-	WLAN \
-	NL80211_TESTMODE \
-	CFG80211_WEXT \
-	CFG80211_INTERNAL_REGDB \
-	MAC80211_RC_MINSTREL \
-	MAC80211_RC_MINSTREL_HT \
-	MAC80211_RC_DEFAULT_MINSTREL \
-
-config-$(call config_package,cfg80211) += CFG80211
-
-config-$(call config_package,mac80211) += MAC80211
-config-$(CONFIG_PACKAGE_MAC80211_MESH) += MAC80211_MESH
-ifdef CONFIG_PACKAGE_MAC80211_DEBUGFS
-  config-y += \
-	CFG80211_DEBUGFS \
-	MAC80211_DEBUGFS \
-	ATH9K_DEBUGFS \
-	ATH9K_HTC_DEBUGFS \
-	ATH10K_DEBUGFS \
-	CARL9170_DEBUGFS \
-	ATH5K_DEBUG
-endif
-
-config-$(call config_package,lib80211) += LIB80211 LIB80211_CRYPT_WEP LIB80211_CRYPT_CCMP LIB80211_CRYPT_TKIP
-
-config-$(call config_package,ath) += ATH_CARDS ATH_COMMON
-config-$(CONFIG_PACKAGE_ATH_DEBUG) += ATH_DEBUG ATH10K_DEBUG
-
-config-$(call config_package,ath9k) += ATH9K
-config-$(call config_package,ath9k-common) += ATH9K_COMMON
-config-$(CONFIG_TARGET_ar71xx) += ATH9K_AHB
-config-$(CONFIG_PCI) += ATH9K_PCI
-config-$(CONFIG_ATH_USER_REGD) += ATH_USER_REGD
-
-config-$(call config_package,ath9k-htc) += ATH9K_HTC
-config-$(call config_package,ath10k) += ATH10K ATH10K_PCI
-
-config-$(call config_package,ath5k) += ATH5K
-ifdef CONFIG_TARGET_atheros
-  config-y += ATH5K_AHB
-else
-  config-y += ATH5K_PCI
-endif
-
-config-$(call config_package,carl9170) += CARL9170
-
-config-$(call config_package,b43) += B43
-config-y += B43_SSB B43_BCMA B43_PHY_LP
-config-$(CONFIG_PACKAGE_B43_PHY_N) += B43_PHY_N
-config-$(CONFIG_PACKAGE_B43_PHY_HT) += B43_PHY_HT
-config-$(CONFIG_PACKAGE_B43_PIO) += B43_PIO
-config-$(CONFIG_PACKAGE_B43_DEBUG) += B43_DEBUG
-
-config-$(call config_package,b43legacy) += B43LEGACY
-config-y += B43LEGACY_DMA_MODE
-
-config-$(call config_package,brcmutil) += BRCMUTIL
-config-$(call config_package,brcmsmac) += BRCMSMAC
-config-$(call config_package,brcmfmac) += BRCMFMAC
-config-y += BRCMFMAC_USB
-config-$(CONFIG_PACKAGE_BRCM80211_DEBUG) += BRCMDBG
-
-config-$(call config_package,mac80211-hwsim) += MAC80211_HWSIM
-
-config-$(call config_package,rt2x00-lib) += RT2X00 RT2X00_LIB
-config-$(call config_package,rt2x00-pci) += RT2X00_LIB_PCI
-config-$(call config_package,rt2x00-mmio) += RT2X00_LIB_MMIO
-config-$(call config_package,rt2x00-usb) += RT2X00_LIB_USB
-config-$(CONFIG_PACKAGE_RT2X00_LIB_DEBUGFS) += RT2X00_LIB_DEBUGFS
-config-$(CONFIG_PACKAGE_RT2X00_DEBUG) += RT2X00_DEBUG
-
-config-$(call config_package,rt2400-pci) += RT2400PCI
-config-$(call config_package,rt2500-pci) += RT2500PCI
-config-$(call config_package,rt2500-usb) += RT2500USB
-config-$(call config_package,rt61-pci) += RT61PCI
-config-$(call config_package,rt73-usb) += RT73USB
-
-config-$(call config_package,rt2800-lib) += RT2800_LIB
-
-config-$(call config_package,rt2800-soc) += RT2800SOC
-config-$(call config_package,rt2800-pci) += RT2800PCI
-config-y += RT2800PCI_RT33XX RT2800PCI_RT35XX RT2800PCI_RT53XX RT2800PCI_RT3290
-
-config-$(call config_package,rt2800-usb) += RT2800USB
-config-y += RT2800USB_RT33XX RT2800USB_RT35XX RT2800USB_RT3573 RT2800USB_RT53XX RT2800USB_RT55XX
-
-config-$(call config_package,iwl-legacy) += IWLEGACY
-config-$(call config_package,iwl3945) += IWL3945
-config-$(call config_package,iwl4965) += IWL4965
-config-$(call config_package,iwlagn) += IWLWIFI IWLDVM
-
-config-$(call config_package,net-libipw) += LIBIPW
-config-$(call config_package,net-ipw2100) += IPW2100
-config-$(call config_package,net-ipw2200) += IPW2200
-
-config-$(call config_package,p54-common) += P54_COMMON
-config-$(call config_package,p54-pci) += P54_PCI
-config-$(call config_package,p54-usb) += P54_USB
-config-$(call config_package,p54-spi) += P54_SPI
-
-config-$(call config_package,net-hermes) += HERMES
-config-$(call config_package,net-hermes-pci) += PCI_HERMES
-config-$(call config_package,net-hermes-plx) += PLX_HERMES
-config-$(call config_package,net-hermes-pcmcia) += PCMCIA_HERMES
-config-y += HERMES_PRISM
-
-config-$(call config_package,adm8211) += ADM8211
-config-$(call config_package,libertas-sd) += LIBERTAS LIBERTAS_SDIO
-config-$(call config_package,libertas-usb) += LIBERTAS LIBERTAS_USB
-config-$(call config_package,mwl8k) += MWL8K
-config-$(call config_package,rtl8180) += RTL8180
-config-$(call config_package,rtl8187) += RTL8187
-config-$(call config_package,wlcore) += WLCORE WLCORE_SDIO
-config-$(call config_package,wl12xx) += WL12XX
-config-$(call config_package,wl18xx) += WL18XX
-config-y += WL_TI WILINK_PLATFORM_DATA
-config-$(call config_package,zd1211rw) += ZD1211RW
-
-config-$(call config_package,rtlwifi) += RTL_CARDS RTLWIFI
-config-$(call config_package,rtlwifi-pci) += RTLWIFI_PCI
-config-$(call config_package,rtlwifi-usb) += RTLWIFI_USB
-config-$(call config_package,rtl8192c-common) += RTL8192C_COMMON
-config-$(call config_package,rtl8192ce) += RTL8192CE
-config-$(call config_package,rtl8192se) += RTL8192SE
-config-$(call config_package,rtl8192de) += RTL8192DE
-config-$(call config_package,rtl8192cu) += RTL8192CU
-config-$(CONFIG_PACKAGE_RTLWIFI_DEBUG) += RTLWIFI_DEBUG
-
-config-$(CONFIG_LEDS_TRIGGERS) += MAC80211_LEDS B43_LEDS B43LEGACY_LEDS
-
-MAKE_OPTS:= -C "$(PKG_BUILD_DIR)" \
-	CROSS_COMPILE="$(KERNEL_CROSS)" \
-	ARCH="$(LINUX_KARCH)" \
-	EXTRA_CFLAGS="-I$(PKG_BUILD_DIR)/include" \
-	KLIB_BUILD="$(LINUX_DIR)" \
-	MODPROBE=true \
-	KLIB=$(TARGET_MODULES_DIR) \
-	KERNEL_SUBLEVEL=$(lastword $(subst ., ,$(KERNEL_PATCHVER))) \
-	KBUILD_LDFLAGS_MODULE_PREREQ=
-
-ifneq ($(findstring c,$(OPENWRT_VERBOSE)),)
-  MAKE_OPTS += V=1
-endif
-
-define ConfigVars
-$(subst $(space),,$(foreach opt,$(config-$(1)),CPTCFG_$(opt)=$(1)
-))
-endef
-
-define mac80211_config
-$(call ConfigVars,m)$(call ConfigVars,y)
-endef
-$(eval $(call shexport,mac80211_config))
-
-define Build/Prepare
-	rm -rf $(PKG_BUILD_DIR)
-	mkdir -p $(PKG_BUILD_DIR)
-	$(PKG_UNPACK)
-	$(Build/Patch)
-	$(TAR) -C $(PKG_BUILD_DIR) -xzf $(DL_DIR)/$(IPW2100_NAME)-$(IPW2100_VERSION).tgz
-	$(TAR) -C $(PKG_BUILD_DIR) -xzf $(DL_DIR)/$(IPW2200_NAME)-$(IPW2200_VERSION).tgz
-	$(TAR) -C $(PKG_BUILD_DIR) -xjf $(DL_DIR)/$(ZD1211FW_NAME)-$(ZD1211FW_VERSION).tar.bz2
-	$(TAR) -C $(PKG_BUILD_DIR) -xjf $(DL_DIR)/$(PKG_LINUX_FIRMWARE_SOURCE)
-	$(TAR) -C $(PKG_BUILD_DIR) -xjf $(DL_DIR)/$(PKG_ATH10K_LINUX_FIRMWARE_SOURCE)
-	rm -rf \
-		$(PKG_BUILD_DIR)/include/linux/ssb \
-		$(PKG_BUILD_DIR)/include/linux/bcma \
-		$(PKG_BUILD_DIR)/include/net/bluetooth
-
-	rm -f \
-		$(PKG_BUILD_DIR)/include/linux/cordic.h \
-		$(PKG_BUILD_DIR)/include/linux/crc8.h \
-		$(PKG_BUILD_DIR)/include/linux/eeprom_93cx6.h \
-		$(PKG_BUILD_DIR)/include/linux/wl12xx.h \
-		$(PKG_BUILD_DIR)/include/linux/spi/libertas_spi.h \
-		$(PKG_BUILD_DIR)/include/net/ieee80211.h
-
-	echo 'compat-wireless-$(PKG_VERSION)-$(PKG_RELEASE)-$(REVISION)' > $(PKG_BUILD_DIR)/compat_version
-	$(CP) ./files/regdb.txt $(PKG_BUILD_DIR)/net/wireless/db.txt
-endef
-
-ifneq ($(CONFIG_PACKAGE_kmod-cfg80211)$(CONFIG_PACKAGE_kmod-lib80211),)
- define Build/Compile/kmod
-	rm -rf $(PKG_BUILD_DIR)/modules
-	+$(MAKE) $(PKG_JOBS) $(MAKE_OPTS) modules
- endef
-endif
-
-define Build/Configure
-	cmp $(PKG_BUILD_DIR)/include/linux/ath9k_platform.h $(LINUX_DIR)/include/linux/ath9k_platform.h
-	cmp $(PKG_BUILD_DIR)/include/linux/ath5k_platform.h $(LINUX_DIR)/include/linux/ath5k_platform.h
-	cmp $(PKG_BUILD_DIR)/include/linux/rt2x00_platform.h $(LINUX_DIR)/include/linux/rt2x00_platform.h
-endef
-
-define Build/Compile
-	$(SH_FUNC) var2file "$(call shvar,mac80211_config)" $(PKG_BUILD_DIR)/.config
-	$(MAKE) $(MAKE_OPTS) allnoconfig
-	$(call Build/Compile/kmod)
-endef
-
-define Build/InstallDev
-	mkdir -p \
-		$(1)/usr/include/mac80211 \
-		$(1)/usr/include/mac80211-backport \
-		$(1)/usr/include/mac80211/ath \
-		$(1)/usr/include/net/mac80211
-	$(CP) $(PKG_BUILD_DIR)/net/mac80211/*.h $(PKG_BUILD_DIR)/include/* $(1)/usr/include/mac80211/
-	$(CP) $(PKG_BUILD_DIR)/backport-include/* $(1)/usr/include/mac80211-backport/
-	$(CP) $(PKG_BUILD_DIR)/net/mac80211/rate.h $(1)/usr/include/net/mac80211/
-	$(CP) $(PKG_BUILD_DIR)/drivers/net/wireless/ath/*.h $(1)/usr/include/mac80211/ath/
-endef
-
-define KernelPackage/libertas-usb/install
-	$(INSTALL_DIR) $(1)/lib/firmware/libertas
-	$(INSTALL_DATA) \
-		$(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/libertas/usb8388_v9.bin \
-		$(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/libertas/usb8682.bin \
-		$(1)/lib/firmware/libertas/
-endef
-
-define KernelPackage/libertas-sd/install
-	$(INSTALL_DIR) $(1)/lib/firmware/libertas
-	$(INSTALL_DATA) \
-		$(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/libertas/sd8385_helper.bin \
-		$(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/libertas/sd8385.bin \
-		$(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/libertas/sd8686_v9_helper.bin \
-		$(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/libertas/sd8686_v9.bin \
-		$(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/libertas/sd8688_helper.bin \
-		$(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/libertas/sd8688.bin \
-		$(1)/lib/firmware/libertas
-endef
-
-define KernelPackage/cfg80211/install
-	$(INSTALL_DIR) $(1)/lib/wifi
-	$(INSTALL_DATA) ./files/lib/wifi/mac80211.sh $(1)/lib/wifi
-endef
-
-define KernelPackage/p54-pci/install
-	$(INSTALL_DIR) $(1)/lib/firmware
-	$(INSTALL_DATA) $(DL_DIR)/$(P54PCIFW) $(1)/lib/firmware/isl3886pci
-endef
-
-define KernelPackage/p54-usb/install
-	$(INSTALL_DIR) $(1)/lib/firmware
-	$(INSTALL_DATA) $(DL_DIR)/$(P54USBFW) $(1)/lib/firmware/isl3887usb
-endef
-
-define KernelPackage/p54-spi/install
-	$(INSTALL_DIR) $(1)/lib/firmware
-	$(INSTALL_DATA) $(DL_DIR)/$(P54SPIFW) $(1)/lib/firmware/3826.arm
-endef
-
-define KernelPackage/rt61-pci/install
-	$(INSTALL_DIR) $(1)/lib/firmware
-	$(INSTALL_DATA) \
-		$(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/rt2561.bin \
-		$(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/rt2561s.bin \
-		$(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/rt2661.bin \
-		$(1)/lib/firmware/
-endef
-
-define KernelPackage/rt73-usb/install
-	$(INSTALL_DIR) $(1)/lib/firmware
-	$(INSTALL_DATA) $(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/rt73.bin $(1)/lib/firmware/
-endef
-
-define KernelPackage/rt2800-pci/install
-	$(INSTALL_DIR) $(1)/lib/firmware
-	$(INSTALL_DATA) \
-		$(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/rt2860.bin \
-		$(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/rt3290.bin \
-		$(1)/lib/firmware
-endef
-
-define KernelPackage/rt2800-usb/install
-	$(INSTALL_DIR) $(1)/lib/firmware
-	$(INSTALL_DATA) $(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/rt2870.bin $(1)/lib/firmware/
-endef
-
-define KernelPackage/wl12xx/install
-	$(INSTALL_DIR) $(1)/lib/firmware/ti-connectivity
-	$(INSTALL_DATA) \
-		$(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/ti-connectivity/wl127x-fw-5-mr.bin \
-		$(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/ti-connectivity/wl127x-fw-5-plt.bin \
-		$(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/ti-connectivity/wl127x-fw-5-sr.bin \
-		$(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/ti-connectivity/wl1271-nvs.bin \
-		$(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/ti-connectivity/wl128x-fw-5-mr.bin \
-		$(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/ti-connectivity/wl128x-fw-5-plt.bin \
-		$(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/ti-connectivity/wl128x-fw-5-sr.bin \
-		$(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/ti-connectivity/wl128x-nvs.bin \
-		$(1)/lib/firmware/ti-connectivity
-endef
-
-define KernelPackage/wl18xx/install
-	$(INSTALL_DIR) $(1)/lib/firmware/ti-connectivity
-	$(INSTALL_DATA) \
-		$(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/ti-connectivity/wl18xx-conf.bin \
-		$(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/ti-connectivity/wl18xx-fw.bin \
-		$(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/ti-connectivity/wl18xx-fw-2.bin \
-		$(1)/lib/firmware/ti-connectivity
-endef
-
-define KernelPackage/zd1211rw/install
-	$(INSTALL_DIR) $(1)/lib/firmware/zd1211
-	$(INSTALL_DATA) $(PKG_BUILD_DIR)/$(ZD1211FW_NAME)/zd1211* $(1)/lib/firmware/zd1211
-endef
-
-define KernelPackage/carl9170/install
-	$(INSTALL_DIR) $(1)/lib/firmware
-	$(INSTALL_DATA) $(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/carl9170-1.fw $(1)/lib/firmware
-endef
-
-define KernelPackage/ath9k-htc/install
-	$(INSTALL_DIR) $(1)/lib/firmware
-	$(INSTALL_DATA) \
-		$(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/htc_9271.fw \
-		$(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/htc_7010.fw \
-		$(1)/lib/firmware/
-endef
-
-define KernelPackage/ath10k/install
-	$(INSTALL_DIR) $(1)/lib/firmware/ath10k/QCA988X/hw2.0
-	$(INSTALL_DATA) \
-		$(PKG_BUILD_DIR)/$(PKG_ATH10K_LINUX_FIRMWARE_SUBDIR)/ath10k/QCA988X/hw2.0/board.bin \
-		$(PKG_BUILD_DIR)/$(PKG_ATH10K_LINUX_FIRMWARE_SUBDIR)/ath10k/QCA988X/hw2.0/firmware-2.bin \
-		$(1)/lib/firmware/ath10k/QCA988X/hw2.0/
-endef
-
-define KernelPackage/mwl8k/install
-	$(INSTALL_DIR) $(1)/lib/firmware/mwl8k
-	$(INSTALL_DATA) \
-		$(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/mwl8k/fmimage_8366_ap-3.fw \
-		$(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/mwl8k/fmimage_8366.fw \
-		$(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/mwl8k/helper_8366.fw \
-		$(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/mwl8k/fmimage_8687.fw \
-		$(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/mwl8k/helper_8687.fw \
-		$(1)/lib/firmware/mwl8k/
-endef
-
-define KernelPackage/net-ipw2100/install
-	$(INSTALL_DIR) $(1)/lib/firmware
-	$(INSTALL_DATA) $(PKG_BUILD_DIR)/ipw2100-$(IPW2100_VERSION)*.fw $(1)/lib/firmware
-endef
-
-define KernelPackage/net-ipw2200/install
-	$(INSTALL_DIR) $(1)/lib/firmware
-	$(INSTALL_DATA) $(PKG_BUILD_DIR)/$(IPW2200_NAME)-$(IPW2200_VERSION)/ipw2200*.fw $(1)/lib/firmware
-endef
-
-define KernelPackage/iwlagn/install
-	$(INSTALL_DIR) $(1)/lib/firmware
-ifneq ($(CONFIG_IWL5000_FW),)
-	$(INSTALL_DATA) $(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/iwlwifi-5000-5.ucode $(1)/lib/firmware
-endif
-ifneq ($(CONFIG_IWL5150_FW),)
-	$(INSTALL_DATA) $(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/iwlwifi-5150-2.ucode $(1)/lib/firmware
-endif
-ifneq ($(CONFIG_IWL1000_FW),)
-	$(INSTALL_DATA) $(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/iwlwifi-1000-5.ucode $(1)/lib/firmware
-endif
-ifneq ($(CONFIG_IWL6000_FW),)
-	$(INSTALL_DATA) $(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/iwlwifi-6000-4.ucode $(1)/lib/firmware
-endif
-ifneq ($(CONFIG_IWL6050_FW),)
-	$(INSTALL_DATA) $(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/iwlwifi-6050-5.ucode $(1)/lib/firmware
-endif
-ifneq ($(CONFIG_IWL6005_FW),)
-	$(INSTALL_DATA) $(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/iwlwifi-6000g2a-6.ucode $(1)/lib/firmware
-endif
-ifneq ($(CONFIG_IWL6030_FW),)
-	$(INSTALL_DATA) $(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/iwlwifi-6000g2b-6.ucode $(1)/lib/firmware
-endif
-ifneq ($(CONFIG_IWL100_FW),)
-	$(INSTALL_DATA) $(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/iwlwifi-100-5.ucode $(1)/lib/firmware
-endif
-ifneq ($(CONFIG_IWL2000_FW),)
-	$(INSTALL_DATA) $(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/iwlwifi-2000-6.ucode $(1)/lib/firmware
-endif
-ifneq ($(CONFIG_IWL2030_FW),)
-	$(INSTALL_DATA) $(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/iwlwifi-2030-6.ucode $(1)/lib/firmware
-endif
-ifneq ($(CONFIG_IWL105_FW),)
-	$(INSTALL_DATA) $(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/iwlwifi-105-6.ucode $(1)/lib/firmware
-endif
-ifneq ($(CONFIG_IWL135_FW),)
-	$(INSTALL_DATA) $(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/iwlwifi-135-6.ucode $(1)/lib/firmware
-endif
-endef
-
-define KernelPackage/iwl3945/install
-	$(INSTALL_DIR) $(1)/lib/firmware
-	$(INSTALL_DATA) $(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/iwlwifi-3945-2.ucode $(1)/lib/firmware
-endef
-
-define KernelPackage/iwl4965/install
-	$(INSTALL_DIR) $(1)/lib/firmware
-	$(INSTALL_DATA) $(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/iwlwifi-4965-2.ucode $(1)/lib/firmware
-endef
-
-define KernelPackage/b43/install
-	rm -rf $(1)/lib/firmware/
-ifeq ($(CONFIG_B43_OPENFIRMWARE),y)
-	tar xzf "$(DL_DIR)/$(PKG_B43_FWV4_SOURCE)" -C "$(PKG_BUILD_DIR)"
-else
-	tar xjf "$(DL_DIR)/$(PKG_B43_FWV4_SOURCE)" -C "$(PKG_BUILD_DIR)"
-endif
-	$(INSTALL_DIR) $(1)/lib/firmware/
-ifeq ($(CONFIG_B43_OPENFIRMWARE),y)
-	$(MAKE) -C "$(PKG_BUILD_DIR)/$(PKG_B43_FWV4_OBJECT)/"
-	$(INSTALL_DIR) $(1)/lib/firmware/b43-open/
-	$(INSTALL_DATA) $(PKG_BUILD_DIR)/$(PKG_B43_FWV4_OBJECT)/ucode5.fw $(1)/lib/firmware/b43-open/ucode5.fw
-	$(INSTALL_DATA) $(PKG_BUILD_DIR)/$(PKG_B43_FWV4_OBJECT)/b0g0bsinitvals5.fw $(1)/lib/firmware/b43-open/b0g0bsinitvals5.fw
-	$(INSTALL_DATA) $(PKG_BUILD_DIR)/$(PKG_B43_FWV4_OBJECT)/b0g0initvals5.fw $(1)/lib/firmware/b43-open/b0g0initvals5.fw
-else
-	b43-fwcutter -w $(1)/lib/firmware/ $(PKG_BUILD_DIR)/$(PKG_B43_FWV4_OBJECT)
-endif
-ifneq ($(CONFIG_B43_FW_SQUASH),)
-	b43-fwsquash.py "$(CONFIG_B43_FW_SQUASH_PHYTYPES)" "$(CONFIG_B43_FW_SQUASH_COREREVS)" "$(1)/lib/firmware/b43"
-endif
-endef
-
-define KernelPackage/b43legacy/install
-	$(INSTALL_DIR) $(1)/lib/firmware/
-	b43-fwcutter --unsupported -w $(1)/lib/firmware/ $(DL_DIR)/$(PKG_B43_FWV3_SOURCE)
-ifneq ($(CONFIG_B43LEGACY_FW_SQUASH),)
-	b43-fwsquash.py "G" "$(CONFIG_B43LEGACY_FW_SQUASH_COREREVS)" "$(1)/lib/firmware/b43legacy"
-endif
-endef
-
-define KernelPackage/brcmsmac/install
-	$(INSTALL_DIR) $(1)/lib/firmware/brcm
-ifeq ($(CONFIG_BRCMSMAC_USE_FW_FROM_WL),y)
-	tar xjf "$(DL_DIR)/$(PKG_BRCMSMAC_FW_SOURCE)" -C "$(PKG_BUILD_DIR)"
-	b43-fwcutter --brcmsmac -w $(1)/lib/firmware/ $(PKG_BUILD_DIR)/$(PKG_BRCMSMAC_FW_OBJECT)
-else
-	$(INSTALL_DATA) \
-		$(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/brcm/bcm43xx-0.fw \
-		$(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/brcm/bcm43xx_hdr-0.fw \
-		$(1)/lib/firmware/brcm/
-endif
-endef
-
-define KernelPackage/brcmfmac/install
-	$(INSTALL_DIR) $(1)/lib/firmware/brcm
-	$(INSTALL_DATA) \
-		$(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/brcm/brcmfmac43236b.bin \
-		$(1)/lib/firmware/brcm/
-endef
-
-$(eval $(call KernelPackage,adm8211))
-$(eval $(call KernelPackage,ath5k))
-$(eval $(call KernelPackage,lib80211))
-$(eval $(call KernelPackage,libertas-usb))
-$(eval $(call KernelPackage,libertas-sd))
-$(eval $(call KernelPackage,cfg80211))
-$(eval $(call KernelPackage,mac80211))
-$(eval $(call KernelPackage,p54-common))
-$(eval $(call KernelPackage,p54-pci))
-$(eval $(call KernelPackage,p54-usb))
-$(eval $(call KernelPackage,p54-spi))
-$(eval $(call KernelPackage,rt2x00-lib))
-$(eval $(call KernelPackage,rt2x00-mmio))
-$(eval $(call KernelPackage,rt2x00-pci))
-$(eval $(call KernelPackage,rt2x00-usb))
-$(eval $(call KernelPackage,rt2800-lib))
-$(eval $(call KernelPackage,rt2400-pci))
-$(eval $(call KernelPackage,rt2500-pci))
-$(eval $(call KernelPackage,rt2500-usb))
-$(eval $(call KernelPackage,rt61-pci))
-$(eval $(call KernelPackage,rt73-usb))
-$(eval $(call KernelPackage,rt2800-mmio))
-$(eval $(call KernelPackage,rt2800-soc))
-$(eval $(call KernelPackage,rt2800-pci))
-$(eval $(call KernelPackage,rt2800-usb))
-$(eval $(call KernelPackage,rtl8180))
-$(eval $(call KernelPackage,rtl8187))
-$(eval $(call KernelPackage,rtlwifi))
-$(eval $(call KernelPackage,rtlwifi-pci))
-$(eval $(call KernelPackage,rtlwifi-usb))
-$(eval $(call KernelPackage,rtl8192c-common))
-$(eval $(call KernelPackage,rtl8192ce))
-$(eval $(call KernelPackage,rtl8192se))
-$(eval $(call KernelPackage,rtl8192de))
-$(eval $(call KernelPackage,rtl8192cu))
-$(eval $(call KernelPackage,zd1211rw))
-$(eval $(call KernelPackage,mac80211-hwsim))
-$(eval $(call KernelPackage,ath9k-common))
-$(eval $(call KernelPackage,ath9k))
-$(eval $(call KernelPackage,ath9k-htc))
-$(eval $(call KernelPackage,ath10k))
-$(eval $(call KernelPackage,ath))
-$(eval $(call KernelPackage,carl9170))
-$(eval $(call KernelPackage,b43))
-$(eval $(call KernelPackage,b43legacy))
-$(eval $(call KernelPackage,brcmutil))
-$(eval $(call KernelPackage,brcmsmac))
-$(eval $(call KernelPackage,brcmfmac))
-$(eval $(call KernelPackage,net-libipw))
-$(eval $(call KernelPackage,net-ipw2100))
-$(eval $(call KernelPackage,net-ipw2200))
-$(eval $(call KernelPackage,iwlagn))
-$(eval $(call KernelPackage,iwl-legacy))
-$(eval $(call KernelPackage,iwl4965))
-$(eval $(call KernelPackage,iwl3945))
-$(eval $(call KernelPackage,mwl8k))
-$(eval $(call KernelPackage,net-hermes))
-$(eval $(call KernelPackage,net-hermes-pci))
-$(eval $(call KernelPackage,net-hermes-plx))
-$(eval $(call KernelPackage,net-hermes-pcmcia))
-$(eval $(call KernelPackage,wlcore))
-$(eval $(call KernelPackage,wl12xx))
-$(eval $(call KernelPackage,wl18xx))
diff --git a/package/mac80211/files/lib/wifi/mac80211.sh b/package/mac80211/files/lib/wifi/mac80211.sh
deleted file mode 100644
index 1994ca3..0000000
--- a/package/mac80211/files/lib/wifi/mac80211.sh
+++ /dev/null
@@ -1,655 +0,0 @@
-#!/bin/sh
-append DRIVERS "mac80211"
-
-mac80211_hostapd_setup_base() {
-	local phy="$1"
-	local ifname="$2"
-
-	cfgfile="/var/run/hostapd-$phy.conf"
-
-	config_get device "$vif" device
-	config_get country "$device" country
-	config_get hwmode "$device" hwmode
-	config_get channel "$device" channel
-	config_get beacon_int "$device" beacon_int
-	config_get basic_rate_list "$device" basic_rate
-	config_get_bool noscan "$device" noscan
-
-	hostapd_set_log_options base_cfg "$device"
-
-	[ -n "$channel" -a -z "$hwmode" ] && wifi_fixup_hwmode "$device"
-
-	hostapd_channel=$channel
-	[ "$channel" = auto -o "$channel" = 0 ] && hostapd_channel=acs_survey
-
-	[ -n "$hwmode" ] && {
-		config_get hwmode_11n "$device" hwmode_11n
-		[ -n "$hwmode_11n" ] && {
-			hwmode="$hwmode_11n"
-			append base_cfg "ieee80211n=1" "$N"
-			config_get htmode "$device" htmode
-			config_get ht_capab_list "$device" ht_capab
-			case "$htmode" in
-				HT20|HT40+|HT40-) ht_capab="[$htmode]";;
-				*)ht_capab=;;
-			esac
-			for cap in $ht_capab_list; do
-				ht_capab="$ht_capab[$cap]"
-			done
-			[ -n "$ht_capab" ] && append base_cfg "ht_capab=$ht_capab" "$N"
-		}
-	}
-
-	local country_ie=0
-	[ -n "$country" ] && country_ie=1
-	config_get_bool country_ie "$device" country_ie "$country_ie"
-	[ "$country_ie" -gt 0 ] && append base_cfg "ieee80211d=1" "$N"
-
-	local br brval brstr
-	[ -n "$basic_rate_list" ] && {
-		for br in $basic_rate_list; do
-			brval="$(($br / 100))"
-			[ -n "$brstr" ] && brstr="$brstr "
-			brstr="$brstr$brval"
-		done
-	}
-
-	cat >> "$cfgfile" <<EOF
-ctrl_interface=/var/run/hostapd-$phy
-driver=nl80211
-wmm_ac_bk_cwmin=4
-wmm_ac_bk_cwmax=10
-wmm_ac_bk_aifs=7
-wmm_ac_bk_txop_limit=0
-wmm_ac_bk_acm=0
-wmm_ac_be_aifs=3
-wmm_ac_be_cwmin=4
-wmm_ac_be_cwmax=10
-wmm_ac_be_txop_limit=0
-wmm_ac_be_acm=0
-wmm_ac_vi_aifs=2
-wmm_ac_vi_cwmin=3
-wmm_ac_vi_cwmax=4
-wmm_ac_vi_txop_limit=94
-wmm_ac_vi_acm=0
-wmm_ac_vo_aifs=2
-wmm_ac_vo_cwmin=2
-wmm_ac_vo_cwmax=3
-wmm_ac_vo_txop_limit=47
-wmm_ac_vo_acm=0
-tx_queue_data3_aifs=7
-tx_queue_data3_cwmin=15
-tx_queue_data3_cwmax=1023
-tx_queue_data3_burst=0
-tx_queue_data2_aifs=3
-tx_queue_data2_cwmin=15
-tx_queue_data2_cwmax=63
-tx_queue_data2_burst=0
-tx_queue_data1_aifs=1
-tx_queue_data1_cwmin=7
-tx_queue_data1_cwmax=15
-tx_queue_data1_burst=3.0
-tx_queue_data0_aifs=1
-tx_queue_data0_cwmin=3
-tx_queue_data0_cwmax=7
-tx_queue_data0_burst=1.5
-${hwmode:+hw_mode=$hwmode}
-${hostapd_channel:+channel=$hostapd_channel}
-${beacon_int:+beacon_int=$beacon_int}
-${country:+country_code=$country}
-${noscan:+noscan=$noscan}
-${brstr:+basic_rates=$brstr}
-$base_cfg
-
-EOF
-}
-
-mac80211_hostapd_setup_bss() {
-	local phy="$1"
-	local vif="$2"
-	local staidx="$3"
-
-	hostapd_cfg=
-	cfgfile="/var/run/hostapd-$phy.conf"
-	config_get ifname "$vif" ifname
-
-	if [ -f "$cfgfile" ]; then
-		append hostapd_cfg "bss=$ifname" "$N"
-	else
-		mac80211_hostapd_setup_base "$phy" "$ifname"
-		append hostapd_cfg "interface=$ifname" "$N"
-	fi
-
-	local net_cfg bridge
-	net_cfg="$(find_net_config "$vif")"
-	[ -z "$net_cfg" ] || bridge="$(bridge_interface "$net_cfg")"
-	config_set "$vif" bridge "$bridge"
-
-	hostapd_set_bss_options hostapd_cfg "$vif"
-
-	config_get_bool wds "$vif" wds 0
-	[ "$wds" -gt 0 ] && append hostapd_cfg "wds_sta=1" "$N"
-
-	[ "$staidx" -gt 0 ] && append hostapd_cfg "start_disabled=1" "$N"
-
-	local macaddr hidden maxassoc wmm
-	config_get macaddr "$vif" macaddr
-	config_get maxassoc "$vif" maxassoc
-	config_get dtim_period "$vif" dtim_period
-	config_get max_listen_int "$vif" max_listen_int
-	config_get_bool hidden "$vif" hidden 0
-	config_get_bool wmm "$vif" wmm 1
-	cat >> /var/run/hostapd-$phy.conf <<EOF
-$hostapd_cfg
-wmm_enabled=$wmm
-bssid=$macaddr
-ignore_broadcast_ssid=$hidden
-${dtim_period:+dtim_period=$dtim_period}
-${max_listen_int:+max_listen_interval=$max_listen_int}
-${maxassoc:+max_num_sta=$maxassoc}
-EOF
-}
-
-mac80211_start_vif() {
-	local vif="$1"
-	local ifname="$2"
-
-	local net_cfg
-	net_cfg="$(find_net_config "$vif")"
-	[ -z "$net_cfg" ] || start_net "$ifname" "$net_cfg"
-
-	set_wifi_up "$vif" "$ifname"
-}
-
-lookup_phy() {
-	[ -n "$phy" ] && {
-		[ -d /sys/class/ieee80211/$phy ] && return
-	}
-
-	local devpath
-	config_get devpath "$device" path
-	[ -n "$devpath" -a -d "/sys/devices/$devpath/ieee80211" ] && {
-		phy="$(ls /sys/devices/$devpath/ieee80211 | grep -m 1 phy)"
-		[ -n "$phy" ] && return
-	}
-
-	local macaddr="$(config_get "$device" macaddr | tr 'A-Z' 'a-z')"
-	[ -n "$macaddr" ] && {
-		for _phy in $(ls /sys/class/ieee80211 2>/dev/null); do
-			[ "$macaddr" = "$(cat /sys/class/ieee80211/${_phy}/macaddress)" ] || continue
-			phy="$_phy"
-			return
-		done
-	}
-	phy=
-	return
-}
-
-find_mac80211_phy() {
-	local device="$1"
-
-	config_get phy "$device" phy
-	lookup_phy
-	[ -n "$phy" -a -d "/sys/class/ieee80211/$phy" ] || {
-		echo "PHY for wifi device $1 not found"
-		return 1
-	}
-	config_set "$device" phy "$phy"
-
-	config_get macaddr "$device" macaddr
-	[ -z "$macaddr" ] && {
-		config_set "$device" macaddr "$(cat /sys/class/ieee80211/${phy}/macaddress)"
-	}
-
-	return 0
-}
-
-scan_mac80211() {
-	local device="$1"
-	local adhoc sta ap monitor mesh disabled
-
-	config_get vifs "$device" vifs
-	for vif in $vifs; do
-		config_get_bool disabled "$vif" disabled 0
-		[ $disabled = 0 ] || continue
-
-		config_get mode "$vif" mode
-		case "$mode" in
-			adhoc|sta|ap|monitor|mesh)
-				append $mode "$vif"
-			;;
-			*) echo "$device($vif): Invalid mode, ignored."; continue;;
-		esac
-	done
-
-	config_set "$device" vifs "${ap:+$ap }${adhoc:+$adhoc }${sta:+$sta }${monitor:+$monitor }${mesh:+$mesh}"
-}
-
-list_phy_interfaces() {
-	local phy="$1"
-	if [ -d "/sys/class/ieee80211/${phy}/device/net" ]; then
-		ls "/sys/class/ieee80211/${phy}/device/net" 2>/dev/null;
-	else
-		ls "/sys/class/ieee80211/${phy}/device" 2>/dev/null | grep net: | sed -e 's,net:,,g'
-	fi
-}
-
-disable_mac80211() (
-	local device="$1"
-
-	find_mac80211_phy "$device" || return 0
-	config_get phy "$device" phy
-
-	set_wifi_down "$device"
-	# kill all running hostapd and wpa_supplicant processes that
-	# are running on atheros/mac80211 vifs
-	for pid in `pidof hostapd`; do
-		grep -E "$phy" /proc/$pid/cmdline >/dev/null && \
-			kill $pid
-	done
-
-	include /lib/network
-	for wdev in $(list_phy_interfaces "$phy"); do
-		[ -f "/var/run/$wdev.pid" ] && kill $(cat /var/run/$wdev.pid) >&/dev/null 2>&1
-		for pid in `pidof wpa_supplicant meshd-nl80211`; do
-			grep "$wdev" /proc/$pid/cmdline >/dev/null && \
-				kill $pid
-		done
-		ifconfig "$wdev" down 2>/dev/null
-		unbridge "$dev"
-		iw dev "$wdev" del
-	done
-
-	return 0
-)
-
-get_freq() {
-	local phy="$1"
-	local chan="$2"
-	iw "$phy" info | grep -E -m1 "(\* ${chan:-....} MHz${chan:+|\\[$chan\\]})" | grep MHz | awk '{print $2}'
-}
-
-mac80211_generate_mac() {
-	local id="$1"
-	local ref="$2"
-	local mask="$3"
-
-	[ "$mask" = "00:00:00:00:00:00" ] && mask="ff:ff:ff:ff:ff:ff";
-	local oIFS="$IFS"; IFS=":"; set -- $mask; IFS="$oIFS"
-
-	local mask1=$1
-	local mask6=$6
-
-	local oIFS="$IFS"; IFS=":"; set -- $ref; IFS="$oIFS"
-	[ "$((0x$mask1))" -gt 0 ] && {
-		b1="0x$1"
-		[ "$id" -gt 0 ] && \
-			b1=$(($b1 ^ ((($id - 1) << 2) | 0x2)))
-		printf "%02x:%s:%s:%s:%s:%s" $b1 $2 $3 $4 $5 $6
-		return
-	}
-
-	[ "$((0x$mask6))" -lt 255 ] && {
-		printf "%s:%s:%s:%s:%s:%02x" $1 $2 $3 $4 $5 $(( 0x$6 ^ $id ))
-		return
-	}
-
-	off2=$(( (0x$6 + $id) / 0x100 ))
-	printf "%s:%s:%s:%s:%02x:%02x" \
-		$1 $2 $3 $4 \
-		$(( (0x$5 + $off2) % 0x100 )) \
-		$(( (0x$6 + $id) % 0x100 ))
-}
-
-enable_mac80211() {
-	local device="$1"
-	config_get channel "$device" channel
-	config_get vifs "$device" vifs
-	config_get txpower "$device" txpower
-	config_get country "$device" country
-	config_get distance "$device" distance
-	config_get txantenna "$device" txantenna all
-	config_get rxantenna "$device" rxantenna all
-	config_get antenna_gain "$device" antenna_gain 0
-	config_get frag "$device" frag
-	config_get rts "$device" rts
-	find_mac80211_phy "$device" || return 0
-	config_get phy "$device" phy
-	local i=0
-	local macidx=0
-	local apidx=0
-	local staidx=0
-	fixed=""
-	local hostapd_ctrl=""
-
-	[ -n "$country" ] && {
-		iw reg get | grep -q "^country $country:" || {
-			iw reg set "$country"
-			sleep 1
-		}
-	}
-
-	config_get chanbw "$device" chanbw
-	[ -n "$chanbw" -a -d /sys/kernel/debug/ieee80211/$phy/ath9k ] && echo "$chanbw" > /sys/kernel/debug/ieee80211/$phy/ath9k/chanbw
-	[ -n "$chanbw" -a -d /sys/kernel/debug/ieee80211/$phy/ath5k ] && echo "$chanbw" > /sys/kernel/debug/ieee80211/$phy/ath5k/bwmode
-
-	[ "$channel" = "auto" -o "$channel" = "0" ] || {
-		fixed=1
-	}
-
-	iw phy "$phy" set antenna $txantenna $rxantenna >/dev/null 2>&1
-	iw phy "$phy" set antenna_gain $antenna_gain
-
-	[ -n "$distance" ] && iw phy "$phy" set distance "$distance"
-	[ -n "$frag" ] && iw phy "$phy" set frag "${frag%%.*}"
-	[ -n "$rts" ] && iw phy "$phy" set rts "${rts%%.*}"
-
-	export channel fixed
-	# convert channel to frequency
-	local freq="$(get_freq "$phy" "${fixed:+$channel}")"
-
-	wifi_fixup_hwmode "$device" "g"
-	for vif in $vifs; do
-		config_get ifname "$vif" ifname
-		[ -n "$ifname" ] || {
-			[ $i -gt 0 ] && ifname="wlan${phy#phy}-$i" || ifname="wlan${phy#phy}"
-		}
-		config_set "$vif" ifname "$ifname"
-
-		config_get mode "$vif" mode
-		config_get ssid "$vif" ssid
-
-		# It is far easier to delete and create the desired interface
-		case "$mode" in
-			adhoc)
-				iw phy "$phy" interface add "$ifname" type adhoc
-			;;
-			ap)
-				# Hostapd will handle recreating the interface and
-				# it's accompanying monitor
-				apidx="$(($apidx + 1))"
-				[ "$apidx" -gt 1 ] || iw phy "$phy" interface add "$ifname" type managed
-			;;
-			mesh)
-				config_get key "$vif" key ""
-				if [ -n "$key" ]; then
-					iw phy "$phy" interface add "$ifname" type mp
-				else
-					config_get mesh_id "$vif" mesh_id
-					iw phy "$phy" interface add "$ifname" type mp mesh_id "$mesh_id"
-				fi
-			;;
-			monitor)
-				iw phy "$phy" interface add "$ifname" type monitor
-			;;
-			sta)
-				local wdsflag
-				staidx="$(($staidx + 1))"
-				config_get_bool wds "$vif" wds 0
-				[ "$wds" -gt 0 ] && wdsflag="4addr on"
-				iw phy "$phy" interface add "$ifname" type managed $wdsflag
-				config_get_bool powersave "$vif" powersave 0
-				[ "$powersave" -gt 0 ] && powersave="on" || powersave="off"
-				iw "$ifname" set power_save "$powersave"
-			;;
-		esac
-
-		# All interfaces must have unique mac addresses
-		# which can either be explicitly set in the device
-		# section, or automatically generated
-		config_get macaddr "$device" macaddr
-		config_get vif_mac "$vif" macaddr
-		[ -n "$vif_mac" ] || {
-			vif_mac="$(mac80211_generate_mac $macidx $macaddr $(cat /sys/class/ieee80211/${phy}/address_mask))"
-			macidx="$(($macidx + 1))"
-		}
-		[ "$mode" = "ap" ] || ifconfig "$ifname" hw ether "$vif_mac"
-		config_set "$vif" macaddr "$vif_mac"
-
-		# !! ap !!
-		#
-		# ALL ap functionality will be passed to hostapd
-		#
-		# !! station !!
-		#
-		# ALL station functionality will be passed to wpa_supplicant
-		#
-		if [ ! "$mode" = "ap" ]; then
-			# We attempt to set the channel for all interfaces, although
-			# mac80211 may not support it or the driver might not yet
-			# for ap mode this is handled by hostapd
-			config_get htmode "$device" htmode
-			case "$htmode" in
-				HT20|HT40+|HT40-) ;;
-				*) htmode= ;;
-			esac
-			[ -n "$fixed" -a -n "$channel" ] && iw dev "$ifname" set channel "$channel" $htmode
-		fi
-
-		i=$(($i + 1))
-	done
-
-	local start_hostapd=
-	rm -f /var/run/hostapd-$phy.conf
-	for vif in $vifs; do
-		config_get mode "$vif" mode
-		case "$mode" in
-			ap)
-				mac80211_hostapd_setup_bss "$phy" "$vif" "$staidx"
-				start_hostapd=1
-			;;
-			mesh)
-				config_get key "$vif" key ""
-				[ -n "$key" ] && authsae_start_interface "$device" "$vif"
-			;;
-		esac
-	done
-
-	[ -n "$start_hostapd" ] && {
-		hostapd -P /var/run/wifi-$phy.pid -B /var/run/hostapd-$phy.conf || {
-			echo "Failed to start hostapd for $phy"
-			return
-		}
-		sleep 2
-
-		for vif in $vifs; do
-			config_get mode "$vif" mode
-			config_get ifname "$vif" ifname
-			[ "$mode" = "ap" ] || continue
-			hostapd_ctrl="${hostapd_ctrl:-/var/run/hostapd-$phy/$ifname}"
-			mac80211_start_vif "$vif" "$ifname"
-		done
-	}
-
-	for vif in $vifs; do
-		config_get mode "$vif" mode
-		config_get ifname "$vif" ifname
-		[ "$mode" = "ap" ] || ifconfig "$ifname" up
-
-		config_get vif_txpower "$vif" txpower
-		# use vif_txpower (from wifi-iface) to override txpower (from
-		# wifi-device) if the latter doesn't exist
-		txpower="${txpower:-$vif_txpower}"
-		[ -z "$txpower" ] || iw dev "$ifname" set txpower fixed "${txpower%%.*}00"
-
-		case "$mode" in
-			adhoc)
-				config_get bssid "$vif" bssid
-				config_get ssid "$vif" ssid
-				config_get beacon_int "$device" beacon_int
-				config_get basic_rate_list "$device" basic_rate
-				config_get encryption "$vif" encryption
-				config_get key "$vif" key 1
-				config_get mcast_rate "$vif" mcast_rate
-				config_get htmode "$device" htmode
-				case "$htmode" in
-					HT20|HT40+|HT40-) ;;
-					*) htmode= ;;
-				esac
-
-
-				local keyspec=""
-				[ "$encryption" == "psk" -o "$encryption" == "psk2" ] && {
-					if eval "type wpa_supplicant_setup_vif" 2>/dev/null >/dev/null; then
-						wpa_supplicant_setup_vif "$vif" nl80211 "${hostapd_ctrl:+-H $hostapd_ctrl}" $freq $htmode || {
-							echo "enable_mac80211($device): Failed to set up wpa_supplicant for interface $ifname" >&2
-							# make sure this wifi interface won't accidentally stay open without encryption
-							ifconfig "$ifname" down
-						}
-						mac80211_start_vif "$vif" "$ifname"
-						continue
-					fi
-				}
-
-				[ "$encryption" == "wep" ] && {
-					case "$key" in
-						[1234])
-							local idx
-							for idx in 1 2 3 4; do
-								local ikey
-								config_get ikey "$vif" "key$idx"
-
-								[ -n "$ikey" ] && {
-									ikey="$(($idx - 1)):$(prepare_key_wep "$ikey")"
-									[ $idx -eq $key ] && ikey="d:$ikey"
-									append keyspec "$ikey"
-								}
-							done
-						;;
-						*) append keyspec "d:0:$(prepare_key_wep "$key")" ;;
-					esac
-				}
-
-				local br brval brsub brstr
-				[ -n "$basic_rate_list" ] && {
-					for br in $basic_rate_list; do
-						brval="$(($br / 1000))"
-						brsub="$((($br / 100) % 10))"
-						[ "$brsub" -gt 0 ] && brval="$brval.$brsub"
-						[ -n "$brstr" ] && brstr="$brstr,"
-						brstr="$brstr$brval"
-					done
-				}
-
-				local mcval=""
-				[ -n "$mcast_rate" ] && {
-					mcval="$(($mcast_rate / 1000))"
-					mcsub="$(( ($mcast_rate / 100) % 10 ))"
-					[ "$mcsub" -gt 0 ] && mcval="$mcval.$mcsub"
-				}
-
-				iw dev "$ifname" ibss join "$ssid" $freq $htmode \
-					${fixed:+fixed-freq} $bssid \
-					${beacon_int:+beacon-interval $beacon_int} \
-					${brstr:+basic-rates $brstr} \
-					${mcval:+mcast-rate $mcval} \
-					${keyspec:+keys $keyspec}
-			;;
-			mesh)
-				mp_list="mesh_retry_timeout mesh_confirm_timeout mesh_holding_timeout mesh_max_peer_links
-					mesh_max_retries mesh_ttl mesh_element_ttl mesh_auto_open_plinks mesh_hwmp_max_preq_retries
-					mesh_path_refresh_time mesh_min_discovery_timeout mesh_hwmp_active_path_timeout
-					mesh_hwmp_preq_min_interval mesh_hwmp_net_diameter_traversal_time mesh_hwmp_rootmode
-					mesh_hwmp_rann_interval mesh_gate_announcements mesh_fwding mesh_sync_offset_max_neighor
-					mesh_rssi_threshold mesh_hwmp_active_path_to_root_timeout mesh_hwmp_root_interval
-					mesh_hwmp_confirmation_interval mesh_power_mode mesh_awake_window"
-				for mp in $mp_list
-				do
-					config_get mp_val "$vif" "$mp" ""
-					[ -n "$mp_val" ] && iw dev "$ifname" set mesh_param "$mp" "$mp_val"
-				done
-			;;
-			sta)
-				if eval "type wpa_supplicant_setup_vif" 2>/dev/null >/dev/null; then
-					wpa_supplicant_setup_vif "$vif" nl80211 "${hostapd_ctrl:+-H $hostapd_ctrl}" || {
-						echo "enable_mac80211($device): Failed to set up wpa_supplicant for interface $ifname" >&2
-						# make sure this wifi interface won't accidentally stay open without encryption
-						ifconfig "$ifname" down
-						continue
-					}
-				fi
-			;;
-		esac
-		[ "$mode" = "ap" ] || mac80211_start_vif "$vif" "$ifname"
-	done
-
-}
-
-
-check_mac80211_device() {
-	config_get phy "$1" phy
-	[ -z "$phy" ] && {
-		find_mac80211_phy "$1" >/dev/null || return 0
-		config_get phy "$1" phy
-	}
-	[ "$phy" = "$dev" ] && found=1
-}
-
-detect_mac80211() {
-	devidx=0
-	config_load wireless
-	while :; do
-		config_get type "radio$devidx" type
-		[ -n "$type" ] || break
-		devidx=$(($devidx + 1))
-	done
-	for dev in $(ls /sys/class/ieee80211); do
-		found=0
-		config_foreach check_mac80211_device wifi-device
-		[ "$found" -gt 0 ] && continue
-
-		mode_11n=""
-		mode_band="g"
-		channel="11"
-		ht_cap=0
-		for cap in $(iw phy "$dev" info | grep 'Capabilities:' | cut -d: -f2); do
-			ht_cap="$(($ht_cap | $cap))"
-		done
-		ht_capab="";
-		[ "$ht_cap" -gt 0 ] && {
-			mode_11n="n"
-			append ht_capab "	option htmode	HT20" "$N"
-
-			list="	list ht_capab"
-			[ "$(($ht_cap & 1))" -eq 1 ] && append ht_capab "$list	LDPC" "$N"
-			[ "$(($ht_cap & 16))" -eq 16 ] && append ht_capab "$list	GF" "$N"
-			[ "$(($ht_cap & 32))" -eq 32 ] && append ht_capab "$list	SHORT-GI-20" "$N"
-			[ "$(($ht_cap & 64))" -eq 64 ] && append ht_capab "$list	SHORT-GI-40" "$N"
-			[ "$(($ht_cap & 128))" -eq 128 ] && append ht_capab "$list	TX-STBC" "$N"
-			[ "$(($ht_cap & 768))" -eq 256 ] && append ht_capab "$list	RX-STBC1" "$N"
-			[ "$(($ht_cap & 768))" -eq 512 ] && append ht_capab "$list	RX-STBC12" "$N"
-			[ "$(($ht_cap & 768))" -eq 768 ] && append ht_capab "$list	RX-STBC123" "$N"
-			[ "$(($ht_cap & 4096))" -eq 4096 ] && append ht_capab "$list	DSSS_CCK-40" "$N"
-		}
-		iw phy "$dev" info | grep -q '2412 MHz' || { mode_band="a"; channel="36"; }
-
-		if [ -x /usr/bin/readlink ]; then
-			path="$(readlink -f /sys/class/ieee80211/${dev}/device)"
-			path="${path##/sys/devices/}"
-			dev_id="	option path	'$path'"
-		else
-			dev_id="	option macaddr	$(cat /sys/class/ieee80211/${dev}/macaddress)"
-		fi
-
-		cat <<EOF
-config wifi-device  radio$devidx
-	option type     mac80211
-	option channel  ${channel}
-	option hwmode	11${mode_11n}${mode_band}
-$dev_id
-$ht_capab
-	# REMOVE THIS LINE TO ENABLE WIFI:
-	option disabled 1
-
-config wifi-iface
-	option device   radio$devidx
-	option network  lan
-	option mode     ap
-	option ssid     OpenWrt
-	option encryption none
-
-EOF
-	devidx=$(($devidx + 1))
-	done
-}
-
diff --git a/package/mac80211/files/regdb.txt b/package/mac80211/files/regdb.txt
deleted file mode 100644
index 2badb21..0000000
--- a/package/mac80211/files/regdb.txt
+++ /dev/null
@@ -1,823 +0,0 @@
-# This is the world regulatory domain
-country 00:
-	(2402 - 2472 @ 40), (3, 20)
-	# Channel 12 - 13.
-	(2457 - 2482 @ 40), (3, 20), PASSIVE-SCAN, NO-IBSS
-	# Channel 14. Only JP enables this and for 802.11b only
-	(2474 - 2494 @ 20), (3, 20), PASSIVE-SCAN, NO-IBSS, NO-OFDM
-	# Channel 36 - 48
-	(5170 - 5250 @ 80), (3, 20)
-	# NB: 5260 MHz - 5700 MHz requies DFS
-	# Channel 149 - 165
-	(5735 - 5835 @ 80), (3, 20), PASSIVE-SCAN, NO-IBSS
-	# IEEE 802.11ad (60GHz), channels 1..3
-	(57240 - 63720 @ 2160), (N/A, 0)
-
-
-country AD:
-	# 60 gHz band channels 1-4, ref: Etsi En 302 567
-	(57240 - 65880 @ 2160), (N/A, 40), NO-OUTDOOR
-
-country AE:
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 80), (3, 17)
-	(5250 - 5330 @ 80), (3, 24), DFS
-	(5490 - 5710 @ 80), (3, 24), DFS
-	(5735 - 5835 @ 80), (3, 30)
-
-country AL:
-	(2402 - 2482 @ 20), (N/A, 20)
-
-country AM:
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 20), (N/A, 18)
-	(5250 - 5330 @ 20), (N/A, 18), DFS
-
-country AN:
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 40), (N/A, 20)
-	(5250 - 5330 @ 40), (N/A, 20), DFS
-	(5490 - 5710 @ 40), (N/A, 27), DFS
-
-country AR:
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 80), (3, 17)
-	(5250 - 5330 @ 80), (3, 24), DFS
-	(5490 - 5710 @ 80), (3, 24), DFS
-	(5735 - 5835 @ 80), (3, 30)
-
-country AT: DFS-ETSI
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 80), (N/A, 20)
-	(5250 - 5330 @ 80), (N/A, 20), DFS
-	(5490 - 5710 @ 80), (N/A, 27), DFS
-	# 60 gHz band channels 1-4, ref: Etsi En 302 567
-	(57240 - 65880 @ 2160), (N/A, 40), NO-OUTDOOR
-
-country AU:
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 80), (3, 17)
-	(5250 - 5330 @ 80), (3, 24), DFS
-	(5490 - 5710 @ 80), (3, 24), DFS
-	(5735 - 5835 @ 80), (3, 30)
-
-country AW:
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 40), (N/A, 20)
-	(5250 - 5330 @ 40), (N/A, 20), DFS
-	(5490 - 5710 @ 40), (N/A, 27), DFS
-
-country AZ:
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 40), (N/A, 18)
-	(5250 - 5330 @ 40), (N/A, 18), DFS
-
-country BA: DFS-ETSI
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 40), (N/A, 20)
-	(5250 - 5330 @ 40), (N/A, 20), DFS
-	(5490 - 5710 @ 40), (N/A, 27), DFS
-	# 60 gHz band channels 1-4, ref: Etsi En 302 567
-	(57240 - 65880 @ 2160), (N/A, 40), NO-OUTDOOR
-
-country BB:
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 40), (3, 23)
-	(5250 - 5330 @ 40), (3, 23), DFS
-	(5735 - 5835 @ 40), (3, 30)
-
-country BD:
-	(2402 - 2482 @ 40), (N/A, 20)
-
-country BE: DFS-ETSI
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 80), (N/A, 20)
-	(5250 - 5330 @ 80), (N/A, 20), DFS
-	(5490 - 5710 @ 80), (N/A, 27), DFS
-	# 60 gHz band channels 1-4, ref: Etsi En 302 567
-	(57240 - 65880 @ 2160), (N/A, 40), NO-OUTDOOR
-
-country BG: DFS-ETSI
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 40), (N/A, 23)
-	(5250 - 5290 @ 40), (N/A, 23), DFS
-	(5490 - 5710 @ 40), (N/A, 30), DFS
-	# 60 gHz band channels 1-4, ref: Etsi En 302 567
-	(57240 - 65880 @ 2160), (N/A, 40), NO-OUTDOOR
-
-country BH:
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 20), (N/A, 20)
-	(5250 - 5330 @ 20), (N/A, 20), DFS
-	(5735 - 5835 @ 20), (N/A, 20)
-
-country BL:
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 40), (N/A, 18)
-	(5250 - 5330 @ 40), (N/A, 18), DFS
-
-country BN:
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 40), (N/A, 20)
-	(5250 - 5330 @ 40), (N/A, 20), DFS
-	(5735 - 5835 @ 40), (N/A, 30)
-
-country BO:
-	(2402 - 2482 @ 40), (N/A, 30)
-	(5735 - 5835 @ 40), (N/A, 30)
-
-country BR:
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 80), (3, 17)
-	(5250 - 5330 @ 80), (3, 24), DFS
-	(5490 - 5710 @ 80), (3, 24), DFS
-	(5735 - 5835 @ 80), (3, 30)
-
-country BY:
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 40), (N/A, 20)
-	(5250 - 5330 @ 40), (N/A, 20), DFS
-	(5490 - 5710 @ 40), (N/A, 27), DFS
-
-country BZ:
-	(2402 - 2482 @ 40), (N/A, 30)
-	(5735 - 5835 @ 40), (N/A, 30)
-
-country CA:
-	(2402 - 2472 @ 40), (3, 27)
-	(5170 - 5250 @ 80), (3, 17)
-	(5250 - 5330 @ 80), (3, 24), DFS
-	(5490 - 5710 @ 80), (3, 24), DFS
-	(5735 - 5835 @ 80), (3, 30)
-
-country CH: DFS-ETSI
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 80), (N/A, 20)
-	(5250 - 5330 @ 80), (N/A, 20), DFS
-	(5490 - 5710 @ 80), (N/A, 27), DFS
-	# 60 gHz band channels 1-4, ref: Etsi En 302 567
-	(57240 - 65880 @ 2160), (N/A, 40), NO-OUTDOOR
-
-country CL:
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 40), (N/A, 20)
-	(5250 - 5330 @ 40), (N/A, 20), DFS
-	(5735 - 5835 @ 40), (N/A, 20)
-
-country CN:
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5735 - 5835 @ 80), (N/A, 30)
-	# 60 gHz band channels 1,4: 28dBm, channels 2,3: 44dBm
-	# ref: http://www.miit.gov.cn/n11293472/n11505629/n11506593/n11960250/n11960606/n11960700/n12330791.files/n12330790.pdf
-	(57240 - 59400 @ 2160), (N/A, 28)
-	(59400 - 63720 @ 2160), (N/A, 44)
-	(63720 - 65880 @ 2160), (N/A, 28)
-
-country CO:
-	(2402 - 2472 @ 40), (3, 27)
-	(5170 - 5250 @ 80), (3, 17)
-	(5250 - 5330 @ 80), (3, 24), DFS
-	(5490 - 5710 @ 80), (3, 24), DFS
-	(5735 - 5835 @ 80), (3, 30)
-
-country CR:
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 80), (3, 17)
-	(5250 - 5330 @ 80), (3, 24), DFS
-	(5490 - 5710 @ 80), (3, 24), DFS
-	(5735 - 5835 @ 80), (3, 30)
-
-country CY: DFS-ETSI
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 40), (N/A, 20)
-	(5250 - 5330 @ 40), (N/A, 20), DFS
-	(5490 - 5710 @ 40), (N/A, 27), DFS
-	# 60 gHz band channels 1-4, ref: Etsi En 302 567
-	(57240 - 65880 @ 2160), (N/A, 40), NO-OUTDOOR
-
-# Data from http://www.ctu.eu/164/download/VOR/VOR-12-08-2005-34.pdf
-# and http://www.ctu.eu/164/download/VOR/VOR-12-05-2007-6-AN.pdf
-# Power at 5250 - 5350 MHz and 5470 - 5725 MHz can be doubled if TPC is
-# implemented.
-country CZ: DFS-ETSI
-	(2400 - 2483.5 @ 40), (N/A, 100 mW)
-	(5150 - 5250 @ 80), (N/A, 200 mW), NO-OUTDOOR
-	(5250 - 5350 @ 80), (N/A, 100 mW), NO-OUTDOOR, DFS
-	(5470 - 5725 @ 80), (N/A, 500 mW), DFS
-	# 60 gHz band channels 1-4, ref: Etsi En 302 567
-	(57240 - 65880 @ 2160), (N/A, 40), NO-OUTDOOR
-
-# Data from "Frequenznutzungsplan" (as published in April 2008), downloaded from
-# http://www.bundesnetzagentur.de/cae/servlet/contentblob/38448/publicationFile/2659/Frequenznutzungsplan2008_Id17448pdf.pdf
-# For the 5GHz range also see
-# http://www.bundesnetzagentur.de/cae/servlet/contentblob/38216/publicationFile/6579/WLAN5GHzVfg7_2010_28042010pdf.pdf
-# The values have been reduced by a factor of 2 (3db) for non TPC devices
-# (in other words: devices with TPC can use twice the tx power of this table).
-# Note that the docs do not require TPC for 5150--5250; the reduction to
-# 100mW thus is not strictly required -- however the conservative 100mW
-# limit is used here as the non-interference with radar and satellite
-# apps relies on the attenuation by the building walls only in the
-# absence of DFS; the neighbour countries have 100mW limit here as well.
-
-country DE: DFS-ETSI
-	# entries 279004 and 280006
-	(2400 - 2483.5 @ 40), (N/A, 100 mW)
-	# entry 303005
-	(5150 - 5250 @ 80), (N/A, 100 mW), NO-OUTDOOR
-	# entries 304002 and 305002
-	(5250 - 5350 @ 80), (N/A, 100 mW), NO-OUTDOOR, DFS
-	# entries 308002, 309001 and 310003
-	(5470 - 5725 @ 80), (N/A, 500 mW), DFS
-	# 60 gHz band channels 1-4, ref: Etsi En 302 567
-	(57240 - 65880 @ 2160), (N/A, 40), NO-OUTDOOR
-
-country DK: DFS-ETSI
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 80), (N/A, 20)
-	(5250 - 5330 @ 80), (N/A, 20), DFS
-	(5490 - 5710 @ 80), (N/A, 27), DFS
-	# 60 gHz band channels 1-4, ref: Etsi En 302 567
-	(57240 - 65880 @ 2160), (N/A, 40), NO-OUTDOOR
-
-country DO:
-	(2402 - 2472 @ 40), (3, 27)
-	(5170 - 5250 @ 40), (3, 17)
-	(5250 - 5330 @ 40), (3, 23), DFS
-	(5735 - 5835 @ 40), (3, 30)
-
-country DZ:
-	(2402 - 2482 @ 40), (N/A, 20)
-
-country EC:
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 80), (3, 17)
-	(5250 - 5330 @ 80), (3, 24), DFS
-	(5490 - 5710 @ 80), (3, 24), DFS
-	(5735 - 5835 @ 80), (3, 30)
-
-country EE: DFS-ETSI
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 40), (N/A, 20)
-	(5250 - 5330 @ 40), (N/A, 20), DFS
-	(5490 - 5710 @ 40), (N/A, 27), DFS
-	# 60 gHz band channels 1-4, ref: Etsi En 302 567
-	(57240 - 65880 @ 2160), (N/A, 40), NO-OUTDOOR
-
-country EG:
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 20), (N/A, 20)
-	(5250 - 5330 @ 20), (N/A, 20), DFS
-
-country ES: DFS-ETSI
-	(2400 - 2483.5 @ 40), (N/A, 100 mW)
-	(5150 - 5250 @ 80), (N/A, 100 mW), NO-OUTDOOR
-	(5250 - 5350 @ 80), (N/A, 100 mW), NO-OUTDOOR, DFS
-	(5470 - 5725 @ 80), (N/A, 500 mW), DFS
-	# 60 gHz band channels 1-4, ref: Etsi En 302 567
-	(57240 - 65880 @ 2160), (N/A, 40), NO-OUTDOOR
-
-country FI: DFS-ETSI
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 80), (N/A, 20)
-	(5250 - 5330 @ 80), (N/A, 20), DFS
-	(5490 - 5710 @ 80), (N/A, 27), DFS
-	# 60 gHz band channels 1-4, ref: Etsi En 302 567
-	(57240 - 65880 @ 2160), (N/A, 40), NO-OUTDOOR
-
-country FR: DFS-ETSI
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 80), (N/A, 20)
-	(5250 - 5330 @ 80), (N/A, 20), DFS
-	(5490 - 5710 @ 80), (N/A, 27), DFS
-	# 60 gHz band channels 1-4, ref: Etsi En 302 567
-	(57240 - 65880 @ 2160), (N/A, 40), NO-OUTDOOR
-
-country GE:
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 40), (N/A, 18)
-	(5250 - 5330 @ 40), (N/A, 18), DFS
-	# 60 gHz band channels 1-4, ref: Etsi En 302 567
-	(57240 - 65880 @ 2160), (N/A, 40), NO-OUTDOOR
-
-country GB: DFS-ETSI
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 80), (N/A, 20)
-	(5250 - 5330 @ 80), (N/A, 20), DFS
-	(5490 - 5710 @ 80), (N/A, 27), DFS
-	# 60 gHz band channels 1-4, ref: Etsi En 302 567
-	(57240 - 65880 @ 2160), (N/A, 40), NO-OUTDOOR
-
-country GD:
-	(2402 - 2472 @ 40), (3, 27)
-	(5170 - 5250 @ 40), (3, 17)
-	(5250 - 5330 @ 40), (3, 20), DFS
-	(5490 - 5710 @ 40), (3, 20), DFS
-	(5735 - 5835 @ 40), (3, 30)
-
-country GR: DFS-ETSI
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 80), (N/A, 20)
-	(5250 - 5330 @ 80), (N/A, 20), DFS
-	(5490 - 5710 @ 80), (N/A, 27), DFS
-	# 60 gHz band channels 1-4, ref: Etsi En 302 567
-	(57240 - 65880 @ 2160), (N/A, 40), NO-OUTDOOR
-
-country GL: DFS-ETSI
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 20), (N/A, 20)
-	(5250 - 5330 @ 20), (N/A, 20), DFS
-	(5490 - 5710 @ 20), (N/A, 27), DFS
-
-country GT:
-	(2402 - 2472 @ 40), (3, 27)
-	(5170 - 5250 @ 40), (3, 17)
-	(5250 - 5330 @ 40), (3, 23), DFS
-	(5735 - 5835 @ 40), (3, 30)
-
-country GU:
-	(2402 - 2472 @ 40), (3, 27)
-	(5170 - 5250 @ 80), (3, 17)
-	(5250 - 5330 @ 80), (3, 24), DFS
-	(5490 - 5710 @ 80), (3, 24), DFS
-	(5735 - 5835 @ 80), (3, 30)
-
-country HN:
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 40), (3, 17)
-	(5250 - 5330 @ 40), (3, 20), DFS
-	(5490 - 5710 @ 40), (3, 20), DFS
-	(5735 - 5835 @ 40), (3, 30)
-
-country HK:
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 80), (3, 17)
-	(5250 - 5330 @ 80), (3, 24), DFS
-	(5490 - 5710 @ 80), (3, 24), DFS
-	(5735 - 5835 @ 80), (3, 30)
-
-country HR: DFS-ETSI
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 40), (N/A, 20)
-	(5250 - 5330 @ 40), (N/A, 20), DFS
-	(5490 - 5710 @ 40), (N/A, 27), DFS
-	# 60 gHz band channels 1-4, ref: Etsi En 302 567
-	(57240 - 65880 @ 2160), (N/A, 40), NO-OUTDOOR
-
-country HT:
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 40), (N/A, 20)
-	(5250 - 5330 @ 40), (N/A, 20), DFS
-	(5490 - 5710 @ 40), (N/A, 27), DFS
-
-country HU: DFS-ETSI
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 40), (N/A, 20)
-	(5250 - 5330 @ 40), (N/A, 20), DFS
-	(5490 - 5710 @ 40), (N/A, 27), DFS
-	# 60 gHz band channels 1-4, ref: Etsi En 302 567
-	(57240 - 65880 @ 2160), (N/A, 40), NO-OUTDOOR
-
-country ID:
-	# ref: http://www.postel.go.id/content/ID/regulasi/standardisasi/kepdir/bwa%205,8%20ghz.pdf
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5735 - 5815 @ 80), (N/A, 20)
-
-country IE: DFS-ETSI
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 80), (N/A, 20)
-	(5250 - 5330 @ 80), (N/A, 20), DFS
-	(5490 - 5710 @ 80), (N/A, 27), DFS
-	# 60 gHz band channels 1-4, ref: Etsi En 302 567
-	(57240 - 65880 @ 2160), (N/A, 40), NO-OUTDOOR
-
-country IL:
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5150 - 5250 @ 80), (N/A, 200 mW), NO-OUTDOOR
-	(5250 - 5350 @ 80), (N/A, 200 mW), NO-OUTDOOR, DFS
-
-country IN:
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 40), (N/A, 20)
-	(5250 - 5330 @ 40), (N/A, 20), DFS
-	(5735 - 5835 @ 40), (N/A, 20)
-
-country IS: DFS-ETSI
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 40), (N/A, 20)
-	(5250 - 5330 @ 40), (N/A, 20), DFS
-	(5490 - 5710 @ 40), (N/A, 27), DFS
-	# 60 gHz band channels 1-4, ref: Etsi En 302 567
-	(57240 - 65880 @ 2160), (N/A, 40), NO-OUTDOOR
-
-country IR:
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5735 - 5835 @ 40), (N/A, 30)
-
-country IT: DFS-ETSI
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 80), (N/A, 20)
-	(5250 - 5330 @ 80), (N/A, 20), DFS
-	(5490 - 5710 @ 80), (N/A, 27), DFS
-	# 60 gHz band channels 1-4, ref: Etsi En 302 567
-	(57240 - 65880 @ 2160), (N/A, 40), NO-OUTDOOR
-
-country JM:
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 40), (3, 17)
-	(5250 - 5330 @ 40), (3, 20), DFS
-	(5490 - 5710 @ 40), (3, 20), DFS
-	(5735 - 5835 @ 40), (3, 30)
-
-country JP:
-	(2402 - 2482 @ 40), (N/A, 20)
-	(2474 - 2494 @ 20), (N/A, 20), NO-OFDM
-	(4910 - 4990 @ 40), (N/A, 23)
-	(5030 - 5090 @ 40), (N/A, 23)
-	(5170 - 5250 @ 80), (N/A, 20)
-	(5250 - 5330 @ 80), (N/A, 20), DFS
-	(5490 - 5710 @ 160), (N/A, 23), DFS
-
-country JO:
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 40), (N/A, 18)
-
-country KE:
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5735 - 5835 @ 40), (N/A, 30)
-
-country KH:
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 40), (N/A, 20)
-	(5250 - 5330 @ 40), (N/A, 20), DFS
-	(5490 - 5710 @ 40), (N/A, 27), DFS
-
-country KP:
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5330 @ 40), (3, 20)
-	(5160 - 5250 @ 40), (3, 20), DFS
-	(5490 - 5630 @ 40), (3, 30), DFS
-	(5735 - 5815 @ 40), (3, 30)
-
-country KR:
-	(2402 - 2482 @ 20), (N/A, 20)
-	(5170 - 5250 @ 80), (3, 20)
-	(5250 - 5330 @ 80), (3, 20), DFS
-	(5490 - 5630 @ 80), (3, 30), DFS
-	(5735 - 5815 @ 80), (3, 30)
-
-country KW:
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 80), (N/A, 20)
-	(5250 - 5330 @ 80), (N/A, 20), DFS
-
-country KZ:
-	(2402 - 2482 @ 40), (N/A, 20)
-
-country LB:
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5735 - 5835 @ 40), (N/A, 30)
-
-country LI: DFS-ETSI
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 40), (N/A, 20)
-	(5250 - 5330 @ 40), (N/A, 20), DFS
-	(5490 - 5710 @ 40), (N/A, 27), DFS
-
-country LK:
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 20), (3, 17)
-	(5250 - 5330 @ 20), (3, 20), DFS
-	(5490 - 5710 @ 20), (3, 20), DFS
-	(5735 - 5835 @ 20), (3, 30)
-
-country LT: DFS-ETSI
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 40), (N/A, 20)
-	(5250 - 5330 @ 40), (N/A, 20), DFS
-	(5490 - 5710 @ 40), (N/A, 27), DFS
-	# 60 gHz band channels 1-4, ref: Etsi En 302 567
-	(57240 - 65880 @ 2160), (N/A, 40), NO-OUTDOOR
-
-country LU: DFS-ETSI
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 80), (N/A, 20)
-	(5250 - 5330 @ 80), (N/A, 20), DFS
-	(5490 - 5710 @ 80), (N/A, 27), DFS
-	# 60 gHz band channels 1-4, ref: Etsi En 302 567
-	(57240 - 65880 @ 2160), (N/A, 40), NO-OUTDOOR
-
-country LV: DFS-ETSI
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 40), (N/A, 20)
-	(5250 - 5330 @ 40), (N/A, 20), DFS
-	(5490 - 5710 @ 40), (N/A, 27), DFS
-	# 60 gHz band channels 1-4, ref: Etsi En 302 567
-	(57240 - 65880 @ 2160), (N/A, 40), NO-OUTDOOR
-
-country MC: DFS-ETSI
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 40), (N/A, 18)
-	(5250 - 5330 @ 40), (N/A, 18), DFS
-
-country MA:
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 80), (N/A, 23)
-	(5735 - 5835 @ 80), (N/A, 23)
-
-country MO:
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 40), (3, 23)
-	(5250 - 5330 @ 40), (3, 23), DFS
-	(5735 - 5835 @ 40), (3, 30)
-
-country MK: DFS-ETSI
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 40), (N/A, 20)
-	(5250 - 5330 @ 40), (N/A, 20), DFS
-	(5490 - 5710 @ 40), (N/A, 27), DFS
-	# 60 gHz band channels 1-4, ref: Etsi En 302 567
-	(57240 - 65880 @ 2160), (N/A, 40), NO-OUTDOOR
-
-country MT: DFS-ETSI
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 40), (N/A, 20)
-	(5250 - 5330 @ 40), (N/A, 20), DFS
-	(5490 - 5710 @ 40), (N/A, 27), DFS
-	# 60 gHz band channels 1-4, ref: Etsi En 302 567
-	(57240 - 65880 @ 2160), (N/A, 40), NO-OUTDOOR
-
-country MY:
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 80), (N/A, 17)
-	(5250 - 5330 @ 80), (N/A, 23), DFS
-	(5735 - 5835 @ 80), (N/A, 30)
-
-country MX:
-	(2402 - 2472 @ 40), (3, 27)
-	(5170 - 5250 @ 80), (3, 17)
-	(5250 - 5330 @ 80), (3, 24), DFS
-	(5490 - 5710 @ 80), (3, 24), DFS
-	(5735 - 5835 @ 80), (3, 30)
-
-country NL: DFS-ETSI
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 80), (N/A, 20), NO-OUTDOOR
-	(5250 - 5330 @ 80), (N/A, 20), NO-OUTDOOR, DFS
-	(5490 - 5710 @ 80), (N/A, 27), DFS
-	# 60 gHz band channels 1-4, ref: Etsi En 302 567
-	(57240 - 65880 @ 2160), (N/A, 40), NO-OUTDOOR
-
-country NO: DFS-ETSI
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 40), (N/A, 20)
-	(5250 - 5330 @ 40), (N/A, 20), DFS
-	(5490 - 5710 @ 40), (N/A, 27), DFS
-	# 60 gHz band channels 1-4, ref: Etsi En 302 567
-	(57240 - 65880 @ 2160), (N/A, 40), NO-OUTDOOR
-
-country NP:
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5735 - 5835 @ 40), (N/A, 30)
-
-country NZ:
-	(2402 - 2482 @ 40), (N/A, 30)
-	(5170 - 5250 @ 80), (3, 17)
-	(5250 - 5330 @ 80), (3, 24), DFS
-	(5490 - 5710 @ 80), (3, 24), DFS
-	(5735 - 5835 @ 80), (3, 30)
-
-country OM:
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 40), (3, 17)
-	(5250 - 5330 @ 40), (3, 20), DFS
-	(5490 - 5710 @ 40), (3, 20), DFS
-	(5735 - 5835 @ 40), (3, 30)
-
-country PA:
-	(2402 - 2472 @ 40), (3, 27)
-	(5170 - 5250 @ 40), (3, 17)
-	(5250 - 5330 @ 40), (3, 23), DFS
-	(5735 - 5835 @ 40), (3, 30)
-
-country PE:
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 80), (3, 17)
-	(5250 - 5330 @ 80), (3, 24), DFS
-	(5490 - 5710 @ 80), (3, 24), DFS
-	(5735 - 5835 @ 80), (3, 30)
-
-country PG:
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 40), (3, 17)
-	(5250 - 5330 @ 40), (3, 23), DFS
-	(5735 - 5835 @ 40), (3, 30)
-
-country PH:
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 80), (3, 17)
-	(5250 - 5330 @ 80), (3, 24), DFS
-	(5490 - 5710 @ 80), (3, 24), DFS
-	(5735 - 5835 @ 80), (3, 30)
-
-country PK:
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5735 - 5835 @ 40), (N/A, 30)
-
-country PL: DFS-ETSI
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 80), (N/A, 20)
-	(5250 - 5330 @ 80), (N/A, 20), DFS
-	(5490 - 5710 @ 80), (N/A, 27), DFS
-	# 60 gHz band channels 1-4, ref: Etsi En 302 567
-	(57240 - 65880 @ 2160), (N/A, 40), NO-OUTDOOR
-
-country PT: DFS-ETSI
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 80), (N/A, 20)
-	(5250 - 5330 @ 80), (N/A, 20), DFS
-	(5490 - 5710 @ 80), (N/A, 27), DFS
-	# 60 gHz band channels 1-4, ref: Etsi En 302 567
-	(57240 - 65880 @ 2160), (N/A, 40), NO-OUTDOOR
-
-country PR:
-	(2402 - 2472 @ 40), (3, 27)
-	(5170 - 5250 @ 80), (3, 17)
-	(5250 - 5330 @ 80), (3, 24), DFS
-	(5490 - 5710 @ 80), (3, 24), DFS
-	(5735 - 5835 @ 80), (3, 30)
-
-country QA:
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5735 - 5835 @ 40), (N/A, 30)
-
-country RO: DFS-ETSI
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 40), (N/A, 20)
-	(5250 - 5330 @ 40), (N/A, 20), DFS
-	(5490 - 5710 @ 40), (N/A, 27), DFS
-	# 60 gHz band channels 1-4, ref: Etsi En 302 567
-	(57240 - 65880 @ 2160), (N/A, 40), NO-OUTDOOR
-
-
-# Source:
-# http://www.ratel.rs/upload/documents/Plan_namene/Plan_namene-sl_glasnik.pdf
-country RS:
-	(2400 - 2483.5 @ 40), (N/A, 100 mW)
-	(5150 - 5350 @ 40), (N/A, 200 mW), NO-OUTDOOR
-	(5470 - 5725 @ 20), (3, 1000 mW), DFS
-	# 60 gHz band channels 1-4, ref: Etsi En 302 567
-	(57240 - 65880 @ 2160), (N/A, 40), NO-OUTDOOR
-
-country RU:
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5330 @ 40), (N/A, 20)
-	(5650 - 5710 @ 40), (N/A, 30)
-	(5735 - 5835 @ 40), (N/A, 30)
-
-country RW:
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5735 - 5835 @ 40), (N/A, 30)
-
-country SA:
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 80), (3, 17)
-	(5250 - 5330 @ 80), (3, 24), DFS
-	(5490 - 5710 @ 80), (3, 24), DFS
-	(5735 - 5835 @ 80), (3, 30)
-
-country SE: DFS-ETSI
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 80), (N/A, 20)
-	(5250 - 5330 @ 80), (N/A, 20), DFS
-	(5490 - 5710 @ 80), (N/A, 27), DFS
-	# 60 gHz band channels 1-4, ref: Etsi En 302 567
-	(57240 - 65880 @ 2160), (N/A, 40), NO-OUTDOOR
-
-country SG:
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 80), (3, 17)
-	(5250 - 5330 @ 80), (3, 24), DFS
-	(5490 - 5710 @ 80), (3, 24), DFS
-	(5735 - 5835 @ 80), (3, 30)
-
-country SI: DFS-ETSI
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 40), (N/A, 20)
-	(5250 - 5330 @ 40), (N/A, 20), DFS
-	(5490 - 5710 @ 40), (N/A, 27), DFS
-	# 60 gHz band channels 1-4, ref: Etsi En 302 567
-	(57240 - 65880 @ 2160), (N/A, 40), NO-OUTDOOR
-
-country SK: DFS-ETSI
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 80), (N/A, 20)
-	(5250 - 5330 @ 80), (N/A, 20), DFS
-	(5490 - 5710 @ 80), (N/A, 27), DFS
-	# 60 gHz band channels 1-4, ref: Etsi En 302 567
-	(57240 - 65880 @ 2160), (N/A, 40), NO-OUTDOOR
-
-country SV:
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 20), (3, 17)
-	(5250 - 5330 @ 20), (3, 23), DFS
-	(5735 - 5835 @ 20), (3, 30)
-
-country SY:
-	(2402 - 2482 @ 40), (N/A, 20)
-
-country TW:
-	(2402 - 2472 @ 40), (3, 27)
-	(5270 - 5330 @ 40), (3, 17), DFS
-	(5490 - 5710 @ 80), (3, 30), DFS
-	(5735 - 5815 @ 80), (3, 30)
-
-country TH:
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 80), (3, 17)
-	(5250 - 5330 @ 80), (3, 24), DFS
-	(5490 - 5710 @ 80), (3, 24), DFS
-	(5735 - 5835 @ 80), (3, 30)
-
-country TT:
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 40), (3, 17)
-	(5250 - 5330 @ 40), (3, 20), DFS
-	(5490 - 5710 @ 40), (3, 20), DFS
-	(5735 - 5835 @ 40), (3, 30)
-
-country TN:
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 20), (N/A, 20)
-	(5250 - 5330 @ 20), (N/A, 20), DFS
-
-country TR: DFS-ETSI
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 80), (N/A, 20)
-	(5250 - 5330 @ 80), (N/A, 20), DFS
-	(5490 - 5710 @ 80), (N/A, 27), DFS
-	# 60 gHz band channels 1-4, ref: Etsi En 302 567
-	(57240 - 65880 @ 2160), (N/A, 40), NO-OUTDOOR
- 
-# Source:
-# #914 / 06 Sep 2007: http://www.ucrf.gov.ua/uk/doc/nkrz/1196068874
-# #1174 / 23 Oct 2008: http://www.nkrz.gov.ua/uk/activities/ruling/1225269361
-# (appendix 8)
-# Listed 5GHz range is a lowest common denominator for all related
-# rules in the referenced laws. Such a range is used because of
-# disputable definitions there.
-country UA:
-	(2400 - 2483.5 @ 40), (N/A, 20), NO-OUTDOOR
-	(5150 - 5350 @ 40), (N/A, 20), NO-OUTDOOR
-	# 60 gHz band channels 1-4, ref: Etsi En 302 567
-	(57240 - 65880 @ 2160), (N/A, 40), NO-OUTDOOR
-
-country US: DFS-FCC
-	(2402 - 2472 @ 40), (3, 27)
-	(5170 - 5250 @ 80), (3, 17)
-	(5250 - 5330 @ 80), (3, 24), DFS
-	(5490 - 5600 @ 80), (3, 24), DFS
-	(5650 - 5710 @ 40), (3, 24), DFS
-	(5735 - 5835 @ 80), (3, 30)
-	# 60g band
-	# reference: http://cfr.regstoday.com/47cfr15.aspx#47_CFR_15p255
-	# channels 1,2,3, EIRP=40dBm(43dBm peak)
-	(57240 - 63720 @ 2160), (N/A, 40)
-
-country UY:
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 40), (3, 17)
-	(5250 - 5330 @ 40), (3, 20), DFS
-	(5490 - 5710 @ 40), (3, 20), DFS
-	(5735 - 5835 @ 40), (3, 30)
-
-country UZ:
-	(2402 - 2472 @ 40), (3, 27)
-	(5170 - 5250 @ 40), (3, 17)
-	(5250 - 5330 @ 40), (3, 20), DFS
-	(5490 - 5710 @ 40), (3, 20), DFS
-	(5735 - 5835 @ 40), (3, 30)
-
-country VE:
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5735 - 5815 @ 40), (N/A, 23)
-
-country VN:
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 80), (3, 17)
-	(5250 - 5330 @ 80), (3, 24), DFS
-	(5490 - 5710 @ 80), (3, 24), DFS
-	(5735 - 5835 @ 80), (3, 30)
-
-country YE:
-	(2402 - 2482 @ 40), (N/A, 20)
-
-country ZA:
-	(2402 - 2482 @ 40), (N/A, 20)
-	(5170 - 5250 @ 80), (3, 17)
-	(5250 - 5330 @ 80), (3, 24), DFS
-	(5490 - 5710 @ 80), (3, 24), DFS
-	(5735 - 5835 @ 80), (3, 30)
-
-country ZW:
-	(2402 - 2482 @ 40), (N/A, 20)
-
diff --git a/package/mac80211/patches/000-fix_kconfig.patch b/package/mac80211/patches/000-fix_kconfig.patch
deleted file mode 100644
index 88d0b04..0000000
--- a/package/mac80211/patches/000-fix_kconfig.patch
+++ /dev/null
@@ -1,16 +0,0 @@
---- a/kconf/Makefile
-+++ b/kconf/Makefile
-@@ -1,10 +1,10 @@
--CFLAGS=-Wall -Wmissing-prototypes -Wstrict-prototypes -O2 -fomit-frame-pointer
-+CFLAGS=-Wall -Wmissing-prototypes -Wstrict-prototypes -O2 -fomit-frame-pointer -DKBUILD_NO_NLS
- 
- LXDIALOG := lxdialog/checklist.o lxdialog/inputbox.o lxdialog/menubox.o lxdialog/textbox.o lxdialog/util.o lxdialog/yesno.o
- 
- conf: conf.o zconf.tab.o
--mconf: LDFLAGS = -Wl,--no-as-needed $(shell ./lxdialog/check-lxdialog.sh -ldflags $(CC))
--mconf: CFLAGS += -DCURSES_LOC="<ncurses.h>" -DLOCALE
-+mconf: LDFLAGS = $(shell ./lxdialog/check-lxdialog.sh -ldflags $(CC))
-+mconf: CFLAGS += -DCURSES_LOC="<ncurses.h>"
- mconf: mconf.o zconf.tab.o $(LXDIALOG)
- 
- .PHONY: clean
diff --git a/package/mac80211/patches/001-fix_build.patch b/package/mac80211/patches/001-fix_build.patch
deleted file mode 100644
index 26b327a..0000000
--- a/package/mac80211/patches/001-fix_build.patch
+++ /dev/null
@@ -1,156 +0,0 @@
---- a/Makefile
-+++ b/Makefile
-@@ -19,6 +19,7 @@ KLIB_BUILD ?= $(KLIB)/build/
- KERNEL_CONFIG := $(KLIB_BUILD)/.config
- KERNEL_MAKEFILE := $(KLIB_BUILD)/Makefile
- CONFIG_MD5 := $(shell md5sum $(KERNEL_CONFIG) 2>/dev/null | sed 's/\s.*//')
-+STAMP_KERNEL_CONFIG := .kernel_config_md5_$(CONFIG_MD5)
- 
- export KLIB KLIB_BUILD BACKPORT_PWD KMODDIR KMODPATH_ARG
- 
-@@ -36,7 +37,8 @@ mrproper:
- 	@rm -f .kernel_config_md5 Kconfig.versions Kconfig.kernel
- 	@rm -f backport-include/backport/autoconf.h
- 
--.DEFAULT:
-+.SILENT: $(STAMP_KERNEL_CONFIG)
-+$(STAMP_KERNEL_CONFIG):
- 	@set -e ; test -f .local-symbols || (						\
- 	echo "/--------------"								;\
- 	echo "| You shouldn't run make in the backports tree, but only in"		;\
-@@ -60,56 +62,60 @@ mrproper:
- 	echo "| (that isn't currently running.)"					;\
- 	echo "\\--"									;\
- 	false)
--	@set -e ; if [ "$$(cat .kernel_config_md5 2>/dev/null)" != "$(CONFIG_MD5)" ]	;\
--	then 										\
--		echo -n "Generating local configuration database from kernel ..."	;\
--		grep -v -f .local-symbols $(KERNEL_CONFIG) | grep = | (			\
--			while read l ; do						\
--				if [ "$${l:0:7}" != "CONFIG_" ] ; then			\
--					continue					;\
--				fi							;\
--				l=$${l:7}						;\
--				n=$${l%%=*}						;\
--				v=$${l#*=}						;\
--				if [ "$$v" = "m" ] ; then				\
--					echo config $$n					;\
--					echo '    tristate' 				;\
--				elif [ "$$v" = "y" ] ; then				\
--					echo config $$n					;\
--					echo '    bool'					;\
--				else							\
--					continue					;\
--				fi							;\
--				echo "    default $$v"					;\
--				echo ""							;\
--			done								\
--		) > Kconfig.kernel							;\
--		kver=$$($(MAKE) --no-print-directory -C $(KLIB_BUILD) kernelversion |	\
--			sed 's/^\(\(3\|2\.6\)\.[0-9]\+\).*/\1/;t;d')			;\
--		test "$$kver" != "" || echo "Kernel version parse failed!"		;\
--		test "$$kver" != ""							;\
--		kvers="$$(seq 14 39 | sed 's/^/2.6./')"					;\
--		kvers="$$kvers $$(seq 0 99 | sed 's/^/3./')"				;\
--		print=0									;\
--		for v in $$kvers ; do							\
--			if [ "$$print" = "1" ] ; then					\
--				echo config BACKPORT_KERNEL_$$(echo $$v | tr . _)	;\
--				echo "    def_bool y"					;\
--			fi								;\
--			if [ "$$v" = "$$kver" ] ; then print=1 ; fi			;\
--		done > Kconfig.versions							;\
--		# RHEL as well, sadly we need to grep for it				;\
--		RHEL_MAJOR=$$(grep '^RHEL_MAJOR' $(KERNEL_MAKEFILE) | 			\
--					sed 's/.*=\s*\([0-9]*\)/\1/;t;d')		;\
--		RHEL_MINOR=$$(grep '^RHEL_MINOR' $(KERNEL_MAKEFILE) | 			\
--					sed 's/.*=\s*\([0-9]*\)/\1/;t;d')		;\
--		for v in $$(seq 0 $$RHEL_MINOR) ; do 					\
--			echo config BACKPORT_RHEL_KERNEL_$${RHEL_MAJOR}_$$v		;\
--			echo "    def_bool y"						;\
--		done >> Kconfig.versions						;\
--		echo " done."								;\
--	fi										;\
--	echo "$(CONFIG_MD5)" > .kernel_config_md5
-+	@rm -f .kernel_config_md5_*
-+	@touch $@
-+
-+Kconfig.kernel: $(STAMP_KERNEL_CONFIG) .local-symbols
-+	@printf "Generating local configuration database from kernel ..."
-+	@grep -v -f .local-symbols $(KERNEL_CONFIG) | grep = | (			\
-+		while read l ; do						\
-+			if [ "$${l:0:7}" != "CONFIG_" ] ; then			\
-+				continue					;\
-+			fi							;\
-+			l=$${l:7}						;\
-+			n=$${l%%=*}						;\
-+			v=$${l#*=}						;\
-+			if [ "$$v" = "m" ] ; then				\
-+				echo config $$n					;\
-+				echo '    tristate' 				;\
-+			elif [ "$$v" = "y" ] ; then				\
-+				echo config $$n					;\
-+				echo '    bool'					;\
-+			else							\
-+				continue					;\
-+			fi							;\
-+			echo "    default $$v"					;\
-+			echo ""							;\
-+		done								\
-+	) > $@
-+	@echo " done."
-+
-+Kconfig.versions: Kconfig.kernel
-+	@kver=$$($(MAKE) --no-print-directory -C $(KLIB_BUILD) kernelversion |	\
-+		sed 's/^\(\(3\|2\.6\)\.[0-9]\+\).*/\1/;t;d')			;\
-+	test "$$kver" != "" || echo "Kernel version parse failed!"		;\
-+	test "$$kver" != ""							;\
-+	kvers="$$(seq 14 39 | sed 's/^/2.6./')"					;\
-+	kvers="$$kvers $$(seq 0 99 | sed 's/^/3./')"				;\
-+	print=0									;\
-+	for v in $$kvers ; do							\
-+		if [ "$$print" = "1" ] ; then					\
-+			echo config BACKPORT_KERNEL_$$(echo $$v | tr . _)	;\
-+			echo "    def_bool y"					;\
-+		fi								;\
-+		if [ "$$v" = "$$kver" ] ; then print=1 ; fi			;\
-+	done > $@
-+	@RHEL_MAJOR=$$(grep '^RHEL_MAJOR' $(KERNEL_MAKEFILE) | 			\
-+				sed 's/.*=\s*\([0-9]*\)/\1/;t;d')		;\
-+	RHEL_MINOR=$$(grep '^RHEL_MINOR' $(KERNEL_MAKEFILE) | 			\
-+				sed 's/.*=\s*\([0-9]*\)/\1/;t;d')		;\
-+	for v in $$(seq 0 $$RHEL_MINOR) ; do 					\
-+		echo config BACKPORT_RHEL_KERNEL_$${RHEL_MAJOR}_$$v		;\
-+		echo "    def_bool y"						;\
-+	done >> $@
-+
-+.DEFAULT:
-+	@$(MAKE) Kconfig.versions
- 	@$(MAKE) -f Makefile.real "$@"
- 
- .PHONY: defconfig-help
---- a/Makefile.real
-+++ b/Makefile.real
-@@ -54,7 +54,7 @@ defconfig-%::
- 
- backport-include/backport/autoconf.h: .config Kconfig.versions Kconfig.kernel
- 	@$(MAKE) oldconfig
--	@echo -n "Building backport-include/backport/autoconf.h ..."
-+	@printf "Building backport-include/backport/autoconf.h ..."
- 	@grep -f .local-symbols .config | (				\
- 		echo "#ifndef COMPAT_AUTOCONF_INCLUDED"			;\
- 		echo "#define COMPAT_AUTOCONF_INCLUDED"			;\
-@@ -75,7 +75,12 @@ backport-include/backport/autoconf.h: .c
- 			esac						;\
- 		done							;\
- 		echo "#endif /* COMPAT_AUTOCONF_INCLUDED */"		;\
--	) > backport-include/backport/autoconf.h
-+	) > $@.new
-+	@if cmp -s $@ $@.new; then \
-+		rm -f $@.new; \
-+	else \
-+		mv $@.new $@; \
-+	fi
- 	@echo " done."
- 
- .PHONY: modules
diff --git a/package/mac80211/patches/002-change_allconfig.patch b/package/mac80211/patches/002-change_allconfig.patch
deleted file mode 100644
index 91ad20f..0000000
--- a/package/mac80211/patches/002-change_allconfig.patch
+++ /dev/null
@@ -1,44 +0,0 @@
---- a/kconf/conf.c
-+++ b/kconf/conf.c
-@@ -578,40 +578,12 @@ int main(int ac, char **av)
- 	case oldconfig:
- 	case listnewconfig:
- 	case olddefconfig:
--		conf_read(NULL);
--		break;
- 	case allnoconfig:
- 	case allyesconfig:
- 	case allmodconfig:
- 	case alldefconfig:
- 	case randconfig:
--		name = getenv("KCONFIG_ALLCONFIG");
--		if (!name)
--			break;
--		if ((strcmp(name, "") != 0) && (strcmp(name, "1") != 0)) {
--			if (conf_read_simple(name, S_DEF_USER)) {
--				fprintf(stderr,
--					_("*** Can't read seed configuration \"%s\"!\n"),
--					name);
--				exit(1);
--			}
--			break;
--		}
--		switch (input_mode) {
--		case allnoconfig:	name = "allno.config"; break;
--		case allyesconfig:	name = "allyes.config"; break;
--		case allmodconfig:	name = "allmod.config"; break;
--		case alldefconfig:	name = "alldef.config"; break;
--		case randconfig:	name = "allrandom.config"; break;
--		default: break;
--		}
--		if (conf_read_simple(name, S_DEF_USER) &&
--		    conf_read_simple("all.config", S_DEF_USER)) {
--			fprintf(stderr,
--				_("*** KCONFIG_ALLCONFIG set, but no \"%s\" or \"all.config\" file found\n"),
--				name);
--			exit(1);
--		}
-+		conf_read(NULL);
- 		break;
- 	default:
- 		break;
diff --git a/package/mac80211/patches/003-remove_bogus_modparams.patch b/package/mac80211/patches/003-remove_bogus_modparams.patch
deleted file mode 100644
index c969b19..0000000
--- a/package/mac80211/patches/003-remove_bogus_modparams.patch
+++ /dev/null
@@ -1,34 +0,0 @@
---- a/compat/main.c
-+++ b/compat/main.c
-@@ -21,31 +21,6 @@ MODULE_LICENSE("GPL");
- #error "You need a BACKPORTS_VERSION"
- #endif
- 
--static char *backported_kernel_name = BACKPORTED_KERNEL_NAME;
--
--module_param(backported_kernel_name, charp, 0400);
--MODULE_PARM_DESC(backported_kernel_name,
--		 "The kernel tree name that was used for this backport (" BACKPORTED_KERNEL_NAME ")");
--
--#ifdef BACKPORTS_GIT_TRACKED 
--static char *backports_tracker_id = BACKPORTS_GIT_TRACKED;
--module_param(backports_tracker_id, charp, 0400);
--MODULE_PARM_DESC(backports_tracker_id,
--		 "The version of the tree containing this backport (" BACKPORTS_GIT_TRACKED ")");
--#else
--static char *backported_kernel_version = BACKPORTED_KERNEL_VERSION;
--static char *backports_version = BACKPORTS_VERSION;
--
--module_param(backported_kernel_version, charp, 0400);
--MODULE_PARM_DESC(backported_kernel_version,
--		 "The kernel version that was used for this backport (" BACKPORTED_KERNEL_VERSION ")");
--
--module_param(backports_version, charp, 0400);
--MODULE_PARM_DESC(backports_version,
--		 "The git version of the backports tree used to generate this backport (" BACKPORTS_VERSION ")");
--
--#endif
--
- void backport_dependency_symbol(void)
- {
- }
diff --git a/package/mac80211/patches/004-backports-add-led_trigger_blink-_oneshot.patch b/package/mac80211/patches/004-backports-add-led_trigger_blink-_oneshot.patch
deleted file mode 100644
index 584fb05..0000000
--- a/package/mac80211/patches/004-backports-add-led_trigger_blink-_oneshot.patch
+++ /dev/null
@@ -1,40 +0,0 @@
-From 88e75363ff9c00cc2e7768ca23ded79bf8d6bf08 Mon Sep 17 00:00:00 2001
-From: Hauke Mehrtens <hauke@hauke-m.de>
-Date: Fri, 7 Feb 2014 19:13:11 +0100
-Subject: [PATCH 1/8] backports: add led_trigger_blink{_oneshot}()
-
-When led support is deactivated in the kernel and
-CPTCFG_BACKPORT_BUILD_LEDS is set mac80211 references
-led_trigger_blink_oneshot() but it is not declared anywhere.
-
-This fixes the following build error:
-net/mac80211/led.c: In function 'ieee80211_led_rx':
-net/mac80211/led.c:25:2: error: implicit declaration of function 'led_trigger_blink_oneshot' [-Werror=implicit-function-declaration]
-
-Signed-off-by: Hauke Mehrtens <hauke@hauke-m.de>
----
- backport-include/backport/leds-disabled.h |   13 +++++++++++++
- 1 file changed, 13 insertions(+)
-
---- a/backport-include/backport/leds-disabled.h
-+++ b/backport-include/backport/leds-disabled.h
-@@ -163,6 +163,19 @@ static inline void led_trigger_event(str
- 				     enum led_brightness event)
- {
- }
-+
-+static inline void led_trigger_blink(struct led_trigger *trigger,
-+				     unsigned long *delay_on,
-+				     unsigned long *delay_off)
-+{
-+}
-+
-+static inline void led_trigger_blink_oneshot(struct led_trigger *trigger,
-+					     unsigned long *delay_on,
-+					     unsigned long *delay_off,
-+					     int invert)
-+{
-+}
- #endif
- 
- #endif /* __BACKPORT_LED_DISABLED_SUPPORT */
diff --git a/package/mac80211/patches/010-disable_rfkill.patch b/package/mac80211/patches/010-disable_rfkill.patch
deleted file mode 100644
index c5a92d6..0000000
--- a/package/mac80211/patches/010-disable_rfkill.patch
+++ /dev/null
@@ -1,13 +0,0 @@
---- a/backport-include/linux/rfkill.h
-+++ b/backport-include/linux/rfkill.h
-@@ -2,6 +2,10 @@
- #define __COMPAT_RFKILL_H
- #include <linux/version.h>
- 
-+#undef CONFIG_RFKILL
-+#undef CONFIG_RFKILL_LEDS
-+#undef CONFIG_RFKILL_MODULE
-+
- #if LINUX_VERSION_CODE >= KERNEL_VERSION(3,10,0)
- #include_next <linux/rfkill.h>
- #else
diff --git a/package/mac80211/patches/020-disable_tty_set_termios.patch b/package/mac80211/patches/020-disable_tty_set_termios.patch
deleted file mode 100644
index e6d4ff6..0000000
--- a/package/mac80211/patches/020-disable_tty_set_termios.patch
+++ /dev/null
@@ -1,16 +0,0 @@
---- a/compat/compat-2.6.39.c
-+++ b/compat/compat-2.6.39.c
-@@ -13,6 +13,7 @@
- #include <linux/sched.h>
- #include <linux/module.h>
- 
-+#ifdef CONFIG_COMPAT_BLUETOOTH
- #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27))
- #ifdef CONFIG_TTY
- /*
-@@ -114,4 +115,4 @@ int tty_set_termios(struct tty_struct *t
- EXPORT_SYMBOL_GPL(tty_set_termios);
- #endif /* CONFIG_TTY */
- #endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27)) */
--
-+#endif
diff --git a/package/mac80211/patches/030-rt2x00_options.patch b/package/mac80211/patches/030-rt2x00_options.patch
deleted file mode 100644
index 5ee52a2..0000000
--- a/package/mac80211/patches/030-rt2x00_options.patch
+++ /dev/null
@@ -1,47 +0,0 @@
---- a/drivers/net/wireless/rt2x00/Kconfig
-+++ b/drivers/net/wireless/rt2x00/Kconfig
-@@ -225,36 +225,37 @@ config RT2800SOC
- 
- 
- config RT2800_LIB
--	tristate
-+	tristate "RT2800 USB/PCI support"
- 	depends on m
- 
- config RT2800_LIB_MMIO
--	tristate
-+	tristate "RT2800 MMIO support"
- 	depends on m
- 	select RT2X00_LIB_MMIO
- 	select RT2800_LIB
- 
- config RT2X00_LIB_MMIO
--	tristate
-+	tristate "RT2x00 MMIO support"
- 	depends on m
- 
- config RT2X00_LIB_PCI
--	tristate
-+	tristate "RT2x00 PCI support"
- 	depends on m
- 	select RT2X00_LIB
- 
- config RT2X00_LIB_SOC
--	tristate
-+	tristate "RT2x00 SoC support"
-+	depends on SOC_RT288X || SOC_RT305X
- 	depends on m
- 	select RT2X00_LIB
- 
- config RT2X00_LIB_USB
--	tristate
-+	tristate "RT2x00 USB support"
- 	depends on m
- 	select RT2X00_LIB
- 
- config RT2X00_LIB
--	tristate
-+	tristate "RT2x00 support"
- 	depends on m
- 	select BACKPORT_AVERAGE
- 
diff --git a/package/mac80211/patches/040-brcmutil_option.patch b/package/mac80211/patches/040-brcmutil_option.patch
deleted file mode 100644
index 8a6cae6..0000000
--- a/package/mac80211/patches/040-brcmutil_option.patch
+++ /dev/null
@@ -1,9 +0,0 @@
---- a/drivers/net/wireless/brcm80211/Kconfig
-+++ b/drivers/net/wireless/brcm80211/Kconfig
-@@ -1,5 +1,5 @@
- config BRCMUTIL
--	tristate
-+	tristate "Broadcom 802.11 driver utility functions"
- 	depends on m
- 
- config BRCMSMAC
diff --git a/package/mac80211/patches/050-lib80211_option.patch b/package/mac80211/patches/050-lib80211_option.patch
deleted file mode 100644
index 5372114..0000000
--- a/package/mac80211/patches/050-lib80211_option.patch
+++ /dev/null
@@ -1,30 +0,0 @@
---- a/net/wireless/Kconfig
-+++ b/net/wireless/Kconfig
-@@ -123,7 +123,7 @@ config CFG80211_WEXT
- 	  extensions with cfg80211-based drivers.
- 
- config LIB80211
--	tristate
-+	tristate "lib80211"
- 	depends on m
- 	default n
- 	help
-@@ -133,15 +133,15 @@ config LIB80211
- 	  Drivers should select this themselves if needed.
- 
- config LIB80211_CRYPT_WEP
--	tristate
-+	tristate "lib80211 WEP support"
- 	depends on m
- 
- config LIB80211_CRYPT_CCMP
--	tristate
-+	tristate "lib80211 CCMP support"
- 	depends on m
- 
- config LIB80211_CRYPT_TKIP
--	tristate
-+	tristate "lib80211 TKIP support"
- 	depends on m
- 
- config LIB80211_DEBUG
diff --git a/package/mac80211/patches/060-no_local_ssb_bcma.patch b/package/mac80211/patches/060-no_local_ssb_bcma.patch
deleted file mode 100644
index f4b9470..0000000
--- a/package/mac80211/patches/060-no_local_ssb_bcma.patch
+++ /dev/null
@@ -1,129 +0,0 @@
---- a/.local-symbols
-+++ b/.local-symbols
-@@ -379,42 +379,6 @@ USB_CDC_PHONET=
- USB_IPHETH=
- USB_SIERRA_NET=
- USB_VL600=
--SSB_POSSIBLE=
--SSB=
--SSB_SPROM=
--SSB_BLOCKIO=
--SSB_PCIHOST_POSSIBLE=
--SSB_PCIHOST=
--SSB_B43_PCI_BRIDGE=
--SSB_PCMCIAHOST_POSSIBLE=
--SSB_PCMCIAHOST=
--SSB_SDIOHOST_POSSIBLE=
--SSB_SDIOHOST=
--SSB_SILENT=
--SSB_DEBUG=
--SSB_SERIAL=
--SSB_DRIVER_PCICORE_POSSIBLE=
--SSB_DRIVER_PCICORE=
--SSB_PCICORE_HOSTMODE=
--SSB_DRIVER_MIPS=
--SSB_SFLASH=
--SSB_EMBEDDED=
--SSB_DRIVER_EXTIF=
--SSB_DRIVER_GIGE=
--SSB_DRIVER_GPIO=
--BCMA_POSSIBLE=
--BCMA=
--BCMA_BLOCKIO=
--BCMA_HOST_PCI_POSSIBLE=
--BCMA_HOST_PCI=
--BCMA_DRIVER_PCI_HOSTMODE=
--BCMA_HOST_SOC=
--BCMA_DRIVER_MIPS=
--BCMA_SFLASH=
--BCMA_NFLASH=
--BCMA_DRIVER_GMAC_CMN=
--BCMA_DRIVER_GPIO=
--BCMA_DEBUG=
- NFC=
- NFC_DIGITAL=
- NFC_NCI=
---- a/Kconfig
-+++ b/Kconfig
-@@ -33,9 +33,6 @@ source drivers/net/wireless/Kconfig
- source drivers/net/ethernet/Kconfig
- source drivers/net/usb/Kconfig
- 
--source drivers/ssb/Kconfig
--source drivers/bcma/Kconfig
--
- source net/nfc/Kconfig
- 
- source drivers/regulator/Kconfig
---- a/Makefile.kernel
-+++ b/Makefile.kernel
-@@ -25,8 +25,6 @@ obj-$(CPTCFG_MAC80211) += net/mac80211/
- obj-$(CPTCFG_WLAN) += drivers/net/wireless/
- obj-$(CPTCFG_BT) += net/bluetooth/
- obj-$(CPTCFG_BT) += drivers/bluetooth/
--obj-$(CPTCFG_SSB) += drivers/ssb/
--obj-$(CPTCFG_BCMA) += drivers/bcma/
- obj-$(CPTCFG_ETHERNET) += drivers/net/ethernet/
- obj-$(CPTCFG_USB_NET_RNDIS_WLAN) += drivers/net/usb/
- obj-$(CPTCFG_NFC) += net/nfc/
---- a/drivers/net/wireless/b43/main.c
-+++ b/drivers/net/wireless/b43/main.c
-@@ -2734,7 +2734,7 @@ static struct ssb_device *b43_ssb_gpio_d
- {
- 	struct ssb_bus *bus = dev->dev->sdev->bus;
- 
--#ifdef CPTCFG_SSB_DRIVER_PCICORE
-+#ifdef CONFIG_SSB_DRIVER_PCICORE
- 	return (bus->chipco.dev ? bus->chipco.dev : bus->pcicore.dev);
- #else
- 	return bus->chipco.dev;
-@@ -4751,7 +4751,7 @@ static int b43_wireless_core_init(struct
- 	}
- 	if (sprom->boardflags_lo & B43_BFL_XTAL_NOSLOW)
- 		hf |= B43_HF_DSCRQ; /* Disable slowclock requests from ucode. */
--#ifdef CPTCFG_SSB_DRIVER_PCICORE
-+#ifdef CONFIG_SSB_DRIVER_PCICORE
- 	if (dev->dev->bus_type == B43_BUS_SSB &&
- 	    dev->dev->sdev->bus->bustype == SSB_BUSTYPE_PCI &&
- 	    dev->dev->sdev->bus->pcicore.dev->id.revision <= 10)
---- a/drivers/net/wireless/b43legacy/main.c
-+++ b/drivers/net/wireless/b43legacy/main.c
-@@ -1937,7 +1937,7 @@ static int b43legacy_gpio_init(struct b4
- 	if (dev->dev->id.revision >= 2)
- 		mask  |= 0x0010; /* FIXME: This is redundant. */
- 
--#ifdef CPTCFG_SSB_DRIVER_PCICORE
-+#ifdef CONFIG_SSB_DRIVER_PCICORE
- 	pcidev = bus->pcicore.dev;
- #endif
- 	gpiodev = bus->chipco.dev ? : pcidev;
-@@ -1956,7 +1956,7 @@ static void b43legacy_gpio_cleanup(struc
- 	struct ssb_bus *bus = dev->dev->bus;
- 	struct ssb_device *gpiodev, *pcidev = NULL;
- 
--#ifdef CPTCFG_SSB_DRIVER_PCICORE
-+#ifdef CONFIG_SSB_DRIVER_PCICORE
- 	pcidev = bus->pcicore.dev;
- #endif
- 	gpiodev = bus->chipco.dev ? : pcidev;
---- a/drivers/net/wireless/brcm80211/brcmsmac/Makefile
-+++ b/drivers/net/wireless/brcm80211/brcmsmac/Makefile
-@@ -43,6 +43,6 @@ brcmsmac-y := \
- 	brcms_trace_events.o \
- 	debug.o
- 
--brcmsmac-$(CPTCFG_BCMA_DRIVER_GPIO) += led.o
-+brcmsmac-$(CONFIG_BCMA_DRIVER_GPIO) += led.o
- 
- obj-$(CPTCFG_BRCMSMAC)	+= brcmsmac.o
---- a/drivers/net/wireless/brcm80211/brcmsmac/led.h
-+++ b/drivers/net/wireless/brcm80211/brcmsmac/led.h
-@@ -22,7 +22,7 @@ struct brcms_led {
- 	bool active_low;
- };
- 
--#ifdef CPTCFG_BCMA_DRIVER_GPIO
-+#ifdef CONFIG_BCMA_DRIVER_GPIO
- void brcms_led_unregister(struct brcms_info *wl);
- int brcms_led_register(struct brcms_info *wl);
- #else
diff --git a/package/mac80211/patches/100-revert_aes_ccm_port.patch b/package/mac80211/patches/100-revert_aes_ccm_port.patch
deleted file mode 100644
index 4654bc8..0000000
--- a/package/mac80211/patches/100-revert_aes_ccm_port.patch
+++ /dev/null
@@ -1,347 +0,0 @@
---- a/net/mac80211/Kconfig
-+++ b/net/mac80211/Kconfig
-@@ -5,7 +5,6 @@ config MAC80211
- 	depends on CRYPTO
- 	depends on CRYPTO_ARC4
- 	depends on CRYPTO_AES
--	depends on CRYPTO_CCM
- 	depends on CRC32
- 	select BACKPORT_AVERAGE
- 	---help---
---- a/net/mac80211/aes_ccm.c
-+++ b/net/mac80211/aes_ccm.c
-@@ -2,8 +2,6 @@
-  * Copyright 2003-2004, Instant802 Networks, Inc.
-  * Copyright 2005-2006, Devicescape Software, Inc.
-  *
-- * Rewrite: Copyright (C) 2013 Linaro Ltd <ard.biesheuvel@linaro.org>
-- *
-  * This program is free software; you can redistribute it and/or modify
-  * it under the terms of the GNU General Public License version 2 as
-  * published by the Free Software Foundation.
-@@ -19,75 +17,134 @@
- #include "key.h"
- #include "aes_ccm.h"
- 
--void ieee80211_aes_ccm_encrypt(struct crypto_aead *tfm, u8 *b_0, u8 *aad,
--			       u8 *data, size_t data_len, u8 *mic)
-+static void aes_ccm_prepare(struct crypto_cipher *tfm, u8 *scratch, u8 *a)
- {
--	struct scatterlist assoc, pt, ct[2];
--	struct {
--		struct aead_request	req;
--		u8			priv[crypto_aead_reqsize(tfm)];
--	} aead_req;
--
--	memset(&aead_req, 0, sizeof(aead_req));
--
--	sg_init_one(&pt, data, data_len);
--	sg_init_one(&assoc, &aad[2], be16_to_cpup((__be16 *)aad));
--	sg_init_table(ct, 2);
--	sg_set_buf(&ct[0], data, data_len);
--	sg_set_buf(&ct[1], mic, IEEE80211_CCMP_MIC_LEN);
--
--	aead_request_set_tfm(&aead_req.req, tfm);
--	aead_request_set_assoc(&aead_req.req, &assoc, assoc.length);
--	aead_request_set_crypt(&aead_req.req, &pt, ct, data_len, b_0);
-+	int i;
-+	u8 *b_0, *aad, *b, *s_0;
- 
--	crypto_aead_encrypt(&aead_req.req);
-+	b_0 = scratch + 3 * AES_BLOCK_SIZE;
-+	aad = scratch + 4 * AES_BLOCK_SIZE;
-+	b = scratch;
-+	s_0 = scratch + AES_BLOCK_SIZE;
-+
-+	crypto_cipher_encrypt_one(tfm, b, b_0);
-+
-+	/* Extra Authenticate-only data (always two AES blocks) */
-+	for (i = 0; i < AES_BLOCK_SIZE; i++)
-+		aad[i] ^= b[i];
-+	crypto_cipher_encrypt_one(tfm, b, aad);
-+
-+	aad += AES_BLOCK_SIZE;
-+
-+	for (i = 0; i < AES_BLOCK_SIZE; i++)
-+		aad[i] ^= b[i];
-+	crypto_cipher_encrypt_one(tfm, a, aad);
-+
-+	/* Mask out bits from auth-only-b_0 */
-+	b_0[0] &= 0x07;
-+
-+	/* S_0 is used to encrypt T (= MIC) */
-+	b_0[14] = 0;
-+	b_0[15] = 0;
-+	crypto_cipher_encrypt_one(tfm, s_0, b_0);
- }
- 
--int ieee80211_aes_ccm_decrypt(struct crypto_aead *tfm, u8 *b_0, u8 *aad,
--			      u8 *data, size_t data_len, u8 *mic)
-+
-+void ieee80211_aes_ccm_encrypt(struct crypto_cipher *tfm, u8 *scratch,
-+			       u8 *data, size_t data_len,
-+			       u8 *cdata, u8 *mic)
- {
--	struct scatterlist assoc, pt, ct[2];
--	struct {
--		struct aead_request	req;
--		u8			priv[crypto_aead_reqsize(tfm)];
--	} aead_req;
--
--	memset(&aead_req, 0, sizeof(aead_req));
--
--	sg_init_one(&pt, data, data_len);
--	sg_init_one(&assoc, &aad[2], be16_to_cpup((__be16 *)aad));
--	sg_init_table(ct, 2);
--	sg_set_buf(&ct[0], data, data_len);
--	sg_set_buf(&ct[1], mic, IEEE80211_CCMP_MIC_LEN);
--
--	aead_request_set_tfm(&aead_req.req, tfm);
--	aead_request_set_assoc(&aead_req.req, &assoc, assoc.length);
--	aead_request_set_crypt(&aead_req.req, ct, &pt,
--			       data_len + IEEE80211_CCMP_MIC_LEN, b_0);
-+	int i, j, last_len, num_blocks;
-+	u8 *pos, *cpos, *b, *s_0, *e, *b_0;
-+
-+	b = scratch;
-+	s_0 = scratch + AES_BLOCK_SIZE;
-+	e = scratch + 2 * AES_BLOCK_SIZE;
-+	b_0 = scratch + 3 * AES_BLOCK_SIZE;
-+
-+	num_blocks = DIV_ROUND_UP(data_len, AES_BLOCK_SIZE);
-+	last_len = data_len % AES_BLOCK_SIZE;
-+	aes_ccm_prepare(tfm, scratch, b);
-+
-+	/* Process payload blocks */
-+	pos = data;
-+	cpos = cdata;
-+	for (j = 1; j <= num_blocks; j++) {
-+		int blen = (j == num_blocks && last_len) ?
-+			last_len : AES_BLOCK_SIZE;
-+
-+		/* Authentication followed by encryption */
-+		for (i = 0; i < blen; i++)
-+			b[i] ^= pos[i];
-+		crypto_cipher_encrypt_one(tfm, b, b);
-+
-+		b_0[14] = (j >> 8) & 0xff;
-+		b_0[15] = j & 0xff;
-+		crypto_cipher_encrypt_one(tfm, e, b_0);
-+		for (i = 0; i < blen; i++)
-+			*cpos++ = *pos++ ^ e[i];
-+	}
- 
--	return crypto_aead_decrypt(&aead_req.req);
-+	for (i = 0; i < IEEE80211_CCMP_MIC_LEN; i++)
-+		mic[i] = b[i] ^ s_0[i];
- }
- 
--struct crypto_aead *ieee80211_aes_key_setup_encrypt(const u8 key[])
-+
-+int ieee80211_aes_ccm_decrypt(struct crypto_cipher *tfm, u8 *scratch,
-+			      u8 *cdata, size_t data_len, u8 *mic, u8 *data)
- {
--	struct crypto_aead *tfm;
--	int err;
-+	int i, j, last_len, num_blocks;
-+	u8 *pos, *cpos, *b, *s_0, *a, *b_0;
- 
--	tfm = crypto_alloc_aead("ccm(aes)", 0, CRYPTO_ALG_ASYNC);
--	if (IS_ERR(tfm))
--		return tfm;
--
--	err = crypto_aead_setkey(tfm, key, WLAN_KEY_LEN_CCMP);
--	if (!err)
--		err = crypto_aead_setauthsize(tfm, IEEE80211_CCMP_MIC_LEN);
--	if (!err)
--		return tfm;
-+	b = scratch;
-+	s_0 = scratch + AES_BLOCK_SIZE;
-+	a = scratch + 2 * AES_BLOCK_SIZE;
-+	b_0 = scratch + 3 * AES_BLOCK_SIZE;
-+
-+	num_blocks = DIV_ROUND_UP(data_len, AES_BLOCK_SIZE);
-+	last_len = data_len % AES_BLOCK_SIZE;
-+	aes_ccm_prepare(tfm, scratch, a);
-+
-+	/* Process payload blocks */
-+	cpos = cdata;
-+	pos = data;
-+	for (j = 1; j <= num_blocks; j++) {
-+		int blen = (j == num_blocks && last_len) ?
-+			last_len : AES_BLOCK_SIZE;
-+
-+		/* Decryption followed by authentication */
-+		b_0[14] = (j >> 8) & 0xff;
-+		b_0[15] = j & 0xff;
-+		crypto_cipher_encrypt_one(tfm, b, b_0);
-+		for (i = 0; i < blen; i++) {
-+			*pos = *cpos++ ^ b[i];
-+			a[i] ^= *pos++;
-+		}
-+		crypto_cipher_encrypt_one(tfm, a, a);
-+	}
-+
-+	for (i = 0; i < IEEE80211_CCMP_MIC_LEN; i++) {
-+		if ((mic[i] ^ s_0[i]) != a[i])
-+			return -1;
-+	}
- 
--	crypto_free_aead(tfm);
--	return ERR_PTR(err);
-+	return 0;
- }
- 
--void ieee80211_aes_key_free(struct crypto_aead *tfm)
-+
-+struct crypto_cipher *ieee80211_aes_key_setup_encrypt(const u8 key[])
-+{
-+	struct crypto_cipher *tfm;
-+
-+	tfm = crypto_alloc_cipher("aes", 0, CRYPTO_ALG_ASYNC);
-+	if (!IS_ERR(tfm))
-+		crypto_cipher_setkey(tfm, key, WLAN_KEY_LEN_CCMP);
-+
-+	return tfm;
-+}
-+
-+
-+void ieee80211_aes_key_free(struct crypto_cipher *tfm)
- {
--	crypto_free_aead(tfm);
-+	crypto_free_cipher(tfm);
- }
---- a/net/mac80211/aes_ccm.h
-+++ b/net/mac80211/aes_ccm.h
-@@ -12,11 +12,13 @@
- 
- #include <linux/crypto.h>
- 
--struct crypto_aead *ieee80211_aes_key_setup_encrypt(const u8 key[]);
--void ieee80211_aes_ccm_encrypt(struct crypto_aead *tfm, u8 *b_0, u8 *aad,
--			       u8 *data, size_t data_len, u8 *mic);
--int ieee80211_aes_ccm_decrypt(struct crypto_aead *tfm, u8 *b_0, u8 *aad,
--			      u8 *data, size_t data_len, u8 *mic);
--void ieee80211_aes_key_free(struct crypto_aead *tfm);
-+struct crypto_cipher *ieee80211_aes_key_setup_encrypt(const u8 key[]);
-+void ieee80211_aes_ccm_encrypt(struct crypto_cipher *tfm, u8 *scratch,
-+			       u8 *data, size_t data_len,
-+			       u8 *cdata, u8 *mic);
-+int ieee80211_aes_ccm_decrypt(struct crypto_cipher *tfm, u8 *scratch,
-+			      u8 *cdata, size_t data_len,
-+			      u8 *mic, u8 *data);
-+void ieee80211_aes_key_free(struct crypto_cipher *tfm);
- 
- #endif /* AES_CCM_H */
---- a/net/mac80211/key.h
-+++ b/net/mac80211/key.h
-@@ -84,7 +84,7 @@ struct ieee80211_key {
- 			 * Management frames.
- 			 */
- 			u8 rx_pn[IEEE80211_NUM_TIDS + 1][IEEE80211_CCMP_PN_LEN];
--			struct crypto_aead *tfm;
-+			struct crypto_cipher *tfm;
- 			u32 replays; /* dot11RSNAStatsCCMPReplays */
- 		} ccmp;
- 		struct {
---- a/net/mac80211/wpa.c
-+++ b/net/mac80211/wpa.c
-@@ -301,16 +301,22 @@ ieee80211_crypto_tkip_decrypt(struct iee
- }
- 
- 
--static void ccmp_special_blocks(struct sk_buff *skb, u8 *pn, u8 *b_0, u8 *aad,
-+static void ccmp_special_blocks(struct sk_buff *skb, u8 *pn, u8 *scratch,
- 				int encrypted)
- {
- 	__le16 mask_fc;
- 	int a4_included, mgmt;
- 	u8 qos_tid;
--	u16 len_a;
-+	u8 *b_0, *aad;
-+	u16 data_len, len_a;
- 	unsigned int hdrlen;
- 	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;
- 
-+	memset(scratch, 0, 6 * AES_BLOCK_SIZE);
-+
-+	b_0 = scratch + 3 * AES_BLOCK_SIZE;
-+	aad = scratch + 4 * AES_BLOCK_SIZE;
-+
- 	/*
- 	 * Mask FC: zero subtype b4 b5 b6 (if not mgmt)
- 	 * Retry, PwrMgt, MoreData; set Protected
-@@ -332,21 +338,20 @@ static void ccmp_special_blocks(struct s
- 	else
- 		qos_tid = 0;
- 
--	/* In CCM, the initial vectors (IV) used for CTR mode encryption and CBC
--	 * mode authentication are not allowed to collide, yet both are derived
--	 * from this vector b_0. We only set L := 1 here to indicate that the
--	 * data size can be represented in (L+1) bytes. The CCM layer will take
--	 * care of storing the data length in the top (L+1) bytes and setting
--	 * and clearing the other bits as is required to derive the two IVs.
--	 */
--	b_0[0] = 0x1;
-+	data_len = skb->len - hdrlen - IEEE80211_CCMP_HDR_LEN;
-+	if (encrypted)
-+		data_len -= IEEE80211_CCMP_MIC_LEN;
- 
-+	/* First block, b_0 */
-+	b_0[0] = 0x59; /* flags: Adata: 1, M: 011, L: 001 */
- 	/* Nonce: Nonce Flags | A2 | PN
- 	 * Nonce Flags: Priority (b0..b3) | Management (b4) | Reserved (b5..b7)
- 	 */
- 	b_0[1] = qos_tid | (mgmt << 4);
- 	memcpy(&b_0[2], hdr->addr2, ETH_ALEN);
- 	memcpy(&b_0[8], pn, IEEE80211_CCMP_PN_LEN);
-+	/* l(m) */
-+	put_unaligned_be16(data_len, &b_0[14]);
- 
- 	/* AAD (extra authenticate-only data) / masked 802.11 header
- 	 * FC | A1 | A2 | A3 | SC | [A4] | [QC] */
-@@ -402,8 +407,7 @@ static int ccmp_encrypt_skb(struct ieee8
- 	u8 *pos;
- 	u8 pn[6];
- 	u64 pn64;
--	u8 aad[2 * AES_BLOCK_SIZE];
--	u8 b_0[AES_BLOCK_SIZE];
-+	u8 scratch[6 * AES_BLOCK_SIZE];
- 
- 	if (info->control.hw_key &&
- 	    !(info->control.hw_key->flags & IEEE80211_KEY_FLAG_GENERATE_IV) &&
-@@ -456,9 +460,9 @@ static int ccmp_encrypt_skb(struct ieee8
- 		return 0;
- 
- 	pos += IEEE80211_CCMP_HDR_LEN;
--	ccmp_special_blocks(skb, pn, b_0, aad, 0);
--	ieee80211_aes_ccm_encrypt(key->u.ccmp.tfm, b_0, aad, pos, len,
--				  skb_put(skb, IEEE80211_CCMP_MIC_LEN));
-+	ccmp_special_blocks(skb, pn, scratch, 0);
-+	ieee80211_aes_ccm_encrypt(key->u.ccmp.tfm, scratch, pos, len,
-+				  pos, skb_put(skb, IEEE80211_CCMP_MIC_LEN));
- 
- 	return 0;
- }
-@@ -521,16 +525,16 @@ ieee80211_crypto_ccmp_decrypt(struct iee
- 	}
- 
- 	if (!(status->flag & RX_FLAG_DECRYPTED)) {
--		u8 aad[2 * AES_BLOCK_SIZE];
--		u8 b_0[AES_BLOCK_SIZE];
-+		u8 scratch[6 * AES_BLOCK_SIZE];
- 		/* hardware didn't decrypt/verify MIC */
--		ccmp_special_blocks(skb, pn, b_0, aad, 1);
-+		ccmp_special_blocks(skb, pn, scratch, 1);
- 
- 		if (ieee80211_aes_ccm_decrypt(
--			    key->u.ccmp.tfm, b_0, aad,
-+			    key->u.ccmp.tfm, scratch,
- 			    skb->data + hdrlen + IEEE80211_CCMP_HDR_LEN,
- 			    data_len,
--			    skb->data + skb->len - IEEE80211_CCMP_MIC_LEN))
-+			    skb->data + skb->len - IEEE80211_CCMP_MIC_LEN,
-+			    skb->data + hdrlen + IEEE80211_CCMP_HDR_LEN))
- 			return RX_DROP_UNUSABLE;
- 	}
- 
diff --git a/package/mac80211/patches/150-disable_addr_notifier.patch b/package/mac80211/patches/150-disable_addr_notifier.patch
deleted file mode 100644
index 7b50154..0000000
--- a/package/mac80211/patches/150-disable_addr_notifier.patch
+++ /dev/null
@@ -1,67 +0,0 @@
---- a/net/mac80211/main.c
-+++ b/net/mac80211/main.c
-@@ -287,7 +287,7 @@ void ieee80211_restart_hw(struct ieee802
- }
- EXPORT_SYMBOL(ieee80211_restart_hw);
- 
--#ifdef CONFIG_INET
-+#ifdef __disabled__CONFIG_INET
- static int ieee80211_ifa_changed(struct notifier_block *nb,
- 				 unsigned long data, void *arg)
- {
-@@ -346,7 +346,7 @@ static int ieee80211_ifa_changed(struct 
- }
- #endif
- 
--#if IS_ENABLED(CONFIG_IPV6)
-+#if IS_ENABLED(__disabled__CONFIG_IPV6)
- static int ieee80211_ifa6_changed(struct notifier_block *nb,
- 				  unsigned long data, void *arg)
- {
-@@ -1031,14 +1031,14 @@ int ieee80211_register_hw(struct ieee802
- 		goto fail_pm_qos;
- 	}
- 
--#ifdef CONFIG_INET
-+#ifdef __disabled__CONFIG_INET
- 	local->ifa_notifier.notifier_call = ieee80211_ifa_changed;
- 	result = register_inetaddr_notifier(&local->ifa_notifier);
- 	if (result)
- 		goto fail_ifa;
- #endif
- 
--#if IS_ENABLED(CONFIG_IPV6)
-+#if IS_ENABLED(__disabled__CONFIG_IPV6)
- 	local->ifa6_notifier.notifier_call = ieee80211_ifa6_changed;
- 	result = register_inet6addr_notifier(&local->ifa6_notifier);
- 	if (result)
-@@ -1047,13 +1047,13 @@ int ieee80211_register_hw(struct ieee802
- 
- 	return 0;
- 
--#if IS_ENABLED(CONFIG_IPV6)
-+#if IS_ENABLED(__disabled__CONFIG_IPV6)
-  fail_ifa6:
--#ifdef CONFIG_INET
-+#ifdef __disabled__CONFIG_INET
- 	unregister_inetaddr_notifier(&local->ifa_notifier);
- #endif
- #endif
--#if defined(CONFIG_INET) || defined(CONFIG_IPV6)
-+#if defined(__disabled__CONFIG_INET) || defined(__disabled__CONFIG_IPV6)
-  fail_ifa:
- 	pm_qos_remove_notifier(PM_QOS_NETWORK_LATENCY,
- 			       &local->network_latency_notifier);
-@@ -1086,10 +1086,10 @@ void ieee80211_unregister_hw(struct ieee
- 
- 	pm_qos_remove_notifier(PM_QOS_NETWORK_LATENCY,
- 			       &local->network_latency_notifier);
--#ifdef CONFIG_INET
-+#ifdef __disabled__CONFIG_INET
- 	unregister_inetaddr_notifier(&local->ifa_notifier);
- #endif
--#if IS_ENABLED(CONFIG_IPV6)
-+#if IS_ENABLED(__disabled__CONFIG_IPV6)
- 	unregister_inet6addr_notifier(&local->ifa6_notifier);
- #endif
- 
diff --git a/package/mac80211/patches/200-ath5k_pci_dependency.patch b/package/mac80211/patches/200-ath5k_pci_dependency.patch
deleted file mode 100644
index 2d99b4a..0000000
--- a/package/mac80211/patches/200-ath5k_pci_dependency.patch
+++ /dev/null
@@ -1,11 +0,0 @@
---- a/drivers/net/wireless/ath/ath5k/Kconfig
-+++ b/drivers/net/wireless/ath/ath5k/Kconfig
-@@ -55,7 +55,7 @@ config ATH5K_TRACER
- 
- config ATH5K_AHB
- 	bool "Atheros 5xxx AHB bus support"
--	depends on (ATHEROS_AR231X && !PCI)
-+	depends on ATHEROS_AR231X
- 	---help---
- 	  This adds support for WiSoC type chipsets of the 5xxx Atheros
- 	  family.
diff --git a/package/mac80211/patches/201-ath5k-WAR-for-AR71xx-PCI-bug.patch b/package/mac80211/patches/201-ath5k-WAR-for-AR71xx-PCI-bug.patch
deleted file mode 100644
index 21516ff..0000000
--- a/package/mac80211/patches/201-ath5k-WAR-for-AR71xx-PCI-bug.patch
+++ /dev/null
@@ -1,38 +0,0 @@
---- a/drivers/net/wireless/ath/ath5k/initvals.c
-+++ b/drivers/net/wireless/ath/ath5k/initvals.c
-@@ -62,8 +62,14 @@ static const struct ath5k_ini ar5210_ini
- 	{ AR5K_IMR,		0 },
- 	{ AR5K_IER,		AR5K_IER_DISABLE },
- 	{ AR5K_BSR,		0, AR5K_INI_READ },
-+#if !defined(CONFIG_ATHEROS_AR71XX) && !defined(CONFIG_ATH79)
- 	{ AR5K_TXCFG,		AR5K_DMASIZE_128B },
- 	{ AR5K_RXCFG,		AR5K_DMASIZE_128B },
-+#else
-+	/* WAR for AR71xx PCI bug */
-+	{ AR5K_TXCFG,		AR5K_DMASIZE_128B },
-+	{ AR5K_RXCFG,		AR5K_DMASIZE_4B },
-+#endif
- 	{ AR5K_CFG,		AR5K_INIT_CFG },
- 	{ AR5K_TOPS,		8 },
- 	{ AR5K_RXNOFRM,		8 },
---- a/drivers/net/wireless/ath/ath5k/dma.c
-+++ b/drivers/net/wireless/ath/ath5k/dma.c
-@@ -869,10 +869,18 @@ ath5k_hw_dma_init(struct ath5k_hw *ah)
- 	 * guess we can tweak it and see how it goes ;-)
- 	 */
- 	if (ah->ah_version != AR5K_AR5210) {
-+#if !defined(CONFIG_ATHEROS_AR71XX) && !defined(CONFIG_ATH79)
- 		AR5K_REG_WRITE_BITS(ah, AR5K_TXCFG,
- 			AR5K_TXCFG_SDMAMR, AR5K_DMASIZE_128B);
- 		AR5K_REG_WRITE_BITS(ah, AR5K_RXCFG,
- 			AR5K_RXCFG_SDMAMW, AR5K_DMASIZE_128B);
-+#else
-+		/* WAR for AR71xx PCI bug */
-+		AR5K_REG_WRITE_BITS(ah, AR5K_TXCFG,
-+			AR5K_TXCFG_SDMAMR, AR5K_DMASIZE_128B);
-+		AR5K_REG_WRITE_BITS(ah, AR5K_RXCFG,
-+			AR5K_RXCFG_SDMAMW, AR5K_DMASIZE_4B);
-+#endif
- 	}
- 
- 	/* Pre-enable interrupts on 5211/5212*/
diff --git a/package/mac80211/patches/300-pending_work.patch b/package/mac80211/patches/300-pending_work.patch
deleted file mode 100644
index 1da7941..0000000
--- a/package/mac80211/patches/300-pending_work.patch
+++ /dev/null
@@ -1,4142 +0,0 @@
-commit 584d297fd29fb39c76af25ae74ff9d5fe74c8a14
-Author: Helmut Schaa <helmut.schaa@googlemail.com>
-Date:   Wed Mar 12 10:37:55 2014 +0100
-
-    ath9k: Fix sequence number assignment for non-data frames
-    
-    Since commit 558ff225de80ac95b132d3a115ddadcd64498b4f (ath9k: fix
-    ps-poll responses under a-mpdu sessions) non-data frames would have
-    gotten a sequence number from a TIDs sequence counter instead of
-    using the global sequence counter.
-    
-    This can lead to instable connections.
-    
-    To fix this only select the correct TID if we are processing a
-    data frame. Furthermore, prevent non-data frames to get a sequence
-    number from a TID sequence counter by adding a check to
-    ath_tx_setup_buffer.
-    
-    Cc: Felix Fietkau <nbd@openwrt.org>
-    Signed-off-by: Helmut Schaa <helmut.schaa@googlemail.com>
-
-commit 3a0f984b1cdcd6a9f8c441635ef3b05d58547f4e
-Author: Felix Fietkau <nbd@openwrt.org>
-Date:   Tue Mar 11 14:03:32 2014 +0100
-
-    ath9k_hw: set ANI firstep as absolute values instead of relative
-    
-    On older chips, the INI value differ in similar ways as cycpwr_thr1, so
-    convert it to absolute values as well.
-    
-    Since the ANI algorithm is different here compared to the old
-    implementation (fewer steps, controlled at a different point in time),
-    it makes sense to use values similar to what would be applied for newer
-    chips, just without relying on INI defaults.
-    
-    Signed-off-by: Felix Fietkau <nbd@openwrt.org>
-
-commit 91d70d40400c569b49605b78fd7c43e9405694f4
-Author: Felix Fietkau <nbd@openwrt.org>
-Date:   Tue Mar 11 14:00:37 2014 +0100
-
-    ath9k_hw: set ANI cycpwr_thr1 as absolute values instead of relative
-    
-    The table was copied from the ANI implementation of AR9300. It assumes
-    that the INI values contain a baseline value that is usable as reference
-    from which to increase/decrease based on the noise immunity value.
-    
-    On older chips, the differences are bigger and especially AR5008/AR9001
-    are configured to much more sensitive values than what is useful.
-    
-    Improve ANI behavior by reverting to the absolute values used in the
-    previous implementation (expressed as a simple formula instead of the
-    old table).
-    
-    Signed-off-by: Felix Fietkau <nbd@openwrt.org>
-
-commit c977493766310a825f406836636ffd66e1447783
-Author: Felix Fietkau <nbd@openwrt.org>
-Date:   Mon Mar 10 19:52:56 2014 +0100
-
-    ath9k_hw: remove ANI function restrictions for AP mode
-    
-    The primary purpose of this piece of code was to selectively disable
-    OFDM weak signal detection. The checks for this are elsewhere, and an
-    earlier commit relaxed the restrictions for older chips, which are more
-    sensitive to interference.
-    
-    Signed-off-by: Felix Fietkau <nbd@openwrt.org>
-
-commit 8d804f1af11e4e058b1e8453327777d73a585cb8
-Author: Felix Fietkau <nbd@openwrt.org>
-Date:   Sun Mar 9 11:25:43 2014 +0100
-
-    ath9k: clean up and enhance ANI debugfs file
-    
-    Unify scnprintf calls and include the current OFDM/CCK immunity level.
-    
-    Signed-off-by: Felix Fietkau <nbd@openwrt.org>
-
-commit 22e298b5a3a8a49e33805d4e351965123dede35b
-Author: Felix Fietkau <nbd@openwrt.org>
-Date:   Sun Mar 9 10:58:47 2014 +0100
-
-    ath9k: fix ready time of the multicast buffer queue
-    
-    qi->tqi_readyTime is written directly to registers that expect
-    microseconds as unit instead of TU.
-    When setting the CABQ ready time, cur_conf->beacon_interval is in TU, so
-    convert it to microseconds before passing it to ath9k_hw.
-    
-    This should hopefully fix some Tx DMA issues with buffered multicast
-    frames in AP mode.
-    
-    Cc: stable@vger.kernel.org
-    Signed-off-by: Felix Fietkau <nbd@openwrt.org>
-
-commit fcb064fdd5a27bec8d24099bc0172468f34c97cb
-Author: Felix Fietkau <nbd@openwrt.org>
-Date:   Sun Mar 9 09:43:09 2014 +0100
-
-    ath9k_hw: fix unreachable code in baseband hang detection code
-    
-    The commit "ath9k: reduce baseband hang detection false positive rate"
-    added a delay in the loop checking the baseband state, however it was
-    unreachable due to previous 'continue' statements.
-    
-    Reported-by: Dan Carpenter <dan.carpenter@oracle.com>
-    Signed-off-by: Felix Fietkau <nbd@openwrt.org>
-
-commit 31959d8df39319e32c6d5ba9c135727be90cfad7
-Author: Michal Kazior <michal.kazior@tieto.com>
-Date:   Fri Mar 7 08:09:38 2014 +0100
-
-    mac80211: fix possible NULL dereference
-    
-    If chanctx is missing on a given vif then the band
-    is assumed to be 2GHz. However if hw doesn't
-    support 2GHz band then mac80211 ended up with a
-    NULL dereference.
-    
-    This fixes a splat:
-    
-    [ 4605.207223] BUG: unable to handle kernel NULL pointer dereference at 0000000000000018
-    [ 4605.210789] IP: [<ffffffffa07b5635>] ieee80211_parse_bitrates+0x65/0x110 [mac80211]
-    
-    The splat was preceeded by WARN_ON(!chanctx_conf)
-    in ieee80211_get_sdata_band().
-    
-    Signed-off-by: Michal Kazior <michal.kazior@tieto.com>
-
-commit 6c5a3ffa0a2d22c091a2717f427259bacf77ac5e
-Author: Michael Braun <michael-dev@fami-braun.de>
-Date:   Thu Mar 6 15:08:43 2014 +0100
-
-    mac80211: fix WPA with VLAN on AP side with ps-sta again
-    
-    commit de74a1d9032f4d37ea453ad2a647e1aff4cd2591
-      "mac80211: fix WPA with VLAN on AP side with ps-sta"
-    fixed an issue where queued multicast packets would
-    be sent out encrypted with the key of an other bss.
-    
-    commit "7cbf9d017dbb5e3276de7d527925d42d4c11e732"
-      "mac80211: fix oops on mesh PS broadcast forwarding"
-    essentially reverted it, because vif.type cannot be AP_VLAN
-    due to the check to vif.type in ieee80211_get_buffered_bc before.
-    
-    As the later commit intended to fix the MESH case, fix it
-    by checking for IFTYPE_AP instead of IFTYPE_AP_VLAN.
-    
-    Fixes: 7cbf9d017dbb
-    Cc: <stable@vger.kernel.org> # 3.10.x
-    Cc: <stable@vger.kernel.org> # 3.11.x
-    Cc: <stable@vger.kernel.org> # 3.12.x
-    Cc: <stable@vger.kernel.org> # 3.13.x
-    Cc: <linux-wireless@vger.kernel.org>
-    Cc: <projekt-wlan@fem.tu-ilmenau.de>
-    Signed-off-by: Michael Braun <michael-dev@fami-braun.de>
-
-commit 9d6ab9bdb9b368a6cf9519f0f92509b5b2c297ec
-Author: Johannes Berg <johannes.berg@intel.com>
-Date:   Mon Mar 3 14:19:08 2014 +0100
-
-    cfg80211: remove racy beacon_interval assignment
-    
-    In case of AP mode, the beacon interval is already reset to
-    zero inside cfg80211_stop_ap(), and in the other modes it
-    isn't relevant. Remove the assignment to remove a potential
-    race since the assignment isn't properly locked.
-    
-    Reported-by: Michal Kazior <michal.kazior@tieto.com>
-    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
-
-commit 1abdeca3c6fb9cf1f84f85e78ed8d1c33bd69db0
-Author: Felix Fietkau <nbd@openwrt.org>
-Date:   Fri Feb 28 18:52:56 2014 +0100
-
-    ath9k_hw: tweak noise immunity thresholds for older chipsets
-    
-    Older chipsets are more sensitive to high PHY error counts, and the
-    current noise immunity thresholds were based on tests run at QCA with
-    newer chipsets.
-    
-    This patch brings back the values from the old ANI implementation for
-    old chipsets, and it also disables weak signal detection on an earlier
-    noise immunity level, to improve overall radio stability on affected
-    devices.
-    
-    Signed-off-by: Felix Fietkau <nbd@openwrt.org>
-
-commit 431e506da5953adc3b65af25f4b90873d528c115
-Author: Felix Fietkau <nbd@openwrt.org>
-Date:   Fri Feb 28 18:44:13 2014 +0100
-
-    ath9k_hw: toggle weak signal detection in AP mode on older chipsets
-    
-    The commit 80b4205b "ath9k: Fix OFDM weak signal detection for AP mode"
-    prevented weak signal detection changes from taking effect in AP mode on
-    all chipsets, claiming it is "not allowed".
-    
-    The main reason for not disabling weak signal detection in AP mode is
-    that typically beacon RSSI is used to track whether it is needed to
-    boost range, and this is unavailable in AP mode for obvious reasons.
-    
-    The problem with not disabling weak signal detection is that older
-    chipsets are very sensitive to high PHY error counts. When faced with
-    heavy noise, this can lead to an excessive amount of "Failed to stop
-    TX DMA" errors in the field.
-    
-    Signed-off-by: Felix Fietkau <nbd@openwrt.org>
-
-commit 98d1a6c5b14688ed030e81b889f607be308e0df9
-Author: Felix Fietkau <nbd@openwrt.org>
-Date:   Mon Feb 24 22:20:32 2014 +0100
-
-    ath9k: fix invalid descriptor discarding
-    
-    Only set sc->rx.discard_next to rx_stats->rs_more when actually
-    discarding the current descriptor.
-    
-    Also, fix a detection of broken descriptors:
-    First the code checks if the current descriptor is not done.
-    Then it checks if the next descriptor is done.
-    Add a check that afterwards checks the first descriptor again, because
-    it might have been completed in the mean time.
-    
-    This fixes a regression introduced in
-    commit 723e711356b5a8a95728a890e254e8b0d47b55cf
-    "ath9k: fix handling of broken descriptors"
-    
-    Cc: stable@vger.kernel.org
-    Reported-by: Marco André Dinis <marcoandredinis@gmail.com>
-    Signed-off-by: Felix Fietkau <nbd@openwrt.org>
-
-commit 52a46300e782fe6994466523eb2b0b59091ea59f
-Author: Felix Fietkau <nbd@openwrt.org>
-Date:   Mon Feb 24 11:43:50 2014 +0100
-
-    ath9k: reduce baseband hang detection false positive rate
-    
-    Check if the baseband state remains stable, and add a small delay
-    between register reads.
-    
-    Signed-off-by: Felix Fietkau <nbd@openwrt.org>
-
-commit 118945bb12082e9d4edddc868d88143164e0f440
-Author: Felix Fietkau <nbd@openwrt.org>
-Date:   Sat Feb 22 14:55:23 2014 +0100
-
-    ath5k: set SURVEY_INFO_IN_USE on get_survey
-    
-    Only one channel is returned - the one currently being used.
-    
-    Signed-off-by: Felix Fietkau <nbd@openwrt.org>
-
-commit ee41f72476e1ea44283dfe1cbf75b9543a1e15c8
-Author: Felix Fietkau <nbd@openwrt.org>
-Date:   Sat Feb 22 14:44:52 2014 +0100
-
-    ath9k: make some hardware reset log messages debug-only
-    
-    On some chips, baseband watchdog hangs are more common than others, and
-    the driver has support for handling them.
-    Interrupts even after a watchdog hang are also quite common, so there's
-    not much point in spamming the user's logfiles.
-    
-    Signed-off-by: Felix Fietkau <nbd@openwrt.org>
-
-commit b14fbb554fc65a2e0b5c41a319269b0350f187e7
-Author: Felix Fietkau <nbd@openwrt.org>
-Date:   Sat Feb 22 14:35:25 2014 +0100
-
-    ath9k: do not set half/quarter channel flags in AR_PHY_MODE
-    
-    5/10 MHz channel bandwidth is configured via the PLL clock, instead of
-    the AR_PHY_MODE register. Using that register is AR93xx specific, and
-    makes the mode incompatible with earlier chipsets.
-    
-    In some early versions, these flags were apparently applied at the wrong
-    point in time and thus did not cause connectivity issues, however now
-    they are causing problems, as pointed out in this OpenWrt ticket:
-    
-    https://dev.openwrt.org/ticket/14916
-    
-    Signed-off-by: Felix Fietkau <nbd@openwrt.org>
-
-commit 0f1cb7be2551b30b02cd54c897e0e29e483cfda5
-Author: Felix Fietkau <nbd@openwrt.org>
-Date:   Sat Feb 22 13:43:29 2014 +0100
-
-    ath9k: fix ps-poll responses under a-mpdu sessions
-    
-    When passing tx frames to the U-APSD queue for powersave poll responses,
-    the ath_atx_tid pointer needs to be passed to ath_tx_setup_buffer for
-    proper sequence number accounting.
-    
-    This fixes high latency and connection stability issues with ath9k
-    running as AP and a few kinds of mobile phones as client, when PS-Poll
-    is heavily used
-    
-    Cc: stable@vger.kernel.org
-    Signed-off-by: Felix Fietkau <nbd@openwrt.org>
-
-commit d5d87a37bbd6066b2c3c5d0bd0fe2a6e2ea45cc5
-Author: Felix Fietkau <nbd@openwrt.org>
-Date:   Fri Feb 21 11:39:59 2014 +0100
-
-    ath9k: list more reset causes in debugfs
-    
-    Number of MAC hangs and stuck beacons were missing
-    
-    Signed-off-by: Felix Fietkau <nbd@openwrt.org>
-
-commit d84856012e0f10fe598a5ad3b7b869397a089e07
-Author: Johannes Berg <johannes.berg@intel.com>
-Date:   Thu Feb 20 11:19:58 2014 +0100
-
-    mac80211: fix station wakeup powersave race
-    
-    Consider the following (relatively unlikely) scenario:
-     1) station goes to sleep while frames are buffered in driver
-     2) driver blocks wakeup (until no more frames are buffered)
-     3) station wakes up again
-     4) driver unblocks wakeup
-    
-    In this case, the current mac80211 code will do the following:
-     1) WLAN_STA_PS_STA set
-     2) WLAN_STA_PS_DRIVER set
-     3) - nothing -
-     4) WLAN_STA_PS_DRIVER cleared
-    
-    As a result, no frames will be delivered to the client, even
-    though it is awake, until it sends another frame to us that
-    triggers ieee80211_sta_ps_deliver_wakeup() in sta_ps_end().
-    
-    Since we now take the PS spinlock, we can fix this while at
-    the same time removing the complexity with the pending skb
-    queue function. This was broken since my commit 50a9432daeec
-    ("mac80211: fix powersaving clients races") due to removing
-    the clearing of WLAN_STA_PS_STA in the RX path.
-    
-    While at it, fix a cleanup path issue when a station is
-    removed while the driver is still blocking its wakeup.
-    
-    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
-
-commit 798f2786602cbe93e6b928299614aa36ebf50692
-Author: Johannes Berg <johannes.berg@intel.com>
-Date:   Mon Feb 17 20:49:03 2014 +0100
-
-    mac80211: insert stations before adding to driver
-    
-    There's a race condition in mac80211 because we add stations
-    to the internal lists after adding them to the driver, which
-    means that (for example) the following can happen:
-     1. a station connects and is added
-     2. first, it is added to the driver
-     3. then, it is added to the mac80211 lists
-    
-    If the station goes to sleep between steps 2 and 3, and the
-    firmware/hardware records it as being asleep, mac80211 will
-    never instruct the driver to wake it up again as it never
-    realized it went to sleep since the RX path discarded the
-    frame as a "spurious class 3 frame", no station entry was
-    present yet.
-    
-    Fix this by adding the station in software first, and only
-    then adding it to the driver. That way, any state that the
-    driver changes will be reflected properly in mac80211's
-    station state. The problematic part is the roll-back if the
-    driver fails to add the station, in that case a bit more is
-    needed. To not make that overly complex prevent starting BA
-    sessions in the meantime.
-    
-    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
-
-commit b9ba6a520cb07ab3aa7aaaf9ce4a0bc7a6bc06fe
-Author: Emmanuel Grumbach <emmanuel.grumbach@intel.com>
-Date:   Thu Feb 20 09:22:11 2014 +0200
-
-    mac80211: fix AP powersave TX vs. wakeup race
-    
-    There is a race between the TX path and the STA wakeup: while
-    a station is sleeping, mac80211 buffers frames until it wakes
-    up, then the frames are transmitted. However, the RX and TX
-    path are concurrent, so the packet indicating wakeup can be
-    processed while a packet is being transmitted.
-    
-    This can lead to a situation where the buffered frames list
-    is emptied on the one side, while a frame is being added on
-    the other side, as the station is still seen as sleeping in
-    the TX path.
-    
-    As a result, the newly added frame will not be send anytime
-    soon. It might be sent much later (and out of order) when the
-    station goes to sleep and wakes up the next time.
-    
-    Additionally, it can lead to the crash below.
-    
-    Fix all this by synchronising both paths with a new lock.
-    Both path are not fastpath since they handle PS situations.
-    
-    In a later patch we'll remove the extra skb queue locks to
-    reduce locking overhead.
-    
-    BUG: unable to handle kernel
-    NULL pointer dereference at 000000b0
-    IP: [<ff6f1791>] ieee80211_report_used_skb+0x11/0x3e0 [mac80211]
-    *pde = 00000000
-    Oops: 0000 [#1] SMP DEBUG_PAGEALLOC
-    EIP: 0060:[<ff6f1791>] EFLAGS: 00210282 CPU: 1
-    EIP is at ieee80211_report_used_skb+0x11/0x3e0 [mac80211]
-    EAX: e5900da0 EBX: 00000000 ECX: 00000001 EDX: 00000000
-    ESI: e41d00c0 EDI: e5900da0 EBP: ebe458e4 ESP: ebe458b0
-     DS: 007b ES: 007b FS: 00d8 GS: 00e0 SS: 0068
-    CR0: 8005003b CR2: 000000b0 CR3: 25a78000 CR4: 000407d0
-    DR0: 00000000 DR1: 00000000 DR2: 00000000 DR3: 00000000
-    DR6: ffff0ff0 DR7: 00000400
-    Process iperf (pid: 3934, ti=ebe44000 task=e757c0b0 task.ti=ebe44000)
-    iwlwifi 0000:02:00.0: I iwl_pcie_enqueue_hcmd Sending command LQ_CMD (#4e), seq: 0x0903, 92 bytes at 3[3]:9
-    Stack:
-     e403b32c ebe458c4 00200002 00200286 e403b338 ebe458cc c10960bb e5900da0
-     ff76a6ec ebe458d8 00000000 e41d00c0 e5900da0 ebe458f0 ff6f1b75 e403b210
-     ebe4598c ff723dc1 00000000 ff76a6ec e597c978 e403b758 00000002 00000002
-    Call Trace:
-     [<ff6f1b75>] ieee80211_free_txskb+0x15/0x20 [mac80211]
-     [<ff723dc1>] invoke_tx_handlers+0x1661/0x1780 [mac80211]
-     [<ff7248a5>] ieee80211_tx+0x75/0x100 [mac80211]
-     [<ff7249bf>] ieee80211_xmit+0x8f/0xc0 [mac80211]
-     [<ff72550e>] ieee80211_subif_start_xmit+0x4fe/0xe20 [mac80211]
-     [<c149ef70>] dev_hard_start_xmit+0x450/0x950
-     [<c14b9aa9>] sch_direct_xmit+0xa9/0x250
-     [<c14b9c9b>] __qdisc_run+0x4b/0x150
-     [<c149f732>] dev_queue_xmit+0x2c2/0xca0
-    
-    Cc: stable@vger.kernel.org
-    Reported-by: Yaara Rozenblum <yaara.rozenblum@intel.com>
-    Signed-off-by: Emmanuel Grumbach <emmanuel.grumbach@intel.com>
-    Reviewed-by: Stanislaw Gruszka <sgruszka@redhat.com>
-    [reword commit log, use a separate lock]
-    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
-
-commit 80e419de0dff38436b30d363311c625766193f86
-Author: Inbal Hacohen <Inbal.Hacohen@intel.com>
-Date:   Wed Feb 12 09:32:27 2014 +0200
-
-    cfg80211: bugfix in regulatory user hint process
-    
-    After processing hint_user, we would want to schedule the
-    timeout work only if we are actually waiting to CRDA. This happens
-    when the status is not "IGNORE" nor "ALREADY_SET".
-    
-    Signed-off-by: Inbal Hacohen <Inbal.Hacohen@intel.com>
-    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
-
-commit 6514c93afede55284e2cb63359aadedb85884c80
-Author: Jouni Malinen <jouni@qca.qualcomm.com>
-Date:   Tue Feb 18 20:41:08 2014 +0200
-
-    ath9k: Enable U-APSD AP mode support
-    
-    mac80211 handles the actual operations, so ath9k can just indicate
-    support for this. Based on initial tests, this combination seems to
-    work fine.
-    
-    Signed-off-by: Jouni Malinen <jouni@qca.qualcomm.com>
-
-commit a63caf0a357ad5c1f08d6b7827dc76c451445017
-Author: Stanislaw Gruszka <sgruszka@redhat.com>
-Date:   Wed Feb 19 13:15:17 2014 +0100
-
-    ath9k: protect tid->sched check
-    
-    We check tid->sched without a lock taken on ath_tx_aggr_sleep(). That
-    is race condition which can result of doing list_del(&tid->list) twice
-    (second time with poisoned list node) and cause crash like shown below:
-    
-    [424271.637220] BUG: unable to handle kernel paging request at 00100104
-    [424271.637328] IP: [<f90fc072>] ath_tx_aggr_sleep+0x62/0xe0 [ath9k]
-    ...
-    [424271.639953] Call Trace:
-    [424271.639998]  [<f90f6900>] ? ath9k_get_survey+0x110/0x110 [ath9k]
-    [424271.640083]  [<f90f6942>] ath9k_sta_notify+0x42/0x50 [ath9k]
-    [424271.640177]  [<f809cfef>] sta_ps_start+0x8f/0x1c0 [mac80211]
-    [424271.640258]  [<c10f730e>] ? free_compound_page+0x2e/0x40
-    [424271.640346]  [<f809e915>] ieee80211_rx_handlers+0x9d5/0x2340 [mac80211]
-    [424271.640437]  [<c112f048>] ? kmem_cache_free+0x1d8/0x1f0
-    [424271.640510]  [<c1345a84>] ? kfree_skbmem+0x34/0x90
-    [424271.640578]  [<c10fc23c>] ? put_page+0x2c/0x40
-    [424271.640640]  [<c1345a84>] ? kfree_skbmem+0x34/0x90
-    [424271.640706]  [<c1345a84>] ? kfree_skbmem+0x34/0x90
-    [424271.640787]  [<f809dde3>] ? ieee80211_rx_handlers_result+0x73/0x1d0 [mac80211]
-    [424271.640897]  [<f80a07a0>] ieee80211_prepare_and_rx_handle+0x520/0xad0 [mac80211]
-    [424271.641009]  [<f809e22d>] ? ieee80211_rx_handlers+0x2ed/0x2340 [mac80211]
-    [424271.641104]  [<c13846ce>] ? ip_output+0x7e/0xd0
-    [424271.641182]  [<f80a1057>] ieee80211_rx+0x307/0x7c0 [mac80211]
-    [424271.641266]  [<f90fa6ee>] ath_rx_tasklet+0x88e/0xf70 [ath9k]
-    [424271.641358]  [<f80a0f2c>] ? ieee80211_rx+0x1dc/0x7c0 [mac80211]
-    [424271.641445]  [<f90f82db>] ath9k_tasklet+0xcb/0x130 [ath9k]
-    
-    Bug report:
-    https://bugzilla.kernel.org/show_bug.cgi?id=70551
-    
-    Reported-and-tested-by: Max Sydorenko <maxim.stargazer@gmail.com>
-    Cc: stable@vger.kernel.org
-    Signed-off-by: Stanislaw Gruszka <sgruszka@redhat.com>
-
-commit 82ed9e3ccc02797df2ffe4b78127c4cd5f799a41
-Author: Felix Fietkau <nbd@openwrt.org>
-Date:   Tue Feb 11 15:54:13 2014 +0100
-
-    mac80211: send control port protocol frames to the VO queue
-    
-    Improves reliability of wifi connections with WPA, since authentication
-    frames are prioritized over normal traffic and also typically exempt
-    from aggregation.
-    
-    Cc: stable@vger.kernel.org
-    Signed-off-by: Felix Fietkau <nbd@openwrt.org>
-
-commit d4426800f71e972feaa33e04c5801fc730627bdd
-Author: Stanislaw Gruszka <stf_xl@wp.pl>
-Date:   Mon Feb 10 22:38:28 2014 +0100
-
-    rtl8187: fix regression on MIPS without coherent DMA
-    
-    This patch fixes regression caused by commit a16dad77634 "MIPS: Fix
-    potencial corruption". That commit fixes one corruption scenario in
-    cost of adding another one, which actually start to cause crashes
-    on Yeeloong laptop when rtl8187 driver is used.
-    
-    For correct DMA read operation on machines without DMA coherence, kernel
-    have to invalidate cache, such it will refill later with new data that
-    device wrote to memory, when that data is needed to process. We can only
-    invalidate full cache line. Hence when cache line includes both dma
-    buffer and some other data (written in cache, but not yet in main
-    memory), the other data can not hit memory due to invalidation. That
-    happen on rtl8187 where struct rtl8187_priv fields are located just
-    before and after small buffers that are passed to USB layer and DMA
-    is performed on them.
-    
-    To fix the problem we align buffers and reserve space after them to make
-    them match cache line.
-    
-    This patch does not resolve all possible MIPS problems entirely, for
-    that we have to assure that we always map cache aligned buffers for DMA,
-    what can be complex or even not possible. But patch fixes visible and
-    reproducible regression and seems other possible corruptions do not
-    happen in practice, since Yeeloong laptop works stable without rtl8187
-    driver.
-    
-    Bug report:
-    https://bugzilla.kernel.org/show_bug.cgi?id=54391
-    
-    Reported-by: Petr Pisar <petr.pisar@atlas.cz>
-    Bisected-by: Tom Li <biergaizi2009@gmail.com>
-    Reported-and-tested-by: Tom Li <biergaizi2009@gmail.com>
-    Cc: stable@vger.kernel.org
-    Signed-off-by: Stanislaw Gruszka <stf_xl@wp.pl>
-
-commit e2f141d67ad1e7fe10aaab61811e8a409dfb2442
-Author: Sujith Manoharan <c_manoha@qca.qualcomm.com>
-Date:   Fri Feb 7 10:29:55 2014 +0530
-
-    ath9k: Calculate IQ-CAL median
-    
-    This patch adds a routine to calculate the median IQ correction
-    values for AR955x, which is used for outlier detection.
-    The normal method which is used for all other chips is
-    bypassed for AR955x.
-    
-    Signed-off-by: Sujith Manoharan <c_manoha@qca.qualcomm.com>
-
-commit c52a6fce0820c8d0687443ab86058ae03b478c8f
-Author: Sujith Manoharan <c_manoha@qca.qualcomm.com>
-Date:   Fri Feb 7 10:29:54 2014 +0530
-
-    ath9k: Expand the IQ coefficient array
-    
-    This will be used for storing data for mutiple
-    IQ calibration runs, for AR955x.
-    
-    Signed-off-by: Sujith Manoharan <c_manoha@qca.qualcomm.com>
-
-commit 034969ff5c2b6431d10e07c1938f0b916da85cc3
-Author: Sujith Manoharan <c_manoha@qca.qualcomm.com>
-Date:   Fri Feb 7 10:29:53 2014 +0530
-
-    ath9k: Modify IQ calibration for AR955x
-    
-    IQ calibration post-processing for AR955x is different
-    from other chips - instead of just doing it as part
-    of AGC calibration once, it is triggered 3 times and
-    a median is determined. This patch adds initial support
-    for changing the calibration behavior for AR955x.
-    
-    Also, to simplify things, a helper routine to issue/poll
-    AGC calibration is used.
-    
-    For non-AR955x chips, the iqcal_idx (which will be used
-    in subsequent patches) is set to zero.
-    
-    Signed-off-by: Sujith Manoharan <c_manoha@qca.qualcomm.com>
-
-commit 9b1ed6454e6f3511f24266be99b4e403f243f6a8
-Author: Sujith Manoharan <c_manoha@qca.qualcomm.com>
-Date:   Fri Feb 7 10:29:52 2014 +0530
-
-    ath9k: Fix magnitude/phase calculation
-    
-    Incorrect values are programmed in the registers
-    containing the IQ correction coefficients by the IQ-CAL
-    post-processing code. Fix this.
-    
-    Signed-off-by: Sujith Manoharan <c_manoha@qca.qualcomm.com>
-
-commit 36f93484f96f79171dcecb67c5ef0c3de22531a6
-Author: Sujith Manoharan <c_manoha@qca.qualcomm.com>
-Date:   Fri Feb 7 10:29:51 2014 +0530
-
-    ath9k: Rename ar9003_hw_tx_iqcal_load_avg_2_passes
-    
-    Use ar9003_hw_tx_iq_cal_outlier_detection instead.
-    
-    Signed-off-by: Sujith Manoharan <c_manoha@qca.qualcomm.com>
-
-commit 3af09a7f5d21dd5fd15b973ce6a91a575da30417
-Author: Sujith Manoharan <c_manoha@qca.qualcomm.com>
-Date:   Fri Feb 7 10:29:50 2014 +0530
-
-    ath9k: Check explicitly for IQ calibration
-    
-    In chips like AR955x, the initvals contain the information
-    whether IQ calibration is to be done in the HW when an
-    AGC calibration is triggered. Check if IQ-CAL is enabled
-    in the initvals before flagging 'txiqcal_done' as true.
-    
-    Signed-off-by: Sujith Manoharan <c_manoha@qca.qualcomm.com>
-
-commit cb4969634b93c4643a32cc3fbd27d2b288b25771
-Author: Sujith Manoharan <c_manoha@qca.qualcomm.com>
-Date:   Fri Feb 7 10:29:49 2014 +0530
-
-    ath9k: Fix IQ cal post processing for SoC
-    
-    Calibration data is not reused for SoC chips, so
-    call ar9003_hw_tx_iq_cal_post_proc() with the correct
-    argument. The 'is_reusable' flag is currently used
-    only for PC-OEM chips, but it makes things clearer to
-    specify it explicity.
-    
-    Signed-off-by: Sujith Manoharan <c_manoha@qca.qualcomm.com>
-
-commit e138e0ef9560c46ce93dbb22a728a57888e94d1c
-Author: Sujith Manoharan <c_manoha@qca.qualcomm.com>
-Date:   Mon Feb 3 13:31:37 2014 +0530
-
-    ath9k: Fix TX power calculation
-    
-    The commit, "ath9k_hw: Fix incorrect Tx control power in AR9003 template"
-    fixed the incorrect values in the eeprom templates, but if
-    boards have already been calibrated with incorrect values,
-    they would still be using the wrong TX power. Fix this by assigning
-    a default value in such cases.
-    
-    Cc: Rajkumar Manoharan <rmanohar@qti.qualcomm.com>
-    Signed-off-by: Sujith Manoharan <c_manoha@qca.qualcomm.com>
-
-commit b9f268b5b01331c3c82179abca551429450e9417
-Author: Michal Kazior <michal.kazior@tieto.com>
-Date:   Wed Jan 29 14:22:27 2014 +0100
-
-    cfg80211: consider existing DFS interfaces
-    
-    It was possible to break interface combinations in
-    the following way:
-    
-     combo 1: iftype = AP, num_ifaces = 2, num_chans = 2,
-     combo 2: iftype = AP, num_ifaces = 1, num_chans = 1, radar = HT20
-    
-    With the above interface combinations it was
-    possible to:
-    
-     step 1. start AP on DFS channel by matching combo 2
-     step 2. start AP on non-DFS channel by matching combo 1
-    
-    This was possible beacuse (step 2) did not consider
-    if other interfaces require radar detection.
-    
-    The patch changes how cfg80211 tracks channels -
-    instead of channel itself now a complete chandef
-    is stored.
-    
-    Signed-off-by: Michal Kazior <michal.kazior@tieto.com>
-    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
-
-commit bc9c62f5f511cc395c62dbf4cdd437f23db53b28
-Author: Antonio Quartulli <antonio@open-mesh.com>
-Date:   Wed Jan 29 17:53:43 2014 +0100
-
-    cfg80211: fix channel configuration in IBSS join
-    
-    When receiving an IBSS_JOINED event select the BSS object
-    based on the {bssid, channel} couple rather than the bssid
-    only.
-    With the current approach if another cell having the same
-    BSSID (but using a different channel) exists then cfg80211
-    picks up the wrong BSS object.
-    The result is a mismatching channel configuration between
-    cfg80211 and the driver, that can lead to any sort of
-    problem.
-    
-    The issue can be triggered by having an IBSS sitting on
-    given channel and then asking the driver to create a new
-    cell using the same BSSID but with a different frequency.
-    By passing the channel to cfg80211_get_bss() we can solve
-    this ambiguity and retrieve/create the correct BSS object.
-    All the users of cfg80211_ibss_joined() have been changed
-    accordingly.
-    
-    Moreover WARN when cfg80211_ibss_joined() gets a NULL
-    channel as argument and remove a bogus call of the same
-    function in ath6kl (it does not make sense to call
-    cfg80211_ibss_joined() with a zero BSSID on ibss-leave).
-    
-    Cc: Kalle Valo <kvalo@qca.qualcomm.com>
-    Cc: Arend van Spriel <arend@broadcom.com>
-    Cc: Bing Zhao <bzhao@marvell.com>
-    Cc: Jussi Kivilinna <jussi.kivilinna@iki.fi>
-    Cc: libertas-dev@lists.infradead.org
-    Acked-by: Kalle Valo <kvalo@qca.qualcomm.com>
-    Signed-off-by: Antonio Quartulli <antonio@open-mesh.com>
-    [minor code cleanup in ath6kl]
-    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
-
-commit 7e0c41cb41f215aba2c39b1c237bb4d42ec49a85
-Author: Johannes Berg <johannes.berg@intel.com>
-Date:   Fri Jan 24 14:41:44 2014 +0100
-
-    mac80211: fix bufferable MMPDU RX handling
-    
-    Action, disassoc and deauth frames are bufferable, and as such don't
-    have the PM bit in the frame control field reserved which means we
-    need to react to the bit when receiving in such a frame.
-    
-    Fix this by introducing a new helper ieee80211_is_bufferable_mmpdu()
-    and using it for the RX path that currently ignores the PM bit in
-    any non-data frames for doze->wake transitions, but listens to it in
-    all frames for wake->doze transitions, both of which are wrong.
-    
-    Also use the new helper in the TX path to clean up the code.
-    
-    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
-
-commit fc0df6d2343636e3f48a069330d5b972e3d8659d
-Author: Janusz Dziedzic <janusz.dziedzic@tieto.com>
-Date:   Fri Jan 24 14:29:21 2014 +0100
-
-    cfg80211: set preset_chandef after channel switch
-    
-    Set preset_chandef in channel switch notification.
-    In other case we will have old preset_chandef.
-    
-    Signed-off-by: Janusz Dziedzic <janusz.dziedzic@tieto.com>
-    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
-
-commit cdec895e2344987ff171cece96e25d7407a3ebf6
-Author: Simon Wunderlich <simon@open-mesh.com>
-Date:   Fri Jan 24 23:48:29 2014 +0100
-
-    mac80211: send ibss probe responses with noack flag
-    
-    Responding to probe requests for scanning clients will often create
-    excessive retries, as it happens quite often that the scanning client
-    already left the channel. Therefore do it like hostapd and send probe
-    responses for wildcard SSID only once by using the noack flag.
-    
-    Signed-off-by: Simon Wunderlich <simon@open-mesh.com>
-    [fix typo & 'wildcard SSID' in commit log]
-    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
-
-commit 0b865d1e6b9c05052adae9315df7cb195dc60c3b
-Author: Luciano Coelho <luciano.coelho@intel.com>
-Date:   Tue Jan 28 17:09:08 2014 +0200
-
-    mac80211: ibss: remove unnecessary call to release channel
-    
-    The ieee80211_vif_use_channel() function calls
-    ieee80211_vif_release_channel(), so there's no need to call it
-    explicitly in __ieee80211_sta_join_ibss().
-    
-    Signed-off-by: Luciano Coelho <luciano.coelho@intel.com>
-    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
-
-commit e1b6c17e971f0a51ff86c2dac2584c63cd999cd7
-Author: Michal Kazior <michal.kazior@tieto.com>
-Date:   Wed Jan 29 07:56:21 2014 +0100
-
-    mac80211: add missing CSA locking
-    
-    The patch adds a missing sdata lock and adds a few
-    lockdeps for easier maintenance.
-    
-    Signed-off-by: Michal Kazior <michal.kazior@tieto.com>
-    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
-
-commit ad17ba7d14d225b109b73c177cd446afb8050598
-Author: Michal Kazior <michal.kazior@tieto.com>
-Date:   Wed Jan 29 07:56:20 2014 +0100
-
-    mac80211: fix sdata->radar_required locking
-    
-    radar_required setting wasn't protected by
-    local->mtx in some places. This should prevent
-    from scanning/radar detection/roc colliding.
-    
-    Signed-off-by: Michal Kazior <michal.kazior@tieto.com>
-    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
-
-commit 5fcd5f1808813a3d9e502fd756e01bee8a79c85d
-Author: Michal Kazior <michal.kazior@tieto.com>
-Date:   Wed Jan 29 07:56:19 2014 +0100
-
-    mac80211: move csa_active setting in STA CSA
-    
-    The sdata->vif.csa_active could be left set after,
-    e.g. channel context constraints check fail in STA
-    mode leaving the interface in a strange state for
-    a brief period of time until it is disconnected.
-    This was harmless but ugly.
-    
-    Signed-off-by: Michal Kazior <michal.kazior@tieto.com>
-    Reviewed-by: Luciano Coelho <luciano.coelho@intel.com>
-    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
-
-commit e486da4b7eed71821c6b4c1bb9ac62ffd3ab13e9
-Author: Michal Kazior <michal.kazior@tieto.com>
-Date:   Wed Jan 29 07:56:18 2014 +0100
-
-    mac80211: fix possible memory leak on AP CSA failure
-    
-    If CSA for AP interface failed and the interface
-    was not stopped afterwards another CSA request
-    would leak sdata->u.ap.next_beacon.
-    
-    Signed-off-by: Michal Kazior <michal.kazior@tieto.com>
-    Reviewed-by: Luciano Coelho <luciano.coelho@intel.com>
-    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
-
-commit 3a77ba08940682bf3d52cf14f980337324af9d4a
-Author: Johannes Berg <johannes.berg@intel.com>
-Date:   Sat Feb 1 00:33:29 2014 +0100
-
-    mac80211: fix fragmentation code, particularly for encryption
-    
-    The "new" fragmentation code (since my rewrite almost 5 years ago)
-    erroneously sets skb->len rather than using skb_trim() to adjust
-    the length of the first fragment after copying out all the others.
-    This leaves the skb tail pointer pointing to after where the data
-    originally ended, and thus causes the encryption MIC to be written
-    at that point, rather than where it belongs: immediately after the
-    data.
-    
-    The impact of this is that if software encryption is done, then
-     a) encryption doesn't work for the first fragment, the connection
-        becomes unusable as the first fragment will never be properly
-        verified at the receiver, the MIC is practically guaranteed to
-        be wrong
-     b) we leak up to 8 bytes of plaintext (!) of the packet out into
-        the air
-    
-    This is only mitigated by the fact that many devices are capable
-    of doing encryption in hardware, in which case this can't happen
-    as the tail pointer is irrelevant in that case. Additionally,
-    fragmentation is not used very frequently and would normally have
-    to be configured manually.
-    
-    Fix this by using skb_trim() properly.
-    
-    Cc: stable@vger.kernel.org
-    Fixes: 2de8e0d999b8 ("mac80211: rewrite fragmentation")
-    Reported-by: Jouni Malinen <j@w1.fi>
-    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
-
-commit de5f242e0c10e841017e37eb8c38974a642dbca8
-Author: Sujith Manoharan <c_manoha@qca.qualcomm.com>
-Date:   Tue Jan 28 06:21:59 2014 +0530
-
-    ath9k: Fix build error on ARM
-    
-    Use mdelay instead of udelay to fix this error:
-    
-    ERROR: "__bad_udelay" [drivers/net/wireless/ath/ath9k/ath9k_hw.ko] undefined!
-    make[1]: *** [__modpost] Error 1
-    make: *** [modules] Error 2
-    
-    Reported-by: Josh Boyer <jwboyer@fedoraproject.org>
-    Signed-off-by: Sujith Manoharan <c_manoha@qca.qualcomm.com>
-
-commit 8e3ea7a51dfc61810fcefd947f6edcf61125252a
-Author: Geert Uytterhoeven <geert@linux-m68k.org>
-Date:   Sun Jan 26 11:53:21 2014 +0100
-
-    ath9k: Fix uninitialized variable in ath9k_has_tx_pending()
-    
-    drivers/net/wireless/ath/ath9k/main.c: In function ‘ath9k_has_tx_pending’:
-    drivers/net/wireless/ath/ath9k/main.c:1869: warning: ‘npend’ may be used uninitialized in this function
-    
-    Introduced by commit 10e2318103f5941aa70c318afe34bc41f1b98529 ("ath9k:
-    optimize ath9k_flush").
-    
-    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
-
-commit a4a634a6937ebdd827fa58e8fcdb8ca49a3769f6
-Author: Emmanuel Grumbach <emmanuel.grumbach@intel.com>
-Date:   Mon Jan 27 11:07:42 2014 +0200
-
-    mac80211: release the channel in error path in start_ap
-    
-    When the driver cannot start the AP or when the assignement
-    of the beacon goes wrong, we need to unassign the vif.
-    
-    Cc: stable@vger.kernel.org
-    Signed-off-by: Emmanuel Grumbach <emmanuel.grumbach@intel.com>
-    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
-
-commit dfb6889a75c601aedb7450b7e606668e77da6679
-Author: Johannes Berg <johannes.berg@intel.com>
-Date:   Wed Jan 22 11:14:19 2014 +0200
-
-    cfg80211: send scan results from work queue
-    
-    Due to the previous commit, when a scan finishes, it is in theory
-    possible to hit the following sequence:
-     1. interface starts being removed
-     2. scan is cancelled by driver and cfg80211 is notified
-     3. scan done work is scheduled
-     4. interface is removed completely, rdev->scan_req is freed,
-        event sent to userspace but scan done work remains pending
-     5. new scan is requested on another virtual interface
-     6. scan done work runs, freeing the still-running scan
-    
-    To fix this situation, hang on to the scan done message and block
-    new scans while that is the case, and only send the message from
-    the work function, regardless of whether the scan_req is already
-    freed from interface removal. This makes step 5 above impossible
-    and changes step 6 to be
-     5. scan done work runs, sending the scan done message
-    
-    As this can't work for wext, so we send the message immediately,
-    but this shouldn't be an issue since we still return -EBUSY.
-    
-    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
-
-commit 45b7ab41fc08627d9a8428cb413d5d84662a9707
-Author: Johannes Berg <johannes.berg@intel.com>
-Date:   Wed Jan 22 11:14:18 2014 +0200
-
-    cfg80211: fix scan done race
-    
-    When an interface/wdev is removed, any ongoing scan should be
-    cancelled by the driver. This will make it call cfg80211, which
-    only queues a work struct. If interface/wdev removal is quick
-    enough, this can leave the scan request pending and processed
-    only after the interface is gone, causing a use-after-free.
-    
-    Fix this by making sure the scan request is not pending after
-    the interface is destroyed. We can't flush or cancel the work
-    item due to locking concerns, but when it'll run it shouldn't
-    find anything to do. This leaves a potential issue, if a new
-    scan gets requested before the work runs, it prematurely stops
-    the running scan, potentially causing another crash. I'll fix
-    that in the next patch.
-    
-    This was particularly observed with P2P_DEVICE wdevs, likely
-    because freeing them is quicker than freeing netdevs.
-    
-    Reported-by: Andrei Otcheretianski <andrei.otcheretianski@intel.com>
-    Fixes: 4a58e7c38443 ("cfg80211: don't "leak" uncompleted scans")
-    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
-
-commit ae04fa489ab31b5a10d3cc8399f52761175d4321
-Author: Emmanuel Grumbach <emmanuel.grumbach@intel.com>
-Date:   Thu Jan 23 14:28:16 2014 +0200
-
-    mac80211: avoid deadlock revealed by lockdep
-    
-    sdata->u.ap.request_smps_work can’t be flushed synchronously
-    under wdev_lock(wdev) since ieee80211_request_smps_ap_work
-    itself locks the same lock.
-    While at it, reset the driver_smps_mode when the ap is
-    stopped to its default: OFF.
-    
-    This solves:
-    
-    ======================================================
-    [ INFO: possible circular locking dependency detected ]
-    3.12.0-ipeer+ #2 Tainted: G           O
-    -------------------------------------------------------
-    rmmod/2867 is trying to acquire lock:
-      ((&sdata->u.ap.request_smps_work)){+.+...}, at: [<c105b8d0>] flush_work+0x0/0x90
-    
-    but task is already holding lock:
-      (&wdev->mtx){+.+.+.}, at: [<f9b32626>] cfg80211_stop_ap+0x26/0x230 [cfg80211]
-    
-    which lock already depends on the new lock.
-    
-    the existing dependency chain (in reverse order) is:
-    
-    -> #1 (&wdev->mtx){+.+.+.}:
-            [<c10aefa9>] lock_acquire+0x79/0xe0
-            [<c1607a1a>] mutex_lock_nested+0x4a/0x360
-            [<fb06288b>] ieee80211_request_smps_ap_work+0x2b/0x50 [mac80211]
-            [<c105cdd8>] process_one_work+0x198/0x450
-            [<c105d469>] worker_thread+0xf9/0x320
-            [<c10669ff>] kthread+0x9f/0xb0
-            [<c1613397>] ret_from_kernel_thread+0x1b/0x28
-    
-    -> #0 ((&sdata->u.ap.request_smps_work)){+.+...}:
-            [<c10ae9df>] __lock_acquire+0x183f/0x1910
-            [<c10aefa9>] lock_acquire+0x79/0xe0
-            [<c105b917>] flush_work+0x47/0x90
-            [<c105d867>] __cancel_work_timer+0x67/0xe0
-            [<c105d90f>] cancel_work_sync+0xf/0x20
-            [<fb0765cc>] ieee80211_stop_ap+0x8c/0x340 [mac80211]
-            [<f9b3268c>] cfg80211_stop_ap+0x8c/0x230 [cfg80211]
-            [<f9b0d8f9>] cfg80211_leave+0x79/0x100 [cfg80211]
-            [<f9b0da72>] cfg80211_netdev_notifier_call+0xf2/0x4f0 [cfg80211]
-            [<c160f2c9>] notifier_call_chain+0x59/0x130
-            [<c106c6de>] __raw_notifier_call_chain+0x1e/0x30
-            [<c106c70f>] raw_notifier_call_chain+0x1f/0x30
-            [<c14f8213>] call_netdevice_notifiers_info+0x33/0x70
-            [<c14f8263>] call_netdevice_notifiers+0x13/0x20
-            [<c14f82a4>] __dev_close_many+0x34/0xb0
-            [<c14f83fe>] dev_close_many+0x6e/0xc0
-            [<c14f9c77>] rollback_registered_many+0xa7/0x1f0
-            [<c14f9dd4>] unregister_netdevice_many+0x14/0x60
-            [<fb06f4d9>] ieee80211_remove_interfaces+0xe9/0x170 [mac80211]
-            [<fb055116>] ieee80211_unregister_hw+0x56/0x110 [mac80211]
-            [<fa3e9396>] iwl_op_mode_mvm_stop+0x26/0xe0 [iwlmvm]
-            [<f9b9d8ca>] _iwl_op_mode_stop+0x3a/0x70 [iwlwifi]
-            [<f9b9d96f>] iwl_opmode_deregister+0x6f/0x90 [iwlwifi]
-            [<fa405179>] __exit_compat+0xd/0x19 [iwlmvm]
-            [<c10b8bf9>] SyS_delete_module+0x179/0x2b0
-            [<c1613421>] sysenter_do_call+0x12/0x32
-    
-    Fixes: 687da132234f ("mac80211: implement SMPS for AP")
-    Cc: <stable@vger.kernel.org> [3.13]
-    Reported-by: Ilan Peer <ilan.peer@intel.com>
-    Signed-off-by: Emmanuel Grumbach <emmanuel.grumbach@intel.com>
-    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
-
-commit 178b205e96217164fd7c30113464250d0b6f5eca
-Author: Johannes Berg <johannes.berg@intel.com>
-Date:   Thu Jan 23 16:32:29 2014 +0100
-
-    cfg80211: re-enable 5/10 MHz support
-    
-    Unfortunately I forgot this during the merge window, but the
-    patch seems small enough to go in as a fix. The userspace API
-    bug that was the reason for disabling it has long been fixed.
-    
-    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
-
-commit 110a1c79acda14edc83b7c8dc5af9c7ddd23eb61
-Author: Pontus Fuchs <pontus.fuchs@gmail.com>
-Date:   Thu Jan 16 15:00:40 2014 +0100
-
-    nl80211: Reset split_start when netlink skb is exhausted
-    
-    When the netlink skb is exhausted split_start is left set. In the
-    subsequent retry, with a larger buffer, the dump is continued from the
-    failing point instead of from the beginning.
-    
-    This was causing my rt28xx based USB dongle to now show up when
-    running "iw list" with an old iw version without split dump support.
-    
-    Cc: stable@vger.kernel.org
-    Fixes: 3713b4e364ef ("nl80211: allow splitting wiphy information in dumps")
-    Signed-off-by: Pontus Fuchs <pontus.fuchs@gmail.com>
-    [avoid the entire workaround when state->split is set]
-    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
-
-commit b4c31b45ffc7ef110fa9ecc34d7878fe7c5b9da4
-Author: Eliad Peller <eliad@wizery.com>
-Date:   Sun Jan 12 11:06:37 2014 +0200
-
-    mac80211: move roc cookie assignment earlier
-    
-    ieee80211_start_roc_work() might add a new roc
-    to existing roc, and tell cfg80211 it has already
-    started.
-    
-    However, this might happen before the roc cookie
-    was set, resulting in REMAIN_ON_CHANNEL (started)
-    event with null cookie. Consequently, it can make
-    wpa_supplicant go out of sync.
-    
-    Fix it by setting the roc cookie earlier.
-    
-    Cc: stable@vger.kernel.org
-    Signed-off-by: Eliad Peller <eliad@wizery.com>
-    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
-
-commit cfdc9157bfd7bcf88ab4dae08873a9907eba984c
-Author: Johannes Berg <johannes.berg@intel.com>
-Date:   Fri Jan 24 14:06:29 2014 +0100
-
-    nl80211: send event when AP operation is stopped
-    
-    There are a few cases, e.g. suspend, where an AP interface is
-    stopped by the kernel rather than by userspace request, most
-    commonly when suspending. To let userspace know about this,
-    send the NL80211_CMD_STOP_AP command as an event every time
-    an AP interface is stopped. This also happens when userspace
-    did in fact request the AP stop, but that's not a problem.
-    
-    For full-MAC drivers this may need to be extended to also
-    cover cases where the device stopped the AP operation for
-    some reason, this a bit more complicated because then all
-    cfg80211 state also needs to be reset; such API is not part
-    of this patch.
-    
-    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
-
-commit d5d567eda7704f190379ca852a8f9a4112e3eee3
-Author: Johannes Berg <johannes.berg@intel.com>
-Date:   Thu Jan 23 16:20:29 2014 +0100
-
-    mac80211: add length check in ieee80211_is_robust_mgmt_frame()
-    
-    A few places weren't checking that the frame passed to the
-    function actually has enough data even though the function
-    clearly documents it must have a payload byte. Make this
-    safer by changing the function to take an skb and checking
-    the length inside. The old version is preserved for now as
-    the rtl* drivers use it and don't have a correct skb.
-    
-    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
-
-commit f8f6d212a047fc65c7d3442dfc038f65517236fc
-Author: Johannes Berg <johannes.berg@intel.com>
-Date:   Fri Jan 24 10:53:53 2014 +0100
-
-    nl80211: fix scheduled scan RSSI matchset attribute confusion
-    
-    The scheduled scan matchsets were intended to be a list of filters,
-    with the found BSS having to pass at least one of them to be passed
-    to the host. When the RSSI attribute was added, however, this was
-    broken and currently wpa_supplicant adds that attribute in its own
-    matchset; however, it doesn't intend that to mean that anything
-    that passes the RSSI filter should be passed to the host, instead
-    it wants it to mean that everything needs to also have higher RSSI.
-    
-    This is semantically problematic because we have a list of filters
-    like [ SSID1, SSID2, SSID3, RSSI ] with no real indication which
-    one should be OR'ed and which one AND'ed.
-    
-    To fix this, move the RSSI filter attribute into each matchset. As
-    we need to stay backward compatible, treat a matchset with only the
-    RSSI attribute as a "default RSSI filter" for all other matchsets,
-    but only if there are other matchsets (an RSSI-only matchset by
-    itself is still desirable.)
-    
-    To make driver implementation easier, keep a global min_rssi_thold
-    for the entire request as well. The only affected driver is ath6kl.
-    
-    I found this when I looked into the code after Raja Mani submitted
-    a patch fixing the n_match_sets calculation to disregard the RSSI,
-    but that patch didn't address the semantic issue.
-    
-    Reported-by: Raja Mani <rmani@qti.qualcomm.com>
-    Acked-by: Luciano Coelho <luciano.coelho@intel.com>
-    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
-
-commit de553e8545e65a6dc4e45f43df7e1443d4291922
-Author: Johannes Berg <johannes.berg@intel.com>
-Date:   Fri Jan 24 10:17:47 2014 +0100
-
-    nl80211: check nla_parse() return values
-    
-    If there's a policy, then nla_parse() return values must be
-    checked, otherwise the policy is useless and there's nothing
-    that ensures the attributes are actually what we expect them
-    to be.
-    
-    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
-
-commit 652204a0733e9e1c54661d6f9d36e2e1e3b22bb1
-Author: Karl Beldan <karl.beldan@rivierawaves.com>
-Date:   Thu Jan 23 20:06:34 2014 +0100
-
-    mac80211: send {ADD,DEL}BA on AC_VO like other mgmt frames, as per spec
-    
-    ATM, {ADD,DEL}BA and BAR frames are sent on the AC matching the TID of
-    the BA parameters. In the discussion [1] about this patch, Johannes
-    recalled that it fixed some races with the DELBA and indeed this
-    behavior was introduced in [2].
-    While [2] is right for the BARs, the part queueing the {ADD,DEL}BAs on
-    their BA params TID AC violates the spec and is more a workaround for
-    some drivers. Helmut expressed some concerns wrt such drivers, in
-    particular DELBAs in rt2x00.
-    
-    ATM, DELBAs are sent after a driver has called (hence "purposely")
-    ieee80211_start_tx_ba_cb_irqsafe and Johannes and Emmanuel gave some
-    details wrt intentions behind the split of the IEEE80211_AMPDU_TX_STOP_*
-    given to the driver ampdu_action supposed to call this function, which
-    could prove handy to people trying to do the right thing in faulty
-    drivers (if their fw/hw don't get in their way).
-    
-    [1] http://mid.gmane.org/1390391564-18481-1-git-send-email-karl.beldan@gmail.com
-    [2] Commit: cf6bb79ad828 ("mac80211: Use appropriate TID for sending BAR, ADDBA and DELBA frames")
-    
-    Signed-off-by: Karl Beldan <karl.beldan@rivierawaves.com>
-    Cc: Helmut Schaa <helmut.schaa@googlemail.com>
-    Cc: Emmanuel Grumbach <emmanuel.grumbach@intel.com>
-    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
---- a/drivers/net/wireless/ath/ath6kl/cfg80211.c
-+++ b/drivers/net/wireless/ath/ath6kl/cfg80211.c
-@@ -790,7 +790,7 @@ void ath6kl_cfg80211_connect_event(struc
- 	if (nw_type & ADHOC_NETWORK) {
- 		ath6kl_dbg(ATH6KL_DBG_WLAN_CFG, "ad-hoc %s selected\n",
- 			   nw_type & ADHOC_CREATOR ? "creator" : "joiner");
--		cfg80211_ibss_joined(vif->ndev, bssid, GFP_KERNEL);
-+		cfg80211_ibss_joined(vif->ndev, bssid, chan, GFP_KERNEL);
- 		cfg80211_put_bss(ar->wiphy, bss);
- 		return;
- 	}
-@@ -861,13 +861,9 @@ void ath6kl_cfg80211_disconnect_event(st
- 	}
- 
- 	if (vif->nw_type & ADHOC_NETWORK) {
--		if (vif->wdev.iftype != NL80211_IFTYPE_ADHOC) {
-+		if (vif->wdev.iftype != NL80211_IFTYPE_ADHOC)
- 			ath6kl_dbg(ATH6KL_DBG_WLAN_CFG,
- 				   "%s: ath6k not in ibss mode\n", __func__);
--			return;
--		}
--		memset(bssid, 0, ETH_ALEN);
--		cfg80211_ibss_joined(vif->ndev, bssid, GFP_KERNEL);
- 		return;
- 	}
- 
-@@ -3256,6 +3252,15 @@ static int ath6kl_cfg80211_sscan_start(s
- 	struct ath6kl_vif *vif = netdev_priv(dev);
- 	u16 interval;
- 	int ret, rssi_thold;
-+	int n_match_sets = request->n_match_sets;
-+
-+	/*
-+	 * If there's a matchset w/o an SSID, then assume it's just for
-+	 * the RSSI (nothing else is currently supported) and ignore it.
-+	 * The device only supports a global RSSI filter that we set below.
-+	 */
-+	if (n_match_sets == 1 && !request->match_sets[0].ssid.ssid_len)
-+		n_match_sets = 0;
- 
- 	if (ar->state != ATH6KL_STATE_ON)
- 		return -EIO;
-@@ -3268,11 +3273,11 @@ static int ath6kl_cfg80211_sscan_start(s
- 	ret = ath6kl_set_probed_ssids(ar, vif, request->ssids,
- 				      request->n_ssids,
- 				      request->match_sets,
--				      request->n_match_sets);
-+				      n_match_sets);
- 	if (ret < 0)
- 		return ret;
- 
--	if (!request->n_match_sets) {
-+	if (!n_match_sets) {
- 		ret = ath6kl_wmi_bssfilter_cmd(ar->wmi, vif->fw_vif_idx,
- 					       ALL_BSS_FILTER, 0);
- 		if (ret < 0)
-@@ -3286,12 +3291,12 @@ static int ath6kl_cfg80211_sscan_start(s
- 
- 	if (test_bit(ATH6KL_FW_CAPABILITY_RSSI_SCAN_THOLD,
- 		     ar->fw_capabilities)) {
--		if (request->rssi_thold <= NL80211_SCAN_RSSI_THOLD_OFF)
-+		if (request->min_rssi_thold <= NL80211_SCAN_RSSI_THOLD_OFF)
- 			rssi_thold = 0;
--		else if (request->rssi_thold < -127)
-+		else if (request->min_rssi_thold < -127)
- 			rssi_thold = -127;
- 		else
--			rssi_thold = request->rssi_thold;
-+			rssi_thold = request->min_rssi_thold;
- 
- 		ret = ath6kl_wmi_set_rssi_filter_cmd(ar->wmi, vif->fw_vif_idx,
- 						     rssi_thold);
---- a/drivers/net/wireless/ath/ath9k/hw.c
-+++ b/drivers/net/wireless/ath/ath9k/hw.c
-@@ -1316,7 +1316,7 @@ static bool ath9k_hw_set_reset(struct at
- 	if (AR_SREV_9300_20_OR_LATER(ah))
- 		udelay(50);
- 	else if (AR_SREV_9100(ah))
--		udelay(10000);
-+		mdelay(10);
- 	else
- 		udelay(100);
- 
-@@ -1534,7 +1534,7 @@ EXPORT_SYMBOL(ath9k_hw_check_nav);
- bool ath9k_hw_check_alive(struct ath_hw *ah)
- {
- 	int count = 50;
--	u32 reg;
-+	u32 reg, last_val;
- 
- 	if (AR_SREV_9300(ah))
- 		return !ath9k_hw_detect_mac_hang(ah);
-@@ -1542,9 +1542,14 @@ bool ath9k_hw_check_alive(struct ath_hw 
- 	if (AR_SREV_9285_12_OR_LATER(ah))
- 		return true;
- 
-+	last_val = REG_READ(ah, AR_OBS_BUS_1);
- 	do {
- 		reg = REG_READ(ah, AR_OBS_BUS_1);
-+		if (reg != last_val)
-+			return true;
- 
-+		udelay(1);
-+		last_val = reg;
- 		if ((reg & 0x7E7FFFEF) == 0x00702400)
- 			continue;
- 
-@@ -2051,9 +2056,8 @@ static bool ath9k_hw_set_power_awake(str
- 
- 	REG_SET_BIT(ah, AR_RTC_FORCE_WAKE,
- 		    AR_RTC_FORCE_WAKE_EN);
--
- 	if (AR_SREV_9100(ah))
--		udelay(10000);
-+		mdelay(10);
- 	else
- 		udelay(50);
- 
---- a/drivers/net/wireless/ath/ath9k/main.c
-+++ b/drivers/net/wireless/ath/ath9k/main.c
-@@ -451,7 +451,7 @@ void ath9k_tasklet(unsigned long data)
- 		 * interrupts are enabled in the reset routine.
- 		 */
- 		atomic_inc(&ah->intr_ref_cnt);
--		ath_dbg(common, ANY, "FATAL: Skipping interrupts\n");
-+		ath_dbg(common, RESET, "FATAL: Skipping interrupts\n");
- 		goto out;
- 	}
- 
-@@ -471,7 +471,7 @@ void ath9k_tasklet(unsigned long data)
- 			 * interrupts are enabled in the reset routine.
- 			 */
- 			atomic_inc(&ah->intr_ref_cnt);
--			ath_dbg(common, ANY,
-+			ath_dbg(common, RESET,
- 				"BB_WATCHDOG: Skipping interrupts\n");
- 			goto out;
- 		}
-@@ -484,7 +484,7 @@ void ath9k_tasklet(unsigned long data)
- 			type = RESET_TYPE_TX_GTT;
- 			ath9k_queue_reset(sc, type);
- 			atomic_inc(&ah->intr_ref_cnt);
--			ath_dbg(common, ANY,
-+			ath_dbg(common, RESET,
- 				"GTT: Skipping interrupts\n");
- 			goto out;
- 		}
-@@ -1866,7 +1866,7 @@ static void ath9k_set_coverage_class(str
- 
- static bool ath9k_has_tx_pending(struct ath_softc *sc)
- {
--	int i, npend;
-+	int i, npend = 0;
- 
- 	for (i = 0; i < ATH9K_NUM_TX_QUEUES; i++) {
- 		if (!ATH_TXQ_SETUP(sc, i))
---- a/drivers/net/wireless/iwlwifi/mvm/scan.c
-+++ b/drivers/net/wireless/iwlwifi/mvm/scan.c
-@@ -595,6 +595,9 @@ static void iwl_scan_offload_build_ssid(
- 	 * config match list.
- 	 */
- 	for (i = 0; i < req->n_match_sets && i < PROBE_OPTION_MAX; i++) {
-+		/* skip empty SSID matchsets */
-+		if (!req->match_sets[i].ssid.ssid_len)
-+			continue;
- 		scan->direct_scan[i].id = WLAN_EID_SSID;
- 		scan->direct_scan[i].len = req->match_sets[i].ssid.ssid_len;
- 		memcpy(scan->direct_scan[i].ssid, req->match_sets[i].ssid.ssid,
---- a/drivers/net/wireless/rtlwifi/rtl8188ee/trx.c
-+++ b/drivers/net/wireless/rtlwifi/rtl8188ee/trx.c
-@@ -452,7 +452,7 @@ bool rtl88ee_rx_query_desc(struct ieee80
- 			/* During testing, hdr was NULL */
- 			return false;
- 		}
--		if ((ieee80211_is_robust_mgmt_frame(hdr)) &&
-+		if ((_ieee80211_is_robust_mgmt_frame(hdr)) &&
- 		    (ieee80211_has_protected(hdr->frame_control)))
- 			rx_status->flag &= ~RX_FLAG_DECRYPTED;
- 		else
---- a/drivers/net/wireless/rtlwifi/rtl8192ce/trx.c
-+++ b/drivers/net/wireless/rtlwifi/rtl8192ce/trx.c
-@@ -393,7 +393,7 @@ bool rtl92ce_rx_query_desc(struct ieee80
- 			/* In testing, hdr was NULL here */
- 			return false;
- 		}
--		if ((ieee80211_is_robust_mgmt_frame(hdr)) &&
-+		if ((_ieee80211_is_robust_mgmt_frame(hdr)) &&
- 		    (ieee80211_has_protected(hdr->frame_control)))
- 			rx_status->flag &= ~RX_FLAG_DECRYPTED;
- 		else
---- a/drivers/net/wireless/rtlwifi/rtl8192se/trx.c
-+++ b/drivers/net/wireless/rtlwifi/rtl8192se/trx.c
-@@ -310,7 +310,7 @@ bool rtl92se_rx_query_desc(struct ieee80
- 			/* during testing, hdr was NULL here */
- 			return false;
- 		}
--		if ((ieee80211_is_robust_mgmt_frame(hdr)) &&
-+		if ((_ieee80211_is_robust_mgmt_frame(hdr)) &&
- 			(ieee80211_has_protected(hdr->frame_control)))
- 			rx_status->flag &= ~RX_FLAG_DECRYPTED;
- 		else
---- a/drivers/net/wireless/rtlwifi/rtl8723ae/trx.c
-+++ b/drivers/net/wireless/rtlwifi/rtl8723ae/trx.c
-@@ -334,7 +334,7 @@ bool rtl8723ae_rx_query_desc(struct ieee
- 			/* during testing, hdr could be NULL here */
- 			return false;
- 		}
--		if ((ieee80211_is_robust_mgmt_frame(hdr)) &&
-+		if ((_ieee80211_is_robust_mgmt_frame(hdr)) &&
- 			(ieee80211_has_protected(hdr->frame_control)))
- 			rx_status->flag &= ~RX_FLAG_DECRYPTED;
- 		else
---- a/include/linux/ieee80211.h
-+++ b/include/linux/ieee80211.h
-@@ -597,6 +597,20 @@ static inline int ieee80211_is_qos_nullf
- }
- 
- /**
-+ * ieee80211_is_bufferable_mmpdu - check if frame is bufferable MMPDU
-+ * @fc: frame control field in little-endian byteorder
-+ */
-+static inline bool ieee80211_is_bufferable_mmpdu(__le16 fc)
-+{
-+	/* IEEE 802.11-2012, definition of "bufferable management frame";
-+	 * note that this ignores the IBSS special case. */
-+	return ieee80211_is_mgmt(fc) &&
-+	       (ieee80211_is_action(fc) ||
-+		ieee80211_is_disassoc(fc) ||
-+		ieee80211_is_deauth(fc));
-+}
-+
-+/**
-  * ieee80211_is_first_frag - check if IEEE80211_SCTL_FRAG is not set
-  * @seq_ctrl: frame sequence control bytes in little-endian byteorder
-  */
-@@ -2192,10 +2206,10 @@ static inline u8 *ieee80211_get_DA(struc
- }
- 
- /**
-- * ieee80211_is_robust_mgmt_frame - check if frame is a robust management frame
-+ * _ieee80211_is_robust_mgmt_frame - check if frame is a robust management frame
-  * @hdr: the frame (buffer must include at least the first octet of payload)
-  */
--static inline bool ieee80211_is_robust_mgmt_frame(struct ieee80211_hdr *hdr)
-+static inline bool _ieee80211_is_robust_mgmt_frame(struct ieee80211_hdr *hdr)
- {
- 	if (ieee80211_is_disassoc(hdr->frame_control) ||
- 	    ieee80211_is_deauth(hdr->frame_control))
-@@ -2224,6 +2238,17 @@ static inline bool ieee80211_is_robust_m
- }
- 
- /**
-+ * ieee80211_is_robust_mgmt_frame - check if skb contains a robust mgmt frame
-+ * @skb: the skb containing the frame, length will be checked
-+ */
-+static inline bool ieee80211_is_robust_mgmt_frame(struct sk_buff *skb)
-+{
-+	if (skb->len < 25)
-+		return false;
-+	return _ieee80211_is_robust_mgmt_frame((void *)skb->data);
-+}
-+
-+/**
-  * ieee80211_is_public_action - check if frame is a public action frame
-  * @hdr: the frame
-  * @len: length of the frame
---- a/include/net/cfg80211.h
-+++ b/include/net/cfg80211.h
-@@ -1395,9 +1395,11 @@ struct cfg80211_scan_request {
-  * struct cfg80211_match_set - sets of attributes to match
-  *
-  * @ssid: SSID to be matched
-+ * @rssi_thold: don't report scan results below this threshold (in s32 dBm)
-  */
- struct cfg80211_match_set {
- 	struct cfg80211_ssid ssid;
-+	s32 rssi_thold;
- };
- 
- /**
-@@ -1420,7 +1422,8 @@ struct cfg80211_match_set {
-  * @dev: the interface
-  * @scan_start: start time of the scheduled scan
-  * @channels: channels to scan
-- * @rssi_thold: don't report scan results below this threshold (in s32 dBm)
-+ * @min_rssi_thold: for drivers only supporting a single threshold, this
-+ *	contains the minimum over all matchsets
-  */
- struct cfg80211_sched_scan_request {
- 	struct cfg80211_ssid *ssids;
-@@ -1433,7 +1436,7 @@ struct cfg80211_sched_scan_request {
- 	u32 flags;
- 	struct cfg80211_match_set *match_sets;
- 	int n_match_sets;
--	s32 rssi_thold;
-+	s32 min_rssi_thold;
- 
- 	/* internal */
- 	struct wiphy *wiphy;
-@@ -3130,8 +3133,8 @@ struct cfg80211_cached_keys;
-  * @identifier: (private) Identifier used in nl80211 to identify this
-  *	wireless device if it has no netdev
-  * @current_bss: (private) Used by the internal configuration code
-- * @channel: (private) Used by the internal configuration code to track
-- *	the user-set AP, monitor and WDS channel
-+ * @chandef: (private) Used by the internal configuration code to track
-+ *	the user-set channel definition.
-  * @preset_chandef: (private) Used by the internal configuration code to
-  *	track the channel to be used for AP later
-  * @bssid: (private) Used by the internal configuration code
-@@ -3195,9 +3198,7 @@ struct wireless_dev {
- 
- 	struct cfg80211_internal_bss *current_bss; /* associated / joined */
- 	struct cfg80211_chan_def preset_chandef;
--
--	/* for AP and mesh channel tracking */
--	struct ieee80211_channel *channel;
-+	struct cfg80211_chan_def chandef;
- 
- 	bool ibss_fixed;
- 	bool ibss_dfs_possible;
-@@ -3879,6 +3880,7 @@ void cfg80211_michael_mic_failure(struct
-  *
-  * @dev: network device
-  * @bssid: the BSSID of the IBSS joined
-+ * @channel: the channel of the IBSS joined
-  * @gfp: allocation flags
-  *
-  * This function notifies cfg80211 that the device joined an IBSS or
-@@ -3888,7 +3890,8 @@ void cfg80211_michael_mic_failure(struct
-  * with the locally generated beacon -- this guarantees that there is
-  * always a scan result for this IBSS. cfg80211 will handle the rest.
-  */
--void cfg80211_ibss_joined(struct net_device *dev, const u8 *bssid, gfp_t gfp);
-+void cfg80211_ibss_joined(struct net_device *dev, const u8 *bssid,
-+			  struct ieee80211_channel *channel, gfp_t gfp);
- 
- /**
-  * cfg80211_notify_new_candidate - notify cfg80211 of a new mesh peer candidate
---- a/include/uapi/linux/nl80211.h
-+++ b/include/uapi/linux/nl80211.h
-@@ -2442,9 +2442,15 @@ enum nl80211_reg_rule_attr {
-  * enum nl80211_sched_scan_match_attr - scheduled scan match attributes
-  * @__NL80211_SCHED_SCAN_MATCH_ATTR_INVALID: attribute number 0 is reserved
-  * @NL80211_SCHED_SCAN_MATCH_ATTR_SSID: SSID to be used for matching,
-- * only report BSS with matching SSID.
-+ *	only report BSS with matching SSID.
-  * @NL80211_SCHED_SCAN_MATCH_ATTR_RSSI: RSSI threshold (in dBm) for reporting a
-- *	BSS in scan results. Filtering is turned off if not specified.
-+ *	BSS in scan results. Filtering is turned off if not specified. Note that
-+ *	if this attribute is in a match set of its own, then it is treated as
-+ *	the default value for all matchsets with an SSID, rather than being a
-+ *	matchset of its own without an RSSI filter. This is due to problems with
-+ *	how this API was implemented in the past. Also, due to the same problem,
-+ *	the only way to create a matchset with only an RSSI filter (with this
-+ *	attribute) is if there's only a single matchset with the RSSI attribute.
-  * @NL80211_SCHED_SCAN_MATCH_ATTR_MAX: highest scheduled scan filter
-  *	attribute number currently defined
-  * @__NL80211_SCHED_SCAN_MATCH_ATTR_AFTER_LAST: internal use
---- a/net/mac80211/agg-tx.c
-+++ b/net/mac80211/agg-tx.c
-@@ -107,7 +107,7 @@ static void ieee80211_send_addba_request
- 	mgmt->u.action.u.addba_req.start_seq_num =
- 					cpu_to_le16(start_seq_num << 4);
- 
--	ieee80211_tx_skb_tid(sdata, skb, tid);
-+	ieee80211_tx_skb(sdata, skb);
- }
- 
- void ieee80211_send_bar(struct ieee80211_vif *vif, u8 *ra, u16 tid, u16 ssn)
---- a/net/mac80211/cfg.c
-+++ b/net/mac80211/cfg.c
-@@ -970,9 +970,9 @@ static int ieee80211_start_ap(struct wip
- 	/* TODO: make hostapd tell us what it wants */
- 	sdata->smps_mode = IEEE80211_SMPS_OFF;
- 	sdata->needed_rx_chains = sdata->local->rx_chains;
--	sdata->radar_required = params->radar_required;
- 
- 	mutex_lock(&local->mtx);
-+	sdata->radar_required = params->radar_required;
- 	err = ieee80211_vif_use_channel(sdata, &params->chandef,
- 					IEEE80211_CHANCTX_SHARED);
- 	mutex_unlock(&local->mtx);
-@@ -1021,8 +1021,10 @@ static int ieee80211_start_ap(struct wip
- 					IEEE80211_P2P_OPPPS_ENABLE_BIT;
- 
- 	err = ieee80211_assign_beacon(sdata, &params->beacon);
--	if (err < 0)
-+	if (err < 0) {
-+		ieee80211_vif_release_channel(sdata);
- 		return err;
-+	}
- 	changed |= err;
- 
- 	err = drv_start_ap(sdata->local, sdata);
-@@ -1032,6 +1034,7 @@ static int ieee80211_start_ap(struct wip
- 		if (old)
- 			kfree_rcu(old, rcu_head);
- 		RCU_INIT_POINTER(sdata->u.ap.beacon, NULL);
-+		ieee80211_vif_release_channel(sdata);
- 		return err;
- 	}
- 
-@@ -1053,6 +1056,7 @@ static int ieee80211_change_beacon(struc
- 	int err;
- 
- 	sdata = IEEE80211_DEV_TO_SUB_IF(dev);
-+	sdata_assert_lock(sdata);
- 
- 	/* don't allow changing the beacon while CSA is in place - offset
- 	 * of channel switch counter may change
-@@ -1080,6 +1084,8 @@ static int ieee80211_stop_ap(struct wiph
- 	struct probe_resp *old_probe_resp;
- 	struct cfg80211_chan_def chandef;
- 
-+	sdata_assert_lock(sdata);
-+
- 	old_beacon = sdata_dereference(sdata->u.ap.beacon, sdata);
- 	if (!old_beacon)
- 		return -ENOENT;
-@@ -1090,8 +1096,6 @@ static int ieee80211_stop_ap(struct wiph
- 	kfree(sdata->u.ap.next_beacon);
- 	sdata->u.ap.next_beacon = NULL;
- 
--	cancel_work_sync(&sdata->u.ap.request_smps_work);
--
- 	/* turn off carrier for this interface and dependent VLANs */
- 	list_for_each_entry(vlan, &sdata->u.ap.vlans, u.vlan.list)
- 		netif_carrier_off(vlan->dev);
-@@ -1103,6 +1107,7 @@ static int ieee80211_stop_ap(struct wiph
- 	kfree_rcu(old_beacon, rcu_head);
- 	if (old_probe_resp)
- 		kfree_rcu(old_probe_resp, rcu_head);
-+	sdata->u.ap.driver_smps_mode = IEEE80211_SMPS_OFF;
- 
- 	__sta_info_flush(sdata, true);
- 	ieee80211_free_keys(sdata, true);
-@@ -1988,6 +1993,9 @@ static int ieee80211_change_bss(struct w
- 
- 	band = ieee80211_get_sdata_band(sdata);
- 
-+	if (WARN_ON(!wiphy->bands[band]))
-+		return -EINVAL;
-+
- 	if (params->use_cts_prot >= 0) {
- 		sdata->vif.bss_conf.use_cts_prot = params->use_cts_prot;
- 		changed |= BSS_CHANGED_ERP_CTS_PROT;
-@@ -2638,6 +2646,24 @@ static int ieee80211_start_roc_work(stru
- 	INIT_DELAYED_WORK(&roc->work, ieee80211_sw_roc_work);
- 	INIT_LIST_HEAD(&roc->dependents);
- 
-+	/*
-+	 * cookie is either the roc cookie (for normal roc)
-+	 * or the SKB (for mgmt TX)
-+	 */
-+	if (!txskb) {
-+		/* local->mtx protects this */
-+		local->roc_cookie_counter++;
-+		roc->cookie = local->roc_cookie_counter;
-+		/* wow, you wrapped 64 bits ... more likely a bug */
-+		if (WARN_ON(roc->cookie == 0)) {
-+			roc->cookie = 1;
-+			local->roc_cookie_counter++;
-+		}
-+		*cookie = roc->cookie;
-+	} else {
-+		*cookie = (unsigned long)txskb;
-+	}
-+
- 	/* if there's one pending or we're scanning, queue this one */
- 	if (!list_empty(&local->roc_list) ||
- 	    local->scanning || local->radar_detect_enabled)
-@@ -2772,24 +2798,6 @@ static int ieee80211_start_roc_work(stru
- 	if (!queued)
- 		list_add_tail(&roc->list, &local->roc_list);
- 
--	/*
--	 * cookie is either the roc cookie (for normal roc)
--	 * or the SKB (for mgmt TX)
--	 */
--	if (!txskb) {
--		/* local->mtx protects this */
--		local->roc_cookie_counter++;
--		roc->cookie = local->roc_cookie_counter;
--		/* wow, you wrapped 64 bits ... more likely a bug */
--		if (WARN_ON(roc->cookie == 0)) {
--			roc->cookie = 1;
--			local->roc_cookie_counter++;
--		}
--		*cookie = roc->cookie;
--	} else {
--		*cookie = (unsigned long)txskb;
--	}
--
- 	return 0;
- }
- 
-@@ -3004,8 +3012,10 @@ void ieee80211_csa_finalize_work(struct 
- 	if (!ieee80211_sdata_running(sdata))
- 		goto unlock;
- 
--	sdata->radar_required = sdata->csa_radar_required;
-+	sdata_assert_lock(sdata);
-+
- 	mutex_lock(&local->mtx);
-+	sdata->radar_required = sdata->csa_radar_required;
- 	err = ieee80211_vif_change_channel(sdata, &changed);
- 	mutex_unlock(&local->mtx);
- 	if (WARN_ON(err < 0))
-@@ -3022,13 +3032,13 @@ void ieee80211_csa_finalize_work(struct 
- 	switch (sdata->vif.type) {
- 	case NL80211_IFTYPE_AP:
- 		err = ieee80211_assign_beacon(sdata, sdata->u.ap.next_beacon);
-+		kfree(sdata->u.ap.next_beacon);
-+		sdata->u.ap.next_beacon = NULL;
-+
- 		if (err < 0)
- 			goto unlock;
- 
- 		changed |= err;
--		kfree(sdata->u.ap.next_beacon);
--		sdata->u.ap.next_beacon = NULL;
--
- 		ieee80211_bss_info_change_notify(sdata, err);
- 		break;
- 	case NL80211_IFTYPE_ADHOC:
-@@ -3066,7 +3076,7 @@ int ieee80211_channel_switch(struct wiph
- 	struct ieee80211_if_mesh __maybe_unused *ifmsh;
- 	int err, num_chanctx;
- 
--	lockdep_assert_held(&sdata->wdev.mtx);
-+	sdata_assert_lock(sdata);
- 
- 	if (!list_empty(&local->roc_list) || local->scanning)
- 		return -EBUSY;
---- a/net/mac80211/ht.c
-+++ b/net/mac80211/ht.c
-@@ -375,7 +375,7 @@ void ieee80211_send_delba(struct ieee802
- 	mgmt->u.action.u.delba.params = cpu_to_le16(params);
- 	mgmt->u.action.u.delba.reason_code = cpu_to_le16(reason_code);
- 
--	ieee80211_tx_skb_tid(sdata, skb, tid);
-+	ieee80211_tx_skb(sdata, skb);
- }
- 
- void ieee80211_process_delba(struct ieee80211_sub_if_data *sdata,
-@@ -466,7 +466,9 @@ void ieee80211_request_smps_ap_work(stru
- 			     u.ap.request_smps_work);
- 
- 	sdata_lock(sdata);
--	__ieee80211_request_smps_ap(sdata, sdata->u.ap.driver_smps_mode);
-+	if (sdata_dereference(sdata->u.ap.beacon, sdata))
-+		__ieee80211_request_smps_ap(sdata,
-+					    sdata->u.ap.driver_smps_mode);
- 	sdata_unlock(sdata);
- }
- 
---- a/net/mac80211/iface.c
-+++ b/net/mac80211/iface.c
-@@ -770,12 +770,19 @@ static void ieee80211_do_stop(struct iee
- 
- 	ieee80211_roc_purge(local, sdata);
- 
--	if (sdata->vif.type == NL80211_IFTYPE_STATION)
-+	switch (sdata->vif.type) {
-+	case NL80211_IFTYPE_STATION:
- 		ieee80211_mgd_stop(sdata);
--
--	if (sdata->vif.type == NL80211_IFTYPE_ADHOC)
-+		break;
-+	case NL80211_IFTYPE_ADHOC:
- 		ieee80211_ibss_stop(sdata);
--
-+		break;
-+	case NL80211_IFTYPE_AP:
-+		cancel_work_sync(&sdata->u.ap.request_smps_work);
-+		break;
-+	default:
-+		break;
-+	}
- 
- 	/*
- 	 * Remove all stations associated with this interface.
-@@ -827,7 +834,9 @@ static void ieee80211_do_stop(struct iee
- 	cancel_work_sync(&local->dynamic_ps_enable_work);
- 
- 	cancel_work_sync(&sdata->recalc_smps);
-+	sdata_lock(sdata);
- 	sdata->vif.csa_active = false;
-+	sdata_unlock(sdata);
- 	cancel_work_sync(&sdata->csa_finalize_work);
- 
- 	cancel_delayed_work_sync(&sdata->dfs_cac_timer_work);
---- a/net/mac80211/rx.c
-+++ b/net/mac80211/rx.c
-@@ -599,10 +599,10 @@ static int ieee80211_is_unicast_robust_m
- {
- 	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;
- 
--	if (skb->len < 24 || is_multicast_ether_addr(hdr->addr1))
-+	if (is_multicast_ether_addr(hdr->addr1))
- 		return 0;
- 
--	return ieee80211_is_robust_mgmt_frame(hdr);
-+	return ieee80211_is_robust_mgmt_frame(skb);
- }
- 
- 
-@@ -610,10 +610,10 @@ static int ieee80211_is_multicast_robust
- {
- 	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;
- 
--	if (skb->len < 24 || !is_multicast_ether_addr(hdr->addr1))
-+	if (!is_multicast_ether_addr(hdr->addr1))
- 		return 0;
- 
--	return ieee80211_is_robust_mgmt_frame(hdr);
-+	return ieee80211_is_robust_mgmt_frame(skb);
- }
- 
- 
-@@ -626,7 +626,7 @@ static int ieee80211_get_mmie_keyidx(str
- 	if (skb->len < 24 + sizeof(*mmie) || !is_multicast_ether_addr(hdr->da))
- 		return -1;
- 
--	if (!ieee80211_is_robust_mgmt_frame((struct ieee80211_hdr *) hdr))
-+	if (!ieee80211_is_robust_mgmt_frame(skb))
- 		return -1; /* not a robust management frame */
- 
- 	mmie = (struct ieee80211_mmie *)
-@@ -1128,6 +1128,13 @@ static void sta_ps_end(struct sta_info *
- 	       sta->sta.addr, sta->sta.aid);
- 
- 	if (test_sta_flag(sta, WLAN_STA_PS_DRIVER)) {
-+		/*
-+		 * Clear the flag only if the other one is still set
-+		 * so that the TX path won't start TX'ing new frames
-+		 * directly ... In the case that the driver flag isn't
-+		 * set ieee80211_sta_ps_deliver_wakeup() will clear it.
-+		 */
-+		clear_sta_flag(sta, WLAN_STA_PS_STA);
- 		ps_dbg(sta->sdata, "STA %pM aid %d driver-ps-blocked\n",
- 		       sta->sta.addr, sta->sta.aid);
- 		return;
-@@ -1311,18 +1318,15 @@ ieee80211_rx_h_sta_process(struct ieee80
- 	    !ieee80211_has_morefrags(hdr->frame_control) &&
- 	    !(status->rx_flags & IEEE80211_RX_DEFERRED_RELEASE) &&
- 	    (rx->sdata->vif.type == NL80211_IFTYPE_AP ||
--	     rx->sdata->vif.type == NL80211_IFTYPE_AP_VLAN)) {
-+	     rx->sdata->vif.type == NL80211_IFTYPE_AP_VLAN) &&
-+	    /* PM bit is only checked in frames where it isn't reserved,
-+	     * in AP mode it's reserved in non-bufferable management frames
-+	     * (cf. IEEE 802.11-2012 8.2.4.1.7 Power Management field)
-+	     */
-+	    (!ieee80211_is_mgmt(hdr->frame_control) ||
-+	     ieee80211_is_bufferable_mmpdu(hdr->frame_control))) {
- 		if (test_sta_flag(sta, WLAN_STA_PS_STA)) {
--			/*
--			 * Ignore doze->wake transitions that are
--			 * indicated by non-data frames, the standard
--			 * is unclear here, but for example going to
--			 * PS mode and then scanning would cause a
--			 * doze->wake transition for the probe request,
--			 * and that is clearly undesirable.
--			 */
--			if (ieee80211_is_data(hdr->frame_control) &&
--			    !ieee80211_has_pm(hdr->frame_control))
-+			if (!ieee80211_has_pm(hdr->frame_control))
- 				sta_ps_end(sta);
- 		} else {
- 			if (ieee80211_has_pm(hdr->frame_control))
-@@ -1845,8 +1849,7 @@ static int ieee80211_drop_unencrypted_mg
- 		 * having configured keys.
- 		 */
- 		if (unlikely(ieee80211_is_action(fc) && !rx->key &&
--			     ieee80211_is_robust_mgmt_frame(
--				     (struct ieee80211_hdr *) rx->skb->data)))
-+			     ieee80211_is_robust_mgmt_frame(rx->skb)))
- 			return -EACCES;
- 	}
- 
---- a/net/mac80211/tx.c
-+++ b/net/mac80211/tx.c
-@@ -452,8 +452,7 @@ static int ieee80211_use_mfp(__le16 fc, 
- 	if (sta == NULL || !test_sta_flag(sta, WLAN_STA_MFP))
- 		return 0;
- 
--	if (!ieee80211_is_robust_mgmt_frame((struct ieee80211_hdr *)
--					    skb->data))
-+	if (!ieee80211_is_robust_mgmt_frame(skb))
- 		return 0;
- 
- 	return 1;
-@@ -478,6 +477,20 @@ ieee80211_tx_h_unicast_ps_buf(struct iee
- 		       sta->sta.addr, sta->sta.aid, ac);
- 		if (tx->local->total_ps_buffered >= TOTAL_MAX_TX_BUFFER)
- 			purge_old_ps_buffers(tx->local);
-+
-+		/* sync with ieee80211_sta_ps_deliver_wakeup */
-+		spin_lock(&sta->ps_lock);
-+		/*
-+		 * STA woke up the meantime and all the frames on ps_tx_buf have
-+		 * been queued to pending queue. No reordering can happen, go
-+		 * ahead and Tx the packet.
-+		 */
-+		if (!test_sta_flag(sta, WLAN_STA_PS_STA) &&
-+		    !test_sta_flag(sta, WLAN_STA_PS_DRIVER)) {
-+			spin_unlock(&sta->ps_lock);
-+			return TX_CONTINUE;
-+		}
-+
- 		if (skb_queue_len(&sta->ps_tx_buf[ac]) >= STA_MAX_TX_BUFFER) {
- 			struct sk_buff *old = skb_dequeue(&sta->ps_tx_buf[ac]);
- 			ps_dbg(tx->sdata,
-@@ -492,6 +505,7 @@ ieee80211_tx_h_unicast_ps_buf(struct iee
- 		info->flags |= IEEE80211_TX_INTFL_NEED_TXPROCESSING;
- 		info->flags &= ~IEEE80211_TX_TEMPORARY_FLAGS;
- 		skb_queue_tail(&sta->ps_tx_buf[ac], tx->skb);
-+		spin_unlock(&sta->ps_lock);
- 
- 		if (!timer_pending(&local->sta_cleanup))
- 			mod_timer(&local->sta_cleanup,
-@@ -525,9 +539,7 @@ ieee80211_tx_h_ps_buf(struct ieee80211_t
- 
- 	/* only deauth, disassoc and action are bufferable MMPDUs */
- 	if (ieee80211_is_mgmt(hdr->frame_control) &&
--	    !ieee80211_is_deauth(hdr->frame_control) &&
--	    !ieee80211_is_disassoc(hdr->frame_control) &&
--	    !ieee80211_is_action(hdr->frame_control)) {
-+	    !ieee80211_is_bufferable_mmpdu(hdr->frame_control)) {
- 		if (tx->flags & IEEE80211_TX_UNICAST)
- 			info->flags |= IEEE80211_TX_CTL_NO_PS_BUFFER;
- 		return TX_CONTINUE;
-@@ -567,7 +579,7 @@ ieee80211_tx_h_select_key(struct ieee802
- 		tx->key = key;
- 	else if (ieee80211_is_mgmt(hdr->frame_control) &&
- 		 is_multicast_ether_addr(hdr->addr1) &&
--		 ieee80211_is_robust_mgmt_frame(hdr) &&
-+		 ieee80211_is_robust_mgmt_frame(tx->skb) &&
- 		 (key = rcu_dereference(tx->sdata->default_mgmt_key)))
- 		tx->key = key;
- 	else if (is_multicast_ether_addr(hdr->addr1) &&
-@@ -582,12 +594,12 @@ ieee80211_tx_h_select_key(struct ieee802
- 		tx->key = NULL;
- 	else if (tx->skb->protocol == tx->sdata->control_port_protocol)
- 		tx->key = NULL;
--	else if (ieee80211_is_robust_mgmt_frame(hdr) &&
-+	else if (ieee80211_is_robust_mgmt_frame(tx->skb) &&
- 		 !(ieee80211_is_action(hdr->frame_control) &&
- 		   tx->sta && test_sta_flag(tx->sta, WLAN_STA_MFP)))
- 		tx->key = NULL;
- 	else if (ieee80211_is_mgmt(hdr->frame_control) &&
--		 !ieee80211_is_robust_mgmt_frame(hdr))
-+		 !ieee80211_is_robust_mgmt_frame(tx->skb))
- 		tx->key = NULL;
- 	else {
- 		I802_DEBUG_INC(tx->local->tx_handlers_drop_unencrypted);
-@@ -878,7 +890,7 @@ static int ieee80211_fragment(struct iee
- 	}
- 
- 	/* adjust first fragment's length */
--	skb->len = hdrlen + per_fragm;
-+	skb_trim(skb, hdrlen + per_fragm);
- 	return 0;
- }
- 
-@@ -2900,7 +2912,7 @@ ieee80211_get_buffered_bc(struct ieee802
- 				cpu_to_le16(IEEE80211_FCTL_MOREDATA);
- 		}
- 
--		if (sdata->vif.type == NL80211_IFTYPE_AP_VLAN)
-+		if (sdata->vif.type == NL80211_IFTYPE_AP)
- 			sdata = IEEE80211_DEV_TO_SUB_IF(skb->dev);
- 		if (!ieee80211_tx_prepare(sdata, &tx, skb))
- 			break;
---- a/net/mac80211/wpa.c
-+++ b/net/mac80211/wpa.c
-@@ -499,7 +499,7 @@ ieee80211_crypto_ccmp_decrypt(struct iee
- 	hdrlen = ieee80211_hdrlen(hdr->frame_control);
- 
- 	if (!ieee80211_is_data(hdr->frame_control) &&
--	    !ieee80211_is_robust_mgmt_frame(hdr))
-+	    !ieee80211_is_robust_mgmt_frame(skb))
- 		return RX_CONTINUE;
- 
- 	data_len = skb->len - hdrlen - IEEE80211_CCMP_HDR_LEN -
---- a/net/wireless/ap.c
-+++ b/net/wireless/ap.c
-@@ -27,9 +27,10 @@ static int __cfg80211_stop_ap(struct cfg
- 	err = rdev_stop_ap(rdev, dev);
- 	if (!err) {
- 		wdev->beacon_interval = 0;
--		wdev->channel = NULL;
-+		memset(&wdev->chandef, 0, sizeof(wdev->chandef));
- 		wdev->ssid_len = 0;
- 		rdev_set_qos_map(rdev, dev, NULL);
-+		nl80211_send_ap_stopped(wdev);
- 	}
- 
- 	return err;
---- a/net/wireless/core.c
-+++ b/net/wireless/core.c
-@@ -203,8 +203,11 @@ void cfg80211_stop_p2p_device(struct cfg
- 
- 	rdev->opencount--;
- 
--	WARN_ON(rdev->scan_req && rdev->scan_req->wdev == wdev &&
--		!rdev->scan_req->notified);
-+	if (rdev->scan_req && rdev->scan_req->wdev == wdev) {
-+		if (WARN_ON(!rdev->scan_req->notified))
-+			rdev->scan_req->aborted = true;
-+		___cfg80211_scan_done(rdev, false);
-+	}
- }
- 
- static int cfg80211_rfkill_set_block(void *data, bool blocked)
-@@ -447,9 +450,6 @@ int wiphy_register(struct wiphy *wiphy)
- 	int i;
- 	u16 ifmodes = wiphy->interface_modes;
- 
--	/* support for 5/10 MHz is broken due to nl80211 API mess - disable */
--	wiphy->flags &= ~WIPHY_FLAG_SUPPORTS_5_10_MHZ;
--
- 	/*
- 	 * There are major locking problems in nl80211/mac80211 for CSA,
- 	 * disable for all drivers until this has been reworked.
-@@ -795,8 +795,6 @@ void cfg80211_leave(struct cfg80211_regi
- 	default:
- 		break;
- 	}
--
--	wdev->beacon_interval = 0;
- }
- 
- static int cfg80211_netdev_notifier_call(struct notifier_block *nb,
-@@ -875,8 +873,11 @@ static int cfg80211_netdev_notifier_call
- 		break;
- 	case NETDEV_DOWN:
- 		cfg80211_update_iface_num(rdev, wdev->iftype, -1);
--		WARN_ON(rdev->scan_req && rdev->scan_req->wdev == wdev &&
--			!rdev->scan_req->notified);
-+		if (rdev->scan_req && rdev->scan_req->wdev == wdev) {
-+			if (WARN_ON(!rdev->scan_req->notified))
-+				rdev->scan_req->aborted = true;
-+			___cfg80211_scan_done(rdev, false);
-+		}
- 
- 		if (WARN_ON(rdev->sched_scan_req &&
- 			    rdev->sched_scan_req->dev == wdev->netdev)) {
---- a/net/wireless/core.h
-+++ b/net/wireless/core.h
-@@ -62,6 +62,7 @@ struct cfg80211_registered_device {
- 	struct rb_root bss_tree;
- 	u32 bss_generation;
- 	struct cfg80211_scan_request *scan_req; /* protected by RTNL */
-+	struct sk_buff *scan_msg;
- 	struct cfg80211_sched_scan_request *sched_scan_req;
- 	unsigned long suspend_at;
- 	struct work_struct scan_done_wk;
-@@ -210,6 +211,7 @@ struct cfg80211_event {
- 		} dc;
- 		struct {
- 			u8 bssid[ETH_ALEN];
-+			struct ieee80211_channel *channel;
- 		} ij;
- 	};
- };
-@@ -257,7 +259,8 @@ int __cfg80211_leave_ibss(struct cfg8021
- 			  struct net_device *dev, bool nowext);
- int cfg80211_leave_ibss(struct cfg80211_registered_device *rdev,
- 			struct net_device *dev, bool nowext);
--void __cfg80211_ibss_joined(struct net_device *dev, const u8 *bssid);
-+void __cfg80211_ibss_joined(struct net_device *dev, const u8 *bssid,
-+			    struct ieee80211_channel *channel);
- int cfg80211_ibss_wext_join(struct cfg80211_registered_device *rdev,
- 			    struct wireless_dev *wdev);
- 
-@@ -361,7 +364,8 @@ int cfg80211_validate_key_settings(struc
- 				   struct key_params *params, int key_idx,
- 				   bool pairwise, const u8 *mac_addr);
- void __cfg80211_scan_done(struct work_struct *wk);
--void ___cfg80211_scan_done(struct cfg80211_registered_device *rdev);
-+void ___cfg80211_scan_done(struct cfg80211_registered_device *rdev,
-+			   bool send_message);
- void __cfg80211_sched_scan_results(struct work_struct *wk);
- int __cfg80211_stop_sched_scan(struct cfg80211_registered_device *rdev,
- 			       bool driver_initiated);
-@@ -441,7 +445,8 @@ static inline unsigned int elapsed_jiffi
- void
- cfg80211_get_chan_state(struct wireless_dev *wdev,
- 		        struct ieee80211_channel **chan,
--		        enum cfg80211_chan_mode *chanmode);
-+		        enum cfg80211_chan_mode *chanmode,
-+		        u8 *radar_detect);
- 
- int cfg80211_set_monitor_channel(struct cfg80211_registered_device *rdev,
- 				 struct cfg80211_chan_def *chandef);
---- a/net/wireless/nl80211.c
-+++ b/net/wireless/nl80211.c
-@@ -1723,9 +1723,10 @@ static int nl80211_dump_wiphy(struct sk_
- 				 * We can then retry with the larger buffer.
- 				 */
- 				if ((ret == -ENOBUFS || ret == -EMSGSIZE) &&
--				    !skb->len &&
-+				    !skb->len && !state->split &&
- 				    cb->min_dump_alloc < 4096) {
- 					cb->min_dump_alloc = 4096;
-+					state->split_start = 0;
- 					rtnl_unlock();
- 					return 1;
- 				}
-@@ -2047,10 +2048,12 @@ static int nl80211_set_wiphy(struct sk_b
- 		nla_for_each_nested(nl_txq_params,
- 				    info->attrs[NL80211_ATTR_WIPHY_TXQ_PARAMS],
- 				    rem_txq_params) {
--			nla_parse(tb, NL80211_TXQ_ATTR_MAX,
--				  nla_data(nl_txq_params),
--				  nla_len(nl_txq_params),
--				  txq_params_policy);
-+			result = nla_parse(tb, NL80211_TXQ_ATTR_MAX,
-+					   nla_data(nl_txq_params),
-+					   nla_len(nl_txq_params),
-+					   txq_params_policy);
-+			if (result)
-+				goto bad_res;
- 			result = parse_txq_params(tb, &txq_params);
- 			if (result)
- 				goto bad_res;
-@@ -3289,7 +3292,7 @@ static int nl80211_start_ap(struct sk_bu
- 	if (!err) {
- 		wdev->preset_chandef = params.chandef;
- 		wdev->beacon_interval = params.beacon_interval;
--		wdev->channel = params.chandef.chan;
-+		wdev->chandef = params.chandef;
- 		wdev->ssid_len = params.ssid_len;
- 		memcpy(wdev->ssid, params.ssid, wdev->ssid_len);
- 	}
-@@ -5210,9 +5213,11 @@ static int nl80211_set_reg(struct sk_buf
- 
- 	nla_for_each_nested(nl_reg_rule, info->attrs[NL80211_ATTR_REG_RULES],
- 			    rem_reg_rules) {
--		nla_parse(tb, NL80211_REG_RULE_ATTR_MAX,
--			  nla_data(nl_reg_rule), nla_len(nl_reg_rule),
--			  reg_rule_policy);
-+		r = nla_parse(tb, NL80211_REG_RULE_ATTR_MAX,
-+			      nla_data(nl_reg_rule), nla_len(nl_reg_rule),
-+			      reg_rule_policy);
-+		if (r)
-+			goto bad_reg;
- 		r = parse_reg_rule(tb, &rd->reg_rules[rule_idx]);
- 		if (r)
- 			goto bad_reg;
-@@ -5277,7 +5282,7 @@ static int nl80211_trigger_scan(struct s
- 	if (!rdev->ops->scan)
- 		return -EOPNOTSUPP;
- 
--	if (rdev->scan_req) {
-+	if (rdev->scan_req || rdev->scan_msg) {
- 		err = -EBUSY;
- 		goto unlock;
- 	}
-@@ -5475,6 +5480,7 @@ static int nl80211_start_sched_scan(stru
- 	enum ieee80211_band band;
- 	size_t ie_len;
- 	struct nlattr *tb[NL80211_SCHED_SCAN_MATCH_ATTR_MAX + 1];
-+	s32 default_match_rssi = NL80211_SCAN_RSSI_THOLD_OFF;
- 
- 	if (!(rdev->wiphy.flags & WIPHY_FLAG_SUPPORTS_SCHED_SCAN) ||
- 	    !rdev->ops->sched_scan_start)
-@@ -5509,11 +5515,40 @@ static int nl80211_start_sched_scan(stru
- 	if (n_ssids > wiphy->max_sched_scan_ssids)
- 		return -EINVAL;
- 
--	if (info->attrs[NL80211_ATTR_SCHED_SCAN_MATCH])
-+	/*
-+	 * First, count the number of 'real' matchsets. Due to an issue with
-+	 * the old implementation, matchsets containing only the RSSI attribute
-+	 * (NL80211_SCHED_SCAN_MATCH_ATTR_RSSI) are considered as the 'default'
-+	 * RSSI for all matchsets, rather than their own matchset for reporting
-+	 * all APs with a strong RSSI. This is needed to be compatible with
-+	 * older userspace that treated a matchset with only the RSSI as the
-+	 * global RSSI for all other matchsets - if there are other matchsets.
-+	 */
-+	if (info->attrs[NL80211_ATTR_SCHED_SCAN_MATCH]) {
- 		nla_for_each_nested(attr,
- 				    info->attrs[NL80211_ATTR_SCHED_SCAN_MATCH],
--				    tmp)
--			n_match_sets++;
-+				    tmp) {
-+			struct nlattr *rssi;
-+
-+			err = nla_parse(tb, NL80211_SCHED_SCAN_MATCH_ATTR_MAX,
-+					nla_data(attr), nla_len(attr),
-+					nl80211_match_policy);
-+			if (err)
-+				return err;
-+			/* add other standalone attributes here */
-+			if (tb[NL80211_SCHED_SCAN_MATCH_ATTR_SSID]) {
-+				n_match_sets++;
-+				continue;
-+			}
-+			rssi = tb[NL80211_SCHED_SCAN_MATCH_ATTR_RSSI];
-+			if (rssi)
-+				default_match_rssi = nla_get_s32(rssi);
-+		}
-+	}
-+
-+	/* However, if there's no other matchset, add the RSSI one */
-+	if (!n_match_sets && default_match_rssi != NL80211_SCAN_RSSI_THOLD_OFF)
-+		n_match_sets = 1;
- 
- 	if (n_match_sets > wiphy->max_match_sets)
- 		return -EINVAL;
-@@ -5634,11 +5669,22 @@ static int nl80211_start_sched_scan(stru
- 				    tmp) {
- 			struct nlattr *ssid, *rssi;
- 
--			nla_parse(tb, NL80211_SCHED_SCAN_MATCH_ATTR_MAX,
--				  nla_data(attr), nla_len(attr),
--				  nl80211_match_policy);
-+			err = nla_parse(tb, NL80211_SCHED_SCAN_MATCH_ATTR_MAX,
-+					nla_data(attr), nla_len(attr),
-+					nl80211_match_policy);
-+			if (err)
-+				goto out_free;
- 			ssid = tb[NL80211_SCHED_SCAN_MATCH_ATTR_SSID];
- 			if (ssid) {
-+				if (WARN_ON(i >= n_match_sets)) {
-+					/* this indicates a programming error,
-+					 * the loop above should have verified
-+					 * things properly
-+					 */
-+					err = -EINVAL;
-+					goto out_free;
-+				}
-+
- 				if (nla_len(ssid) > IEEE80211_MAX_SSID_LEN) {
- 					err = -EINVAL;
- 					goto out_free;
-@@ -5647,15 +5693,28 @@ static int nl80211_start_sched_scan(stru
- 				       nla_data(ssid), nla_len(ssid));
- 				request->match_sets[i].ssid.ssid_len =
- 					nla_len(ssid);
-+				/* special attribute - old implemenation w/a */
-+				request->match_sets[i].rssi_thold =
-+					default_match_rssi;
-+				rssi = tb[NL80211_SCHED_SCAN_MATCH_ATTR_RSSI];
-+				if (rssi)
-+					request->match_sets[i].rssi_thold =
-+						nla_get_s32(rssi);
- 			}
--			rssi = tb[NL80211_SCHED_SCAN_MATCH_ATTR_RSSI];
--			if (rssi)
--				request->rssi_thold = nla_get_u32(rssi);
--			else
--				request->rssi_thold =
--						   NL80211_SCAN_RSSI_THOLD_OFF;
- 			i++;
- 		}
-+
-+		/* there was no other matchset, so the RSSI one is alone */
-+		if (i == 0)
-+			request->match_sets[0].rssi_thold = default_match_rssi;
-+
-+		request->min_rssi_thold = INT_MAX;
-+		for (i = 0; i < n_match_sets; i++)
-+			request->min_rssi_thold =
-+				min(request->match_sets[i].rssi_thold,
-+				    request->min_rssi_thold);
-+	} else {
-+		request->min_rssi_thold = NL80211_SCAN_RSSI_THOLD_OFF;
- 	}
- 
- 	if (info->attrs[NL80211_ATTR_IE]) {
-@@ -5751,7 +5810,7 @@ static int nl80211_start_radar_detection
- 
- 	err = rdev->ops->start_radar_detection(&rdev->wiphy, dev, &chandef);
- 	if (!err) {
--		wdev->channel = chandef.chan;
-+		wdev->chandef = chandef;
- 		wdev->cac_started = true;
- 		wdev->cac_start_time = jiffies;
- 	}
-@@ -7502,16 +7561,19 @@ static int nl80211_set_tx_bitrate_mask(s
- 	 * directly to the enum ieee80211_band values used in cfg80211.
- 	 */
- 	BUILD_BUG_ON(NL80211_MAX_SUPP_HT_RATES > IEEE80211_HT_MCS_MASK_LEN * 8);
--	nla_for_each_nested(tx_rates, info->attrs[NL80211_ATTR_TX_RATES], rem)
--	{
-+	nla_for_each_nested(tx_rates, info->attrs[NL80211_ATTR_TX_RATES], rem) {
- 		enum ieee80211_band band = nla_type(tx_rates);
-+		int err;
-+
- 		if (band < 0 || band >= IEEE80211_NUM_BANDS)
- 			return -EINVAL;
- 		sband = rdev->wiphy.bands[band];
- 		if (sband == NULL)
- 			return -EINVAL;
--		nla_parse(tb, NL80211_TXRATE_MAX, nla_data(tx_rates),
--			  nla_len(tx_rates), nl80211_txattr_policy);
-+		err = nla_parse(tb, NL80211_TXRATE_MAX, nla_data(tx_rates),
-+				nla_len(tx_rates), nl80211_txattr_policy);
-+		if (err)
-+			return err;
- 		if (tb[NL80211_TXRATE_LEGACY]) {
- 			mask.control[band].legacy = rateset_to_mask(
- 				sband,
-@@ -10054,40 +10116,31 @@ void nl80211_send_scan_start(struct cfg8
- 				NL80211_MCGRP_SCAN, GFP_KERNEL);
- }
- 
--void nl80211_send_scan_done(struct cfg80211_registered_device *rdev,
--			    struct wireless_dev *wdev)
-+struct sk_buff *nl80211_build_scan_msg(struct cfg80211_registered_device *rdev,
-+				       struct wireless_dev *wdev, bool aborted)
- {
- 	struct sk_buff *msg;
- 
- 	msg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);
- 	if (!msg)
--		return;
-+		return NULL;
- 
- 	if (nl80211_send_scan_msg(msg, rdev, wdev, 0, 0, 0,
--				  NL80211_CMD_NEW_SCAN_RESULTS) < 0) {
-+				  aborted ? NL80211_CMD_SCAN_ABORTED :
-+					    NL80211_CMD_NEW_SCAN_RESULTS) < 0) {
- 		nlmsg_free(msg);
--		return;
-+		return NULL;
- 	}
- 
--	genlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,
--				NL80211_MCGRP_SCAN, GFP_KERNEL);
-+	return msg;
- }
- 
--void nl80211_send_scan_aborted(struct cfg80211_registered_device *rdev,
--			       struct wireless_dev *wdev)
-+void nl80211_send_scan_result(struct cfg80211_registered_device *rdev,
-+			      struct sk_buff *msg)
- {
--	struct sk_buff *msg;
--
--	msg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);
- 	if (!msg)
- 		return;
- 
--	if (nl80211_send_scan_msg(msg, rdev, wdev, 0, 0, 0,
--				  NL80211_CMD_SCAN_ABORTED) < 0) {
--		nlmsg_free(msg);
--		return;
--	}
--
- 	genlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,
- 				NL80211_MCGRP_SCAN, GFP_KERNEL);
- }
-@@ -11158,7 +11211,8 @@ void cfg80211_ch_switch_notify(struct ne
- 		    wdev->iftype != NL80211_IFTYPE_MESH_POINT))
- 		return;
- 
--	wdev->channel = chandef->chan;
-+	wdev->chandef = *chandef;
-+	wdev->preset_chandef = *chandef;
- 	nl80211_ch_switch_notify(rdev, dev, chandef, GFP_KERNEL);
- }
- EXPORT_SYMBOL(cfg80211_ch_switch_notify);
-@@ -11673,6 +11727,35 @@ void cfg80211_crit_proto_stopped(struct 
- }
- EXPORT_SYMBOL(cfg80211_crit_proto_stopped);
- 
-+void nl80211_send_ap_stopped(struct wireless_dev *wdev)
-+{
-+	struct wiphy *wiphy = wdev->wiphy;
-+	struct cfg80211_registered_device *rdev = wiphy_to_dev(wiphy);
-+	struct sk_buff *msg;
-+	void *hdr;
-+
-+	msg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);
-+	if (!msg)
-+		return;
-+
-+	hdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_STOP_AP);
-+	if (!hdr)
-+		goto out;
-+
-+	if (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||
-+	    nla_put_u32(msg, NL80211_ATTR_IFINDEX, wdev->netdev->ifindex) ||
-+	    nla_put_u64(msg, NL80211_ATTR_WDEV, wdev_id(wdev)))
-+		goto out;
-+
-+	genlmsg_end(msg, hdr);
-+
-+	genlmsg_multicast_netns(&nl80211_fam, wiphy_net(wiphy), msg, 0,
-+				NL80211_MCGRP_MLME, GFP_KERNEL);
-+	return;
-+ out:
-+	nlmsg_free(msg);
-+}
-+
- /* initialisation/exit functions */
- 
- int nl80211_init(void)
---- a/net/wireless/nl80211.h
-+++ b/net/wireless/nl80211.h
-@@ -8,10 +8,10 @@ void nl80211_exit(void);
- void nl80211_notify_dev_rename(struct cfg80211_registered_device *rdev);
- void nl80211_send_scan_start(struct cfg80211_registered_device *rdev,
- 			     struct wireless_dev *wdev);
--void nl80211_send_scan_done(struct cfg80211_registered_device *rdev,
--			    struct wireless_dev *wdev);
--void nl80211_send_scan_aborted(struct cfg80211_registered_device *rdev,
--			       struct wireless_dev *wdev);
-+struct sk_buff *nl80211_build_scan_msg(struct cfg80211_registered_device *rdev,
-+				       struct wireless_dev *wdev, bool aborted);
-+void nl80211_send_scan_result(struct cfg80211_registered_device *rdev,
-+			      struct sk_buff *msg);
- void nl80211_send_sched_scan(struct cfg80211_registered_device *rdev,
- 			     struct net_device *netdev, u32 cmd);
- void nl80211_send_sched_scan_results(struct cfg80211_registered_device *rdev,
-@@ -74,6 +74,8 @@ nl80211_radar_notify(struct cfg80211_reg
- 		     enum nl80211_radar_event event,
- 		     struct net_device *netdev, gfp_t gfp);
- 
-+void nl80211_send_ap_stopped(struct wireless_dev *wdev);
-+
- void cfg80211_rdev_free_coalesce(struct cfg80211_registered_device *rdev);
- 
- #endif /* __NET_WIRELESS_NL80211_H */
---- a/net/wireless/scan.c
-+++ b/net/wireless/scan.c
-@@ -161,18 +161,25 @@ static void __cfg80211_bss_expire(struct
- 		dev->bss_generation++;
- }
- 
--void ___cfg80211_scan_done(struct cfg80211_registered_device *rdev)
-+void ___cfg80211_scan_done(struct cfg80211_registered_device *rdev,
-+			   bool send_message)
- {
- 	struct cfg80211_scan_request *request;
- 	struct wireless_dev *wdev;
-+	struct sk_buff *msg;
- #ifdef CPTCFG_CFG80211_WEXT
- 	union iwreq_data wrqu;
- #endif
- 
- 	ASSERT_RTNL();
- 
--	request = rdev->scan_req;
-+	if (rdev->scan_msg) {
-+		nl80211_send_scan_result(rdev, rdev->scan_msg);
-+		rdev->scan_msg = NULL;
-+		return;
-+	}
- 
-+	request = rdev->scan_req;
- 	if (!request)
- 		return;
- 
-@@ -186,18 +193,16 @@ void ___cfg80211_scan_done(struct cfg802
- 	if (wdev->netdev)
- 		cfg80211_sme_scan_done(wdev->netdev);
- 
--	if (request->aborted) {
--		nl80211_send_scan_aborted(rdev, wdev);
--	} else {
--		if (request->flags & NL80211_SCAN_FLAG_FLUSH) {
--			/* flush entries from previous scans */
--			spin_lock_bh(&rdev->bss_lock);
--			__cfg80211_bss_expire(rdev, request->scan_start);
--			spin_unlock_bh(&rdev->bss_lock);
--		}
--		nl80211_send_scan_done(rdev, wdev);
-+	if (!request->aborted &&
-+	    request->flags & NL80211_SCAN_FLAG_FLUSH) {
-+		/* flush entries from previous scans */
-+		spin_lock_bh(&rdev->bss_lock);
-+		__cfg80211_bss_expire(rdev, request->scan_start);
-+		spin_unlock_bh(&rdev->bss_lock);
- 	}
- 
-+	msg = nl80211_build_scan_msg(rdev, wdev, request->aborted);
-+
- #ifdef CPTCFG_CFG80211_WEXT
- 	if (wdev->netdev && !request->aborted) {
- 		memset(&wrqu, 0, sizeof(wrqu));
-@@ -211,6 +216,11 @@ void ___cfg80211_scan_done(struct cfg802
- 
- 	rdev->scan_req = NULL;
- 	kfree(request);
-+
-+	if (!send_message)
-+		rdev->scan_msg = msg;
-+	else
-+		nl80211_send_scan_result(rdev, msg);
- }
- 
- void __cfg80211_scan_done(struct work_struct *wk)
-@@ -221,7 +231,7 @@ void __cfg80211_scan_done(struct work_st
- 			    scan_done_wk);
- 
- 	rtnl_lock();
--	___cfg80211_scan_done(rdev);
-+	___cfg80211_scan_done(rdev, true);
- 	rtnl_unlock();
- }
- 
-@@ -1079,7 +1089,7 @@ int cfg80211_wext_siwscan(struct net_dev
- 	if (IS_ERR(rdev))
- 		return PTR_ERR(rdev);
- 
--	if (rdev->scan_req) {
-+	if (rdev->scan_req || rdev->scan_msg) {
- 		err = -EBUSY;
- 		goto out;
- 	}
-@@ -1481,7 +1491,7 @@ int cfg80211_wext_giwscan(struct net_dev
- 	if (IS_ERR(rdev))
- 		return PTR_ERR(rdev);
- 
--	if (rdev->scan_req)
-+	if (rdev->scan_req || rdev->scan_msg)
- 		return -EAGAIN;
- 
- 	res = ieee80211_scan_results(rdev, info, extra, data->length);
---- a/net/wireless/sme.c
-+++ b/net/wireless/sme.c
-@@ -67,7 +67,7 @@ static int cfg80211_conn_scan(struct wir
- 	ASSERT_RDEV_LOCK(rdev);
- 	ASSERT_WDEV_LOCK(wdev);
- 
--	if (rdev->scan_req)
-+	if (rdev->scan_req || rdev->scan_msg)
- 		return -EBUSY;
- 
- 	if (wdev->conn->params.channel)
---- a/net/mac80211/mlme.c
-+++ b/net/mac80211/mlme.c
-@@ -1001,7 +1001,6 @@ ieee80211_sta_process_chanswitch(struct 
- 	}
- 
- 	ifmgd->flags |= IEEE80211_STA_CSA_RECEIVED;
--	sdata->vif.csa_active = true;
- 
- 	mutex_lock(&local->chanctx_mtx);
- 	if (local->use_chanctx) {
-@@ -1039,6 +1038,7 @@ ieee80211_sta_process_chanswitch(struct 
- 	mutex_unlock(&local->chanctx_mtx);
- 
- 	sdata->csa_chandef = csa_ie.chandef;
-+	sdata->vif.csa_active = true;
- 
- 	if (csa_ie.mode)
- 		ieee80211_stop_queues_by_reason(&local->hw,
---- a/net/mac80211/chan.c
-+++ b/net/mac80211/chan.c
-@@ -196,6 +196,8 @@ static bool ieee80211_is_radar_required(
- {
- 	struct ieee80211_sub_if_data *sdata;
- 
-+	lockdep_assert_held(&local->mtx);
-+
- 	rcu_read_lock();
- 	list_for_each_entry_rcu(sdata, &local->interfaces, list) {
- 		if (sdata->radar_required) {
---- a/net/mac80211/ibss.c
-+++ b/net/mac80211/ibss.c
-@@ -294,7 +294,6 @@ static void __ieee80211_sta_join_ibss(st
- 	}
- 
- 	mutex_lock(&local->mtx);
--	ieee80211_vif_release_channel(sdata);
- 	if (ieee80211_vif_use_channel(sdata, &chandef,
- 				      ifibss->fixed_channel ?
- 					IEEE80211_CHANCTX_SHARED :
-@@ -303,6 +302,7 @@ static void __ieee80211_sta_join_ibss(st
- 		mutex_unlock(&local->mtx);
- 		return;
- 	}
-+	sdata->radar_required = radar_required;
- 	mutex_unlock(&local->mtx);
- 
- 	memcpy(ifibss->bssid, bssid, ETH_ALEN);
-@@ -318,7 +318,6 @@ static void __ieee80211_sta_join_ibss(st
- 	rcu_assign_pointer(ifibss->presp, presp);
- 	mgmt = (void *)presp->head;
- 
--	sdata->radar_required = radar_required;
- 	sdata->vif.bss_conf.enable_beacon = true;
- 	sdata->vif.bss_conf.beacon_int = beacon_int;
- 	sdata->vif.bss_conf.basic_rates = basic_rates;
-@@ -386,7 +385,7 @@ static void __ieee80211_sta_join_ibss(st
- 					      presp->head_len, 0, GFP_KERNEL);
- 	cfg80211_put_bss(local->hw.wiphy, bss);
- 	netif_carrier_on(sdata->dev);
--	cfg80211_ibss_joined(sdata->dev, ifibss->bssid, GFP_KERNEL);
-+	cfg80211_ibss_joined(sdata->dev, ifibss->bssid, chan, GFP_KERNEL);
- }
- 
- static void ieee80211_sta_join_ibss(struct ieee80211_sub_if_data *sdata,
-@@ -802,6 +801,8 @@ ieee80211_ibss_process_chanswitch(struct
- 	int err;
- 	u32 sta_flags;
- 
-+	sdata_assert_lock(sdata);
-+
- 	sta_flags = IEEE80211_STA_DISABLE_VHT;
- 	switch (ifibss->chandef.width) {
- 	case NL80211_CHAN_WIDTH_5:
-@@ -1471,6 +1472,11 @@ static void ieee80211_rx_mgmt_probe_req(
- 	memcpy(((struct ieee80211_mgmt *) skb->data)->da, mgmt->sa, ETH_ALEN);
- 	ibss_dbg(sdata, "Sending ProbeResp to %pM\n", mgmt->sa);
- 	IEEE80211_SKB_CB(skb)->flags |= IEEE80211_TX_INTFL_DONT_ENCRYPT;
-+
-+	/* avoid excessive retries for probe request to wildcard SSIDs */
-+	if (pos[1] == 0)
-+		IEEE80211_SKB_CB(skb)->flags |= IEEE80211_TX_CTL_NO_ACK;
-+
- 	ieee80211_tx_skb(sdata, skb);
- }
- 
---- a/net/mac80211/mesh.c
-+++ b/net/mac80211/mesh.c
-@@ -872,6 +872,8 @@ ieee80211_mesh_process_chnswitch(struct 
- 	if (!ifmsh->mesh_id)
- 		return false;
- 
-+	sdata_assert_lock(sdata);
-+
- 	sta_flags = IEEE80211_STA_DISABLE_VHT;
- 	switch (sdata->vif.bss_conf.chandef.width) {
- 	case NL80211_CHAN_WIDTH_20_NOHT:
---- a/drivers/net/wireless/brcm80211/brcmfmac/wl_cfg80211.c
-+++ b/drivers/net/wireless/brcm80211/brcmfmac/wl_cfg80211.c
-@@ -4658,6 +4658,7 @@ brcmf_notify_connect_status(struct brcmf
- 	struct brcmf_cfg80211_info *cfg = ifp->drvr->config;
- 	struct net_device *ndev = ifp->ndev;
- 	struct brcmf_cfg80211_profile *profile = &ifp->vif->profile;
-+	struct ieee80211_channel *chan;
- 	s32 err = 0;
- 
- 	if (ifp->vif->mode == WL_MODE_AP) {
-@@ -4665,9 +4666,10 @@ brcmf_notify_connect_status(struct brcmf
- 	} else if (brcmf_is_linkup(e)) {
- 		brcmf_dbg(CONN, "Linkup\n");
- 		if (brcmf_is_ibssmode(ifp->vif)) {
-+			chan = ieee80211_get_channel(cfg->wiphy, cfg->channel);
- 			memcpy(profile->bssid, e->addr, ETH_ALEN);
- 			wl_inform_ibss(cfg, ndev, e->addr);
--			cfg80211_ibss_joined(ndev, e->addr, GFP_KERNEL);
-+			cfg80211_ibss_joined(ndev, e->addr, chan, GFP_KERNEL);
- 			clear_bit(BRCMF_VIF_STATUS_CONNECTING,
- 				  &ifp->vif->sme_state);
- 			set_bit(BRCMF_VIF_STATUS_CONNECTED,
---- a/drivers/net/wireless/libertas/cfg.c
-+++ b/drivers/net/wireless/libertas/cfg.c
-@@ -1766,7 +1766,8 @@ static void lbs_join_post(struct lbs_pri
- 	memcpy(priv->wdev->ssid, params->ssid, params->ssid_len);
- 	priv->wdev->ssid_len = params->ssid_len;
- 
--	cfg80211_ibss_joined(priv->dev, bssid, GFP_KERNEL);
-+	cfg80211_ibss_joined(priv->dev, bssid, params->chandef.chan,
-+			     GFP_KERNEL);
- 
- 	/* TODO: consider doing this at MACREG_INT_CODE_LINK_SENSED time */
- 	priv->connect_status = LBS_CONNECTED;
---- a/drivers/net/wireless/mwifiex/cfg80211.c
-+++ b/drivers/net/wireless/mwifiex/cfg80211.c
-@@ -1881,7 +1881,8 @@ mwifiex_cfg80211_join_ibss(struct wiphy 
- 				     params->privacy);
- done:
- 	if (!ret) {
--		cfg80211_ibss_joined(priv->netdev, priv->cfg_bssid, GFP_KERNEL);
-+		cfg80211_ibss_joined(priv->netdev, priv->cfg_bssid,
-+				     params->chandef.chan, GFP_KERNEL);
- 		dev_dbg(priv->adapter->dev,
- 			"info: joined/created adhoc network with bssid"
- 			" %pM successfully\n", priv->cfg_bssid);
---- a/drivers/net/wireless/rndis_wlan.c
-+++ b/drivers/net/wireless/rndis_wlan.c
-@@ -2835,7 +2835,9 @@ static void rndis_wlan_do_link_up_work(s
- 					bssid, req_ie, req_ie_len,
- 					resp_ie, resp_ie_len, GFP_KERNEL);
- 	} else if (priv->infra_mode == NDIS_80211_INFRA_ADHOC)
--		cfg80211_ibss_joined(usbdev->net, bssid, GFP_KERNEL);
-+		cfg80211_ibss_joined(usbdev->net, bssid,
-+				     get_current_channel(usbdev, NULL),
-+				     GFP_KERNEL);
- 
- 	kfree(info);
- 
---- a/net/wireless/ibss.c
-+++ b/net/wireless/ibss.c
-@@ -14,7 +14,8 @@
- #include "rdev-ops.h"
- 
- 
--void __cfg80211_ibss_joined(struct net_device *dev, const u8 *bssid)
-+void __cfg80211_ibss_joined(struct net_device *dev, const u8 *bssid,
-+			    struct ieee80211_channel *channel)
- {
- 	struct wireless_dev *wdev = dev->ieee80211_ptr;
- 	struct cfg80211_bss *bss;
-@@ -28,8 +29,7 @@ void __cfg80211_ibss_joined(struct net_d
- 	if (!wdev->ssid_len)
- 		return;
- 
--	bss = cfg80211_get_bss(wdev->wiphy, NULL, bssid,
--			       wdev->ssid, wdev->ssid_len,
-+	bss = cfg80211_get_bss(wdev->wiphy, channel, bssid, NULL, 0,
- 			       WLAN_CAPABILITY_IBSS, WLAN_CAPABILITY_IBSS);
- 
- 	if (WARN_ON(!bss))
-@@ -54,21 +54,26 @@ void __cfg80211_ibss_joined(struct net_d
- #endif
- }
- 
--void cfg80211_ibss_joined(struct net_device *dev, const u8 *bssid, gfp_t gfp)
-+void cfg80211_ibss_joined(struct net_device *dev, const u8 *bssid,
-+			  struct ieee80211_channel *channel, gfp_t gfp)
- {
- 	struct wireless_dev *wdev = dev->ieee80211_ptr;
- 	struct cfg80211_registered_device *rdev = wiphy_to_dev(wdev->wiphy);
- 	struct cfg80211_event *ev;
- 	unsigned long flags;
- 
--	trace_cfg80211_ibss_joined(dev, bssid);
-+	trace_cfg80211_ibss_joined(dev, bssid, channel);
-+
-+	if (WARN_ON(!channel))
-+		return;
- 
- 	ev = kzalloc(sizeof(*ev), gfp);
- 	if (!ev)
- 		return;
- 
- 	ev->type = EVENT_IBSS_JOINED;
--	memcpy(ev->cr.bssid, bssid, ETH_ALEN);
-+	memcpy(ev->ij.bssid, bssid, ETH_ALEN);
-+	ev->ij.channel = channel;
- 
- 	spin_lock_irqsave(&wdev->event_lock, flags);
- 	list_add_tail(&ev->list, &wdev->event_list);
-@@ -117,6 +122,7 @@ int __cfg80211_join_ibss(struct cfg80211
- 
- 	wdev->ibss_fixed = params->channel_fixed;
- 	wdev->ibss_dfs_possible = params->userspace_handles_dfs;
-+	wdev->chandef = params->chandef;
- #ifdef CPTCFG_CFG80211_WEXT
- 	wdev->wext.ibss.chandef = params->chandef;
- #endif
-@@ -200,6 +206,7 @@ static void __cfg80211_clear_ibss(struct
- 
- 	wdev->current_bss = NULL;
- 	wdev->ssid_len = 0;
-+	memset(&wdev->chandef, 0, sizeof(wdev->chandef));
- #ifdef CPTCFG_CFG80211_WEXT
- 	if (!nowext)
- 		wdev->wext.ibss.ssid_len = 0;
---- a/net/wireless/trace.h
-+++ b/net/wireless/trace.h
-@@ -2278,11 +2278,6 @@ DECLARE_EVENT_CLASS(cfg80211_rx_evt,
- 	TP_printk(NETDEV_PR_FMT ", " MAC_PR_FMT, NETDEV_PR_ARG, MAC_PR_ARG(addr))
- );
- 
--DEFINE_EVENT(cfg80211_rx_evt, cfg80211_ibss_joined,
--	TP_PROTO(struct net_device *netdev, const u8 *addr),
--	TP_ARGS(netdev, addr)
--);
--
- DEFINE_EVENT(cfg80211_rx_evt, cfg80211_rx_spurious_frame,
- 	TP_PROTO(struct net_device *netdev, const u8 *addr),
- 	TP_ARGS(netdev, addr)
-@@ -2293,6 +2288,24 @@ DEFINE_EVENT(cfg80211_rx_evt, cfg80211_r
- 	TP_ARGS(netdev, addr)
- );
- 
-+TRACE_EVENT(cfg80211_ibss_joined,
-+	TP_PROTO(struct net_device *netdev, const u8 *bssid,
-+		 struct ieee80211_channel *channel),
-+	TP_ARGS(netdev, bssid, channel),
-+	TP_STRUCT__entry(
-+		NETDEV_ENTRY
-+		MAC_ENTRY(bssid)
-+		CHAN_ENTRY
-+	),
-+	TP_fast_assign(
-+		NETDEV_ASSIGN;
-+		MAC_ASSIGN(bssid, bssid);
-+		CHAN_ASSIGN(channel);
-+	),
-+	TP_printk(NETDEV_PR_FMT ", bssid: " MAC_PR_FMT ", " CHAN_PR_FMT,
-+		  NETDEV_PR_ARG, MAC_PR_ARG(bssid), CHAN_PR_ARG)
-+);
-+
- TRACE_EVENT(cfg80211_probe_status,
- 	TP_PROTO(struct net_device *netdev, const u8 *addr, u64 cookie,
- 		 bool acked),
---- a/net/wireless/util.c
-+++ b/net/wireless/util.c
-@@ -820,7 +820,8 @@ void cfg80211_process_wdev_events(struct
- 						ev->dc.reason, true);
- 			break;
- 		case EVENT_IBSS_JOINED:
--			__cfg80211_ibss_joined(wdev->netdev, ev->ij.bssid);
-+			__cfg80211_ibss_joined(wdev->netdev, ev->ij.bssid,
-+					       ev->ij.channel);
- 			break;
- 		}
- 		wdev_unlock(wdev);
-@@ -1356,7 +1357,7 @@ int cfg80211_can_use_iftype_chan(struct 
- 		 */
- 		mutex_lock_nested(&wdev_iter->mtx, 1);
- 		__acquire(wdev_iter->mtx);
--		cfg80211_get_chan_state(wdev_iter, &ch, &chmode);
-+		cfg80211_get_chan_state(wdev_iter, &ch, &chmode, &radar_detect);
- 		wdev_unlock(wdev_iter);
- 
- 		switch (chmode) {
---- a/net/wireless/chan.c
-+++ b/net/wireless/chan.c
-@@ -642,7 +642,8 @@ int cfg80211_set_monitor_channel(struct 
- void
- cfg80211_get_chan_state(struct wireless_dev *wdev,
- 		        struct ieee80211_channel **chan,
--		        enum cfg80211_chan_mode *chanmode)
-+		        enum cfg80211_chan_mode *chanmode,
-+		        u8 *radar_detect)
- {
- 	*chan = NULL;
- 	*chanmode = CHAN_MODE_UNDEFINED;
-@@ -660,6 +661,11 @@ cfg80211_get_chan_state(struct wireless_
- 				     !wdev->ibss_dfs_possible)
- 				  ? CHAN_MODE_SHARED
- 				  : CHAN_MODE_EXCLUSIVE;
-+
-+			/* consider worst-case - IBSS can try to return to the
-+			 * original user-specified channel as creator */
-+			if (wdev->ibss_dfs_possible)
-+				*radar_detect |= BIT(wdev->chandef.width);
- 			return;
- 		}
- 		break;
-@@ -674,17 +680,26 @@ cfg80211_get_chan_state(struct wireless_
- 	case NL80211_IFTYPE_AP:
- 	case NL80211_IFTYPE_P2P_GO:
- 		if (wdev->cac_started) {
--			*chan = wdev->channel;
-+			*chan = wdev->chandef.chan;
- 			*chanmode = CHAN_MODE_SHARED;
-+			*radar_detect |= BIT(wdev->chandef.width);
- 		} else if (wdev->beacon_interval) {
--			*chan = wdev->channel;
-+			*chan = wdev->chandef.chan;
- 			*chanmode = CHAN_MODE_SHARED;
-+
-+			if (cfg80211_chandef_dfs_required(wdev->wiphy,
-+							  &wdev->chandef))
-+				*radar_detect |= BIT(wdev->chandef.width);
- 		}
- 		return;
- 	case NL80211_IFTYPE_MESH_POINT:
- 		if (wdev->mesh_id_len) {
--			*chan = wdev->channel;
-+			*chan = wdev->chandef.chan;
- 			*chanmode = CHAN_MODE_SHARED;
-+
-+			if (cfg80211_chandef_dfs_required(wdev->wiphy,
-+							  &wdev->chandef))
-+				*radar_detect |= BIT(wdev->chandef.width);
- 		}
- 		return;
- 	case NL80211_IFTYPE_MONITOR:
---- a/net/wireless/mesh.c
-+++ b/net/wireless/mesh.c
-@@ -195,7 +195,7 @@ int __cfg80211_join_mesh(struct cfg80211
- 	if (!err) {
- 		memcpy(wdev->ssid, setup->mesh_id, setup->mesh_id_len);
- 		wdev->mesh_id_len = setup->mesh_id_len;
--		wdev->channel = setup->chandef.chan;
-+		wdev->chandef = setup->chandef;
- 	}
- 
- 	return err;
-@@ -244,7 +244,7 @@ int cfg80211_set_mesh_channel(struct cfg
- 		err = rdev_libertas_set_mesh_channel(rdev, wdev->netdev,
- 						     chandef->chan);
- 		if (!err)
--			wdev->channel = chandef->chan;
-+			wdev->chandef = *chandef;
- 
- 		return err;
- 	}
-@@ -276,7 +276,7 @@ static int __cfg80211_leave_mesh(struct 
- 	err = rdev_leave_mesh(rdev, dev);
- 	if (!err) {
- 		wdev->mesh_id_len = 0;
--		wdev->channel = NULL;
-+		memset(&wdev->chandef, 0, sizeof(wdev->chandef));
- 		rdev_set_qos_map(rdev, dev, NULL);
- 	}
- 
---- a/net/wireless/mlme.c
-+++ b/net/wireless/mlme.c
-@@ -772,7 +772,7 @@ void cfg80211_cac_event(struct net_devic
- 	if (WARN_ON(!wdev->cac_started))
- 		return;
- 
--	if (WARN_ON(!wdev->channel))
-+	if (WARN_ON(!wdev->chandef.chan))
- 		return;
- 
- 	switch (event) {
---- a/drivers/net/wireless/ath/ath9k/ar9003_eeprom.c
-+++ b/drivers/net/wireless/ath/ath9k/ar9003_eeprom.c
-@@ -5065,6 +5065,10 @@ static u16 ar9003_hw_get_max_edge_power(
- 			break;
- 		}
- 	}
-+
-+	if (is2GHz && !twiceMaxEdgePower)
-+		twiceMaxEdgePower = 60;
-+
- 	return twiceMaxEdgePower;
- }
- 
---- a/drivers/net/wireless/ath/ath9k/ar9003_calib.c
-+++ b/drivers/net/wireless/ath/ath9k/ar9003_calib.c
-@@ -23,10 +23,11 @@
- #define MAX_MEASUREMENT	MAX_IQCAL_MEASUREMENT
- #define MAX_MAG_DELTA	11
- #define MAX_PHS_DELTA	10
-+#define MAXIQCAL        3
- 
- struct coeff {
--	int mag_coeff[AR9300_MAX_CHAINS][MAX_MEASUREMENT];
--	int phs_coeff[AR9300_MAX_CHAINS][MAX_MEASUREMENT];
-+	int mag_coeff[AR9300_MAX_CHAINS][MAX_MEASUREMENT][MAXIQCAL];
-+	int phs_coeff[AR9300_MAX_CHAINS][MAX_MEASUREMENT][MAXIQCAL];
- 	int iqc_coeff[2];
- };
- 
-@@ -800,7 +801,7 @@ static bool ar9003_hw_calc_iq_corr(struc
- 	if (q_q_coff > 63)
- 		q_q_coff = 63;
- 
--	iqc_coeff[0] = (q_q_coff * 128) + q_i_coff;
-+	iqc_coeff[0] = (q_q_coff * 128) + (0x7f & q_i_coff);
- 
- 	ath_dbg(common, CALIBRATE, "tx chain %d: iq corr coeff=%x\n",
- 		chain_idx, iqc_coeff[0]);
-@@ -831,7 +832,7 @@ static bool ar9003_hw_calc_iq_corr(struc
- 	if (q_q_coff > 63)
- 		q_q_coff = 63;
- 
--	iqc_coeff[1] = (q_q_coff * 128) + q_i_coff;
-+	iqc_coeff[1] = (q_q_coff * 128) + (0x7f & q_i_coff);
- 
- 	ath_dbg(common, CALIBRATE, "rx chain %d: iq corr coeff=%x\n",
- 		chain_idx, iqc_coeff[1]);
-@@ -839,7 +840,8 @@ static bool ar9003_hw_calc_iq_corr(struc
- 	return true;
- }
- 
--static void ar9003_hw_detect_outlier(int *mp_coeff, int nmeasurement,
-+static void ar9003_hw_detect_outlier(int mp_coeff[][MAXIQCAL],
-+				     int nmeasurement,
- 				     int max_delta)
- {
- 	int mp_max = -64, max_idx = 0;
-@@ -848,20 +850,20 @@ static void ar9003_hw_detect_outlier(int
- 
- 	/* find min/max mismatch across all calibrated gains */
- 	for (i = 0; i < nmeasurement; i++) {
--		if (mp_coeff[i] > mp_max) {
--			mp_max = mp_coeff[i];
-+		if (mp_coeff[i][0] > mp_max) {
-+			mp_max = mp_coeff[i][0];
- 			max_idx = i;
--		} else if (mp_coeff[i] < mp_min) {
--			mp_min = mp_coeff[i];
-+		} else if (mp_coeff[i][0] < mp_min) {
-+			mp_min = mp_coeff[i][0];
- 			min_idx = i;
- 		}
- 	}
- 
- 	/* find average (exclude max abs value) */
- 	for (i = 0; i < nmeasurement; i++) {
--		if ((abs(mp_coeff[i]) < abs(mp_max)) ||
--		    (abs(mp_coeff[i]) < abs(mp_min))) {
--			mp_avg += mp_coeff[i];
-+		if ((abs(mp_coeff[i][0]) < abs(mp_max)) ||
-+		    (abs(mp_coeff[i][0]) < abs(mp_min))) {
-+			mp_avg += mp_coeff[i][0];
- 			mp_count++;
- 		}
- 	}
-@@ -873,7 +875,7 @@ static void ar9003_hw_detect_outlier(int
- 	if (mp_count)
- 		mp_avg /= mp_count;
- 	else
--		mp_avg = mp_coeff[nmeasurement - 1];
-+		mp_avg = mp_coeff[nmeasurement - 1][0];
- 
- 	/* detect outlier */
- 	if (abs(mp_max - mp_min) > max_delta) {
-@@ -882,15 +884,16 @@ static void ar9003_hw_detect_outlier(int
- 		else
- 			outlier_idx = min_idx;
- 
--		mp_coeff[outlier_idx] = mp_avg;
-+		mp_coeff[outlier_idx][0] = mp_avg;
- 	}
- }
- 
--static void ar9003_hw_tx_iqcal_load_avg_2_passes(struct ath_hw *ah,
--						 struct coeff *coeff,
--						 bool is_reusable)
-+static void ar9003_hw_tx_iq_cal_outlier_detection(struct ath_hw *ah,
-+						  struct coeff *coeff,
-+						  bool is_reusable)
- {
- 	int i, im, nmeasurement;
-+	int magnitude, phase;
- 	u32 tx_corr_coeff[MAX_MEASUREMENT][AR9300_MAX_CHAINS];
- 	struct ath9k_hw_cal_data *caldata = ah->caldata;
- 
-@@ -920,21 +923,30 @@ static void ar9003_hw_tx_iqcal_load_avg_
- 		if (nmeasurement > MAX_MEASUREMENT)
- 			nmeasurement = MAX_MEASUREMENT;
- 
--		/* detect outlier only if nmeasurement > 1 */
--		if (nmeasurement > 1) {
--			/* Detect magnitude outlier */
--			ar9003_hw_detect_outlier(coeff->mag_coeff[i],
--					nmeasurement, MAX_MAG_DELTA);
--
--			/* Detect phase outlier */
--			ar9003_hw_detect_outlier(coeff->phs_coeff[i],
--					nmeasurement, MAX_PHS_DELTA);
-+		/*
-+		 * Skip normal outlier detection for AR9550.
-+		 */
-+		if (!AR_SREV_9550(ah)) {
-+			/* detect outlier only if nmeasurement > 1 */
-+			if (nmeasurement > 1) {
-+				/* Detect magnitude outlier */
-+				ar9003_hw_detect_outlier(coeff->mag_coeff[i],
-+							 nmeasurement,
-+							 MAX_MAG_DELTA);
-+
-+				/* Detect phase outlier */
-+				ar9003_hw_detect_outlier(coeff->phs_coeff[i],
-+							 nmeasurement,
-+							 MAX_PHS_DELTA);
-+			}
- 		}
- 
- 		for (im = 0; im < nmeasurement; im++) {
-+			magnitude = coeff->mag_coeff[i][im][0];
-+			phase = coeff->phs_coeff[i][im][0];
- 
--			coeff->iqc_coeff[0] = (coeff->mag_coeff[i][im] & 0x7f) |
--				((coeff->phs_coeff[i][im] & 0x7f) << 7);
-+			coeff->iqc_coeff[0] =
-+				(phase & 0x7f) | ((magnitude & 0x7f) << 7);
- 
- 			if ((im % 2) == 0)
- 				REG_RMW_FIELD(ah, tx_corr_coeff[im][i],
-@@ -991,7 +1003,63 @@ static bool ar9003_hw_tx_iq_cal_run(stru
- 	return true;
- }
- 
--static void ar9003_hw_tx_iq_cal_post_proc(struct ath_hw *ah, bool is_reusable)
-+static void __ar955x_tx_iq_cal_sort(struct ath_hw *ah,
-+				    struct coeff *coeff,
-+				    int i, int nmeasurement)
-+{
-+	struct ath_common *common = ath9k_hw_common(ah);
-+	int im, ix, iy, temp;
-+
-+	for (im = 0; im < nmeasurement; im++) {
-+		for (ix = 0; ix < MAXIQCAL - 1; ix++) {
-+			for (iy = ix + 1; iy <= MAXIQCAL - 1; iy++) {
-+				if (coeff->mag_coeff[i][im][iy] <
-+				    coeff->mag_coeff[i][im][ix]) {
-+					temp = coeff->mag_coeff[i][im][ix];
-+					coeff->mag_coeff[i][im][ix] =
-+						coeff->mag_coeff[i][im][iy];
-+					coeff->mag_coeff[i][im][iy] = temp;
-+				}
-+				if (coeff->phs_coeff[i][im][iy] <
-+				    coeff->phs_coeff[i][im][ix]) {
-+					temp = coeff->phs_coeff[i][im][ix];
-+					coeff->phs_coeff[i][im][ix] =
-+						coeff->phs_coeff[i][im][iy];
-+					coeff->phs_coeff[i][im][iy] = temp;
-+				}
-+			}
-+		}
-+		coeff->mag_coeff[i][im][0] = coeff->mag_coeff[i][im][MAXIQCAL / 2];
-+		coeff->phs_coeff[i][im][0] = coeff->phs_coeff[i][im][MAXIQCAL / 2];
-+
-+		ath_dbg(common, CALIBRATE,
-+			"IQCAL: Median [ch%d][gain%d]: mag = %d phase = %d\n",
-+			i, im,
-+			coeff->mag_coeff[i][im][0],
-+			coeff->phs_coeff[i][im][0]);
-+	}
-+}
-+
-+static bool ar955x_tx_iq_cal_median(struct ath_hw *ah,
-+				    struct coeff *coeff,
-+				    int iqcal_idx,
-+				    int nmeasurement)
-+{
-+	int i;
-+
-+	if ((iqcal_idx + 1) != MAXIQCAL)
-+		return false;
-+
-+	for (i = 0; i < AR9300_MAX_CHAINS; i++) {
-+		__ar955x_tx_iq_cal_sort(ah, coeff, i, nmeasurement);
-+	}
-+
-+	return true;
-+}
-+
-+static void ar9003_hw_tx_iq_cal_post_proc(struct ath_hw *ah,
-+					  int iqcal_idx,
-+					  bool is_reusable)
- {
- 	struct ath_common *common = ath9k_hw_common(ah);
- 	const u32 txiqcal_status[AR9300_MAX_CHAINS] = {
-@@ -1004,10 +1072,11 @@ static void ar9003_hw_tx_iq_cal_post_pro
- 		AR_PHY_CHAN_INFO_TAB_1,
- 		AR_PHY_CHAN_INFO_TAB_2,
- 	};
--	struct coeff coeff;
-+	static struct coeff coeff;
- 	s32 iq_res[6];
- 	int i, im, j;
--	int nmeasurement;
-+	int nmeasurement = 0;
-+	bool outlier_detect = true;
- 
- 	for (i = 0; i < AR9300_MAX_CHAINS; i++) {
- 		if (!(ah->txchainmask & (1 << i)))
-@@ -1065,17 +1134,23 @@ static void ar9003_hw_tx_iq_cal_post_pro
- 				goto tx_iqcal_fail;
- 			}
- 
--			coeff.mag_coeff[i][im] = coeff.iqc_coeff[0] & 0x7f;
--			coeff.phs_coeff[i][im] =
-+			coeff.phs_coeff[i][im][iqcal_idx] =
-+				coeff.iqc_coeff[0] & 0x7f;
-+			coeff.mag_coeff[i][im][iqcal_idx] =
- 				(coeff.iqc_coeff[0] >> 7) & 0x7f;
- 
--			if (coeff.mag_coeff[i][im] > 63)
--				coeff.mag_coeff[i][im] -= 128;
--			if (coeff.phs_coeff[i][im] > 63)
--				coeff.phs_coeff[i][im] -= 128;
-+			if (coeff.mag_coeff[i][im][iqcal_idx] > 63)
-+				coeff.mag_coeff[i][im][iqcal_idx] -= 128;
-+			if (coeff.phs_coeff[i][im][iqcal_idx] > 63)
-+				coeff.phs_coeff[i][im][iqcal_idx] -= 128;
- 		}
- 	}
--	ar9003_hw_tx_iqcal_load_avg_2_passes(ah, &coeff, is_reusable);
-+
-+	if (AR_SREV_9550(ah))
-+		outlier_detect = ar955x_tx_iq_cal_median(ah, &coeff,
-+							 iqcal_idx, nmeasurement);
-+	if (outlier_detect)
-+		ar9003_hw_tx_iq_cal_outlier_detection(ah, &coeff, is_reusable);
- 
- 	return;
- 
-@@ -1409,7 +1484,7 @@ skip_tx_iqcal:
- 	}
- 
- 	if (txiqcal_done)
--		ar9003_hw_tx_iq_cal_post_proc(ah, is_reusable);
-+		ar9003_hw_tx_iq_cal_post_proc(ah, 0, is_reusable);
- 	else if (caldata && test_bit(TXIQCAL_DONE, &caldata->cal_flags))
- 		ar9003_hw_tx_iq_cal_reload(ah);
- 
-@@ -1455,14 +1530,38 @@ skip_tx_iqcal:
- 	return true;
- }
- 
-+static bool do_ar9003_agc_cal(struct ath_hw *ah)
-+{
-+	struct ath_common *common = ath9k_hw_common(ah);
-+	bool status;
-+
-+	REG_WRITE(ah, AR_PHY_AGC_CONTROL,
-+		  REG_READ(ah, AR_PHY_AGC_CONTROL) |
-+		  AR_PHY_AGC_CONTROL_CAL);
-+
-+	status = ath9k_hw_wait(ah, AR_PHY_AGC_CONTROL,
-+			       AR_PHY_AGC_CONTROL_CAL,
-+			       0, AH_WAIT_TIMEOUT);
-+	if (!status) {
-+		ath_dbg(common, CALIBRATE,
-+			"offset calibration failed to complete in %d ms,"
-+			"noisy environment?\n",
-+			AH_WAIT_TIMEOUT / 1000);
-+		return false;
-+	}
-+
-+	return true;
-+}
-+
- static bool ar9003_hw_init_cal_soc(struct ath_hw *ah,
- 				   struct ath9k_channel *chan)
- {
- 	struct ath_common *common = ath9k_hw_common(ah);
- 	struct ath9k_hw_cal_data *caldata = ah->caldata;
- 	bool txiqcal_done = false;
--	bool is_reusable = true, status = true;
-+	bool status = true;
- 	bool run_agc_cal = false, sep_iq_cal = false;
-+	int i = 0;
- 
- 	/* Use chip chainmask only for calibration */
- 	ar9003_hw_set_chain_masks(ah, ah->caps.rx_chainmask, ah->caps.tx_chainmask);
-@@ -1485,7 +1584,12 @@ static bool ar9003_hw_init_cal_soc(struc
- 	 * AGC calibration. Specifically, AR9550 in SoC chips.
- 	 */
- 	if (ah->enabled_cals & TX_IQ_ON_AGC_CAL) {
--		txiqcal_done = true;
-+		if (REG_READ_FIELD(ah, AR_PHY_TX_IQCAL_CONTROL_0,
-+				   AR_PHY_TX_IQCAL_CONTROL_0_ENABLE_TXIQ_CAL)) {
-+				txiqcal_done = true;
-+		} else {
-+			txiqcal_done = false;
-+		}
- 		run_agc_cal = true;
- 	} else {
- 		sep_iq_cal = true;
-@@ -1512,27 +1616,37 @@ skip_tx_iqcal:
- 		if (AR_SREV_9330_11(ah))
- 			ar9003_hw_manual_peak_cal(ah, 0, IS_CHAN_2GHZ(chan));
- 
--		/* Calibrate the AGC */
--		REG_WRITE(ah, AR_PHY_AGC_CONTROL,
--			  REG_READ(ah, AR_PHY_AGC_CONTROL) |
--			  AR_PHY_AGC_CONTROL_CAL);
--
--		/* Poll for offset calibration complete */
--		status = ath9k_hw_wait(ah, AR_PHY_AGC_CONTROL,
--				       AR_PHY_AGC_CONTROL_CAL,
--				       0, AH_WAIT_TIMEOUT);
--	}
-+		/*
-+		 * For non-AR9550 chips, we just trigger AGC calibration
-+		 * in the HW, poll for completion and then process
-+		 * the results.
-+		 *
-+		 * For AR955x, we run it multiple times and use
-+		 * median IQ correction.
-+		 */
-+		if (!AR_SREV_9550(ah)) {
-+			status = do_ar9003_agc_cal(ah);
-+			if (!status)
-+				return false;
- 
--	if (!status) {
--		ath_dbg(common, CALIBRATE,
--			"offset calibration failed to complete in %d ms; noisy environment?\n",
--			AH_WAIT_TIMEOUT / 1000);
--		return false;
-+			if (txiqcal_done)
-+				ar9003_hw_tx_iq_cal_post_proc(ah, 0, false);
-+		} else {
-+			if (!txiqcal_done) {
-+				status = do_ar9003_agc_cal(ah);
-+				if (!status)
-+					return false;
-+			} else {
-+				for (i = 0; i < MAXIQCAL; i++) {
-+					status = do_ar9003_agc_cal(ah);
-+					if (!status)
-+						return false;
-+					ar9003_hw_tx_iq_cal_post_proc(ah, i, false);
-+				}
-+			}
-+		}
- 	}
- 
--	if (txiqcal_done)
--		ar9003_hw_tx_iq_cal_post_proc(ah, is_reusable);
--
- 	/* Revert chainmask to runtime parameters */
- 	ar9003_hw_set_chain_masks(ah, ah->rxchainmask, ah->txchainmask);
- 
---- a/drivers/net/wireless/rtl818x/rtl8187/rtl8187.h
-+++ b/drivers/net/wireless/rtl818x/rtl8187/rtl8187.h
-@@ -15,6 +15,8 @@
- #ifndef RTL8187_H
- #define RTL8187_H
- 
-+#include <linux/cache.h>
-+
- #include "rtl818x.h"
- #include "leds.h"
- 
-@@ -139,7 +141,10 @@ struct rtl8187_priv {
- 	u8 aifsn[4];
- 	u8 rfkill_mask;
- 	struct {
--		__le64 buf;
-+		union {
-+			__le64 buf;
-+			u8 dummy1[L1_CACHE_BYTES];
-+		} ____cacheline_aligned;
- 		struct sk_buff_head queue;
- 	} b_tx_status; /* This queue is used by both -b and non-b devices */
- 	struct mutex io_mutex;
-@@ -147,7 +152,8 @@ struct rtl8187_priv {
- 		u8 bits8;
- 		__le16 bits16;
- 		__le32 bits32;
--	} *io_dmabuf;
-+		u8 dummy2[L1_CACHE_BYTES];
-+	} *io_dmabuf ____cacheline_aligned;
- 	bool rfkill_off;
- 	u16 seqno;
- };
---- a/net/mac80211/wme.c
-+++ b/net/mac80211/wme.c
-@@ -154,6 +154,11 @@ u16 ieee80211_select_queue(struct ieee80
- 		return IEEE80211_AC_BE;
- 	}
- 
-+	if (skb->protocol == sdata->control_port_protocol) {
-+		skb->priority = 7;
-+		return ieee80211_downgrade_queue(sdata, skb);
-+	}
-+
- 	/* use the data classifier to determine what 802.1d tag the
- 	 * data frame has */
- 	rcu_read_lock();
---- a/drivers/net/wireless/ath/ath9k/xmit.c
-+++ b/drivers/net/wireless/ath/ath9k/xmit.c
-@@ -1444,14 +1444,16 @@ void ath_tx_aggr_sleep(struct ieee80211_
- 	for (tidno = 0, tid = &an->tid[tidno];
- 	     tidno < IEEE80211_NUM_TIDS; tidno++, tid++) {
- 
--		if (!tid->sched)
--			continue;
--
- 		ac = tid->ac;
- 		txq = ac->txq;
- 
- 		ath_txq_lock(sc, txq);
- 
-+		if (!tid->sched) {
-+			ath_txq_unlock(sc, txq);
-+			continue;
-+		}
-+
- 		buffered = ath_tid_has_buffered(tid);
- 
- 		tid->sched = false;
-@@ -1696,7 +1698,7 @@ int ath_cabq_update(struct ath_softc *sc
- 
- 	ath9k_hw_get_txq_props(sc->sc_ah, qnum, &qi);
- 
--	qi.tqi_readyTime = (cur_conf->beacon_interval *
-+	qi.tqi_readyTime = (TU_TO_USEC(cur_conf->beacon_interval) *
- 			    ATH_CABQ_READY_TIME) / 100;
- 	ath_txq_update(sc, qnum, &qi);
- 
-@@ -2061,7 +2063,7 @@ static struct ath_buf *ath_tx_setup_buff
- 
- 	ATH_TXBUF_RESET(bf);
- 
--	if (tid) {
-+	if (tid && ieee80211_is_data_present(hdr->frame_control)) {
- 		fragno = le16_to_cpu(hdr->seq_ctrl) & IEEE80211_SCTL_FRAG;
- 		seqno = tid->seq_next;
- 		hdr->seq_ctrl = cpu_to_le16(tid->seq_next << IEEE80211_SEQ_SEQ_SHIFT);
-@@ -2184,14 +2186,15 @@ int ath_tx_start(struct ieee80211_hw *hw
- 		txq->stopped = true;
- 	}
- 
-+	if (txctl->an && ieee80211_is_data_present(hdr->frame_control))
-+		tid = ath_get_skb_tid(sc, txctl->an, skb);
-+
- 	if (info->flags & IEEE80211_TX_CTL_PS_RESPONSE) {
- 		ath_txq_unlock(sc, txq);
- 		txq = sc->tx.uapsdq;
- 		ath_txq_lock(sc, txq);
- 	} else if (txctl->an &&
- 		   ieee80211_is_data_present(hdr->frame_control)) {
--		tid = ath_get_skb_tid(sc, txctl->an, skb);
--
- 		WARN_ON(tid->ac->txq != txctl->txq);
- 
- 		if (info->flags & IEEE80211_TX_CTL_CLEAR_PS_FILT)
---- a/drivers/net/wireless/ath/ath9k/init.c
-+++ b/drivers/net/wireless/ath/ath9k/init.c
-@@ -943,6 +943,7 @@ static void ath9k_set_hw_capab(struct at
- 	hw->wiphy->flags |= WIPHY_FLAG_HAS_REMAIN_ON_CHANNEL;
- 	hw->wiphy->flags |= WIPHY_FLAG_SUPPORTS_5_10_MHZ;
- 	hw->wiphy->flags |= WIPHY_FLAG_HAS_CHANNEL_SWITCH;
-+	hw->wiphy->flags |= WIPHY_FLAG_AP_UAPSD;
- 
- 	hw->queues = 4;
- 	hw->max_rates = 4;
---- a/net/mac80211/ieee80211_i.h
-+++ b/net/mac80211/ieee80211_i.h
-@@ -1700,14 +1700,8 @@ void ieee80211_stop_queue_by_reason(stru
- void ieee80211_propagate_queue_wake(struct ieee80211_local *local, int queue);
- void ieee80211_add_pending_skb(struct ieee80211_local *local,
- 			       struct sk_buff *skb);
--void ieee80211_add_pending_skbs_fn(struct ieee80211_local *local,
--				   struct sk_buff_head *skbs,
--				   void (*fn)(void *data), void *data);
--static inline void ieee80211_add_pending_skbs(struct ieee80211_local *local,
--					      struct sk_buff_head *skbs)
--{
--	ieee80211_add_pending_skbs_fn(local, skbs, NULL, NULL);
--}
-+void ieee80211_add_pending_skbs(struct ieee80211_local *local,
-+				struct sk_buff_head *skbs);
- void ieee80211_flush_queues(struct ieee80211_local *local,
- 			    struct ieee80211_sub_if_data *sdata);
- 
---- a/net/mac80211/sta_info.c
-+++ b/net/mac80211/sta_info.c
-@@ -91,7 +91,7 @@ static int sta_info_hash_del(struct ieee
- 	return -ENOENT;
- }
- 
--static void cleanup_single_sta(struct sta_info *sta)
-+static void __cleanup_single_sta(struct sta_info *sta)
- {
- 	int ac, i;
- 	struct tid_ampdu_tx *tid_tx;
-@@ -99,7 +99,8 @@ static void cleanup_single_sta(struct st
- 	struct ieee80211_local *local = sdata->local;
- 	struct ps_data *ps;
- 
--	if (test_sta_flag(sta, WLAN_STA_PS_STA)) {
-+	if (test_sta_flag(sta, WLAN_STA_PS_STA) ||
-+	    test_sta_flag(sta, WLAN_STA_PS_DRIVER)) {
- 		if (sta->sdata->vif.type == NL80211_IFTYPE_AP ||
- 		    sta->sdata->vif.type == NL80211_IFTYPE_AP_VLAN)
- 			ps = &sdata->bss->ps;
-@@ -109,6 +110,7 @@ static void cleanup_single_sta(struct st
- 			return;
- 
- 		clear_sta_flag(sta, WLAN_STA_PS_STA);
-+		clear_sta_flag(sta, WLAN_STA_PS_DRIVER);
- 
- 		atomic_dec(&ps->num_sta_ps);
- 		sta_info_recalc_tim(sta);
-@@ -139,7 +141,14 @@ static void cleanup_single_sta(struct st
- 		ieee80211_purge_tx_queue(&local->hw, &tid_tx->pending);
- 		kfree(tid_tx);
- 	}
-+}
- 
-+static void cleanup_single_sta(struct sta_info *sta)
-+{
-+	struct ieee80211_sub_if_data *sdata = sta->sdata;
-+	struct ieee80211_local *local = sdata->local;
-+
-+	__cleanup_single_sta(sta);
- 	sta_info_free(local, sta);
- }
- 
-@@ -330,6 +339,7 @@ struct sta_info *sta_info_alloc(struct i
- 	rcu_read_unlock();
- 
- 	spin_lock_init(&sta->lock);
-+	spin_lock_init(&sta->ps_lock);
- 	INIT_WORK(&sta->drv_unblock_wk, sta_unblock);
- 	INIT_WORK(&sta->ampdu_mlme.work, ieee80211_ba_session_work);
- 	mutex_init(&sta->ampdu_mlme.mtx);
-@@ -487,21 +497,26 @@ static int sta_info_insert_finish(struct
- 		goto out_err;
- 	}
- 
--	/* notify driver */
--	err = sta_info_insert_drv_state(local, sdata, sta);
--	if (err)
--		goto out_err;
--
- 	local->num_sta++;
- 	local->sta_generation++;
- 	smp_mb();
- 
-+	/* simplify things and don't accept BA sessions yet */
-+	set_sta_flag(sta, WLAN_STA_BLOCK_BA);
-+
- 	/* make the station visible */
- 	sta_info_hash_add(local, sta);
- 
- 	list_add_rcu(&sta->list, &local->sta_list);
- 
-+	/* notify driver */
-+	err = sta_info_insert_drv_state(local, sdata, sta);
-+	if (err)
-+		goto out_remove;
-+
- 	set_sta_flag(sta, WLAN_STA_INSERTED);
-+	/* accept BA sessions now */
-+	clear_sta_flag(sta, WLAN_STA_BLOCK_BA);
- 
- 	ieee80211_recalc_min_chandef(sdata);
- 	ieee80211_sta_debugfs_add(sta);
-@@ -522,6 +537,12 @@ static int sta_info_insert_finish(struct
- 		mesh_accept_plinks_update(sdata);
- 
- 	return 0;
-+ out_remove:
-+	sta_info_hash_del(local, sta);
-+	list_del_rcu(&sta->list);
-+	local->num_sta--;
-+	synchronize_net();
-+	__cleanup_single_sta(sta);
-  out_err:
- 	mutex_unlock(&local->sta_mtx);
- 	rcu_read_lock();
-@@ -1071,10 +1092,14 @@ struct ieee80211_sta *ieee80211_find_sta
- }
- EXPORT_SYMBOL(ieee80211_find_sta);
- 
--static void clear_sta_ps_flags(void *_sta)
-+/* powersave support code */
-+void ieee80211_sta_ps_deliver_wakeup(struct sta_info *sta)
- {
--	struct sta_info *sta = _sta;
- 	struct ieee80211_sub_if_data *sdata = sta->sdata;
-+	struct ieee80211_local *local = sdata->local;
-+	struct sk_buff_head pending;
-+	int filtered = 0, buffered = 0, ac;
-+	unsigned long flags;
- 	struct ps_data *ps;
- 
- 	if (sdata->vif.type == NL80211_IFTYPE_AP ||
-@@ -1085,20 +1110,6 @@ static void clear_sta_ps_flags(void *_st
- 	else
- 		return;
- 
--	clear_sta_flag(sta, WLAN_STA_PS_DRIVER);
--	if (test_and_clear_sta_flag(sta, WLAN_STA_PS_STA))
--		atomic_dec(&ps->num_sta_ps);
--}
--
--/* powersave support code */
--void ieee80211_sta_ps_deliver_wakeup(struct sta_info *sta)
--{
--	struct ieee80211_sub_if_data *sdata = sta->sdata;
--	struct ieee80211_local *local = sdata->local;
--	struct sk_buff_head pending;
--	int filtered = 0, buffered = 0, ac;
--	unsigned long flags;
--
- 	clear_sta_flag(sta, WLAN_STA_SP);
- 
- 	BUILD_BUG_ON(BITS_TO_LONGS(IEEE80211_NUM_TIDS) > 1);
-@@ -1109,6 +1120,8 @@ void ieee80211_sta_ps_deliver_wakeup(str
- 
- 	skb_queue_head_init(&pending);
- 
-+	/* sync with ieee80211_tx_h_unicast_ps_buf */
-+	spin_lock(&sta->ps_lock);
- 	/* Send all buffered frames to the station */
- 	for (ac = 0; ac < IEEE80211_NUM_ACS; ac++) {
- 		int count = skb_queue_len(&pending), tmp;
-@@ -1127,7 +1140,12 @@ void ieee80211_sta_ps_deliver_wakeup(str
- 		buffered += tmp - count;
- 	}
- 
--	ieee80211_add_pending_skbs_fn(local, &pending, clear_sta_ps_flags, sta);
-+	ieee80211_add_pending_skbs(local, &pending);
-+	clear_sta_flag(sta, WLAN_STA_PS_DRIVER);
-+	clear_sta_flag(sta, WLAN_STA_PS_STA);
-+	spin_unlock(&sta->ps_lock);
-+
-+	atomic_dec(&ps->num_sta_ps);
- 
- 	/* This station just woke up and isn't aware of our SMPS state */
- 	if (!ieee80211_smps_is_restrictive(sta->known_smps_mode,
---- a/net/mac80211/sta_info.h
-+++ b/net/mac80211/sta_info.h
-@@ -267,6 +267,7 @@ struct ieee80211_tx_latency_stat {
-  * @drv_unblock_wk: used for driver PS unblocking
-  * @listen_interval: listen interval of this station, when we're acting as AP
-  * @_flags: STA flags, see &enum ieee80211_sta_info_flags, do not use directly
-+ * @ps_lock: used for powersave (when mac80211 is the AP) related locking
-  * @ps_tx_buf: buffers (per AC) of frames to transmit to this station
-  *	when it leaves power saving state or polls
-  * @tx_filtered: buffers (per AC) of frames we already tried to
-@@ -356,10 +357,8 @@ struct sta_info {
- 	/* use the accessors defined below */
- 	unsigned long _flags;
- 
--	/*
--	 * STA powersave frame queues, no more than the internal
--	 * locking required.
--	 */
-+	/* STA powersave lock and frame queues */
-+	spinlock_t ps_lock;
- 	struct sk_buff_head ps_tx_buf[IEEE80211_NUM_ACS];
- 	struct sk_buff_head tx_filtered[IEEE80211_NUM_ACS];
- 	unsigned long driver_buffered_tids;
---- a/net/mac80211/util.c
-+++ b/net/mac80211/util.c
-@@ -435,9 +435,8 @@ void ieee80211_add_pending_skb(struct ie
- 	spin_unlock_irqrestore(&local->queue_stop_reason_lock, flags);
- }
- 
--void ieee80211_add_pending_skbs_fn(struct ieee80211_local *local,
--				   struct sk_buff_head *skbs,
--				   void (*fn)(void *data), void *data)
-+void ieee80211_add_pending_skbs(struct ieee80211_local *local,
-+				struct sk_buff_head *skbs)
- {
- 	struct ieee80211_hw *hw = &local->hw;
- 	struct sk_buff *skb;
-@@ -461,9 +460,6 @@ void ieee80211_add_pending_skbs_fn(struc
- 		__skb_queue_tail(&local->pending[queue], skb);
- 	}
- 
--	if (fn)
--		fn(data);
--
- 	for (i = 0; i < hw->queues; i++)
- 		__ieee80211_wake_queue(hw, i,
- 			IEEE80211_QUEUE_STOP_REASON_SKB_ADD);
---- a/net/wireless/reg.c
-+++ b/net/wireless/reg.c
-@@ -1700,7 +1700,7 @@ static void reg_process_hint(struct regu
- 		return;
- 	case NL80211_REGDOM_SET_BY_USER:
- 		treatment = reg_process_hint_user(reg_request);
--		if (treatment == REG_REQ_OK ||
-+		if (treatment == REG_REQ_IGNORE ||
- 		    treatment == REG_REQ_ALREADY_SET)
- 			return;
- 		schedule_delayed_work(&reg_timeout, msecs_to_jiffies(3142));
---- a/drivers/net/wireless/ath/ath9k/debug.c
-+++ b/drivers/net/wireless/ath/ath9k/debug.c
-@@ -138,43 +138,41 @@ static ssize_t read_file_ani(struct file
- 	unsigned int len = 0, size = 1024;
- 	ssize_t retval = 0;
- 	char *buf;
-+	int i;
-+	struct {
-+		const char *name;
-+		unsigned int val;
-+	} ani_info[] = {
-+		{ "ANI RESET", ah->stats.ast_ani_reset },
-+		{ "OFDM LEVEL", ah->ani.ofdmNoiseImmunityLevel },
-+		{ "CCK LEVEL", ah->ani.cckNoiseImmunityLevel },
-+		{ "SPUR UP", ah->stats.ast_ani_spurup },
-+		{ "SPUR DOWN", ah->stats.ast_ani_spurup },
-+		{ "OFDM WS-DET ON", ah->stats.ast_ani_ofdmon },
-+		{ "OFDM WS-DET OFF", ah->stats.ast_ani_ofdmoff },
-+		{ "MRC-CCK ON", ah->stats.ast_ani_ccklow },
-+		{ "MRC-CCK OFF", ah->stats.ast_ani_cckhigh },
-+		{ "FIR-STEP UP", ah->stats.ast_ani_stepup },
-+		{ "FIR-STEP DOWN", ah->stats.ast_ani_stepdown },
-+		{ "INV LISTENTIME", ah->stats.ast_ani_lneg_or_lzero },
-+		{ "OFDM ERRORS", ah->stats.ast_ani_ofdmerrs },
-+		{ "CCK ERRORS", ah->stats.ast_ani_cckerrs },
-+	};
- 
- 	buf = kzalloc(size, GFP_KERNEL);
- 	if (buf == NULL)
- 		return -ENOMEM;
- 
--	if (common->disable_ani) {
--		len += scnprintf(buf + len, size - len, "%s: %s\n",
--				 "ANI", "DISABLED");
-+	len += scnprintf(buf + len, size - len, "%15s: %s\n", "ANI",
-+			 common->disable_ani ? "DISABLED" : "ENABLED");
-+
-+	if (common->disable_ani)
- 		goto exit;
--	}
- 
--	len += scnprintf(buf + len, size - len, "%15s: %s\n",
--			 "ANI", "ENABLED");
--	len += scnprintf(buf + len, size - len, "%15s: %u\n",
--			 "ANI RESET", ah->stats.ast_ani_reset);
--	len += scnprintf(buf + len, size - len, "%15s: %u\n",
--			 "SPUR UP", ah->stats.ast_ani_spurup);
--	len += scnprintf(buf + len, size - len, "%15s: %u\n",
--			 "SPUR DOWN", ah->stats.ast_ani_spurup);
--	len += scnprintf(buf + len, size - len, "%15s: %u\n",
--			 "OFDM WS-DET ON", ah->stats.ast_ani_ofdmon);
--	len += scnprintf(buf + len, size - len, "%15s: %u\n",
--			 "OFDM WS-DET OFF", ah->stats.ast_ani_ofdmoff);
--	len += scnprintf(buf + len, size - len, "%15s: %u\n",
--			 "MRC-CCK ON", ah->stats.ast_ani_ccklow);
--	len += scnprintf(buf + len, size - len, "%15s: %u\n",
--			 "MRC-CCK OFF", ah->stats.ast_ani_cckhigh);
--	len += scnprintf(buf + len, size - len, "%15s: %u\n",
--			 "FIR-STEP UP", ah->stats.ast_ani_stepup);
--	len += scnprintf(buf + len, size - len, "%15s: %u\n",
--			 "FIR-STEP DOWN", ah->stats.ast_ani_stepdown);
--	len += scnprintf(buf + len, size - len, "%15s: %u\n",
--			 "INV LISTENTIME", ah->stats.ast_ani_lneg_or_lzero);
--	len += scnprintf(buf + len, size - len, "%15s: %u\n",
--			 "OFDM ERRORS", ah->stats.ast_ani_ofdmerrs);
--	len += scnprintf(buf + len, size - len, "%15s: %u\n",
--			 "CCK ERRORS", ah->stats.ast_ani_cckerrs);
-+	for (i = 0; i < ARRAY_SIZE(ani_info); i++)
-+		len += scnprintf(buf + len, size - len, "%15s: %u\n",
-+				 ani_info[i].name, ani_info[i].val);
-+
- exit:
- 	if (len > size)
- 		len = size;
-@@ -866,6 +864,12 @@ static ssize_t read_file_reset(struct fi
- 			 "%17s: %2d\n", "PLL RX Hang",
- 			 sc->debug.stats.reset[RESET_TYPE_PLL_HANG]);
- 	len += scnprintf(buf + len, sizeof(buf) - len,
-+			 "%17s: %2d\n", "MAC Hang",
-+			 sc->debug.stats.reset[RESET_TYPE_MAC_HANG]);
-+	len += scnprintf(buf + len, sizeof(buf) - len,
-+			 "%17s: %2d\n", "Stuck Beacon",
-+			 sc->debug.stats.reset[RESET_TYPE_BEACON_STUCK]);
-+	len += scnprintf(buf + len, sizeof(buf) - len,
- 			 "%17s: %2d\n", "MCI Reset",
- 			 sc->debug.stats.reset[RESET_TYPE_MCI]);
- 
---- a/drivers/net/wireless/ath/ath9k/ar9003_phy.c
-+++ b/drivers/net/wireless/ath/ath9k/ar9003_phy.c
-@@ -868,10 +868,6 @@ static void ar9003_hw_set_rfmode(struct 
- 
- 	if (IS_CHAN_A_FAST_CLOCK(ah, chan))
- 		rfMode |= (AR_PHY_MODE_DYNAMIC | AR_PHY_MODE_DYN_CCK_DISABLE);
--	if (IS_CHAN_QUARTER_RATE(chan))
--		rfMode |= AR_PHY_MODE_QUARTER;
--	if (IS_CHAN_HALF_RATE(chan))
--		rfMode |= AR_PHY_MODE_HALF;
- 
- 	if (rfMode & (AR_PHY_MODE_QUARTER | AR_PHY_MODE_HALF))
- 		REG_RMW_FIELD(ah, AR_PHY_FRAME_CTL,
---- a/drivers/net/wireless/ath/ath5k/mac80211-ops.c
-+++ b/drivers/net/wireless/ath/ath5k/mac80211-ops.c
-@@ -706,6 +706,7 @@ ath5k_get_survey(struct ieee80211_hw *hw
- 	survey->channel = conf->chandef.chan;
- 	survey->noise = ah->ah_noise_floor;
- 	survey->filled = SURVEY_INFO_NOISE_DBM |
-+			SURVEY_INFO_IN_USE |
- 			SURVEY_INFO_CHANNEL_TIME |
- 			SURVEY_INFO_CHANNEL_TIME_BUSY |
- 			SURVEY_INFO_CHANNEL_TIME_RX |
---- a/drivers/net/wireless/ath/ath9k/recv.c
-+++ b/drivers/net/wireless/ath/ath9k/recv.c
-@@ -732,11 +732,18 @@ static struct ath_rxbuf *ath_get_next_rx
- 			return NULL;
- 
- 		/*
--		 * mark descriptor as zero-length and set the 'more'
--		 * flag to ensure that both buffers get discarded
-+		 * Re-check previous descriptor, in case it has been filled
-+		 * in the mean time.
- 		 */
--		rs->rs_datalen = 0;
--		rs->rs_more = true;
-+		ret = ath9k_hw_rxprocdesc(ah, ds, rs);
-+		if (ret == -EINPROGRESS) {
-+			/*
-+			 * mark descriptor as zero-length and set the 'more'
-+			 * flag to ensure that both buffers get discarded
-+			 */
-+			rs->rs_datalen = 0;
-+			rs->rs_more = true;
-+		}
- 	}
- 
- 	list_del(&bf->list);
-@@ -985,32 +992,32 @@ static int ath9k_rx_skb_preprocess(struc
- 	struct ath_common *common = ath9k_hw_common(ah);
- 	struct ieee80211_hdr *hdr;
- 	bool discard_current = sc->rx.discard_next;
--	int ret = 0;
- 
- 	/*
- 	 * Discard corrupt descriptors which are marked in
- 	 * ath_get_next_rx_buf().
- 	 */
--	sc->rx.discard_next = rx_stats->rs_more;
- 	if (discard_current)
--		return -EINVAL;
-+		goto corrupt;
-+
-+	sc->rx.discard_next = false;
- 
- 	/*
- 	 * Discard zero-length packets.
- 	 */
- 	if (!rx_stats->rs_datalen) {
- 		RX_STAT_INC(rx_len_err);
--		return -EINVAL;
-+		goto corrupt;
- 	}
- 
--        /*
--         * rs_status follows rs_datalen so if rs_datalen is too large
--         * we can take a hint that hardware corrupted it, so ignore
--         * those frames.
--         */
-+	/*
-+	 * rs_status follows rs_datalen so if rs_datalen is too large
-+	 * we can take a hint that hardware corrupted it, so ignore
-+	 * those frames.
-+	 */
- 	if (rx_stats->rs_datalen > (common->rx_bufsize - ah->caps.rx_status_len)) {
- 		RX_STAT_INC(rx_len_err);
--		return -EINVAL;
-+		goto corrupt;
- 	}
- 
- 	/* Only use status info from the last fragment */
-@@ -1024,10 +1031,8 @@ static int ath9k_rx_skb_preprocess(struc
- 	 * This is different from the other corrupt descriptor
- 	 * condition handled above.
- 	 */
--	if (rx_stats->rs_status & ATH9K_RXERR_CORRUPT_DESC) {
--		ret = -EINVAL;
--		goto exit;
--	}
-+	if (rx_stats->rs_status & ATH9K_RXERR_CORRUPT_DESC)
-+		goto corrupt;
- 
- 	hdr = (struct ieee80211_hdr *) (skb->data + ah->caps.rx_status_len);
- 
-@@ -1043,18 +1048,15 @@ static int ath9k_rx_skb_preprocess(struc
- 		if (ath_process_fft(sc, hdr, rx_stats, rx_status->mactime))
- 			RX_STAT_INC(rx_spectral);
- 
--		ret = -EINVAL;
--		goto exit;
-+		return -EINVAL;
- 	}
- 
- 	/*
- 	 * everything but the rate is checked here, the rate check is done
- 	 * separately to avoid doing two lookups for a rate for each frame.
- 	 */
--	if (!ath9k_rx_accept(common, hdr, rx_status, rx_stats, decrypt_error)) {
--		ret = -EINVAL;
--		goto exit;
--	}
-+	if (!ath9k_rx_accept(common, hdr, rx_status, rx_stats, decrypt_error))
-+		return -EINVAL;
- 
- 	if (ath_is_mybeacon(common, hdr)) {
- 		RX_STAT_INC(rx_beacons);
-@@ -1064,15 +1066,11 @@ static int ath9k_rx_skb_preprocess(struc
- 	/*
- 	 * This shouldn't happen, but have a safety check anyway.
- 	 */
--	if (WARN_ON(!ah->curchan)) {
--		ret = -EINVAL;
--		goto exit;
--	}
-+	if (WARN_ON(!ah->curchan))
-+		return -EINVAL;
- 
--	if (ath9k_process_rate(common, hw, rx_stats, rx_status)) {
--		ret =-EINVAL;
--		goto exit;
--	}
-+	if (ath9k_process_rate(common, hw, rx_stats, rx_status))
-+		return -EINVAL;
- 
- 	ath9k_process_rssi(common, hw, rx_stats, rx_status);
- 
-@@ -1087,9 +1085,11 @@ static int ath9k_rx_skb_preprocess(struc
- 		sc->rx.num_pkts++;
- #endif
- 
--exit:
--	sc->rx.discard_next = false;
--	return ret;
-+	return 0;
-+
-+corrupt:
-+	sc->rx.discard_next = rx_stats->rs_more;
-+	return -EINVAL;
- }
- 
- static void ath9k_rx_skb_postprocess(struct ath_common *common,
---- a/drivers/net/wireless/ath/ath9k/ani.c
-+++ b/drivers/net/wireless/ath/ath9k/ani.c
-@@ -176,16 +176,26 @@ static void ath9k_hw_set_ofdm_nil(struct
- 	if (ah->opmode == NL80211_IFTYPE_STATION &&
- 	    BEACON_RSSI(ah) <= ATH9K_ANI_RSSI_THR_HIGH)
- 		weak_sig = true;
--
- 	/*
--	 * OFDM Weak signal detection is always enabled for AP mode.
-+	 * Newer chipsets are better at dealing with high PHY error counts -
-+	 * keep weak signal detection enabled when no RSSI threshold is
-+	 * available to determine if it is needed (mode != STA)
- 	 */
--	if (ah->opmode != NL80211_IFTYPE_AP &&
--	    aniState->ofdmWeakSigDetect != weak_sig) {
--		ath9k_hw_ani_control(ah,
--				     ATH9K_ANI_OFDM_WEAK_SIGNAL_DETECTION,
--				     entry_ofdm->ofdm_weak_signal_on);
--	}
-+	else if (AR_SREV_9300_20_OR_LATER(ah) &&
-+		 ah->opmode != NL80211_IFTYPE_STATION)
-+		weak_sig = true;
-+
-+	/* Older chipsets are more sensitive to high PHY error counts */
-+	else if (!AR_SREV_9300_20_OR_LATER(ah) &&
-+		 aniState->ofdmNoiseImmunityLevel >= 8)
-+		weak_sig = false;
-+
-+	if (aniState->ofdmWeakSigDetect != weak_sig)
-+		ath9k_hw_ani_control(ah, ATH9K_ANI_OFDM_WEAK_SIGNAL_DETECTION,
-+				     weak_sig);
-+
-+	if (!AR_SREV_9300_20_OR_LATER(ah))
-+		return;
- 
- 	if (aniState->ofdmNoiseImmunityLevel >= ATH9K_ANI_OFDM_DEF_LEVEL) {
- 		ah->config.ofdm_trig_high = ATH9K_ANI_OFDM_TRIG_HIGH;
-@@ -308,17 +318,6 @@ void ath9k_ani_reset(struct ath_hw *ah, 
- 	BUG_ON(aniState == NULL);
- 	ah->stats.ast_ani_reset++;
- 
--	/* only allow a subset of functions in AP mode */
--	if (ah->opmode == NL80211_IFTYPE_AP) {
--		if (IS_CHAN_2GHZ(chan)) {
--			ah->ani_function = (ATH9K_ANI_SPUR_IMMUNITY_LEVEL |
--					    ATH9K_ANI_FIRSTEP_LEVEL);
--			if (AR_SREV_9300_20_OR_LATER(ah))
--				ah->ani_function |= ATH9K_ANI_MRC_CCK;
--		} else
--			ah->ani_function = 0;
--	}
--
- 	ofdm_nil = max_t(int, ATH9K_ANI_OFDM_DEF_LEVEL,
- 			 aniState->ofdmNoiseImmunityLevel);
- 	cck_nil = max_t(int, ATH9K_ANI_CCK_DEF_LEVEL,
-@@ -483,10 +482,17 @@ void ath9k_hw_ani_init(struct ath_hw *ah
- 
- 	ath_dbg(common, ANI, "Initialize ANI\n");
- 
--	ah->config.ofdm_trig_high = ATH9K_ANI_OFDM_TRIG_HIGH;
--	ah->config.ofdm_trig_low = ATH9K_ANI_OFDM_TRIG_LOW;
--	ah->config.cck_trig_high = ATH9K_ANI_CCK_TRIG_HIGH;
--	ah->config.cck_trig_low = ATH9K_ANI_CCK_TRIG_LOW;
-+	if (AR_SREV_9300_20_OR_LATER(ah)) {
-+		ah->config.ofdm_trig_high = ATH9K_ANI_OFDM_TRIG_HIGH;
-+		ah->config.ofdm_trig_low = ATH9K_ANI_OFDM_TRIG_LOW;
-+		ah->config.cck_trig_high = ATH9K_ANI_CCK_TRIG_HIGH;
-+		ah->config.cck_trig_low = ATH9K_ANI_CCK_TRIG_LOW;
-+	} else {
-+		ah->config.ofdm_trig_high = ATH9K_ANI_OFDM_TRIG_HIGH_OLD;
-+		ah->config.ofdm_trig_low = ATH9K_ANI_OFDM_TRIG_LOW_OLD;
-+		ah->config.cck_trig_high = ATH9K_ANI_CCK_TRIG_HIGH_OLD;
-+		ah->config.cck_trig_low = ATH9K_ANI_CCK_TRIG_LOW_OLD;
-+	}
- 
- 	ani->spurImmunityLevel = ATH9K_ANI_SPUR_IMMUNE_LVL;
- 	ani->firstepLevel = ATH9K_ANI_FIRSTEP_LVL;
---- a/drivers/net/wireless/ath/ath9k/ani.h
-+++ b/drivers/net/wireless/ath/ath9k/ani.h
-@@ -22,12 +22,16 @@
- /* units are errors per second */
- #define ATH9K_ANI_OFDM_TRIG_HIGH           3500
- #define ATH9K_ANI_OFDM_TRIG_HIGH_BELOW_INI 1000
-+#define ATH9K_ANI_OFDM_TRIG_HIGH_OLD       500
- 
- #define ATH9K_ANI_OFDM_TRIG_LOW           400
- #define ATH9K_ANI_OFDM_TRIG_LOW_ABOVE_INI 900
-+#define ATH9K_ANI_OFDM_TRIG_LOW_OLD       200
- 
- #define ATH9K_ANI_CCK_TRIG_HIGH           600
-+#define ATH9K_ANI_CCK_TRIG_HIGH_OLD       200
- #define ATH9K_ANI_CCK_TRIG_LOW            300
-+#define ATH9K_ANI_CCK_TRIG_LOW_OLD        100
- 
- #define ATH9K_ANI_SPUR_IMMUNE_LVL         3
- #define ATH9K_ANI_FIRSTEP_LVL             2
---- a/drivers/net/wireless/ath/ath9k/ar5008_phy.c
-+++ b/drivers/net/wireless/ath/ath9k/ar5008_phy.c
-@@ -26,10 +26,6 @@ static const int firstep_table[] =
- /* level:  0   1   2   3   4   5   6   7   8  */
- 	{ -4, -2,  0,  2,  4,  6,  8, 10, 12 }; /* lvl 0-8, default 2 */
- 
--static const int cycpwrThr1_table[] =
--/* level:  0   1   2   3   4   5   6   7   8  */
--	{ -6, -4, -2,  0,  2,  4,  6,  8 };     /* lvl 0-7, default 3 */
--
- /*
-  * register values to turn OFDM weak signal detection OFF
-  */
-@@ -921,7 +917,7 @@ static bool ar5008_hw_ani_control_new(st
- 	struct ath_common *common = ath9k_hw_common(ah);
- 	struct ath9k_channel *chan = ah->curchan;
- 	struct ar5416AniState *aniState = &ah->ani;
--	s32 value, value2;
-+	s32 value;
- 
- 	switch (cmd & ah->ani_function) {
- 	case ATH9K_ANI_OFDM_WEAK_SIGNAL_DETECTION:{
-@@ -1008,42 +1004,11 @@ static bool ar5008_hw_ani_control_new(st
- 	case ATH9K_ANI_FIRSTEP_LEVEL:{
- 		u32 level = param;
- 
--		if (level >= ARRAY_SIZE(firstep_table)) {
--			ath_dbg(common, ANI,
--				"ATH9K_ANI_FIRSTEP_LEVEL: level out of range (%u > %zu)\n",
--				level, ARRAY_SIZE(firstep_table));
--			return false;
--		}
--
--		/*
--		 * make register setting relative to default
--		 * from INI file & cap value
--		 */
--		value = firstep_table[level] -
--			firstep_table[ATH9K_ANI_FIRSTEP_LVL] +
--			aniState->iniDef.firstep;
--		if (value < ATH9K_SIG_FIRSTEP_SETTING_MIN)
--			value = ATH9K_SIG_FIRSTEP_SETTING_MIN;
--		if (value > ATH9K_SIG_FIRSTEP_SETTING_MAX)
--			value = ATH9K_SIG_FIRSTEP_SETTING_MAX;
-+		value = level * 2;
- 		REG_RMW_FIELD(ah, AR_PHY_FIND_SIG,
--			      AR_PHY_FIND_SIG_FIRSTEP,
--			      value);
--		/*
--		 * we need to set first step low register too
--		 * make register setting relative to default
--		 * from INI file & cap value
--		 */
--		value2 = firstep_table[level] -
--			 firstep_table[ATH9K_ANI_FIRSTEP_LVL] +
--			 aniState->iniDef.firstepLow;
--		if (value2 < ATH9K_SIG_FIRSTEP_SETTING_MIN)
--			value2 = ATH9K_SIG_FIRSTEP_SETTING_MIN;
--		if (value2 > ATH9K_SIG_FIRSTEP_SETTING_MAX)
--			value2 = ATH9K_SIG_FIRSTEP_SETTING_MAX;
--
-+			      AR_PHY_FIND_SIG_FIRSTEP, value);
- 		REG_RMW_FIELD(ah, AR_PHY_FIND_SIG_LOW,
--			      AR_PHY_FIND_SIG_FIRSTEP_LOW, value2);
-+			      AR_PHY_FIND_SIG_FIRSTEP_LOW, value);
- 
- 		if (level != aniState->firstepLevel) {
- 			ath_dbg(common, ANI,
-@@ -1060,7 +1025,7 @@ static bool ar5008_hw_ani_control_new(st
- 				aniState->firstepLevel,
- 				level,
- 				ATH9K_ANI_FIRSTEP_LVL,
--				value2,
-+				value,
- 				aniState->iniDef.firstepLow);
- 			if (level > aniState->firstepLevel)
- 				ah->stats.ast_ani_stepup++;
-@@ -1073,41 +1038,13 @@ static bool ar5008_hw_ani_control_new(st
- 	case ATH9K_ANI_SPUR_IMMUNITY_LEVEL:{
- 		u32 level = param;
- 
--		if (level >= ARRAY_SIZE(cycpwrThr1_table)) {
--			ath_dbg(common, ANI,
--				"ATH9K_ANI_SPUR_IMMUNITY_LEVEL: level out of range (%u > %zu)\n",
--				level, ARRAY_SIZE(cycpwrThr1_table));
--			return false;
--		}
--		/*
--		 * make register setting relative to default
--		 * from INI file & cap value
--		 */
--		value = cycpwrThr1_table[level] -
--			cycpwrThr1_table[ATH9K_ANI_SPUR_IMMUNE_LVL] +
--			aniState->iniDef.cycpwrThr1;
--		if (value < ATH9K_SIG_SPUR_IMM_SETTING_MIN)
--			value = ATH9K_SIG_SPUR_IMM_SETTING_MIN;
--		if (value > ATH9K_SIG_SPUR_IMM_SETTING_MAX)
--			value = ATH9K_SIG_SPUR_IMM_SETTING_MAX;
-+		value = (level + 1) * 2;
- 		REG_RMW_FIELD(ah, AR_PHY_TIMING5,
--			      AR_PHY_TIMING5_CYCPWR_THR1,
--			      value);
-+			      AR_PHY_TIMING5_CYCPWR_THR1, value);
- 
--		/*
--		 * set AR_PHY_EXT_CCA for extension channel
--		 * make register setting relative to default
--		 * from INI file & cap value
--		 */
--		value2 = cycpwrThr1_table[level] -
--			 cycpwrThr1_table[ATH9K_ANI_SPUR_IMMUNE_LVL] +
--			 aniState->iniDef.cycpwrThr1Ext;
--		if (value2 < ATH9K_SIG_SPUR_IMM_SETTING_MIN)
--			value2 = ATH9K_SIG_SPUR_IMM_SETTING_MIN;
--		if (value2 > ATH9K_SIG_SPUR_IMM_SETTING_MAX)
--			value2 = ATH9K_SIG_SPUR_IMM_SETTING_MAX;
--		REG_RMW_FIELD(ah, AR_PHY_EXT_CCA,
--			      AR_PHY_EXT_TIMING5_CYCPWR_THR1, value2);
-+		if (IS_CHAN_HT40(ah->curchan))
-+			REG_RMW_FIELD(ah, AR_PHY_EXT_CCA,
-+				      AR_PHY_EXT_TIMING5_CYCPWR_THR1, value);
- 
- 		if (level != aniState->spurImmunityLevel) {
- 			ath_dbg(common, ANI,
-@@ -1124,7 +1061,7 @@ static bool ar5008_hw_ani_control_new(st
- 				aniState->spurImmunityLevel,
- 				level,
- 				ATH9K_ANI_SPUR_IMMUNE_LVL,
--				value2,
-+				value,
- 				aniState->iniDef.cycpwrThr1Ext);
- 			if (level > aniState->spurImmunityLevel)
- 				ah->stats.ast_ani_spurup++;
diff --git a/package/mac80211/patches/310-ap_scan.patch b/package/mac80211/patches/310-ap_scan.patch
deleted file mode 100644
index 389a003..0000000
--- a/package/mac80211/patches/310-ap_scan.patch
+++ /dev/null
@@ -1,11 +0,0 @@
---- a/net/mac80211/cfg.c
-+++ b/net/mac80211/cfg.c
-@@ -2148,7 +2148,7 @@ static int ieee80211_scan(struct wiphy *
- 		 * the  frames sent while scanning on other channel will be
- 		 * lost)
- 		 */
--		if (sdata->u.ap.beacon &&
-+		if (0 && sdata->u.ap.beacon &&
- 		    (!(wiphy->features & NL80211_FEATURE_AP_SCAN) ||
- 		     !(req->flags & NL80211_SCAN_FLAG_AP)))
- 			return -EOPNOTSUPP;
diff --git a/package/mac80211/patches/400-ath_move_debug_code.patch b/package/mac80211/patches/400-ath_move_debug_code.patch
deleted file mode 100644
index 0dba7ac..0000000
--- a/package/mac80211/patches/400-ath_move_debug_code.patch
+++ /dev/null
@@ -1,28 +0,0 @@
---- a/drivers/net/wireless/ath/Makefile
-+++ b/drivers/net/wireless/ath/Makefile
-@@ -13,8 +13,8 @@ ath-objs :=	main.o \
- 		regd.o \
- 		hw.o \
- 		key.o \
-+		debug.o \
- 		dfs_pattern_detector.o \
- 		dfs_pri_detector.o
- 
--ath-$(CPTCFG_ATH_DEBUG) += debug.o
- ccflags-y += -D__CHECK_ENDIAN__
---- a/drivers/net/wireless/ath/ath.h
-+++ b/drivers/net/wireless/ath/ath.h
-@@ -282,13 +282,6 @@ void _ath_dbg(struct ath_common *common,
- #endif /* CPTCFG_ATH_DEBUG */
- 
- /** Returns string describing opmode, or NULL if unknown mode. */
--#ifdef CPTCFG_ATH_DEBUG
- const char *ath_opmode_to_string(enum nl80211_iftype opmode);
--#else
--static inline const char *ath_opmode_to_string(enum nl80211_iftype opmode)
--{
--	return "UNKNOWN";
--}
--#endif
- 
- #endif /* ATH_H */
diff --git a/package/mac80211/patches/401-ath9k_blink_default.patch b/package/mac80211/patches/401-ath9k_blink_default.patch
deleted file mode 100644
index b0cef87..0000000
--- a/package/mac80211/patches/401-ath9k_blink_default.patch
+++ /dev/null
@@ -1,11 +0,0 @@
---- a/drivers/net/wireless/ath/ath9k/init.c
-+++ b/drivers/net/wireless/ath/ath9k/init.c
-@@ -45,7 +45,7 @@ int ath9k_modparam_nohwcrypt;
- module_param_named(nohwcrypt, ath9k_modparam_nohwcrypt, int, 0444);
- MODULE_PARM_DESC(nohwcrypt, "Disable hardware encryption");
- 
--int led_blink;
-+int led_blink = 1;
- module_param_named(blink, led_blink, int, 0444);
- MODULE_PARM_DESC(blink, "Enable LED blink on activity");
- 
diff --git a/package/mac80211/patches/402-ath9k-fix-invalid-mac-address-handling.patch b/package/mac80211/patches/402-ath9k-fix-invalid-mac-address-handling.patch
deleted file mode 100644
index 63ab0db..0000000
--- a/package/mac80211/patches/402-ath9k-fix-invalid-mac-address-handling.patch
+++ /dev/null
@@ -1,29 +0,0 @@
---- a/drivers/net/wireless/ath/ath9k/hw.c
-+++ b/drivers/net/wireless/ath/ath9k/hw.c
-@@ -19,6 +19,7 @@
- #include <linux/module.h>
- #include <linux/time.h>
- #include <linux/bitops.h>
-+#include <linux/etherdevice.h>
- #include <asm/unaligned.h>
- 
- #include "hw.h"
-@@ -449,8 +450,16 @@ static int ath9k_hw_init_macaddr(struct 
- 		common->macaddr[2 * i] = eeval >> 8;
- 		common->macaddr[2 * i + 1] = eeval & 0xff;
- 	}
--	if (sum == 0 || sum == 0xffff * 3)
--		return -EADDRNOTAVAIL;
-+	if (!is_valid_ether_addr(common->macaddr)) {
-+		ath_err(common,
-+			"eeprom contains invalid mac address: %pM\n",
-+			common->macaddr);
-+
-+		random_ether_addr(common->macaddr);
-+		ath_err(common,
-+			"random mac address will be used: %pM\n",
-+			common->macaddr);
-+	}
- 
- 	return 0;
- }
diff --git a/package/mac80211/patches/403-ath_regd_optional.patch b/package/mac80211/patches/403-ath_regd_optional.patch
deleted file mode 100644
index 07c54cc..0000000
--- a/package/mac80211/patches/403-ath_regd_optional.patch
+++ /dev/null
@@ -1,68 +0,0 @@
---- a/drivers/net/wireless/ath/regd.c
-+++ b/drivers/net/wireless/ath/regd.c
-@@ -341,6 +341,10 @@ ath_reg_apply_beaconing_flags(struct wip
- 	struct ieee80211_channel *ch;
- 	unsigned int i;
- 
-+#ifdef CPTCFG_ATH_USER_REGD
-+	return;
-+#endif
-+
- 	for (band = 0; band < IEEE80211_NUM_BANDS; band++) {
- 		if (!wiphy->bands[band])
- 			continue;
-@@ -374,6 +378,10 @@ ath_reg_apply_ir_flags(struct wiphy *wip
- {
- 	struct ieee80211_supported_band *sband;
- 
-+#ifdef CPTCFG_ATH_USER_REGD
-+	return;
-+#endif
-+
- 	sband = wiphy->bands[IEEE80211_BAND_2GHZ];
- 	if (!sband)
- 		return;
-@@ -402,6 +410,10 @@ static void ath_reg_apply_radar_flags(st
- 	struct ieee80211_channel *ch;
- 	unsigned int i;
- 
-+#ifdef CPTCFG_ATH_USER_REGD
-+	return;
-+#endif
-+
- 	if (!wiphy->bands[IEEE80211_BAND_5GHZ])
- 		return;
- 
-@@ -631,6 +643,10 @@ ath_regd_init_wiphy(struct ath_regulator
- {
- 	const struct ieee80211_regdomain *regd;
- 
-+#ifdef CPTCFG_ATH_USER_REGD
-+	return 0;
-+#endif
-+
- 	wiphy->reg_notifier = reg_notifier;
- 	wiphy->regulatory_flags |= REGULATORY_STRICT_REG |
- 				   REGULATORY_CUSTOM_REG;
---- a/drivers/net/wireless/ath/Kconfig
-+++ b/drivers/net/wireless/ath/Kconfig
-@@ -21,6 +21,9 @@ menuconfig ATH_CARDS
- 
- if ATH_CARDS
- 
-+config ATH_USER_REGD
-+	bool "Do not enforce EEPROM regulatory restrictions"
-+
- config ATH_DEBUG
- 	bool "Atheros wireless debugging"
- 	---help---
---- a/.local-symbols
-+++ b/.local-symbols
-@@ -119,6 +119,7 @@ RTL8187_LEDS=
- ATH_COMMON=
- ATH_CARDS=
- ATH_DEBUG=
-+ATH_USER_REGD=
- ATH_REG_DYNAMIC_USER_REG_HINTS=
- ATH_REG_DYNAMIC_USER_CERT_TESTING=
- ATH5K=
diff --git a/package/mac80211/patches/404-world_regd_fixup.patch b/package/mac80211/patches/404-world_regd_fixup.patch
deleted file mode 100644
index 2b04309..0000000
--- a/package/mac80211/patches/404-world_regd_fixup.patch
+++ /dev/null
@@ -1,84 +0,0 @@
---- a/drivers/net/wireless/ath/regd.c
-+++ b/drivers/net/wireless/ath/regd.c
-@@ -43,7 +43,8 @@ static int __ath_regd_init(struct ath_re
- 					 NL80211_RRF_NO_OFDM)
- 
- /* We allow IBSS on these on a case by case basis by regulatory domain */
--#define ATH9K_5GHZ_5150_5350	REG_RULE(5150-10, 5350+10, 80, 0, 30,\
-+#define ATH9K_5GHZ_5150_5350	REG_RULE(5150-10, 5240+10, 80, 0, 30, 0),\
-+				REG_RULE(5260-10, 5350+10, 80, 0, 30,\
- 					 NL80211_RRF_NO_IR)
- #define ATH9K_5GHZ_5470_5850	REG_RULE(5470-10, 5850+10, 80, 0, 30,\
- 					 NL80211_RRF_NO_IR)
-@@ -61,57 +62,56 @@ static int __ath_regd_init(struct ath_re
- #define ATH9K_5GHZ_NO_MIDBAND	ATH9K_5GHZ_5150_5350, \
- 				ATH9K_5GHZ_5725_5850
- 
-+#define REGD_RULES(...) \
-+	.reg_rules = { __VA_ARGS__ }, \
-+	.n_reg_rules = ARRAY_SIZE(((struct ieee80211_reg_rule[]) { __VA_ARGS__ }))
-+
- /* Can be used for:
-  * 0x60, 0x61, 0x62 */
- static const struct ieee80211_regdomain ath_world_regdom_60_61_62 = {
--	.n_reg_rules = 5,
- 	.alpha2 =  "99",
--	.reg_rules = {
-+	REGD_RULES(
- 		ATH9K_2GHZ_ALL,
- 		ATH9K_5GHZ_ALL,
--	}
-+	)
- };
- 
- /* Can be used by 0x63 and 0x65 */
- static const struct ieee80211_regdomain ath_world_regdom_63_65 = {
--	.n_reg_rules = 4,
- 	.alpha2 =  "99",
--	.reg_rules = {
-+	REGD_RULES(
- 		ATH9K_2GHZ_CH01_11,
- 		ATH9K_2GHZ_CH12_13,
- 		ATH9K_5GHZ_NO_MIDBAND,
--	}
-+	)
- };
- 
- /* Can be used by 0x64 only */
- static const struct ieee80211_regdomain ath_world_regdom_64 = {
--	.n_reg_rules = 3,
- 	.alpha2 =  "99",
--	.reg_rules = {
-+	REGD_RULES(
- 		ATH9K_2GHZ_CH01_11,
- 		ATH9K_5GHZ_NO_MIDBAND,
--	}
-+	)
- };
- 
- /* Can be used by 0x66 and 0x69 */
- static const struct ieee80211_regdomain ath_world_regdom_66_69 = {
--	.n_reg_rules = 3,
- 	.alpha2 =  "99",
--	.reg_rules = {
-+	REGD_RULES(
- 		ATH9K_2GHZ_CH01_11,
- 		ATH9K_5GHZ_ALL,
--	}
-+	)
- };
- 
- /* Can be used by 0x67, 0x68, 0x6A and 0x6C */
- static const struct ieee80211_regdomain ath_world_regdom_67_68_6A_6C = {
--	.n_reg_rules = 4,
- 	.alpha2 =  "99",
--	.reg_rules = {
-+	REGD_RULES(
- 		ATH9K_2GHZ_CH01_11,
- 		ATH9K_2GHZ_CH12_13,
- 		ATH9K_5GHZ_ALL,
--	}
-+	)
- };
- 
- static bool dynamic_country_user_possible(struct ath_regulatory *reg)
diff --git a/package/mac80211/patches/405-regd_no_assoc_hints.patch b/package/mac80211/patches/405-regd_no_assoc_hints.patch
deleted file mode 100644
index 6ad4fda..0000000
--- a/package/mac80211/patches/405-regd_no_assoc_hints.patch
+++ /dev/null
@@ -1,19 +0,0 @@
---- a/net/wireless/reg.c
-+++ b/net/wireless/reg.c
-@@ -1878,6 +1878,8 @@ void regulatory_hint_country_ie(struct w
- 	enum environment_cap env = ENVIRON_ANY;
- 	struct regulatory_request *request = NULL, *lr;
- 
-+	return;
-+
- 	/* IE len must be evenly divisible by 2 */
- 	if (country_ie_len & 0x01)
- 		return;
-@@ -2072,6 +2074,7 @@ static void restore_regulatory_settings(
- 
- void regulatory_hint_disconnect(void)
- {
-+	return;
- 	REG_DBG_PRINT("All devices are disconnected, going to restore regulatory settings\n");
- 	restore_regulatory_settings(false);
- }
diff --git a/package/mac80211/patches/406-ath_regd_us.patch b/package/mac80211/patches/406-ath_regd_us.patch
deleted file mode 100644
index cc55877..0000000
--- a/package/mac80211/patches/406-ath_regd_us.patch
+++ /dev/null
@@ -1,26 +0,0 @@
---- a/drivers/net/wireless/ath/regd_common.h
-+++ b/drivers/net/wireless/ath/regd_common.h
-@@ -32,6 +32,7 @@ enum EnumRd {
- 	FCC2_WORLD = 0x21,
- 	FCC2_ETSIC = 0x22,
- 	FCC6_WORLD = 0x23,
-+	FCC3_FCCA_2 = 0x2A,
- 	FRANCE_RES = 0x31,
- 	FCC3_FCCA = 0x3A,
- 	FCC3_WORLD = 0x3B,
-@@ -167,6 +168,7 @@ static struct reg_dmn_pair_mapping regDo
- 	{FCC2_WORLD, CTL_FCC, CTL_ETSI},
- 	{FCC2_ETSIC, CTL_FCC, CTL_ETSI},
- 	{FCC3_FCCA, CTL_FCC, CTL_FCC},
-+	{FCC3_FCCA_2, CTL_FCC, CTL_FCC},
- 	{FCC3_WORLD, CTL_FCC, CTL_ETSI},
- 	{FCC4_FCCA, CTL_FCC, CTL_FCC},
- 	{FCC5_FCCA, CTL_FCC, CTL_FCC},
-@@ -463,6 +465,7 @@ static struct country_code_to_enum_rd al
- 	{CTRY_UAE, NULL1_WORLD, "AE"},
- 	{CTRY_UNITED_KINGDOM, ETSI1_WORLD, "GB"},
- 	{CTRY_UNITED_STATES, FCC3_FCCA, "US"},
-+	{CTRY_UNITED_STATES, FCC3_FCCA_2, "US"},
- 	/* This "PS" is for US public safety actually... to support this we
- 	 * would need to assign new special alpha2 to CRDA db as with the world
- 	 * regdomain and use another alpha2 */
diff --git a/package/mac80211/patches/410-ath9k_allow_adhoc_and_ap.patch b/package/mac80211/patches/410-ath9k_allow_adhoc_and_ap.patch
deleted file mode 100644
index 1f71e0b..0000000
--- a/package/mac80211/patches/410-ath9k_allow_adhoc_and_ap.patch
+++ /dev/null
@@ -1,10 +0,0 @@
---- a/drivers/net/wireless/ath/ath9k/init.c
-+++ b/drivers/net/wireless/ath/ath9k/init.c
-@@ -866,6 +866,7 @@ static const struct ieee80211_iface_limi
- #endif
- 				 BIT(NL80211_IFTYPE_AP) |
- 				 BIT(NL80211_IFTYPE_P2P_GO) },
-+	{ .max = 1,	.types = BIT(NL80211_IFTYPE_ADHOC) },
- };
- 
- static const struct ieee80211_iface_limit if_dfs_limits[] = {
diff --git a/package/mac80211/patches/411-ath5k_allow_adhoc_and_ap.patch b/package/mac80211/patches/411-ath5k_allow_adhoc_and_ap.patch
deleted file mode 100644
index 3487ab2..0000000
--- a/package/mac80211/patches/411-ath5k_allow_adhoc_and_ap.patch
+++ /dev/null
@@ -1,46 +0,0 @@
---- a/drivers/net/wireless/ath/ath5k/mac80211-ops.c
-+++ b/drivers/net/wireless/ath/ath5k/mac80211-ops.c
-@@ -86,13 +86,8 @@ ath5k_add_interface(struct ieee80211_hw 
- 		goto end;
- 	}
- 
--	/* Don't allow other interfaces if one ad-hoc is configured.
--	 * TODO: Fix the problems with ad-hoc and multiple other interfaces.
--	 * We would need to operate the HW in ad-hoc mode to allow TSF updates
--	 * for the IBSS, but this breaks with additional AP or STA interfaces
--	 * at the moment. */
--	if (ah->num_adhoc_vifs ||
--	    (ah->nvifs && vif->type == NL80211_IFTYPE_ADHOC)) {
-+	/* Don't allow more than one ad-hoc interface */
-+	if (ah->num_adhoc_vifs && vif->type == NL80211_IFTYPE_ADHOC) {
- 		ATH5K_ERR(ah, "Only one single ad-hoc interface is allowed.\n");
- 		ret = -ELNRNG;
- 		goto end;
---- a/drivers/net/wireless/ath/ath5k/base.c
-+++ b/drivers/net/wireless/ath/ath5k/base.c
-@@ -1934,7 +1934,7 @@ ath5k_beacon_send(struct ath5k_hw *ah)
- 	}
- 
- 	if ((ah->opmode == NL80211_IFTYPE_AP && ah->num_ap_vifs +
--			ah->num_mesh_vifs > 1) ||
-+			ah->num_adhoc_vifs + ah->num_mesh_vifs > 1) ||
- 			ah->opmode == NL80211_IFTYPE_MESH_POINT) {
- 		u64 tsf = ath5k_hw_get_tsf64(ah);
- 		u32 tsftu = TSF_TO_TU(tsf);
-@@ -2020,7 +2020,7 @@ ath5k_beacon_update_timers(struct ath5k_
- 
- 	intval = ah->bintval & AR5K_BEACON_PERIOD;
- 	if (ah->opmode == NL80211_IFTYPE_AP && ah->num_ap_vifs
--		+ ah->num_mesh_vifs > 1) {
-+		+ ah->num_adhoc_vifs + ah->num_mesh_vifs > 1) {
- 		intval /= ATH_BCBUF;	/* staggered multi-bss beacons */
- 		if (intval < 15)
- 			ATH5K_WARN(ah, "intval %u is too low, min 15\n",
-@@ -2487,6 +2487,7 @@ static const struct ieee80211_iface_limi
- 				 BIT(NL80211_IFTYPE_MESH_POINT) |
- #endif
- 				 BIT(NL80211_IFTYPE_AP) },
-+	{ .max = 1,	.types = BIT(NL80211_IFTYPE_ADHOC) },
- };
- 
- static const struct ieee80211_iface_combination if_comb = {
diff --git a/package/mac80211/patches/420-ath5k_disable_fast_cc.patch b/package/mac80211/patches/420-ath5k_disable_fast_cc.patch
deleted file mode 100644
index 414f495..0000000
--- a/package/mac80211/patches/420-ath5k_disable_fast_cc.patch
+++ /dev/null
@@ -1,18 +0,0 @@
---- a/drivers/net/wireless/ath/ath5k/reset.c
-+++ b/drivers/net/wireless/ath/ath5k/reset.c
-@@ -1154,6 +1154,7 @@ ath5k_hw_reset(struct ath5k_hw *ah, enum
- 	tsf_lo = 0;
- 	mode = 0;
- 
-+#if 0
- 	/*
- 	 * Sanity check for fast flag
- 	 * Fast channel change only available
-@@ -1161,6 +1162,7 @@ ath5k_hw_reset(struct ath5k_hw *ah, enum
- 	 */
- 	if (fast && (ah->ah_radio != AR5K_RF2413) &&
- 	(ah->ah_radio != AR5K_RF5413))
-+#endif
- 		fast = false;
- 
- 	/* Disable sleep clock operation
diff --git a/package/mac80211/patches/430-add_ath5k_platform.patch b/package/mac80211/patches/430-add_ath5k_platform.patch
deleted file mode 100644
index b213e2a..0000000
--- a/package/mac80211/patches/430-add_ath5k_platform.patch
+++ /dev/null
@@ -1,33 +0,0 @@
---- /dev/null
-+++ b/include/linux/ath5k_platform.h
-@@ -0,0 +1,30 @@
-+/*
-+ * Copyright (c) 2008 Atheros Communications Inc.
-+ * Copyright (c) 2009 Gabor Juhos <juhosg@openwrt.org>
-+ * Copyright (c) 2009 Imre Kaloz <kaloz@openwrt.org>
-+ * Copyright (c) 2010 Daniel Golle <daniel.golle@gmail.com>
-+ *
-+ * Permission to use, copy, modify, and/or distribute this software for any
-+ * purpose with or without fee is hereby granted, provided that the above
-+ * copyright notice and this permission notice appear in all copies.
-+ *
-+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
-+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
-+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
-+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
-+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
-+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
-+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
-+ */
-+
-+#ifndef _LINUX_ATH5K_PLATFORM_H
-+#define _LINUX_ATH5K_PLATFORM_H
-+
-+#define ATH5K_PLAT_EEP_MAX_WORDS	2048
-+
-+struct ath5k_platform_data {
-+	u16 *eeprom_data;
-+	u8 *macaddr;
-+};
-+
-+#endif /* _LINUX_ATH5K_PLATFORM_H */
diff --git a/package/mac80211/patches/431-add_platform_eeprom_support_to_ath5k.patch b/package/mac80211/patches/431-add_platform_eeprom_support_to_ath5k.patch
deleted file mode 100644
index a223b38..0000000
--- a/package/mac80211/patches/431-add_platform_eeprom_support_to_ath5k.patch
+++ /dev/null
@@ -1,56 +0,0 @@
---- a/drivers/net/wireless/ath/ath5k/pci.c
-+++ b/drivers/net/wireless/ath/ath5k/pci.c
-@@ -21,6 +21,7 @@
- #include <linux/pci-aspm.h>
- #include <linux/etherdevice.h>
- #include <linux/module.h>
-+#include <linux/ath5k_platform.h>
- #include "../ath.h"
- #include "ath5k.h"
- #include "debug.h"
-@@ -72,7 +73,7 @@ static void ath5k_pci_read_cachesize(str
- }
- 
- /*
-- * Read from eeprom
-+ * Read from eeprom or platform_data
-  */
- static bool
- ath5k_pci_eeprom_read(struct ath_common *common, u32 offset, u16 *data)
-@@ -80,6 +81,19 @@ ath5k_pci_eeprom_read(struct ath_common 
- 	struct ath5k_hw *ah = (struct ath5k_hw *) common->ah;
- 	u32 status, timeout;
- 
-+	struct ath5k_platform_data *pdata = NULL;
-+	
-+	if (ah->pdev)
-+		pdata = ah->pdev->dev.platform_data;
-+
-+	if (pdata && pdata->eeprom_data && pdata->eeprom_data[61] == AR5K_EEPROM_MAGIC_VALUE) {
-+		if (offset >= ATH5K_PLAT_EEP_MAX_WORDS) 
-+			return false;
-+		
-+		*data = pdata->eeprom_data[offset];
-+		return true;
-+	}
-+
- 	/*
- 	 * Initialize EEPROM access
- 	 */
-@@ -123,6 +137,16 @@ static int ath5k_pci_eeprom_read_mac(str
- 	u16 data;
- 	int octet;
- 
-+	struct ath5k_platform_data *pdata = NULL;
-+
-+	if (ah->pdev)
-+		pdata = ah->pdev->dev.platform_data;
-+
-+	if (pdata && pdata->macaddr) {
-+		memcpy(mac, pdata->macaddr, ETH_ALEN);
-+		return 0;
-+	}
-+
- 	AR5K_EEPROM_READ(0x20, data);
- 
- 	for (offset = 0x1f, octet = 0, total = 0; offset >= 0x1d; offset--) {
diff --git a/package/mac80211/patches/432-ath5k_add_pciids.patch b/package/mac80211/patches/432-ath5k_add_pciids.patch
deleted file mode 100644
index e5c85ce..0000000
--- a/package/mac80211/patches/432-ath5k_add_pciids.patch
+++ /dev/null
@@ -1,11 +0,0 @@
---- a/drivers/net/wireless/ath/ath5k/pci.c
-+++ b/drivers/net/wireless/ath/ath5k/pci.c
-@@ -48,6 +48,8 @@ static DEFINE_PCI_DEVICE_TABLE(ath5k_pci
- 	{ PCI_VDEVICE(ATHEROS, 0x001b) }, /* 5413 Eagle */
- 	{ PCI_VDEVICE(ATHEROS, 0x001c) }, /* PCI-E cards */
- 	{ PCI_VDEVICE(ATHEROS, 0x001d) }, /* 2417 Nala */
-+	{ PCI_VDEVICE(ATHEROS, 0xff16) }, /* 2413,2414 sx76x on lantiq_danube */
-+	{ PCI_VDEVICE(ATHEROS, 0xff1a) }, /* 2417 arv45xx on lantiq_danube */
- 	{ PCI_VDEVICE(ATHEROS, 0xff1b) }, /* AR5BXB63 */
- 	{ 0 }
- };
diff --git a/package/mac80211/patches/440-ath5k_channel_bw_debugfs.patch b/package/mac80211/patches/440-ath5k_channel_bw_debugfs.patch
deleted file mode 100644
index a8ebdf5..0000000
--- a/package/mac80211/patches/440-ath5k_channel_bw_debugfs.patch
+++ /dev/null
@@ -1,143 +0,0 @@
-This adds a bwmode debugfs file which can be used to set alternate
-channel operating bandwidths.  Only tested with AR5413 and only at
-5 and 20 mhz channels.
-
-Signed-off-by: Pat Erley <pat-lkml at erley.org>
----
-Other devices will need to be added to the switch in  write_file_bwmode
-
-drivers/net/wireless/ath/ath5k/debug.c |   86 ++++++++++++++++++++++++++++++++
- 1 files changed, 86 insertions(+), 0 deletions(-)
-
---- a/drivers/net/wireless/ath/ath5k/debug.c
-+++ b/drivers/net/wireless/ath/ath5k/debug.c
-@@ -821,6 +821,97 @@ static const struct file_operations fops
- 	.llseek = default_llseek,
- };
- 
-+/* debugfs: bwmode */
-+
-+static ssize_t read_file_bwmode(struct file *file, char __user *user_buf,
-+				   size_t count, loff_t *ppos)
-+{
-+	struct ath5k_hw *ah = file->private_data;
-+	char buf[15];
-+	unsigned int len = 0;
-+
-+	int cur_ah_bwmode = ah->ah_bwmode_debug;
-+
-+#define print_selected(MODE, LABEL) \
-+	if (cur_ah_bwmode == MODE) \
-+		len += snprintf(buf+len, sizeof(buf)-len, "[%s]", LABEL); \
-+	else \
-+		len += snprintf(buf+len, sizeof(buf)-len, "%s", LABEL); \
-+	len += snprintf(buf+len, sizeof(buf)-len, " ");
-+
-+	print_selected(AR5K_BWMODE_5MHZ, "5");
-+	print_selected(AR5K_BWMODE_10MHZ, "10");
-+	print_selected(AR5K_BWMODE_DEFAULT, "20");
-+	print_selected(AR5K_BWMODE_40MHZ, "40");
-+#undef print_selected
-+
-+	len += snprintf(buf+len, sizeof(buf)-len, "\n");
-+
-+	return simple_read_from_buffer(user_buf, count, ppos, buf, len);
-+}
-+
-+static ssize_t write_file_bwmode(struct file *file,
-+				 const char __user *userbuf,
-+				 size_t count, loff_t *ppos)
-+{
-+	struct ath5k_hw *ah = file->private_data;
-+	char buf[3];
-+	int bw = 20;
-+	int tobwmode = AR5K_BWMODE_DEFAULT;
-+
-+	if (copy_from_user(buf, userbuf, min(count, sizeof(buf))))
-+		return -EFAULT;
-+
-+	/* TODO: Add check for active interface */
-+
-+	if(strncmp(buf, "5", 1) == 0 ) {
-+		tobwmode = AR5K_BWMODE_5MHZ;
-+		bw = 5;
-+	} else if ( strncmp(buf, "10", 2) == 0 ) {
-+		tobwmode = AR5K_BWMODE_10MHZ;
-+		bw = 10;
-+	} else if ( strncmp(buf, "20", 2) == 0 ) {
-+		tobwmode = AR5K_BWMODE_DEFAULT;
-+		bw = 20;
-+	} else if ( strncmp(buf, "40", 2) == 0 ) {
-+		tobwmode = AR5K_BWMODE_40MHZ;
-+		bw = 40;
-+	} else
-+		return -EINVAL;
-+
-+	ATH5K_INFO(ah, "Changing to %imhz channel width[%i]\n",
-+		bw, tobwmode);
-+
-+	switch (ah->ah_radio) {
-+	/* TODO: only define radios that actually support 5/10mhz channels */
-+	case AR5K_RF5413:
-+	case AR5K_RF5110:
-+	case AR5K_RF5111:
-+	case AR5K_RF5112:
-+	case AR5K_RF2413:
-+	case AR5K_RF2316:
-+	case AR5K_RF2317:
-+	case AR5K_RF2425:
-+		if(ah->ah_bwmode_debug != tobwmode) {
-+			mutex_lock(&ah->lock);
-+			ah->ah_bwmode = tobwmode;
-+			ah->ah_bwmode_debug = tobwmode;
-+			mutex_unlock(&ah->lock);
-+		}
-+		break;
-+	default:
-+		return -EOPNOTSUPP;
-+	}
-+	return count;
-+}
-+
-+static const struct file_operations fops_bwmode = {
-+	.read = read_file_bwmode,
-+	.write = write_file_bwmode,
-+	.open = simple_open,
-+	.owner = THIS_MODULE,
-+	.llseek = default_llseek,
-+};
- 
- /* debugfs: queues etc */
- 
-@@ -914,6 +1005,9 @@ ath5k_debug_init_device(struct ath5k_hw 
- 	debugfs_create_file("beacon", S_IWUSR | S_IRUSR, phydir, ah,
- 			    &fops_beacon);
- 
-+	debugfs_create_file("bwmode", S_IWUSR | S_IRUSR, phydir, ah,
-+			    &fops_bwmode);
-+
- 	debugfs_create_file("reset", S_IWUSR, phydir, ah, &fops_reset);
- 
- 	debugfs_create_file("antenna", S_IWUSR | S_IRUSR, phydir, ah,
---- a/drivers/net/wireless/ath/ath5k/ath5k.h
-+++ b/drivers/net/wireless/ath/ath5k/ath5k.h
-@@ -1369,6 +1369,7 @@ struct ath5k_hw {
- 	u8			ah_coverage_class;
- 	bool			ah_ack_bitrate_high;
- 	u8			ah_bwmode;
-+	u8			ah_bwmode_debug;
- 	bool			ah_short_slot;
- 
- 	/* Antenna Control */
---- a/drivers/net/wireless/ath/ath5k/base.c
-+++ b/drivers/net/wireless/ath/ath5k/base.c
-@@ -466,6 +466,9 @@ ath5k_chan_set(struct ath5k_hw *ah, stru
- 		return -EINVAL;
- 	}
- 
-+	if (ah->ah_bwmode_debug != AR5K_BWMODE_DEFAULT)
-+		ah->ah_bwmode = ah->ah_bwmode_debug;
-+
- 	/*
- 	 * To switch channels clear any pending DMA operations;
- 	 * wait long enough for the RX fifo to drain, reset the
diff --git a/package/mac80211/patches/500-ath9k_eeprom_debugfs.patch b/package/mac80211/patches/500-ath9k_eeprom_debugfs.patch
deleted file mode 100644
index 664cf45..0000000
--- a/package/mac80211/patches/500-ath9k_eeprom_debugfs.patch
+++ /dev/null
@@ -1,65 +0,0 @@
---- a/drivers/net/wireless/ath/ath9k/debug.c
-+++ b/drivers/net/wireless/ath/ath9k/debug.c
-@@ -1481,6 +1481,53 @@ void ath9k_deinit_debug(struct ath_softc
- 	ath9k_spectral_deinit_debug(sc);
- }
- 
-+static ssize_t read_file_eeprom(struct file *file, char __user *user_buf,
-+			     size_t count, loff_t *ppos)
-+{
-+	struct ath_softc *sc = file->private_data;
-+	struct ath_hw *ah = sc->sc_ah;
-+	struct ath_common *common = ath9k_hw_common(ah);
-+	int bytes = 0;
-+	int pos = *ppos;
-+	int size = 4096;
-+	u16 val;
-+	int i;
-+
-+	if (AR_SREV_9300_20_OR_LATER(ah))
-+		size = 16384;
-+
-+	if (*ppos < 0)
-+		return -EINVAL;
-+
-+	if (count > size - *ppos)
-+		count = size - *ppos;
-+
-+	for (i = *ppos / 2; count > 0; count -= bytes, *ppos += bytes, i++) {
-+		void *from = &val;
-+
-+		if (!common->bus_ops->eeprom_read(common, i, &val))
-+			val = 0xffff;
-+
-+		if (*ppos % 2) {
-+			from++;
-+			bytes = 1;
-+		} else if (count == 1) {
-+			bytes = 1;
-+		} else {
-+			bytes = 2;
-+		}
-+		copy_to_user(user_buf, from, bytes);
-+		user_buf += bytes;
-+	}
-+	return *ppos - pos;
-+}
-+
-+static const struct file_operations fops_eeprom = {
-+	.read = read_file_eeprom,
-+	.open = simple_open,
-+	.owner = THIS_MODULE
-+};
-+
- int ath9k_init_debug(struct ath_hw *ah)
- {
- 	struct ath_common *common = ath9k_hw_common(ah);
-@@ -1500,6 +1547,8 @@ int ath9k_init_debug(struct ath_hw *ah)
- 	ath9k_tx99_init_debug(sc);
- 	ath9k_spectral_init_debug(sc);
- 
-+	debugfs_create_file("eeprom", S_IRUSR, sc->debug.debugfs_phy, sc,
-+			    &fops_eeprom);
- 	debugfs_create_file("dma", S_IRUSR, sc->debug.debugfs_phy, sc,
- 			    &fops_dma);
- 	debugfs_create_file("interrupt", S_IRUSR, sc->debug.debugfs_phy, sc,
diff --git a/package/mac80211/patches/501-ath9k-eeprom_endianess.patch b/package/mac80211/patches/501-ath9k-eeprom_endianess.patch
deleted file mode 100644
index 96e7c6d..0000000
--- a/package/mac80211/patches/501-ath9k-eeprom_endianess.patch
+++ /dev/null
@@ -1,102 +0,0 @@
---- a/drivers/net/wireless/ath/ath9k/eeprom_def.c
-+++ b/drivers/net/wireless/ath/ath9k/eeprom_def.c
-@@ -262,7 +262,7 @@ static int ath9k_hw_def_check_eeprom(str
- {
- 	struct ar5416_eeprom_def *eep = &ah->eeprom.def;
- 	struct ath_common *common = ath9k_hw_common(ah);
--	u16 *eepdata, temp, magic, magic2;
-+	u16 *eepdata, temp, magic;
- 	u32 sum = 0, el;
- 	bool need_swap = false;
- 	int i, addr, size;
-@@ -272,27 +272,16 @@ static int ath9k_hw_def_check_eeprom(str
- 		return false;
- 	}
- 
--	if (!ath9k_hw_use_flash(ah)) {
--		ath_dbg(common, EEPROM, "Read Magic = 0x%04X\n", magic);
--
--		if (magic != AR5416_EEPROM_MAGIC) {
--			magic2 = swab16(magic);
--
--			if (magic2 == AR5416_EEPROM_MAGIC) {
--				size = sizeof(struct ar5416_eeprom_def);
--				need_swap = true;
--				eepdata = (u16 *) (&ah->eeprom);
--
--				for (addr = 0; addr < size / sizeof(u16); addr++) {
--					temp = swab16(*eepdata);
--					*eepdata = temp;
--					eepdata++;
--				}
--			} else {
--				ath_err(common,
--					"Invalid EEPROM Magic. Endianness mismatch.\n");
--				return -EINVAL;
--			}
-+	if (swab16(magic) == AR5416_EEPROM_MAGIC &&
-+	    !(ah->ah_flags & AH_NO_EEP_SWAP)) {
-+		size = sizeof(struct ar5416_eeprom_def);
-+		need_swap = true;
-+		eepdata = (u16 *) (&ah->eeprom);
-+
-+		for (addr = 0; addr < size / sizeof(u16); addr++) {
-+			temp = swab16(*eepdata);
-+			*eepdata = temp;
-+			eepdata++;
- 		}
- 	}
- 
---- a/drivers/net/wireless/ath/ath9k/eeprom_4k.c
-+++ b/drivers/net/wireless/ath/ath9k/eeprom_4k.c
-@@ -57,7 +57,7 @@ static bool ath9k_hw_4k_fill_eeprom(stru
- {
- 	struct ath_common *common = ath9k_hw_common(ah);
- 
--	if (!ath9k_hw_use_flash(ah)) {
-+	if (!(ah->ah_flags & AH_NO_EEP_SWAP)) {
- 		ath_dbg(common, EEPROM, "Reading from EEPROM, not flash\n");
- 	}
- 
---- a/drivers/net/wireless/ath/ath9k/eeprom_9287.c
-+++ b/drivers/net/wireless/ath/ath9k/eeprom_9287.c
-@@ -60,7 +60,7 @@ static bool ath9k_hw_ar9287_fill_eeprom(
- {
- 	struct ath_common *common = ath9k_hw_common(ah);
- 
--	if (!ath9k_hw_use_flash(ah)) {
-+	if (!(ah->ah_flags & AH_NO_EEP_SWAP)) {
- 		ath_dbg(common, EEPROM, "Reading from EEPROM, not flash\n");
- 	}
- 
---- a/drivers/net/wireless/ath/ath9k/hw.h
-+++ b/drivers/net/wireless/ath/ath9k/hw.h
-@@ -724,6 +724,7 @@ enum ath_cal_list {
- #define AH_USE_EEPROM   0x1
- #define AH_UNPLUGGED    0x2 /* The card has been physically removed. */
- #define AH_FASTCC       0x4
-+#define AH_NO_EEP_SWAP  0x8 /* Do not swap EEPROM data */
- 
- struct ath_hw {
- 	struct ath_ops reg_ops;
---- a/drivers/net/wireless/ath/ath9k/init.c
-+++ b/drivers/net/wireless/ath/ath9k/init.c
-@@ -722,6 +722,8 @@ static int ath9k_init_softc(u16 devid, s
- 		ah->is_clk_25mhz = pdata->is_clk_25mhz;
- 		ah->get_mac_revision = pdata->get_mac_revision;
- 		ah->external_reset = pdata->external_reset;
-+		if (!pdata->endian_check)
-+			ah->ah_flags |= AH_NO_EEP_SWAP;
- 	}
- 
- 	common->ops = &ah->reg_ops;
---- a/include/linux/ath9k_platform.h
-+++ b/include/linux/ath9k_platform.h
-@@ -31,6 +31,7 @@ struct ath9k_platform_data {
- 	u32 gpio_mask;
- 	u32 gpio_val;
- 
-+	bool endian_check;
- 	bool is_clk_25mhz;
- 	bool tx_gain_buffalo;
- 
diff --git a/package/mac80211/patches/502-ath9k_ahb_init.patch b/package/mac80211/patches/502-ath9k_ahb_init.patch
deleted file mode 100644
index 4edc63b..0000000
--- a/package/mac80211/patches/502-ath9k_ahb_init.patch
+++ /dev/null
@@ -1,32 +0,0 @@
---- a/drivers/net/wireless/ath/ath9k/init.c
-+++ b/drivers/net/wireless/ath/ath9k/init.c
-@@ -1112,23 +1112,23 @@ static int __init ath9k_init(void)
- 		goto err_out;
- 	}
- 
--	error = ath_pci_init();
-+	error = ath_ahb_init();
- 	if (error < 0) {
--		pr_err("No PCI devices found, driver not installed\n");
- 		error = -ENODEV;
- 		goto err_rate_unregister;
- 	}
- 
--	error = ath_ahb_init();
-+	error = ath_pci_init();
- 	if (error < 0) {
-+		pr_err("No PCI devices found, driver not installed\n");
- 		error = -ENODEV;
--		goto err_pci_exit;
-+		goto err_ahb_exit;
- 	}
- 
- 	return 0;
- 
-- err_pci_exit:
--	ath_pci_exit();
-+ err_ahb_exit:
-+	ath_ahb_exit();
- 
-  err_rate_unregister:
- 	ath_rate_control_unregister();
diff --git a/package/mac80211/patches/510-ath9k_intr_mitigation_tweak.patch b/package/mac80211/patches/510-ath9k_intr_mitigation_tweak.patch
deleted file mode 100644
index d7478ff..0000000
--- a/package/mac80211/patches/510-ath9k_intr_mitigation_tweak.patch
+++ /dev/null
@@ -1,18 +0,0 @@
---- a/drivers/net/wireless/ath/ath9k/hw.c
-+++ b/drivers/net/wireless/ath/ath9k/hw.c
-@@ -359,13 +359,8 @@ static void ath9k_hw_init_config(struct 
- 
- 	ah->config.rx_intr_mitigation = true;
- 
--	if (AR_SREV_9300_20_OR_LATER(ah)) {
--		ah->config.rimt_last = 500;
--		ah->config.rimt_first = 2000;
--	} else {
--		ah->config.rimt_last = 250;
--		ah->config.rimt_first = 700;
--	}
-+	ah->config.rimt_last = 250;
-+	ah->config.rimt_first = 500;
- 
- 	/*
- 	 * We need this for PCI devices only (Cardbus, PCI, miniPCI)
diff --git a/package/mac80211/patches/511-ath9k_reduce_rxbuf.patch b/package/mac80211/patches/511-ath9k_reduce_rxbuf.patch
deleted file mode 100644
index ef0b9a1..0000000
--- a/package/mac80211/patches/511-ath9k_reduce_rxbuf.patch
+++ /dev/null
@@ -1,11 +0,0 @@
---- a/drivers/net/wireless/ath/ath9k/ath9k.h
-+++ b/drivers/net/wireless/ath/ath9k/ath9k.h
-@@ -90,7 +90,7 @@ int ath_descdma_setup(struct ath_softc *
- 		(_l) &= ((_sz) - 1);		\
- 	} while (0)
- 
--#define ATH_RXBUF               512
-+#define ATH_RXBUF               256
- #define ATH_TXBUF               512
- #define ATH_TXBUF_RESERVE       5
- #define ATH_MAX_QDEPTH          (ATH_TXBUF / 4 - ATH_TXBUF_RESERVE)
diff --git a/package/mac80211/patches/512-ath9k_channelbw_debugfs.patch b/package/mac80211/patches/512-ath9k_channelbw_debugfs.patch
deleted file mode 100644
index 8f3cc03..0000000
--- a/package/mac80211/patches/512-ath9k_channelbw_debugfs.patch
+++ /dev/null
@@ -1,125 +0,0 @@
---- a/drivers/net/wireless/ath/ath9k/debug.c
-+++ b/drivers/net/wireless/ath/ath9k/debug.c
-@@ -1528,6 +1528,52 @@ static const struct file_operations fops
- 	.owner = THIS_MODULE
- };
- 
-+
-+static ssize_t read_file_chan_bw(struct file *file, char __user *user_buf,
-+			     size_t count, loff_t *ppos)
-+{
-+	struct ath_softc *sc = file->private_data;
-+	struct ath_common *common = ath9k_hw_common(sc->sc_ah);
-+	char buf[32];
-+	unsigned int len;
-+
-+	len = sprintf(buf, "0x%08x\n", common->chan_bw);
-+	return simple_read_from_buffer(user_buf, count, ppos, buf, len);
-+}
-+
-+static ssize_t write_file_chan_bw(struct file *file, const char __user *user_buf,
-+			     size_t count, loff_t *ppos)
-+{
-+	struct ath_softc *sc = file->private_data;
-+	struct ath_common *common = ath9k_hw_common(sc->sc_ah);
-+	unsigned long chan_bw;
-+	char buf[32];
-+	ssize_t len;
-+
-+	len = min(count, sizeof(buf) - 1);
-+	if (copy_from_user(buf, user_buf, len))
-+		return -EFAULT;
-+
-+	buf[len] = '\0';
-+	if (kstrtoul(buf, 0, &chan_bw))
-+		return -EINVAL;
-+
-+	common->chan_bw = chan_bw;
-+	if (!test_bit(SC_OP_INVALID, &sc->sc_flags))
-+		ath9k_ops.config(sc->hw, IEEE80211_CONF_CHANGE_CHANNEL);
-+
-+	return count;
-+}
-+
-+static const struct file_operations fops_chanbw = {
-+	.read = read_file_chan_bw,
-+	.write = write_file_chan_bw,
-+	.open = simple_open,
-+	.owner = THIS_MODULE,
-+	.llseek = default_llseek,
-+};
-+
-+
- int ath9k_init_debug(struct ath_hw *ah)
- {
- 	struct ath_common *common = ath9k_hw_common(ah);
-@@ -1549,6 +1595,8 @@ int ath9k_init_debug(struct ath_hw *ah)
- 
- 	debugfs_create_file("eeprom", S_IRUSR, sc->debug.debugfs_phy, sc,
- 			    &fops_eeprom);
-+	debugfs_create_file("chanbw", S_IRUSR | S_IWUSR, sc->debug.debugfs_phy,
-+			    sc, &fops_chanbw);
- 	debugfs_create_file("dma", S_IRUSR, sc->debug.debugfs_phy, sc,
- 			    &fops_dma);
- 	debugfs_create_file("interrupt", S_IRUSR, sc->debug.debugfs_phy, sc,
---- a/drivers/net/wireless/ath/ath.h
-+++ b/drivers/net/wireless/ath/ath.h
-@@ -130,6 +130,7 @@ struct ath_common {
- 	struct ieee80211_hw *hw;
- 	int debug_mask;
- 	enum ath_device_state state;
-+	u32 chan_bw;
- 
- 	struct ath_ani ani;
- 
---- a/drivers/net/wireless/ath/ath9k/common.c
-+++ b/drivers/net/wireless/ath/ath9k/common.c
-@@ -52,11 +52,13 @@ EXPORT_SYMBOL(ath9k_cmn_get_hw_crypto_ke
- /*
-  * Update internal channel flags.
-  */
--static void ath9k_cmn_update_ichannel(struct ath9k_channel *ichan,
-+static void ath9k_cmn_update_ichannel(struct ath_common *common,
-+				      struct ath9k_channel *ichan,
- 				      struct cfg80211_chan_def *chandef)
- {
- 	struct ieee80211_channel *chan = chandef->chan;
- 	u16 flags = 0;
-+	int width;
- 
- 	ichan->channel = chan->center_freq;
- 	ichan->chan = chan;
-@@ -64,7 +66,19 @@ static void ath9k_cmn_update_ichannel(st
- 	if (chan->band == IEEE80211_BAND_5GHZ)
- 		flags |= CHANNEL_5GHZ;
- 
--	switch (chandef->width) {
-+	switch (common->chan_bw) {
-+	case 5:
-+		width = NL80211_CHAN_WIDTH_5;
-+		break;
-+	case 10:
-+		width = NL80211_CHAN_WIDTH_10;
-+		break;
-+	default:
-+		width = chandef->width;
-+		break;
-+	}
-+
-+	switch (width) {
- 	case NL80211_CHAN_WIDTH_5:
- 		flags |= CHANNEL_QUARTER;
- 		break;
-@@ -97,10 +111,11 @@ struct ath9k_channel *ath9k_cmn_get_chan
- 					    struct cfg80211_chan_def *chandef)
- {
- 	struct ieee80211_channel *curchan = chandef->chan;
-+	struct ath_common *common = ath9k_hw_common(ah);
- 	struct ath9k_channel *channel;
- 
- 	channel = &ah->channels[curchan->hw_value];
--	ath9k_cmn_update_ichannel(channel, chandef);
-+	ath9k_cmn_update_ichannel(common, channel, chandef);
- 
- 	return channel;
- }
diff --git a/package/mac80211/patches/513-ath9k_add_pci_ids.patch b/package/mac80211/patches/513-ath9k_add_pci_ids.patch
deleted file mode 100644
index db4e6a1..0000000
--- a/package/mac80211/patches/513-ath9k_add_pci_ids.patch
+++ /dev/null
@@ -1,30 +0,0 @@
---- a/drivers/net/wireless/ath/ath9k/hw.c
-+++ b/drivers/net/wireless/ath/ath9k/hw.c
-@@ -614,6 +614,7 @@ int ath9k_hw_init(struct ath_hw *ah)
- 
- 	/* These are all the AR5008/AR9001/AR9002/AR9003 hardware family of chipsets */
- 	switch (ah->hw_version.devid) {
-+	case AR9300_DEVID_INVALID:
- 	case AR5416_DEVID_PCI:
- 	case AR5416_DEVID_PCIE:
- 	case AR5416_AR9100_DEVID:
---- a/drivers/net/wireless/ath/ath9k/hw.h
-+++ b/drivers/net/wireless/ath/ath9k/hw.h
-@@ -34,6 +34,7 @@
- 
- #define ATHEROS_VENDOR_ID	0x168c
- 
-+#define AR9300_DEVID_INVALID	0xabcd
- #define AR5416_DEVID_PCI	0x0023
- #define AR5416_DEVID_PCIE	0x0024
- #define AR9160_DEVID_PCI	0x0027
---- a/drivers/net/wireless/ath/ath9k/pci.c
-+++ b/drivers/net/wireless/ath/ath9k/pci.c
-@@ -658,6 +658,7 @@ static DEFINE_PCI_DEVICE_TABLE(ath_pci_i
- 	{ PCI_VDEVICE(ATHEROS, 0x0036),
- 	  .driver_data = ATH9K_PCI_BT_ANT_DIV },
- 
-+	{ PCI_VDEVICE(ATHEROS, 0xabcd) }, /* PCI-E  internal chip default ID */
- 	{ 0 }
- };
- 
diff --git a/package/mac80211/patches/520-mac80211_cur_txpower.patch b/package/mac80211/patches/520-mac80211_cur_txpower.patch
deleted file mode 100644
index 6df95bc..0000000
--- a/package/mac80211/patches/520-mac80211_cur_txpower.patch
+++ /dev/null
@@ -1,33 +0,0 @@
---- a/include/net/mac80211.h
-+++ b/include/net/mac80211.h
-@@ -1711,6 +1711,7 @@ struct ieee80211_hw {
- 	u8 max_tx_aggregation_subframes;
- 	u8 offchannel_tx_hw_queue;
- 	u8 radiotap_mcs_details;
-+	s8 cur_power_level;
- 	u16 radiotap_vht_details;
- 	netdev_features_t netdev_features;
- 	u8 uapsd_queues;
---- a/net/mac80211/cfg.c
-+++ b/net/mac80211/cfg.c
-@@ -2329,7 +2329,9 @@ static int ieee80211_get_tx_power(struct
- 	struct ieee80211_local *local = wiphy_priv(wiphy);
- 	struct ieee80211_sub_if_data *sdata = IEEE80211_WDEV_TO_SUB_IF(wdev);
- 
--	if (!local->use_chanctx)
-+	if (local->hw.cur_power_level)
-+		*dbm = local->hw.cur_power_level;
-+	else if (!local->use_chanctx)
- 		*dbm = local->hw.conf.power_level;
- 	else
- 		*dbm = sdata->vif.bss_conf.txpower;
---- a/net/mac80211/main.c
-+++ b/net/mac80211/main.c
-@@ -158,6 +158,7 @@ static u32 ieee80211_hw_conf_chan(struct
- 
- 	if (local->hw.conf.power_level != power) {
- 		changed |= IEEE80211_CONF_CHANGE_POWER;
-+		local->hw.cur_power_level = power;
- 		local->hw.conf.power_level = power;
- 	}
- 
diff --git a/package/mac80211/patches/521-ath9k_cur_txpower.patch b/package/mac80211/patches/521-ath9k_cur_txpower.patch
deleted file mode 100644
index 0d6c360..0000000
--- a/package/mac80211/patches/521-ath9k_cur_txpower.patch
+++ /dev/null
@@ -1,24 +0,0 @@
---- a/drivers/net/wireless/ath/ath9k/main.c
-+++ b/drivers/net/wireless/ath/ath9k/main.c
-@@ -308,8 +308,12 @@ static int ath_reset_internal(struct ath
- 	    (sc->hw->conf.flags & IEEE80211_CONF_OFFCHANNEL))
- 		ath9k_mci_set_txpower(sc, true, false);
- 
--	if (!ath_complete_reset(sc, true))
-+	if (!ath_complete_reset(sc, true)) {
- 		r = -EIO;
-+		goto out;
-+	}
-+
-+	sc->hw->cur_power_level = sc->curtxpow / 2;
- 
- out:
- 	spin_unlock_bh(&sc->sc_pcu_lock);
-@@ -1371,6 +1375,7 @@ static int ath9k_config(struct ieee80211
- 		sc->config.txpowlimit = 2 * conf->power_level;
- 		ath9k_cmn_update_txpow(ah, sc->curtxpow,
- 				       sc->config.txpowlimit, &sc->curtxpow);
-+		hw->cur_power_level = sc->curtxpow / 2;
- 	}
- 
- 	mutex_unlock(&sc->mutex);
diff --git a/package/mac80211/patches/522-mac80211_configure_antenna_gain.patch b/package/mac80211/patches/522-mac80211_configure_antenna_gain.patch
deleted file mode 100644
index 308ee6e..0000000
--- a/package/mac80211/patches/522-mac80211_configure_antenna_gain.patch
+++ /dev/null
@@ -1,172 +0,0 @@
---- a/include/net/cfg80211.h
-+++ b/include/net/cfg80211.h
-@@ -2156,6 +2156,7 @@ struct cfg80211_qos_map {
-  *	(as advertised by the nl80211 feature flag.)
-  * @get_tx_power: store the current TX power into the dbm variable;
-  *	return 0 if successful
-+ * @set_antenna_gain: set antenna gain to reduce maximum tx power if necessary
-  *
-  * @set_wds_peer: set the WDS peer for a WDS interface
-  *
-@@ -2380,6 +2381,7 @@ struct cfg80211_ops {
- 				enum nl80211_tx_power_setting type, int mbm);
- 	int	(*get_tx_power)(struct wiphy *wiphy, struct wireless_dev *wdev,
- 				int *dbm);
-+	int	(*set_antenna_gain)(struct wiphy *wiphy, int dbi);
- 
- 	int	(*set_wds_peer)(struct wiphy *wiphy, struct net_device *dev,
- 				const u8 *addr);
---- a/include/net/mac80211.h
-+++ b/include/net/mac80211.h
-@@ -1033,6 +1033,7 @@ enum ieee80211_smps_mode {
-  *
-  * @power_level: requested transmit power (in dBm), backward compatibility
-  *	value only that is set to the minimum of all interfaces
-+ * @max_antenna_gain: maximum antenna gain adjusted by user config (in dBi)
-  *
-  * @chandef: the channel definition to tune to
-  * @radar_enabled: whether radar detection is enabled
-@@ -1054,6 +1055,7 @@ struct ieee80211_conf {
- 	u32 flags;
- 	int power_level, dynamic_ps_timeout;
- 	int max_sleep_period;
-+	int max_antenna_gain;
- 
- 	u16 listen_interval;
- 	u8 ps_dtim_period;
---- a/include/uapi/linux/nl80211.h
-+++ b/include/uapi/linux/nl80211.h
-@@ -1555,6 +1555,9 @@ enum nl80211_commands {
-  *	data is in the format defined for the payload of the QoS Map Set element
-  *	in IEEE Std 802.11-2012, 8.4.2.97.
-  *
-+ * @NL80211_ATTR_WIPHY_ANTENNA_GAIN: Configured antenna gain. Used to reduce
-+ *	transmit power to stay within regulatory limits. u32, dBi.
-+ *
-  * @NL80211_ATTR_MAX: highest attribute number currently defined
-  * @__NL80211_ATTR_AFTER_LAST: internal use
-  */
-@@ -1883,6 +1886,8 @@ enum nl80211_attrs {
- 
- 	NL80211_ATTR_QOS_MAP,
- 
-+	NL80211_ATTR_WIPHY_ANTENNA_GAIN,
-+
- 	/* add attributes here, update the policy in nl80211.c */
- 
- 	__NL80211_ATTR_AFTER_LAST,
---- a/net/mac80211/cfg.c
-+++ b/net/mac80211/cfg.c
-@@ -2339,6 +2339,19 @@ static int ieee80211_get_tx_power(struct
- 	return 0;
- }
- 
-+static int ieee80211_set_antenna_gain(struct wiphy *wiphy, int dbi)
-+{
-+	struct ieee80211_local *local = wiphy_priv(wiphy);
-+
-+	if (dbi < 0)
-+		return -EINVAL;
-+
-+	local->user_antenna_gain = dbi;
-+	ieee80211_hw_config(local, 0);
-+
-+	return 0;
-+}
-+
- static int ieee80211_set_wds_peer(struct wiphy *wiphy, struct net_device *dev,
- 				  const u8 *addr)
- {
-@@ -3924,6 +3937,7 @@ struct cfg80211_ops mac80211_config_ops 
- 	.set_wiphy_params = ieee80211_set_wiphy_params,
- 	.set_tx_power = ieee80211_set_tx_power,
- 	.get_tx_power = ieee80211_get_tx_power,
-+	.set_antenna_gain = ieee80211_set_antenna_gain,
- 	.set_wds_peer = ieee80211_set_wds_peer,
- 	.rfkill_poll = ieee80211_rfkill_poll,
- 	CFG80211_TESTMODE_CMD(ieee80211_testmode_cmd)
---- a/net/mac80211/ieee80211_i.h
-+++ b/net/mac80211/ieee80211_i.h
-@@ -1221,6 +1221,7 @@ struct ieee80211_local {
- 	int dynamic_ps_forced_timeout;
- 
- 	int user_power_level; /* in dBm, for all interfaces */
-+	int user_antenna_gain; /* in dBi */
- 
- 	enum ieee80211_smps_mode smps_mode;
- 
---- a/net/mac80211/main.c
-+++ b/net/mac80211/main.c
-@@ -101,7 +101,7 @@ static u32 ieee80211_hw_conf_chan(struct
- 	struct ieee80211_sub_if_data *sdata;
- 	struct cfg80211_chan_def chandef = {};
- 	u32 changed = 0;
--	int power;
-+	int power, ant_gain, max_power;
- 	u32 offchannel_flag;
- 
- 	offchannel_flag = local->hw.conf.flags & IEEE80211_CONF_OFFCHANNEL;
-@@ -156,8 +156,21 @@ static u32 ieee80211_hw_conf_chan(struct
- 	}
- 	rcu_read_unlock();
- 
--	if (local->hw.conf.power_level != power) {
-+	max_power = chandef.chan->max_reg_power;
-+	ant_gain = chandef.chan->max_antenna_gain;
-+	if (local->user_antenna_gain > 0) {
-+		if (local->user_antenna_gain > ant_gain) {
-+			max_power -= local->user_antenna_gain - ant_gain;
-+			ant_gain = 0;
-+		} else
-+			ant_gain -= local->user_antenna_gain;
-+		power = min(power, max_power);
-+	}
-+
-+	if (local->hw.conf.power_level != power ||
-+	    local->hw.conf.max_antenna_gain != ant_gain) {
- 		changed |= IEEE80211_CONF_CHANGE_POWER;
-+		local->hw.conf.max_antenna_gain = ant_gain;
- 		local->hw.cur_power_level = power;
- 		local->hw.conf.power_level = power;
- 	}
-@@ -584,6 +597,7 @@ struct ieee80211_hw *ieee80211_alloc_hw(
- 					 IEEE80211_RADIOTAP_MCS_HAVE_BW;
- 	local->hw.radiotap_vht_details = IEEE80211_RADIOTAP_VHT_KNOWN_GI |
- 					 IEEE80211_RADIOTAP_VHT_KNOWN_BANDWIDTH;
-+	local->user_antenna_gain = 0;
- 	local->hw.uapsd_queues = IEEE80211_DEFAULT_UAPSD_QUEUES;
- 	local->hw.uapsd_max_sp_len = IEEE80211_DEFAULT_MAX_SP_LEN;
- 	local->user_power_level = IEEE80211_UNSET_POWER_LEVEL;
---- a/net/wireless/nl80211.c
-+++ b/net/wireless/nl80211.c
-@@ -384,6 +384,7 @@ static const struct nla_policy nl80211_p
- 	[NL80211_ATTR_VENDOR_DATA] = { .type = NLA_BINARY },
- 	[NL80211_ATTR_QOS_MAP] = { .type = NLA_BINARY,
- 				   .len = IEEE80211_QOS_MAP_LEN_MAX },
-+	[NL80211_ATTR_WIPHY_ANTENNA_GAIN] = { .type = NLA_U32 },
- };
- 
- /* policy for the key attributes */
-@@ -2105,6 +2106,22 @@ static int nl80211_set_wiphy(struct sk_b
- 			goto bad_res;
- 	}
- 
-+	if (info->attrs[NL80211_ATTR_WIPHY_ANTENNA_GAIN]) {
-+		int idx, dbi = 0;
-+
-+		if (!rdev->ops->set_antenna_gain) {
-+			result = -EOPNOTSUPP;
-+			goto bad_res;
-+		}
-+
-+		idx = NL80211_ATTR_WIPHY_ANTENNA_GAIN;
-+		dbi = nla_get_u32(info->attrs[idx]);
-+
-+		result = rdev->ops->set_antenna_gain(&rdev->wiphy, dbi);
-+		if (result)
-+			goto bad_res;
-+	}
-+
- 	if (info->attrs[NL80211_ATTR_WIPHY_ANTENNA_TX] &&
- 	    info->attrs[NL80211_ATTR_WIPHY_ANTENNA_RX]) {
- 		u32 tx_ant, rx_ant;
diff --git a/package/mac80211/patches/523-ath9k_use_configured_antenna_gain.patch b/package/mac80211/patches/523-ath9k_use_configured_antenna_gain.patch
deleted file mode 100644
index 30aa9ee..0000000
--- a/package/mac80211/patches/523-ath9k_use_configured_antenna_gain.patch
+++ /dev/null
@@ -1,34 +0,0 @@
---- a/drivers/net/wireless/ath/ath.h
-+++ b/drivers/net/wireless/ath/ath.h
-@@ -74,6 +74,7 @@ struct ath_regulatory {
- 	u16 max_power_level;
- 	u16 current_rd;
- 	int16_t power_limit;
-+	int16_t max_antenna_gain;
- 	struct reg_dmn_pair_mapping *regpair;
- };
- 
---- a/drivers/net/wireless/ath/ath9k/hw.c
-+++ b/drivers/net/wireless/ath/ath9k/hw.c
-@@ -2721,7 +2721,7 @@ void ath9k_hw_apply_txpower(struct ath_h
- 	channel = chan->chan;
- 	chan_pwr = min_t(int, channel->max_power * 2, MAX_RATE_POWER);
- 	new_pwr = min_t(int, chan_pwr, reg->power_limit);
--	max_gain = chan_pwr - new_pwr + channel->max_antenna_gain * 2;
-+	max_gain = chan_pwr - new_pwr + reg->max_antenna_gain * 2;
- 
- 	ant_gain = get_antenna_gain(ah, chan);
- 	if (ant_gain > max_gain)
---- a/drivers/net/wireless/ath/ath9k/main.c
-+++ b/drivers/net/wireless/ath/ath9k/main.c
-@@ -1371,7 +1371,10 @@ static int ath9k_config(struct ieee80211
- 	}
- 
- 	if (changed & IEEE80211_CONF_CHANGE_POWER) {
-+		struct ath_regulatory *reg = ath9k_hw_regulatory(ah);
-+
- 		ath_dbg(common, CONFIG, "Set power: %d\n", conf->power_level);
-+		reg->max_antenna_gain = conf->max_antenna_gain;
- 		sc->config.txpowlimit = 2 * conf->power_level;
- 		ath9k_cmn_update_txpow(ah, sc->curtxpow,
- 				       sc->config.txpowlimit, &sc->curtxpow);
diff --git a/package/mac80211/patches/530-ath9k_extra_leds.patch b/package/mac80211/patches/530-ath9k_extra_leds.patch
deleted file mode 100644
index 59f78d9..0000000
--- a/package/mac80211/patches/530-ath9k_extra_leds.patch
+++ /dev/null
@@ -1,248 +0,0 @@
---- a/drivers/net/wireless/ath/ath9k/ath9k.h
-+++ b/drivers/net/wireless/ath/ath9k/ath9k.h
-@@ -563,6 +563,9 @@ static inline int ath9k_dump_btcoex(stru
- void ath_init_leds(struct ath_softc *sc);
- void ath_deinit_leds(struct ath_softc *sc);
- void ath_fill_led_pin(struct ath_softc *sc);
-+int ath_create_gpio_led(struct ath_softc *sc, int gpio, const char *name,
-+                        const char *trigger, bool active_low);
-+
- #else
- static inline void ath_init_leds(struct ath_softc *sc)
- {
-@@ -710,6 +713,13 @@ enum sc_op_flags {
- #define PS_BEACON_SYNC            BIT(4)
- #define PS_WAIT_FOR_ANI           BIT(5)
- 
-+struct ath_led {
-+	struct list_head list;
-+	struct ath_softc *sc;
-+	const struct gpio_led *gpio;
-+	struct led_classdev cdev;
-+};
-+
- struct ath_softc {
- 	struct ieee80211_hw *hw;
- 	struct device *dev;
-@@ -751,9 +761,8 @@ struct ath_softc {
- 	struct ieee80211_supported_band sbands[IEEE80211_NUM_BANDS];
- 
- #ifdef CPTCFG_MAC80211_LEDS
--	bool led_registered;
--	char led_name[32];
--	struct led_classdev led_cdev;
-+	const char *led_default_trigger;
-+	struct list_head leds;
- #endif
- 
- 	struct ath9k_hw_cal_data caldata;
---- a/drivers/net/wireless/ath/ath9k/gpio.c
-+++ b/drivers/net/wireless/ath/ath9k/gpio.c
-@@ -24,40 +24,102 @@
- static void ath_led_brightness(struct led_classdev *led_cdev,
- 			       enum led_brightness brightness)
- {
--	struct ath_softc *sc = container_of(led_cdev, struct ath_softc, led_cdev);
--	ath9k_hw_set_gpio(sc->sc_ah, sc->sc_ah->led_pin, (brightness == LED_OFF));
-+	struct ath_led *led = container_of(led_cdev, struct ath_led, cdev);
-+	struct ath_softc *sc = led->sc;
-+
-+	ath9k_ps_wakeup(sc);
-+	ath9k_hw_set_gpio(sc->sc_ah, led->gpio->gpio,
-+			  (brightness != LED_OFF) ^ led->gpio->active_low);
-+	ath9k_ps_restore(sc);
-+}
-+
-+static int ath_add_led(struct ath_softc *sc, struct ath_led *led)
-+{
-+	const struct gpio_led *gpio = led->gpio;
-+	int ret;
-+
-+	led->cdev.name = gpio->name;
-+	led->cdev.default_trigger = gpio->default_trigger;
-+	led->cdev.brightness_set = ath_led_brightness;
-+
-+	ret = led_classdev_register(wiphy_dev(sc->hw->wiphy), &led->cdev);
-+	if (ret < 0)
-+		return ret;
-+
-+	led->sc = sc;
-+	list_add(&led->list, &sc->leds);
-+
-+	/* Configure gpio for output */
-+	ath9k_hw_cfg_output(sc->sc_ah, gpio->gpio,
-+			    AR_GPIO_OUTPUT_MUX_AS_OUTPUT);
-+
-+	/* LED off */
-+	ath9k_hw_set_gpio(sc->sc_ah, gpio->gpio, gpio->active_low);
-+
-+	return 0;
-+}
-+
-+int ath_create_gpio_led(struct ath_softc *sc, int gpio_num, const char *name,
-+			const char *trigger, bool active_low)
-+{
-+	struct ath_led *led;
-+	struct gpio_led *gpio;
-+	char *_name;
-+	int ret;
-+
-+	led = kzalloc(sizeof(*led) + sizeof(*gpio) + strlen(name) + 1,
-+		      GFP_KERNEL);
-+	if (!led)
-+		return -ENOMEM;
-+
-+	led->gpio = gpio = (struct gpio_led *) (led + 1);
-+	_name = (char *) (led->gpio + 1);
-+
-+	strcpy(_name, name);
-+	gpio->name = _name;
-+	gpio->gpio = gpio_num;
-+	gpio->active_low = active_low;
-+	gpio->default_trigger = trigger;
-+
-+	ret = ath_add_led(sc, led);
-+	if (unlikely(ret < 0))
-+		kfree(led);
-+
-+	return ret;
- }
- 
- void ath_deinit_leds(struct ath_softc *sc)
- {
--	if (!sc->led_registered)
--		return;
-+	struct ath_led *led;
- 
--	ath_led_brightness(&sc->led_cdev, LED_OFF);
--	led_classdev_unregister(&sc->led_cdev);
-+	while (!list_empty(&sc->leds)) {
-+		led = list_first_entry(&sc->leds, struct ath_led, list);
-+		list_del(&led->list);
-+		ath_led_brightness(&led->cdev, LED_OFF);
-+		led_classdev_unregister(&led->cdev);
-+		kfree(led);
-+	}
- }
- 
- void ath_init_leds(struct ath_softc *sc)
- {
--	int ret;
-+	char led_name[32];
-+	const char *trigger;
-+
-+	INIT_LIST_HEAD(&sc->leds);
- 
- 	if (AR_SREV_9100(sc->sc_ah))
- 		return;
- 
--	if (!led_blink)
--		sc->led_cdev.default_trigger =
--			ieee80211_get_radio_led_name(sc->hw);
--
--	snprintf(sc->led_name, sizeof(sc->led_name),
--		"ath9k-%s", wiphy_name(sc->hw->wiphy));
--	sc->led_cdev.name = sc->led_name;
--	sc->led_cdev.brightness_set = ath_led_brightness;
-+	snprintf(led_name, sizeof(led_name), "ath9k-%s",
-+		 wiphy_name(sc->hw->wiphy));
- 
--	ret = led_classdev_register(wiphy_dev(sc->hw->wiphy), &sc->led_cdev);
--	if (ret < 0)
--		return;
-+	if (led_blink)
-+		trigger = sc->led_default_trigger;
-+	else
-+		trigger = ieee80211_get_radio_led_name(sc->hw);
- 
--	sc->led_registered = true;
-+	ath_create_gpio_led(sc, sc->sc_ah->led_pin, led_name, trigger, 1);
- }
- 
- void ath_fill_led_pin(struct ath_softc *sc)
---- a/drivers/net/wireless/ath/ath9k/init.c
-+++ b/drivers/net/wireless/ath/ath9k/init.c
-@@ -1018,7 +1018,7 @@ int ath9k_init_device(u16 devid, struct 
- 
- #ifdef CPTCFG_MAC80211_LEDS
- 	/* must be initialized before ieee80211_register_hw */
--	sc->led_cdev.default_trigger = ieee80211_create_tpt_led_trigger(sc->hw,
-+	sc->led_default_trigger = ieee80211_create_tpt_led_trigger(sc->hw,
- 		IEEE80211_TPT_LEDTRIG_FL_RADIO, ath9k_tpt_blink,
- 		ARRAY_SIZE(ath9k_tpt_blink));
- #endif
---- a/drivers/net/wireless/ath/ath9k/debug.c
-+++ b/drivers/net/wireless/ath/ath9k/debug.c
-@@ -1573,6 +1573,61 @@ static const struct file_operations fops
- 	.llseek = default_llseek,
- };
- 
-+#ifdef CONFIG_MAC80211_LEDS
-+
-+static ssize_t write_file_gpio_led(struct file *file, const char __user *ubuf,
-+				   size_t count, loff_t *ppos)
-+{
-+	struct ath_softc *sc = file->private_data;
-+	char buf[32], *str, *name, *c;
-+	ssize_t len;
-+	unsigned int gpio;
-+	bool active_low = false;
-+
-+	len = min(count, sizeof(buf) - 1);
-+	if (copy_from_user(buf, ubuf, len))
-+		return -EFAULT;
-+
-+	buf[len] = '\0';
-+	name = strchr(buf, ',');
-+	if (!name)
-+		return -EINVAL;
-+
-+	*(name++) = 0;
-+	if (!*name)
-+		return -EINVAL;
-+
-+	c = strchr(name, '\n');
-+	if (c)
-+		*c = 0;
-+
-+	str = buf;
-+	if (*str == '!') {
-+		str++;
-+		active_low = true;
-+	}
-+
-+	if (kstrtouint(str, 0, &gpio) < 0)
-+		return -EINVAL;
-+
-+	if (gpio >= sc->sc_ah->caps.num_gpio_pins)
-+		return -EINVAL;
-+
-+	if (ath_create_gpio_led(sc, gpio, name, NULL, active_low) < 0)
-+		return -EINVAL;
-+
-+	return count;
-+}
-+
-+static const struct file_operations fops_gpio_led = {
-+	.write = write_file_gpio_led,
-+	.open = simple_open,
-+	.owner = THIS_MODULE,
-+	.llseek = default_llseek,
-+};
-+
-+#endif
-+
- 
- int ath9k_init_debug(struct ath_hw *ah)
- {
-@@ -1597,6 +1652,10 @@ int ath9k_init_debug(struct ath_hw *ah)
- 			    &fops_eeprom);
- 	debugfs_create_file("chanbw", S_IRUSR | S_IWUSR, sc->debug.debugfs_phy,
- 			    sc, &fops_chanbw);
-+#ifdef CONFIG_MAC80211_LEDS
-+	debugfs_create_file("gpio_led", S_IWUSR,
-+			   sc->debug.debugfs_phy, sc, &fops_gpio_led);
-+#endif
- 	debugfs_create_file("dma", S_IRUSR, sc->debug.debugfs_phy, sc,
- 			    &fops_dma);
- 	debugfs_create_file("interrupt", S_IRUSR, sc->debug.debugfs_phy, sc,
diff --git a/package/mac80211/patches/531-ath9k_extra_platform_leds.patch b/package/mac80211/patches/531-ath9k_extra_platform_leds.patch
deleted file mode 100644
index 6c9832c..0000000
--- a/package/mac80211/patches/531-ath9k_extra_platform_leds.patch
+++ /dev/null
@@ -1,71 +0,0 @@
---- a/include/linux/ath9k_platform.h
-+++ b/include/linux/ath9k_platform.h
-@@ -37,6 +37,9 @@ struct ath9k_platform_data {
- 
- 	int (*get_mac_revision)(void);
- 	int (*external_reset)(void);
-+
-+	int num_leds;
-+	const struct gpio_led *leds;
- };
- 
- #endif /* _LINUX_ATH9K_PLATFORM_H */
---- a/drivers/net/wireless/ath/ath9k/gpio.c
-+++ b/drivers/net/wireless/ath/ath9k/gpio.c
-@@ -15,6 +15,7 @@
-  */
- 
- #include "ath9k.h"
-+#include <linux/ath9k_platform.h>
- 
- /********************************/
- /*	 LED functions		*/
-@@ -88,6 +89,24 @@ int ath_create_gpio_led(struct ath_softc
- 	return ret;
- }
- 
-+static int ath_create_platform_led(struct ath_softc *sc,
-+				   const struct gpio_led *gpio)
-+{
-+	struct ath_led *led;
-+	int ret;
-+
-+	led = kzalloc(sizeof(*led), GFP_KERNEL);
-+	if (!led)
-+		return -ENOMEM;
-+
-+	led->gpio = gpio;
-+	ret = ath_add_led(sc, led);
-+	if (ret < 0)
-+		kfree(led);
-+
-+	return ret;
-+}
-+
- void ath_deinit_leds(struct ath_softc *sc)
- {
- 	struct ath_led *led;
-@@ -103,8 +122,10 @@ void ath_deinit_leds(struct ath_softc *s
- 
- void ath_init_leds(struct ath_softc *sc)
- {
-+	struct ath9k_platform_data *pdata = sc->dev->platform_data;
- 	char led_name[32];
- 	const char *trigger;
-+	int i;
- 
- 	INIT_LIST_HEAD(&sc->leds);
- 
-@@ -120,6 +141,12 @@ void ath_init_leds(struct ath_softc *sc)
- 		trigger = ieee80211_get_radio_led_name(sc->hw);
- 
- 	ath_create_gpio_led(sc, sc->sc_ah->led_pin, led_name, trigger, 1);
-+
-+	if (!pdata)
-+		return;
-+
-+	for (i = 0; i < pdata->num_leds; i++)
-+		ath_create_platform_led(sc, &pdata->leds[i]);
- }
- 
- void ath_fill_led_pin(struct ath_softc *sc)
diff --git a/package/mac80211/patches/540-ath9k_reduce_ani_interval.patch b/package/mac80211/patches/540-ath9k_reduce_ani_interval.patch
deleted file mode 100644
index e899903..0000000
--- a/package/mac80211/patches/540-ath9k_reduce_ani_interval.patch
+++ /dev/null
@@ -1,11 +0,0 @@
---- a/drivers/net/wireless/ath/ath9k/ani.h
-+++ b/drivers/net/wireless/ath/ath9k/ani.h
-@@ -42,7 +42,7 @@
- #define ATH9K_ANI_PERIOD                  300
- 
- /* in ms */
--#define ATH9K_ANI_POLLINTERVAL            1000
-+#define ATH9K_ANI_POLLINTERVAL            300
- 
- #define ATH9K_SIG_FIRSTEP_SETTING_MIN     0
- #define ATH9K_SIG_FIRSTEP_SETTING_MAX     20
diff --git a/package/mac80211/patches/541-ath9k_rx_dma_stop_check.patch b/package/mac80211/patches/541-ath9k_rx_dma_stop_check.patch
deleted file mode 100644
index a521525..0000000
--- a/package/mac80211/patches/541-ath9k_rx_dma_stop_check.patch
+++ /dev/null
@@ -1,28 +0,0 @@
---- a/drivers/net/wireless/ath/ath9k/mac.c
-+++ b/drivers/net/wireless/ath/ath9k/mac.c
-@@ -700,7 +700,7 @@ bool ath9k_hw_stopdmarecv(struct ath_hw 
- {
- #define AH_RX_STOP_DMA_TIMEOUT 10000   /* usec */
- 	struct ath_common *common = ath9k_hw_common(ah);
--	u32 mac_status, last_mac_status = 0;
-+	u32 mac_status = 0, last_mac_status = 0;
- 	int i;
- 
- 	/* Enable access to the DMA observation bus */
-@@ -730,6 +730,16 @@ bool ath9k_hw_stopdmarecv(struct ath_hw 
- 	}
- 
- 	if (i == 0) {
-+		if (!AR_SREV_9300_20_OR_LATER(ah) &&
-+		    (mac_status & 0x700) == 0) {
-+			/*
-+			 * DMA is idle but the MAC is still stuck
-+			 * processing events
-+			 */
-+			*reset = true;
-+			return true;
-+		}
-+
- 		ath_err(common,
- 			"DMA failed to stop in %d ms AR_CR=0x%08x AR_DIAG_SW=0x%08x DMADBG_7=0x%08x\n",
- 			AH_RX_STOP_DMA_TIMEOUT / 1000,
diff --git a/package/mac80211/patches/542-ath9k_debugfs_diag.patch b/package/mac80211/patches/542-ath9k_debugfs_diag.patch
deleted file mode 100644
index e1b6ff1..0000000
--- a/package/mac80211/patches/542-ath9k_debugfs_diag.patch
+++ /dev/null
@@ -1,139 +0,0 @@
---- a/drivers/net/wireless/ath/ath9k/debug.c
-+++ b/drivers/net/wireless/ath/ath9k/debug.c
-@@ -1629,6 +1629,50 @@ static const struct file_operations fops
- #endif
- 
- 
-+static ssize_t read_file_diag(struct file *file, char __user *user_buf,
-+			     size_t count, loff_t *ppos)
-+{
-+	struct ath_softc *sc = file->private_data;
-+	struct ath_hw *ah = sc->sc_ah;
-+	char buf[32];
-+	unsigned int len;
-+
-+	len = sprintf(buf, "0x%08lx\n", ah->diag);
-+	return simple_read_from_buffer(user_buf, count, ppos, buf, len);
-+}
-+
-+static ssize_t write_file_diag(struct file *file, const char __user *user_buf,
-+			     size_t count, loff_t *ppos)
-+{
-+	struct ath_softc *sc = file->private_data;
-+	struct ath_hw *ah = sc->sc_ah;
-+	unsigned long diag;
-+	char buf[32];
-+	ssize_t len;
-+
-+	len = min(count, sizeof(buf) - 1);
-+	if (copy_from_user(buf, user_buf, len))
-+		return -EFAULT;
-+
-+	buf[len] = '\0';
-+	if (kstrtoul(buf, 0, &diag))
-+		return -EINVAL;
-+
-+	ah->diag = diag;
-+	ath9k_hw_update_diag(ah);
-+
-+	return count;
-+}
-+
-+static const struct file_operations fops_diag = {
-+	.read = read_file_diag,
-+	.write = write_file_diag,
-+	.open = simple_open,
-+	.owner = THIS_MODULE,
-+	.llseek = default_llseek,
-+};
-+
-+
- int ath9k_init_debug(struct ath_hw *ah)
- {
- 	struct ath_common *common = ath9k_hw_common(ah);
-@@ -1656,6 +1700,8 @@ int ath9k_init_debug(struct ath_hw *ah)
- 	debugfs_create_file("gpio_led", S_IWUSR,
- 			   sc->debug.debugfs_phy, sc, &fops_gpio_led);
- #endif
-+	debugfs_create_file("diag", S_IRUSR | S_IWUSR, sc->debug.debugfs_phy,
-+			    sc, &fops_diag);
- 	debugfs_create_file("dma", S_IRUSR, sc->debug.debugfs_phy, sc,
- 			    &fops_dma);
- 	debugfs_create_file("interrupt", S_IRUSR, sc->debug.debugfs_phy, sc,
---- a/drivers/net/wireless/ath/ath9k/hw.h
-+++ b/drivers/net/wireless/ath/ath9k/hw.h
-@@ -482,6 +482,12 @@ enum {
- 	ATH9K_RESET_COLD,
- };
- 
-+enum {
-+	ATH_DIAG_DISABLE_RX,
-+	ATH_DIAG_DISABLE_TX,
-+	ATH_DIAG_TRIGGER_ERROR,
-+};
-+
- struct ath9k_hw_version {
- 	u32 magic;
- 	u16 devid;
-@@ -762,6 +768,8 @@ struct ath_hw {
- 	u32 rfkill_polarity;
- 	u32 ah_flags;
- 
-+	unsigned long diag;
-+
- 	bool reset_power_on;
- 	bool htc_reset_init;
- 
-@@ -1013,6 +1021,7 @@ void ath9k_hw_check_nav(struct ath_hw *a
- bool ath9k_hw_check_alive(struct ath_hw *ah);
- 
- bool ath9k_hw_setpower(struct ath_hw *ah, enum ath9k_power_mode mode);
-+void ath9k_hw_update_diag(struct ath_hw *ah);
- 
- /* Generic hw timer primitives */
- struct ath_gen_timer *ath_gen_timer_alloc(struct ath_hw *ah,
---- a/drivers/net/wireless/ath/ath9k/hw.c
-+++ b/drivers/net/wireless/ath/ath9k/hw.c
-@@ -1735,6 +1735,20 @@ fail:
- 	return -EINVAL;
- }
- 
-+void ath9k_hw_update_diag(struct ath_hw *ah)
-+{
-+	if (test_bit(ATH_DIAG_DISABLE_RX, &ah->diag))
-+		REG_SET_BIT(ah, AR_DIAG_SW, AR_DIAG_RX_DIS);
-+	else
-+		REG_CLR_BIT(ah, AR_DIAG_SW, AR_DIAG_RX_DIS);
-+
-+	if (test_bit(ATH_DIAG_DISABLE_TX, &ah->diag))
-+		REG_SET_BIT(ah, AR_DIAG_SW, AR_DIAG_LOOP_BACK);
-+	else
-+		REG_CLR_BIT(ah, AR_DIAG_SW, AR_DIAG_LOOP_BACK);
-+}
-+EXPORT_SYMBOL(ath9k_hw_update_diag);
-+
- int ath9k_hw_reset(struct ath_hw *ah, struct ath9k_channel *chan,
- 		   struct ath9k_hw_cal_data *caldata, bool fastcc)
- {
-@@ -1940,6 +1954,7 @@ int ath9k_hw_reset(struct ath_hw *ah, st
- 		ar9003_hw_disable_phy_restart(ah);
- 
- 	ath9k_hw_apply_gpio_override(ah);
-+	ath9k_hw_update_diag(ah);
- 
- 	if (AR_SREV_9565(ah) && common->bt_ant_diversity)
- 		REG_SET_BIT(ah, AR_BTCOEX_WL_LNADIV, AR_BTCOEX_WL_LNADIV_FORCE_ON);
---- a/drivers/net/wireless/ath/ath9k/main.c
-+++ b/drivers/net/wireless/ath/ath9k/main.c
-@@ -602,6 +602,11 @@ irqreturn_t ath_isr(int irq, void *dev)
- 	ath9k_debug_sync_cause(sc, sync_cause);
- 	status &= ah->imask;	/* discard unasked-for bits */
- 
-+	if (test_bit(ATH_DIAG_TRIGGER_ERROR, &ah->diag)) {
-+		status |= ATH9K_INT_FATAL;
-+		clear_bit(ATH_DIAG_TRIGGER_ERROR, &ah->diag);
-+	}
-+
- 	/*
- 	 * If there are no status bits set, then this interrupt was not
- 	 * for me (should have been caught above).
diff --git a/package/mac80211/patches/543-ath9k-allow-to-disable-bands-via-platform-data.patch b/package/mac80211/patches/543-ath9k-allow-to-disable-bands-via-platform-data.patch
deleted file mode 100644
index d26a5af..0000000
--- a/package/mac80211/patches/543-ath9k-allow-to-disable-bands-via-platform-data.patch
+++ /dev/null
@@ -1,69 +0,0 @@
---- a/include/linux/ath9k_platform.h
-+++ b/include/linux/ath9k_platform.h
-@@ -34,6 +34,8 @@ struct ath9k_platform_data {
- 	bool endian_check;
- 	bool is_clk_25mhz;
- 	bool tx_gain_buffalo;
-+	bool disable_2ghz;
-+	bool disable_5ghz;
- 
- 	int (*get_mac_revision)(void);
- 	int (*external_reset)(void);
---- a/drivers/net/wireless/ath/ath9k/hw.c
-+++ b/drivers/net/wireless/ath/ath9k/hw.c
-@@ -2328,17 +2328,25 @@ int ath9k_hw_fill_cap_info(struct ath_hw
- 	}
- 
- 	eeval = ah->eep_ops->get_eeprom(ah, EEP_OP_MODE);
--	if ((eeval & (AR5416_OPFLAGS_11G | AR5416_OPFLAGS_11A)) == 0) {
--		ath_err(common,
--			"no band has been marked as supported in EEPROM\n");
--		return -EINVAL;
-+
-+	if (eeval & AR5416_OPFLAGS_11A) {
-+		if (ah->disable_5ghz)
-+			ath_warn(common, "disabling 5GHz band\n");
-+		else
-+			pCap->hw_caps |= ATH9K_HW_CAP_5GHZ;
- 	}
- 
--	if (eeval & AR5416_OPFLAGS_11A)
--		pCap->hw_caps |= ATH9K_HW_CAP_5GHZ;
-+	if (eeval & AR5416_OPFLAGS_11G) {
-+		if (ah->disable_2ghz)
-+			ath_warn(common, "disabling 2GHz band\n");
-+		else
-+			pCap->hw_caps |= ATH9K_HW_CAP_2GHZ;
-+	}
- 
--	if (eeval & AR5416_OPFLAGS_11G)
--		pCap->hw_caps |= ATH9K_HW_CAP_2GHZ;
-+	if ((pCap->hw_caps & (ATH9K_HW_CAP_2GHZ | ATH9K_HW_CAP_5GHZ)) == 0) {
-+		ath_err(common, "both bands are disabled\n");
-+		return -EINVAL;
-+	}
- 
- 	if (AR_SREV_9485(ah) ||
- 	    AR_SREV_9285(ah) ||
---- a/drivers/net/wireless/ath/ath9k/hw.h
-+++ b/drivers/net/wireless/ath/ath9k/hw.h
-@@ -932,6 +932,8 @@ struct ath_hw {
- 	bool is_clk_25mhz;
- 	int (*get_mac_revision)(void);
- 	int (*external_reset)(void);
-+	bool disable_2ghz;
-+	bool disable_5ghz;
- 
- 	const struct firmware *eeprom_blob;
- };
---- a/drivers/net/wireless/ath/ath9k/init.c
-+++ b/drivers/net/wireless/ath/ath9k/init.c
-@@ -722,6 +722,8 @@ static int ath9k_init_softc(u16 devid, s
- 		ah->is_clk_25mhz = pdata->is_clk_25mhz;
- 		ah->get_mac_revision = pdata->get_mac_revision;
- 		ah->external_reset = pdata->external_reset;
-+		ah->disable_2ghz = pdata->disable_2ghz;
-+		ah->disable_5ghz = pdata->disable_5ghz;
- 		if (!pdata->endian_check)
- 			ah->ah_flags |= AH_NO_EEP_SWAP;
- 	}
diff --git a/package/mac80211/patches/550-ath9k_entropy_from_adc.patch b/package/mac80211/patches/550-ath9k_entropy_from_adc.patch
deleted file mode 100644
index d126fd4..0000000
--- a/package/mac80211/patches/550-ath9k_entropy_from_adc.patch
+++ /dev/null
@@ -1,200 +0,0 @@
---- a/drivers/net/wireless/ath/ath9k/hw.h
-+++ b/drivers/net/wireless/ath/ath9k/hw.h
-@@ -678,6 +678,7 @@ struct ath_spec_scan {
-  * @config_pci_powersave:
-  * @calibrate: periodic calibration for NF, ANI, IQ, ADC gain, ADC-DC
-  *
-+ * @get_adc_entropy: get entropy from the raw ADC I/Q output
-  * @spectral_scan_config: set parameters for spectral scan and enable/disable it
-  * @spectral_scan_trigger: trigger a spectral scan run
-  * @spectral_scan_wait: wait for a spectral scan run to finish
-@@ -701,6 +702,7 @@ struct ath_hw_ops {
- 			struct ath_hw_antcomb_conf *antconf);
- 	void (*antdiv_comb_conf_set)(struct ath_hw *ah,
- 			struct ath_hw_antcomb_conf *antconf);
-+	void (*get_adc_entropy)(struct ath_hw *ah, u8 *buf, size_t len);
- 	void (*spectral_scan_config)(struct ath_hw *ah,
- 				     struct ath_spec_scan *param);
- 	void (*spectral_scan_trigger)(struct ath_hw *ah);
---- a/drivers/net/wireless/ath/ath9k/ar9003_phy.c
-+++ b/drivers/net/wireless/ath/ath9k/ar9003_phy.c
-@@ -1764,6 +1764,26 @@ static void ar9003_hw_tx99_set_txpower(s
- 		  ATH9K_POW_SM(p_pwr_array[ALL_TARGET_HT40_14],  0));
- }
- 
-+static void ar9003_hw_get_adc_entropy(struct ath_hw *ah, u8 *buf, size_t len)
-+{
-+	int i, j;
-+
-+	REG_RMW_FIELD(ah, AR_PHY_TEST, AR_PHY_TEST_BBB_OBS_SEL, 1);
-+	REG_CLR_BIT(ah, AR_PHY_TEST, AR_PHY_TEST_RX_OBS_SEL_BIT5);
-+	REG_RMW_FIELD(ah, AR_PHY_TEST_CTL_STATUS, AR_PHY_TEST_CTL_RX_OBS_SEL, 0);
-+
-+	memset(buf, 0, len);
-+	for (i = 0; i < len; i++) {
-+		for (j = 0; j < 4; j++) {
-+			u32 regval = REG_READ(ah, AR_PHY_TST_ADC);
-+
-+			buf[i] <<= 2;
-+			buf[i] |= (regval & 1) | ((regval & BIT(10)) >> 9);
-+			udelay(1);
-+		}
-+	}
-+}
-+
- void ar9003_hw_attach_phy_ops(struct ath_hw *ah)
- {
- 	struct ath_hw_private_ops *priv_ops = ath9k_hw_private_ops(ah);
-@@ -1794,6 +1814,7 @@ void ar9003_hw_attach_phy_ops(struct ath
- 	priv_ops->set_radar_params = ar9003_hw_set_radar_params;
- 	priv_ops->fast_chan_change = ar9003_hw_fast_chan_change;
- 
-+	ops->get_adc_entropy = ar9003_hw_get_adc_entropy;
- 	ops->antdiv_comb_conf_get = ar9003_hw_antdiv_comb_conf_get;
- 	ops->antdiv_comb_conf_set = ar9003_hw_antdiv_comb_conf_set;
- 	ops->spectral_scan_config = ar9003_hw_spectral_scan_config;
---- a/drivers/net/wireless/ath/ath9k/init.c
-+++ b/drivers/net/wireless/ath/ath9k/init.c
-@@ -846,7 +846,8 @@ static void ath9k_init_txpower_limits(st
- 	if (ah->caps.hw_caps & ATH9K_HW_CAP_5GHZ)
- 		ath9k_init_band_txpower(sc, IEEE80211_BAND_5GHZ);
- 
--	ah->curchan = curchan;
-+	if (curchan)
-+		ah->curchan = curchan;
- }
- 
- void ath9k_reload_chainmask_settings(struct ath_softc *sc)
-@@ -980,6 +981,18 @@ static void ath9k_set_hw_capab(struct at
- 	SET_IEEE80211_PERM_ADDR(hw, common->macaddr);
- }
- 
-+static void ath_get_initial_entropy(struct ath_softc *sc)
-+{
-+	struct ath_hw *ah = sc->sc_ah;
-+	char buf[256];
-+
-+	/* reuse last channel initialized by the tx power test */
-+	ath9k_hw_reset(ah, ah->curchan, NULL, false);
-+
-+	ath9k_hw_get_adc_entropy(ah, buf, sizeof(buf));
-+	add_device_randomness(buf, sizeof(buf));
-+}
-+
- int ath9k_init_device(u16 devid, struct ath_softc *sc,
- 		    const struct ath_bus_ops *bus_ops)
- {
-@@ -1025,6 +1038,8 @@ int ath9k_init_device(u16 devid, struct 
- 		ARRAY_SIZE(ath9k_tpt_blink));
- #endif
- 
-+	ath_get_initial_entropy(sc);
-+
- 	/* Register with mac80211 */
- 	error = ieee80211_register_hw(hw);
- 	if (error)
---- a/drivers/net/wireless/ath/ath9k/hw-ops.h
-+++ b/drivers/net/wireless/ath/ath9k/hw-ops.h
-@@ -95,6 +95,12 @@ static inline void ath9k_hw_tx99_set_txp
- 		ath9k_hw_ops(ah)->tx99_set_txpower(ah, power);
- }
- 
-+static inline void ath9k_hw_get_adc_entropy(struct ath_hw *ah,
-+		u8 *buf, size_t len)
-+{
-+	ath9k_hw_ops(ah)->get_adc_entropy(ah, buf, len);
-+}
-+
- #ifdef CPTCFG_ATH9K_BTCOEX_SUPPORT
- 
- static inline void ath9k_hw_set_bt_ant_diversity(struct ath_hw *ah, bool enable)
---- a/drivers/net/wireless/ath/ath9k/link.c
-+++ b/drivers/net/wireless/ath/ath9k/link.c
-@@ -307,6 +307,11 @@ void ath_ani_calibrate(unsigned long dat
- 	unsigned int timestamp = jiffies_to_msecs(jiffies);
- 	u32 cal_interval, short_cal_interval, long_cal_interval;
- 	unsigned long flags;
-+	char buf[256];
-+
-+	/* gather entropy */
-+	ath9k_hw_get_adc_entropy(ah, buf, sizeof(buf));
-+	add_device_randomness(buf, sizeof(buf));
- 
- 	if (ah->caldata && test_bit(NFCAL_INTF, &ah->caldata->cal_flags))
- 		long_cal_interval = ATH_LONG_CALINTERVAL_INT;
---- a/drivers/net/wireless/ath/ath9k/ar5008_phy.c
-+++ b/drivers/net/wireless/ath/ath9k/ar5008_phy.c
-@@ -1233,9 +1233,30 @@ static void ar5008_hw_set_radar_conf(str
- 	conf->radar_inband = 8;
- }
- 
-+static void ar5008_hw_get_adc_entropy(struct ath_hw *ah, u8 *buf, size_t len)
-+{
-+	int i, j;
-+
-+	REG_RMW_FIELD(ah, AR_PHY_TEST, AR_PHY_TEST_BBB_OBS_SEL, 1);
-+	REG_CLR_BIT(ah, AR_PHY_TEST, AR_PHY_TEST_RX_OBS_SEL_BIT5);
-+	REG_RMW_FIELD(ah, AR_PHY_TEST2, AR_PHY_TEST2_RX_OBS_SEL, 0);
-+
-+	memset(buf, 0, len);
-+	for (i = 0; i < len; i++) {
-+		for (j = 0; j < 4; j++) {
-+			u32 regval = REG_READ(ah, AR_PHY_TST_ADC);
-+
-+			buf[i] <<= 2;
-+			buf[i] |= (regval & 1) | ((regval & BIT(9)) >> 8);
-+			udelay(1);
-+		}
-+	}
-+}
-+
- int ar5008_hw_attach_phy_ops(struct ath_hw *ah)
- {
- 	struct ath_hw_private_ops *priv_ops = ath9k_hw_private_ops(ah);
-+	struct ath_hw_ops *ops = ath9k_hw_ops(ah);
- 	static const u32 ar5416_cca_regs[6] = {
- 		AR_PHY_CCA,
- 		AR_PHY_CH1_CCA,
-@@ -1250,6 +1271,8 @@ int ar5008_hw_attach_phy_ops(struct ath_
- 	if (ret)
- 	    return ret;
- 
-+	ops->get_adc_entropy = ar5008_hw_get_adc_entropy;
-+
- 	priv_ops->rf_set_freq = ar5008_hw_set_channel;
- 	priv_ops->spur_mitigate_freq = ar5008_hw_spur_mitigate;
- 
---- a/drivers/net/wireless/ath/ath9k/ar9002_phy.h
-+++ b/drivers/net/wireless/ath/ath9k/ar9002_phy.h
-@@ -20,6 +20,12 @@
- #define PHY_AGC_CLR             0x10000000
- #define RFSILENT_BB             0x00002000
- 
-+#define AR_PHY_TEST_BBB_OBS_SEL       0x780000
-+#define AR_PHY_TEST_BBB_OBS_SEL_S     19
-+
-+#define AR_PHY_TEST_RX_OBS_SEL_BIT5_S 23
-+#define AR_PHY_TEST_RX_OBS_SEL_BIT5   (1 << AR_PHY_TEST_RX_OBS_SEL_BIT5_S)
-+
- #define AR_PHY_TURBO                0x9804
- #define AR_PHY_FC_TURBO_MODE        0x00000001
- #define AR_PHY_FC_TURBO_SHORT       0x00000002
-@@ -36,6 +42,9 @@
- 
- #define AR_PHY_TEST2			0x9808
- 
-+#define AR_PHY_TEST2_RX_OBS_SEL        0x3C00
-+#define AR_PHY_TEST2_RX_OBS_SEL_S      10
-+
- #define AR_PHY_TIMING2           0x9810
- #define AR_PHY_TIMING3           0x9814
- #define AR_PHY_TIMING3_DSC_MAN   0xFFFE0000
-@@ -390,6 +399,8 @@
- #define AR_PHY_RFBUS_GRANT       0x9C20
- #define AR_PHY_RFBUS_GRANT_EN    0x00000001
- 
-+#define AR_PHY_TST_ADC      0x9C24
-+
- #define AR_PHY_CHAN_INFO_GAIN_DIFF             0x9CF4
- #define AR_PHY_CHAN_INFO_GAIN_DIFF_UPPER_LIMIT 320
- 
diff --git a/package/mac80211/patches/551-ath9k_p2p_ifcomb.patch b/package/mac80211/patches/551-ath9k_p2p_ifcomb.patch
deleted file mode 100644
index ffffe0c..0000000
--- a/package/mac80211/patches/551-ath9k_p2p_ifcomb.patch
+++ /dev/null
@@ -1,33 +0,0 @@
-From c997a1da25fe7c717ed099888b8eb35d4e139e70 Mon Sep 17 00:00:00 2001
-From: Felix Fietkau <nbd@openwrt.org>
-Date: Sun, 8 Dec 2013 08:52:52 +0100
-Subject: [PATCH] ath9k: support only one P2P interface
-
-Preparation for adding P2P powersave and multi-channel support.
-
-Signed-off-by: Felix Fietkau <nbd@openwrt.org>
----
- drivers/net/wireless/ath/ath9k/init.c | 4 ++--
-  1 file changed, 2 insertions(+), 2 deletions(-)
-
---- a/drivers/net/wireless/ath/ath9k/init.c
-+++ b/drivers/net/wireless/ath/ath9k/init.c
-@@ -863,15 +863,15 @@ void ath9k_reload_chainmask_settings(str
- 
- static const struct ieee80211_iface_limit if_limits[] = {
- 	{ .max = 2048,	.types = BIT(NL80211_IFTYPE_STATION) |
--				 BIT(NL80211_IFTYPE_P2P_CLIENT) |
- 				 BIT(NL80211_IFTYPE_WDS) },
- 	{ .max = 8,	.types =
- #ifdef CPTCFG_MAC80211_MESH
- 				 BIT(NL80211_IFTYPE_MESH_POINT) |
- #endif
--				 BIT(NL80211_IFTYPE_AP) |
--				 BIT(NL80211_IFTYPE_P2P_GO) },
-+				 BIT(NL80211_IFTYPE_AP) },
- 	{ .max = 1,	.types = BIT(NL80211_IFTYPE_ADHOC) },
-+	{ .max = 1,	.types = BIT(NL80211_IFTYPE_P2P_CLIENT) |
-+				 BIT(NL80211_IFTYPE_P2P_GO) },
- };
- 
- static const struct ieee80211_iface_limit if_dfs_limits[] = {
diff --git a/package/mac80211/patches/552-ath9k_p2p_ps_support.patch b/package/mac80211/patches/552-ath9k_p2p_ps_support.patch
deleted file mode 100644
index 4a61db3..0000000
--- a/package/mac80211/patches/552-ath9k_p2p_ps_support.patch
+++ /dev/null
@@ -1,247 +0,0 @@
-From 6744d0a7ea037c7d65e13ca906da93009b241d00 Mon Sep 17 00:00:00 2001
-From: Felix Fietkau <nbd@openwrt.org>
-Date: Tue, 11 Feb 2014 11:16:24 +0100
-Subject: [PATCH] ath9k: implement p2p client powersave support
-
-Use generic TSF timers to trigger powersave state changes based
-information from the P2P NoA attribute.
-Opportunistic Powersave is not handled, because the driver does not
-support powersave at the moment.
-
-Signed-off-by: Felix Fietkau <nbd@openwrt.org>
----
- drivers/net/wireless/ath/ath9k/ath9k.h |  12 ++++
- drivers/net/wireless/ath/ath9k/init.c  |   6 ++
- drivers/net/wireless/ath/ath9k/main.c  | 104 +++++++++++++++++++++++++++++++++
- drivers/net/wireless/ath/ath9k/recv.c  |   3 +
- 4 files changed, 125 insertions(+)
-
---- a/drivers/net/wireless/ath/ath9k/main.c
-+++ b/drivers/net/wireless/ath/ath9k/main.c
-@@ -261,6 +261,8 @@ static bool ath_complete_reset(struct at
- 	sc->gtt_cnt = 0;
- 	ieee80211_wake_queues(sc->hw);
- 
-+	ath9k_p2p_ps_timer(sc);
-+
- 	return true;
- }
- 
-@@ -1126,6 +1128,8 @@ static int ath9k_add_interface(struct ie
- 	if (ath9k_uses_beacons(vif->type))
- 		ath9k_beacon_assign_slot(sc, vif);
- 
-+	avp->vif = vif;
-+
- 	an->sc = sc;
- 	an->sta = NULL;
- 	an->vif = vif;
-@@ -1170,6 +1174,29 @@ static int ath9k_change_interface(struct
- 	return 0;
- }
- 
-+static void
-+ath9k_update_p2p_ps_timer(struct ath_softc *sc, struct ath_vif *avp)
-+{
-+	struct ath_hw *ah = sc->sc_ah;
-+	s32 tsf, target_tsf;
-+
-+	if (!avp || !avp->noa.has_next_tsf)
-+		return;
-+
-+	ath9k_hw_gen_timer_stop(ah, sc->p2p_ps_timer);
-+
-+	tsf = ath9k_hw_gettsf32(sc->sc_ah);
-+
-+	target_tsf = avp->noa.next_tsf;
-+	if (!avp->noa.absent)
-+		target_tsf -= ATH_P2P_PS_STOP_TIME;
-+
-+	if (target_tsf - tsf < ATH_P2P_PS_STOP_TIME)
-+		target_tsf = tsf + ATH_P2P_PS_STOP_TIME;
-+
-+	ath9k_hw_gen_timer_start(ah, sc->p2p_ps_timer, (u32) target_tsf, 1000000);
-+}
-+
- static void ath9k_remove_interface(struct ieee80211_hw *hw,
- 				   struct ieee80211_vif *vif)
- {
-@@ -1181,6 +1208,13 @@ static void ath9k_remove_interface(struc
- 
- 	mutex_lock(&sc->mutex);
- 
-+	spin_lock_bh(&sc->sc_pcu_lock);
-+	if (avp == sc->p2p_ps_vif) {
-+		sc->p2p_ps_vif = NULL;
-+		ath9k_update_p2p_ps_timer(sc, NULL);
-+	}
-+	spin_unlock_bh(&sc->sc_pcu_lock);
-+
- 	sc->nvifs--;
- 	sc->tx99_vif = NULL;
- 
-@@ -1649,6 +1683,70 @@ static void ath9k_bss_assoc_iter(void *d
- 		ath9k_set_assoc_state(sc, vif);
- }
- 
-+void ath9k_p2p_ps_timer(void *priv)
-+{
-+	struct ath_softc *sc = priv;
-+	struct ath_vif *avp = sc->p2p_ps_vif;
-+	struct ieee80211_vif *vif;
-+	struct ieee80211_sta *sta;
-+	struct ath_node *an;
-+	u32 tsf;
-+
-+	if (!avp)
-+		return;
-+
-+	tsf = ath9k_hw_gettsf32(sc->sc_ah);
-+	if (!avp->noa.absent)
-+		tsf += ATH_P2P_PS_STOP_TIME;
-+
-+	if (!avp->noa.has_next_tsf ||
-+	    avp->noa.next_tsf - tsf > BIT(31))
-+		ieee80211_update_p2p_noa(&avp->noa, tsf);
-+
-+	ath9k_update_p2p_ps_timer(sc, avp);
-+
-+	rcu_read_lock();
-+
-+	vif = avp->vif;
-+	sta = ieee80211_find_sta(vif, vif->bss_conf.bssid);
-+	if (!sta)
-+		goto out;
-+
-+	an = (void *) sta->drv_priv;
-+	if (an->sleeping == !!avp->noa.absent)
-+		goto out;
-+
-+	an->sleeping = avp->noa.absent;
-+	if (an->sleeping)
-+		ath_tx_aggr_sleep(sta, sc, an);
-+	else
-+		ath_tx_aggr_wakeup(sc, an);
-+
-+out:
-+	rcu_read_unlock();
-+}
-+
-+void ath9k_update_p2p_ps(struct ath_softc *sc, struct ieee80211_vif *vif)
-+{
-+	struct ath_vif *avp = (void *)vif->drv_priv;
-+	u32 tsf;
-+
-+	if (!sc->p2p_ps_timer)
-+		return;
-+
-+	if (vif->type != NL80211_IFTYPE_STATION || !vif->p2p)
-+		return;
-+
-+	sc->p2p_ps_vif = avp;
-+
-+	if (sc->ps_flags & PS_BEACON_SYNC)
-+		return;
-+
-+	tsf = ath9k_hw_gettsf32(sc->sc_ah);
-+	ieee80211_parse_p2p_noa(&vif->bss_conf.p2p_noa_attr, &avp->noa, tsf);
-+	ath9k_update_p2p_ps_timer(sc, avp);
-+}
-+
- static void ath9k_bss_info_changed(struct ieee80211_hw *hw,
- 				   struct ieee80211_vif *vif,
- 				   struct ieee80211_bss_conf *bss_conf,
-@@ -1723,6 +1821,12 @@ static void ath9k_bss_info_changed(struc
- 		}
- 	}
- 
-+	if (changed & BSS_CHANGED_P2P_PS) {
-+		spin_lock_bh(&sc->sc_pcu_lock);
-+		ath9k_update_p2p_ps(sc, vif);
-+		spin_unlock_bh(&sc->sc_pcu_lock);
-+	}
-+
- 	if (changed & CHECK_ANI)
- 		ath_check_ani(sc);
- 
---- a/drivers/net/wireless/ath/ath9k/ath9k.h
-+++ b/drivers/net/wireless/ath/ath9k/ath9k.h
-@@ -115,6 +115,9 @@ int ath_descdma_setup(struct ath_softc *
- #define ATH_TXFIFO_DEPTH           8
- #define ATH_TX_ERROR               0x01
- 
-+/* Stop tx traffic 1ms before the GO goes away */
-+#define ATH_P2P_PS_STOP_TIME       1000
-+
- #define IEEE80211_SEQ_SEQ_SHIFT    4
- #define IEEE80211_SEQ_MAX          4096
- #define IEEE80211_WEP_IVLEN        3
-@@ -363,11 +366,15 @@ void ath9k_release_buffered_frames(struc
- /********/
- 
- struct ath_vif {
-+	struct ieee80211_vif *vif;
- 	struct ath_node mcast_node;
- 	int av_bslot;
- 	bool primary_sta_vif;
- 	__le64 tsf_adjust; /* TSF adjustment for staggered beacons */
- 	struct ath_buf *av_bcbuf;
-+
-+	/* P2P Client */
-+	struct ieee80211_noa_data noa;
- };
- 
- struct ath9k_vif_iter_data {
-@@ -472,6 +479,8 @@ int ath_update_survey_stats(struct ath_s
- void ath_update_survey_nf(struct ath_softc *sc, int channel);
- void ath9k_queue_reset(struct ath_softc *sc, enum ath_reset_type type);
- void ath_ps_full_sleep(unsigned long data);
-+void ath9k_p2p_ps_timer(void *priv);
-+void ath9k_update_p2p_ps(struct ath_softc *sc, struct ieee80211_vif *vif);
- 
- /**********/
- /* BTCOEX */
-@@ -741,6 +750,9 @@ struct ath_softc {
- 	struct completion paprd_complete;
- 	wait_queue_head_t tx_wait;
- 
-+	struct ath_gen_timer *p2p_ps_timer;
-+	struct ath_vif *p2p_ps_vif;
-+
- 	unsigned long sc_flags;
- 	unsigned long driver_data;
- 
---- a/drivers/net/wireless/ath/ath9k/init.c
-+++ b/drivers/net/wireless/ath/ath9k/init.c
-@@ -797,6 +797,9 @@ static int ath9k_init_softc(u16 devid, s
- 	if (ret)
- 		goto err_btcoex;
- 
-+	sc->p2p_ps_timer = ath_gen_timer_alloc(sc->sc_ah, ath9k_p2p_ps_timer,
-+		NULL, sc, AR_FIRST_NDP_TIMER);
-+
- 	ath9k_cmn_init_crypto(sc->sc_ah);
- 	ath9k_init_misc(sc);
- 	ath_fill_led_pin(sc);
-@@ -1082,6 +1085,9 @@ static void ath9k_deinit_softc(struct at
- {
- 	int i = 0;
- 
-+	if (sc->p2p_ps_timer)
-+		ath_gen_timer_free(sc->sc_ah, sc->p2p_ps_timer);
-+
- 	ath9k_deinit_btcoex(sc);
- 
- 	for (i = 0; i < ATH9K_NUM_TX_QUEUES; i++)
---- a/drivers/net/wireless/ath/ath9k/recv.c
-+++ b/drivers/net/wireless/ath/ath9k/recv.c
-@@ -539,6 +539,9 @@ static void ath_rx_ps_beacon(struct ath_
- 		ath_dbg(common, PS,
- 			"Reconfigure beacon timers based on synchronized timestamp\n");
- 		ath9k_set_beacon(sc);
-+
-+		if (sc->p2p_ps_vif)
-+			ath9k_update_p2p_ps(sc, sc->p2p_ps_vif->vif);
- 	}
- 
- 	if (ath_beacon_dtim_pending_cab(skb)) {
diff --git a/package/mac80211/patches/566-ath9k-ar933x-usb-hang-workaround.patch b/package/mac80211/patches/566-ath9k-ar933x-usb-hang-workaround.patch
deleted file mode 100644
index af94c9e..0000000
--- a/package/mac80211/patches/566-ath9k-ar933x-usb-hang-workaround.patch
+++ /dev/null
@@ -1,79 +0,0 @@
---- a/drivers/net/wireless/ath/ath9k/hw.c
-+++ b/drivers/net/wireless/ath/ath9k/hw.c
-@@ -217,6 +217,19 @@ void ath9k_hw_get_channel_centers(struct
- 		centers->synth_center + (extoff * HT40_CHANNEL_CENTER_SHIFT);
- }
- 
-+static inline void ath9k_hw_disable_pll_lock_detect(struct ath_hw *ah)
-+{
-+	/* On AR9330 and AR9340 devices, some PHY registers must be
-+	 * tuned to gain better stability/performance. These registers
-+	 * might be changed while doing wlan reset so the registers must
-+	 * be reprogrammed after each reset.
-+	 */
-+	REG_CLR_BIT(ah, AR_PHY_USB_CTRL1, BIT(20));
-+	REG_RMW(ah, AR_PHY_USB_CTRL2,
-+		(1 << 21) | (0xf << 22),
-+		(1 << 21) | (0x3 << 22));
-+}
-+
- /******************/
- /* Chip Revisions */
- /******************/
-@@ -1337,6 +1350,9 @@ static bool ath9k_hw_set_reset(struct at
- 	if (AR_SREV_9100(ah))
- 		udelay(50);
- 
-+	if (AR_SREV_9330(ah) || AR_SREV_9340(ah))
-+		ath9k_hw_disable_pll_lock_detect(ah);
-+
- 	return true;
- }
- 
-@@ -1436,6 +1452,9 @@ static bool ath9k_hw_chip_reset(struct a
- 		ar9003_hw_internal_regulator_apply(ah);
- 	ath9k_hw_init_pll(ah, chan);
- 
-+	if (AR_SREV_9330(ah) || AR_SREV_9340(ah))
-+		ath9k_hw_disable_pll_lock_detect(ah);
-+
- 	return true;
- }
- 
-@@ -1730,8 +1749,14 @@ static int ath9k_hw_do_fastcc(struct ath
- 	if (AR_SREV_9271(ah))
- 		ar9002_hw_load_ani_reg(ah, chan);
- 
-+	if (AR_SREV_9330(ah) || AR_SREV_9340(ah))
-+		ath9k_hw_disable_pll_lock_detect(ah);
-+
- 	return 0;
- fail:
-+	if (AR_SREV_9330(ah) || AR_SREV_9340(ah))
-+		ath9k_hw_disable_pll_lock_detect(ah);
-+
- 	return -EINVAL;
- }
- 
-@@ -1959,6 +1984,9 @@ int ath9k_hw_reset(struct ath_hw *ah, st
- 	if (AR_SREV_9565(ah) && common->bt_ant_diversity)
- 		REG_SET_BIT(ah, AR_BTCOEX_WL_LNADIV, AR_BTCOEX_WL_LNADIV_FORCE_ON);
- 
-+	if (AR_SREV_9330(ah) || AR_SREV_9340(ah))
-+		ath9k_hw_disable_pll_lock_detect(ah);
-+
- 	return 0;
- }
- EXPORT_SYMBOL(ath9k_hw_reset);
---- a/drivers/net/wireless/ath/ath9k/phy.h
-+++ b/drivers/net/wireless/ath/ath9k/phy.h
-@@ -48,6 +48,9 @@
- #define AR_PHY_PLL_CONTROL 0x16180
- #define AR_PHY_PLL_MODE 0x16184
- 
-+#define AR_PHY_USB_CTRL1	0x16c84
-+#define AR_PHY_USB_CTRL2	0x16c88
-+
- enum ath9k_ant_div_comb_lna_conf {
- 	ATH_ANT_DIV_COMB_LNA1_MINUS_LNA2,
- 	ATH_ANT_DIV_COMB_LNA2,
diff --git a/package/mac80211/patches/601-rt2x00-set_pci_mwi.patch b/package/mac80211/patches/601-rt2x00-set_pci_mwi.patch
deleted file mode 100644
index 08c8fa6..0000000
--- a/package/mac80211/patches/601-rt2x00-set_pci_mwi.patch
+++ /dev/null
@@ -1,13 +0,0 @@
---- a/drivers/net/wireless/rt2x00/rt2x00pci.c
-+++ b/drivers/net/wireless/rt2x00/rt2x00pci.c
-@@ -94,8 +94,10 @@ int rt2x00pci_probe(struct pci_dev *pci_
- 
- 	pci_set_master(pci_dev);
- 
-+#ifdef CONFIG_PCI_SET_MWI
- 	if (pci_set_mwi(pci_dev))
- 		rt2x00_probe_err("MWI not available\n");
-+#endif
- 
- 	if (dma_set_mask(&pci_dev->dev, DMA_BIT_MASK(32))) {
- 		rt2x00_probe_err("PCI DMA not supported\n");
diff --git a/package/mac80211/patches/602-rt2x00-introduce-rt2x00_platform_h.patch b/package/mac80211/patches/602-rt2x00-introduce-rt2x00_platform_h.patch
deleted file mode 100644
index 8c71075..0000000
--- a/package/mac80211/patches/602-rt2x00-introduce-rt2x00_platform_h.patch
+++ /dev/null
@@ -1,32 +0,0 @@
---- /dev/null
-+++ b/include/linux/rt2x00_platform.h
-@@ -0,0 +1,19 @@
-+/*
-+ * Platform data definition for the rt2x00 driver
-+ *
-+ * Copyright (C) 2011 Gabor Juhos <juhosg@openwrt.org>
-+ *
-+ * This program is free software; you can redistribute it and/or modify it
-+ * under the terms of the GNU General Public License version 2 as published
-+ * by the Free Software Foundation.
-+ *
-+ */
-+
-+#ifndef _RT2X00_PLATFORM_H
-+#define _RT2X00_PLATFORM_H
-+
-+struct rt2x00_platform_data {
-+	char *eeprom_file_name;
-+};
-+
-+#endif /* _RT2X00_PLATFORM_H */
---- a/drivers/net/wireless/rt2x00/rt2x00.h
-+++ b/drivers/net/wireless/rt2x00/rt2x00.h
-@@ -38,6 +38,7 @@
- #include <linux/kfifo.h>
- #include <linux/hrtimer.h>
- #include <linux/average.h>
-+#include <linux/rt2x00_platform.h>
- 
- #include <net/mac80211.h>
- 
diff --git a/package/mac80211/patches/603-rt2x00-introduce-rt2x00eeprom.patch b/package/mac80211/patches/603-rt2x00-introduce-rt2x00eeprom.patch
deleted file mode 100644
index 2bbc6f1..0000000
--- a/package/mac80211/patches/603-rt2x00-introduce-rt2x00eeprom.patch
+++ /dev/null
@@ -1,301 +0,0 @@
---- a/.local-symbols
-+++ b/.local-symbols
-@@ -279,6 +279,7 @@ RT2X00_LIB_FIRMWARE=
- RT2X00_LIB_CRYPTO=
- RT2X00_LIB_LEDS=
- RT2X00_LIB_DEBUGFS=
-+RT2X00_LIB_EEPROM=
- RT2X00_DEBUG=
- RTL_CARDS=
- RTL8192CE=
---- a/drivers/net/wireless/rt2x00/Kconfig
-+++ b/drivers/net/wireless/rt2x00/Kconfig
-@@ -69,6 +69,7 @@ config RT2800PCI
- 	select RT2X00_LIB_MMIO
- 	select RT2X00_LIB_PCI
- 	select RT2X00_LIB_FIRMWARE
-+	select RT2X00_LIB_EEPROM
- 	select RT2X00_LIB_CRYPTO
- 	depends on CRC_CCITT
- 	depends on EEPROM_93CX6
-@@ -215,6 +216,7 @@ config RT2800SOC
- 	select RT2X00_LIB_MMIO
- 	select RT2X00_LIB_CRYPTO
- 	select RT2X00_LIB_FIRMWARE
-+	select RT2X00_LIB_EEPROM
- 	select RT2800_LIB
- 	select RT2800_LIB_MMIO
- 	---help---
-@@ -266,6 +268,9 @@ config RT2X00_LIB_FIRMWARE
- config RT2X00_LIB_CRYPTO
- 	boolean
- 
-+config RT2X00_LIB_EEPROM
-+	boolean
-+
- config RT2X00_LIB_LEDS
- 	boolean
- 	default y if (RT2X00_LIB=y && LEDS_CLASS=y) || (RT2X00_LIB=m && LEDS_CLASS!=n)
---- a/drivers/net/wireless/rt2x00/Makefile
-+++ b/drivers/net/wireless/rt2x00/Makefile
-@@ -7,6 +7,7 @@ rt2x00lib-$(CPTCFG_RT2X00_LIB_DEBUGFS)	+
- rt2x00lib-$(CPTCFG_RT2X00_LIB_CRYPTO)	+= rt2x00crypto.o
- rt2x00lib-$(CPTCFG_RT2X00_LIB_FIRMWARE)	+= rt2x00firmware.o
- rt2x00lib-$(CPTCFG_RT2X00_LIB_LEDS)	+= rt2x00leds.o
-+rt2x00lib-$(CPTCFG_RT2X00_LIB_EEPROM)	+= rt2x00eeprom.o
- 
- obj-$(CPTCFG_RT2X00_LIB)		+= rt2x00lib.o
- obj-$(CPTCFG_RT2X00_LIB_MMIO)		+= rt2x00mmio.o
---- a/drivers/net/wireless/rt2x00/rt2800lib.h
-+++ b/drivers/net/wireless/rt2x00/rt2800lib.h
-@@ -20,6 +20,8 @@
- #ifndef RT2800LIB_H
- #define RT2800LIB_H
- 
-+#include "rt2800.h"
-+
- struct rt2800_ops {
- 	void (*register_read)(struct rt2x00_dev *rt2x00dev,
- 			      const unsigned int offset, u32 *value);
-@@ -119,6 +121,15 @@ static inline int rt2800_read_eeprom(str
- {
- 	const struct rt2800_ops *rt2800ops = rt2x00dev->ops->drv;
- 
-+	if (rt2x00dev->eeprom_file) {
-+		memcpy(rt2x00dev->eeprom, rt2x00dev->eeprom_file->data,
-+		       EEPROM_SIZE);
-+		return 0;
-+	}
-+
-+	if (!rt2800ops->read_eeprom)
-+		return -EINVAL;
-+
- 	return rt2800ops->read_eeprom(rt2x00dev);
- }
- 
---- a/drivers/net/wireless/rt2x00/rt2800soc.c
-+++ b/drivers/net/wireless/rt2x00/rt2800soc.c
-@@ -95,19 +95,6 @@ static int rt2800soc_set_device_state(st
- 	return retval;
- }
- 
--static int rt2800soc_read_eeprom(struct rt2x00_dev *rt2x00dev)
--{
--	void __iomem *base_addr = ioremap(0x1F040000, EEPROM_SIZE);
--
--	if (!base_addr)
--		return -ENOMEM;
--
--	memcpy_fromio(rt2x00dev->eeprom, base_addr, EEPROM_SIZE);
--
--	iounmap(base_addr);
--	return 0;
--}
--
- /* Firmware functions */
- static char *rt2800soc_get_firmware_name(struct rt2x00_dev *rt2x00dev)
- {
-@@ -171,7 +158,6 @@ static const struct rt2800_ops rt2800soc
- 	.register_multiread	= rt2x00mmio_register_multiread,
- 	.register_multiwrite	= rt2x00mmio_register_multiwrite,
- 	.regbusy_read		= rt2x00mmio_regbusy_read,
--	.read_eeprom		= rt2800soc_read_eeprom,
- 	.hwcrypt_disabled	= rt2800soc_hwcrypt_disabled,
- 	.drv_write_firmware	= rt2800soc_write_firmware,
- 	.drv_init_registers	= rt2800mmio_init_registers,
---- a/drivers/net/wireless/rt2x00/rt2x00.h
-+++ b/drivers/net/wireless/rt2x00/rt2x00.h
-@@ -694,6 +694,7 @@ enum rt2x00_capability_flags {
- 	REQUIRE_SW_SEQNO,
- 	REQUIRE_HT_TX_DESC,
- 	REQUIRE_PS_AUTOWAKE,
-+	REQUIRE_EEPROM_FILE,
- 
- 	/*
- 	 * Capabilities
-@@ -963,6 +964,11 @@ struct rt2x00_dev {
- 	const struct firmware *fw;
- 
- 	/*
-+	 * EEPROM image.
-+	 */
-+	const struct firmware *eeprom_file;
-+
-+	/*
- 	 * FIFO for storing tx status reports between isr and tasklet.
- 	 */
- 	DECLARE_KFIFO_PTR(txstatus_fifo, u32);
---- a/drivers/net/wireless/rt2x00/rt2x00dev.c
-+++ b/drivers/net/wireless/rt2x00/rt2x00dev.c
-@@ -1324,6 +1324,10 @@ int rt2x00lib_probe_dev(struct rt2x00_de
- 	INIT_DELAYED_WORK(&rt2x00dev->autowakeup_work, rt2x00lib_autowakeup);
- 	INIT_WORK(&rt2x00dev->sleep_work, rt2x00lib_sleep);
- 
-+	retval = rt2x00lib_load_eeprom_file(rt2x00dev);
-+	if (retval)
-+		goto exit;
-+
- 	/*
- 	 * Let the driver probe the device to detect the capabilities.
- 	 */
-@@ -1454,6 +1458,11 @@ void rt2x00lib_remove_dev(struct rt2x00_
- 	 */
- 	if (rt2x00dev->drv_data)
- 		kfree(rt2x00dev->drv_data);
-+
-+	/*
-+	 * Free EEPROM image.
-+	 */
-+	rt2x00lib_free_eeprom_file(rt2x00dev);
- }
- EXPORT_SYMBOL_GPL(rt2x00lib_remove_dev);
- 
---- /dev/null
-+++ b/drivers/net/wireless/rt2x00/rt2x00eeprom.c
-@@ -0,0 +1,111 @@
-+/*
-+	Copyright (C) 2004 - 2009 Ivo van Doorn <IvDoorn@gmail.com>
-+	Copyright (C) 2004 - 2009 Gertjan van Wingerde <gwingerde@gmail.com>
-+	<http://rt2x00.serialmonkey.com>
-+
-+	This program is free software; you can redistribute it and/or modify
-+	it under the terms of the GNU General Public License as published by
-+	the Free Software Foundation; either version 2 of the License, or
-+	(at your option) any later version.
-+
-+	This program is distributed in the hope that it will be useful,
-+	but WITHOUT ANY WARRANTY; without even the implied warranty of
-+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-+	GNU General Public License for more details.
-+
-+	You should have received a copy of the GNU General Public License
-+	along with this program; if not, write to the
-+	Free Software Foundation, Inc.,
-+	59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
-+ */
-+
-+/*
-+	Module: rt2x00lib
-+	Abstract: rt2x00 eeprom file loading routines.
-+ */
-+
-+#include <linux/kernel.h>
-+#include <linux/module.h>
-+
-+#include "rt2x00.h"
-+#include "rt2x00lib.h"
-+
-+static const char *
-+rt2x00lib_get_eeprom_file_name(struct rt2x00_dev *rt2x00dev)
-+{
-+	struct rt2x00_platform_data *pdata = rt2x00dev->dev->platform_data;
-+
-+	if (pdata && pdata->eeprom_file_name)
-+		return pdata->eeprom_file_name;
-+
-+	return NULL
-+}
-+
-+static int rt2x00lib_request_eeprom_file(struct rt2x00_dev *rt2x00dev)
-+{
-+	const struct firmware *ee;
-+	const char *ee_name;
-+	int retval;
-+
-+	ee_name = rt2x00lib_get_eeprom_file_name(rt2x00dev);
-+	if (!ee_name) {
-+		rt2x00_err(rt2x00dev,
-+			   "Invalid EEPROM filename.\n"
-+			   "Please file bug report to %s.\n", DRV_PROJECT);
-+		return -EINVAL;
-+	}
-+
-+	rt2x00_info(rt2x00dev, "Loading EEPROM data from '%s'.\n", ee_name);
-+
-+	retval = request_firmware(&ee, ee_name, rt2x00dev->dev);
-+	if (retval) {
-+		rt2x00_err(rt2x00dev, "Failed to request EEPROM.\n");
-+		return retval;
-+	}
-+
-+	if (!ee || !ee->size || !ee->data) {
-+		rt2x00_err(rt2x00dev, "Failed to read EEPROM file.\n");
-+		retval = -ENOENT;
-+		goto err_exit;
-+	}
-+
-+	if (ee->size != rt2x00dev->ops->eeprom_size) {
-+		rt2x00_err(rt2x00dev,
-+			   "EEPROM file size is invalid, it should be %d bytes\n",
-+			   rt2x00dev->ops->eeprom_size);
-+		retval = -EINVAL;
-+		goto err_release_ee;
-+	}
-+
-+	rt2x00dev->eeprom_file = ee;
-+	return 0;
-+
-+err_release_ee:
-+	release_firmware(ee);
-+err_exit:
-+	return retval;
-+}
-+
-+int rt2x00lib_load_eeprom_file(struct rt2x00_dev *rt2x00dev)
-+{
-+	int retval;
-+
-+	if (!rt2x00lib_get_eeprom_file_name(rt2x00dev))
-+		return 0;
-+
-+	set_bit(REQUIRE_EEPROM_FILE, &rt2x00dev->cap_flags);
-+
-+	if (!rt2x00dev->eeprom_file) {
-+		retval = rt2x00lib_request_eeprom_file(rt2x00dev);
-+		if (retval)
-+			return retval;
-+	}
-+
-+	return 0;
-+}
-+
-+void rt2x00lib_free_eeprom_file(struct rt2x00_dev *rt2x00dev)
-+{
-+	release_firmware(rt2x00dev->eeprom_file);
-+	rt2x00dev->eeprom_file = NULL;
-+}
---- a/drivers/net/wireless/rt2x00/rt2x00lib.h
-+++ b/drivers/net/wireless/rt2x00/rt2x00lib.h
-@@ -320,6 +320,22 @@ static inline void rt2x00lib_free_firmwa
- #endif /* CPTCFG_RT2X00_LIB_FIRMWARE */
- 
- /*
-+ * EEPROM file handlers.
-+ */
-+#ifdef CPTCFG_RT2X00_LIB_EEPROM
-+int rt2x00lib_load_eeprom_file(struct rt2x00_dev *rt2x00dev);
-+void rt2x00lib_free_eeprom_file(struct rt2x00_dev *rt2x00dev);
-+#else
-+static inline int rt2x00lib_load_eeprom_file(struct rt2x00_dev *rt2x00dev)
-+{
-+	return 0;
-+}
-+static inline void rt2x00lib_free_eeprom_file(struct rt2x00_dev *rt2x00dev)
-+{
-+}
-+#endif /* CPTCFG_RT2X00_LIB_EEPROM */
-+
-+/*
-  * Debugfs handlers.
-  */
- #ifdef CPTCFG_RT2X00_LIB_DEBUGFS
---- a/drivers/net/wireless/rt2x00/rt2x00soc.c
-+++ b/drivers/net/wireless/rt2x00/rt2x00soc.c
-@@ -92,6 +92,7 @@ int rt2x00soc_probe(struct platform_devi
- 	rt2x00dev->hw = hw;
- 	rt2x00dev->irq = platform_get_irq(pdev, 0);
- 	rt2x00dev->name = pdev->dev.driver->name;
-+	set_bit(REQUIRE_EEPROM_FILE, &rt2x00dev->cap_flags);
- 
- 	rt2x00_set_chip_intf(rt2x00dev, RT2X00_CHIP_INTF_SOC);
- 
diff --git a/package/mac80211/patches/604-rt2x00-of_load_eeprom_filename.patch b/package/mac80211/patches/604-rt2x00-of_load_eeprom_filename.patch
deleted file mode 100644
index 4bc6f37..0000000
--- a/package/mac80211/patches/604-rt2x00-of_load_eeprom_filename.patch
+++ /dev/null
@@ -1,33 +0,0 @@
---- a/drivers/net/wireless/rt2x00/rt2x00eeprom.c
-+++ b/drivers/net/wireless/rt2x00/rt2x00eeprom.c
-@@ -26,6 +26,7 @@
- 
- #include <linux/kernel.h>
- #include <linux/module.h>
-+#include <linux/of.h>
- 
- #include "rt2x00.h"
- #include "rt2x00lib.h"
-@@ -34,11 +35,21 @@ static const char *
- rt2x00lib_get_eeprom_file_name(struct rt2x00_dev *rt2x00dev)
- {
- 	struct rt2x00_platform_data *pdata = rt2x00dev->dev->platform_data;
-+#ifdef CONFIG_OF
-+	struct device_node *np;
-+	const char *eep;
-+#endif
- 
- 	if (pdata && pdata->eeprom_file_name)
- 		return pdata->eeprom_file_name;
- 
--	return NULL
-+#ifdef CONFIG_OF
-+	np = rt2x00dev->dev->of_node;
-+	if (np && of_property_read_string(np, "ralink,eeprom", &eep) == 0)
-+	    return eep;
-+#endif
-+
-+	return NULL;
- }
- 
- static int rt2x00lib_request_eeprom_file(struct rt2x00_dev *rt2x00dev)
diff --git a/package/mac80211/patches/605-rt2x00-load-eeprom-on-SoC-from-a-mtd-device-defines-.patch b/package/mac80211/patches/605-rt2x00-load-eeprom-on-SoC-from-a-mtd-device-defines-.patch
deleted file mode 100644
index 75f0415..0000000
--- a/package/mac80211/patches/605-rt2x00-load-eeprom-on-SoC-from-a-mtd-device-defines-.patch
+++ /dev/null
@@ -1,101 +0,0 @@
-From 339fe73f340161a624cc08e738d2244814852c3e Mon Sep 17 00:00:00 2001
-From: John Crispin <blogic@openwrt.org>
-Date: Sun, 17 Mar 2013 00:55:04 +0100
-Subject: [PATCH] rt2x00: load eeprom on SoC from a mtd device defines inside
- OF
-
-Signed-off-by: John Crispin <blogic@openwrt.org>
----
- drivers/net/wireless/rt2x00/Kconfig     |    1 +
- drivers/net/wireless/rt2x00/rt2800pci.c |   44 ++++++++++++++++++++++++++-----
- 2 files changed, 39 insertions(+), 6 deletions(-)
-
---- a/drivers/net/wireless/rt2x00/Kconfig
-+++ b/drivers/net/wireless/rt2x00/Kconfig
-@@ -219,6 +219,7 @@ config RT2800SOC
- 	select RT2X00_LIB_EEPROM
- 	select RT2800_LIB
- 	select RT2800_LIB_MMIO
-+	select MTD if SOC_RT288X || SOC_RT305X
- 	---help---
- 	  This adds support for Ralink WiSoC devices.
- 	  Supported chips: RT2880, RT3050, RT3052, RT3350, RT3352.
---- a/drivers/net/wireless/rt2x00/rt2x00eeprom.c
-+++ b/drivers/net/wireless/rt2x00/rt2x00eeprom.c
-@@ -26,11 +26,66 @@
- 
- #include <linux/kernel.h>
- #include <linux/module.h>
-+#include <linux/mtd/mtd.h>
-+#include <linux/mtd/partitions.h>
- #include <linux/of.h>
- 
- #include "rt2x00.h"
- #include "rt2x00lib.h"
- 
-+static int rt2800lib_read_eeprom_mtd(struct rt2x00_dev *rt2x00dev)
-+{
-+	int ret = -EINVAL;
-+#ifdef CONFIG_OF
-+	static struct firmware mtd_fw;
-+	struct device_node *np = rt2x00dev->dev->of_node, *mtd_np = NULL;
-+	size_t retlen, len = rt2x00dev->ops->eeprom_size;
-+	int size, offset = 0;
-+	struct mtd_info *mtd;
-+	const char *part;
-+	const __be32 *list;
-+	phandle phandle;
-+
-+	list = of_get_property(np, "ralink,mtd-eeprom", &size);
-+	if (!list) {
-+		dev_err(rt2x00dev->dev, "failed to load eeprom property\n");
-+		return -ENOENT;
-+	}
-+
-+	phandle = be32_to_cpup(list++);
-+	if (phandle)
-+		mtd_np = of_find_node_by_phandle(phandle);
-+	if (!mtd_np) {
-+		dev_err(rt2x00dev->dev, "failed to load mtd phandle\n");
-+		return -EINVAL;
-+	}
-+
-+	part = of_get_property(mtd_np, "label", NULL);
-+	if (!part)
-+		part = mtd_np->name;
-+
-+	mtd = get_mtd_device_nm(part);
-+	if (IS_ERR(mtd)) {
-+		dev_err(rt2x00dev->dev, "failed to get mtd device \"%s\"\n", part);
-+		return PTR_ERR(mtd);
-+	}
-+
-+	if (size > sizeof(*list))
-+		offset = be32_to_cpup(list);
-+
-+	ret = mtd_read(mtd, offset, len, &retlen, (u_char *) rt2x00dev->eeprom);
-+	put_mtd_device(mtd);
-+
-+	if (!ret) {
-+		rt2x00dev->eeprom_file = &mtd_fw;
-+		mtd_fw.size = len;
-+		mtd_fw.data = rt2x00dev->eeprom;
-+	}
-+#endif
-+
-+	return ret;
-+}
-+
- static const char *
- rt2x00lib_get_eeprom_file_name(struct rt2x00_dev *rt2x00dev)
- {
-@@ -58,6 +113,9 @@ static int rt2x00lib_request_eeprom_file
- 	const char *ee_name;
- 	int retval;
- 
-+	if (!rt2800lib_read_eeprom_mtd(rt2x00dev))
-+		return 0;
-+
- 	ee_name = rt2x00lib_get_eeprom_file_name(rt2x00dev);
- 	if (!ee_name) {
- 		rt2x00_err(rt2x00dev,
diff --git a/package/mac80211/patches/606-rt2x00_no_realign.patch b/package/mac80211/patches/606-rt2x00_no_realign.patch
deleted file mode 100644
index 7e32192..0000000
--- a/package/mac80211/patches/606-rt2x00_no_realign.patch
+++ /dev/null
@@ -1,67 +0,0 @@
-[RFC] rt2x00: For drivers that only need L2 padding don't realign frames
-
-Signed-off-by: Helmut Schaa <helmut.schaa@...>
----
-
-Ivo, Gertjan, do you remeber by any chance why this alignment stuff was added
-in the first place? Was it because of DMA restrictions?
-
-While doing some profiling on the rt3052 SoC I noticed that 30-40% time was
-spent in memmove calls. And the culprit is the memmove aligning the payload
-to a 4byte boundary since that has to move a whole bunch of data.
-
-Interesstingly the legacy drivers insert an l2pad between the header and the
-payload but doesn't realign the payload itself to a 4-byte boundary. Hence,
-I came up with this patch and indeed CPU usage improves impressively.
-
-Only tested on rt2800pci!
-
-Thanks,
-Helmut
-
- drivers/net/wireless/rt2x00/rt2x00queue.c |   30 +++-------------------------
- 1 files changed, 4 insertions(+), 26 deletions(-)
-
---- a/drivers/net/wireless/rt2x00/rt2x00queue.c
-+++ b/drivers/net/wireless/rt2x00/rt2x00queue.c
-@@ -161,36 +161,14 @@ void rt2x00queue_align_frame(struct sk_b
- void rt2x00queue_insert_l2pad(struct sk_buff *skb, unsigned int header_length)
- {
- 	unsigned int payload_length = skb->len - header_length;
--	unsigned int header_align = ALIGN_SIZE(skb, 0);
--	unsigned int payload_align = ALIGN_SIZE(skb, header_length);
- 	unsigned int l2pad = payload_length ? L2PAD_SIZE(header_length) : 0;
- 
--	/*
--	 * Adjust the header alignment if the payload needs to be moved more
--	 * than the header.
--	 */
--	if (payload_align > header_align)
--		header_align += 4;
--
--	/* There is nothing to do if no alignment is needed */
--	if (!header_align)
-+	if (!l2pad)
- 		return;
- 
--	/* Reserve the amount of space needed in front of the frame */
--	skb_push(skb, header_align);
--
--	/*
--	 * Move the header.
--	 */
--	memmove(skb->data, skb->data + header_align, header_length);
--
--	/* Move the payload, if present and if required */
--	if (payload_length && payload_align)
--		memmove(skb->data + header_length + l2pad,
--			skb->data + header_length + l2pad + payload_align,
--			payload_length);
--
--	/* Trim the skb to the correct size */
-+	/* insert l2pad -> Move header */
-+	skb_push(skb, l2pad);
-+	memmove(skb->data, skb->data + l2pad, header_length);
- 	skb_trim(skb, header_length + l2pad + payload_length);
- }
- 
diff --git a/package/mac80211/patches/607-rt2x00-allow_disabling_bands_through_platform_data.patch b/package/mac80211/patches/607-rt2x00-allow_disabling_bands_through_platform_data.patch
deleted file mode 100644
index 4116735..0000000
--- a/package/mac80211/patches/607-rt2x00-allow_disabling_bands_through_platform_data.patch
+++ /dev/null
@@ -1,47 +0,0 @@
---- a/include/linux/rt2x00_platform.h
-+++ b/include/linux/rt2x00_platform.h
-@@ -14,6 +14,9 @@
- 
- struct rt2x00_platform_data {
- 	char *eeprom_file_name;
-+
-+	int disable_2ghz;
-+	int disable_5ghz;
- };
- 
- #endif /* _RT2X00_PLATFORM_H */
---- a/drivers/net/wireless/rt2x00/rt2x00dev.c
-+++ b/drivers/net/wireless/rt2x00/rt2x00dev.c
-@@ -937,6 +937,22 @@ static int rt2x00lib_probe_hw_modes(stru
- 	unsigned int num_rates;
- 	unsigned int i;
- 
-+	if (rt2x00dev->dev->platform_data) {
-+		struct rt2x00_platform_data *pdata;
-+
-+		pdata = rt2x00dev->dev->platform_data;
-+		if (pdata->disable_2ghz)
-+			spec->supported_bands &= ~SUPPORT_BAND_2GHZ;
-+		if (pdata->disable_5ghz)
-+			spec->supported_bands &= ~SUPPORT_BAND_5GHZ;
-+	}
-+
-+	if ((spec->supported_bands & SUPPORT_BAND_BOTH) == 0) {
-+		rt2x00_err(rt2x00dev, "No supported bands\n");
-+		return -EINVAL;
-+	}
-+
-+
- 	num_rates = 0;
- 	if (spec->supported_rates & SUPPORT_RATE_CCK)
- 		num_rates += 4;
---- a/drivers/net/wireless/rt2x00/rt2x00.h
-+++ b/drivers/net/wireless/rt2x00/rt2x00.h
-@@ -403,6 +403,7 @@ struct hw_mode_spec {
- 	unsigned int supported_bands;
- #define SUPPORT_BAND_2GHZ	0x00000001
- #define SUPPORT_BAND_5GHZ	0x00000002
-+#define SUPPORT_BAND_BOTH	(SUPPORT_BAND_2GHZ | SUPPORT_BAND_5GHZ)
- 
- 	unsigned int supported_rates;
- #define SUPPORT_RATE_CCK	0x00000001
diff --git a/package/mac80211/patches/608-add_platform_data_mac_addr.patch b/package/mac80211/patches/608-add_platform_data_mac_addr.patch
deleted file mode 100644
index a910cc3..0000000
--- a/package/mac80211/patches/608-add_platform_data_mac_addr.patch
+++ /dev/null
@@ -1,63 +0,0 @@
---- a/include/linux/rt2x00_platform.h
-+++ b/include/linux/rt2x00_platform.h
-@@ -14,6 +14,7 @@
- 
- struct rt2x00_platform_data {
- 	char *eeprom_file_name;
-+	const u8 *mac_address;
- 
- 	int disable_2ghz;
- 	int disable_5ghz;
---- a/drivers/net/wireless/rt2x00/rt2x00dev.c
-+++ b/drivers/net/wireless/rt2x00/rt2x00dev.c
-@@ -928,6 +928,18 @@ static void rt2x00lib_rate(struct ieee80
- 		entry->flags |= IEEE80211_RATE_SHORT_PREAMBLE;
- }
- 
-+const u8 *rt2x00lib_get_mac_address(struct rt2x00_dev *rt2x00dev)
-+{
-+	struct rt2x00_platform_data *pdata;
-+
-+	pdata = rt2x00dev->dev->platform_data;
-+	if (!pdata)
-+		return NULL;
-+
-+	return pdata->mac_address;
-+}
-+EXPORT_SYMBOL_GPL(rt2x00lib_get_mac_address);
-+
- static int rt2x00lib_probe_hw_modes(struct rt2x00_dev *rt2x00dev,
- 				    struct hw_mode_spec *spec)
- {
---- a/drivers/net/wireless/rt2x00/rt2x00.h
-+++ b/drivers/net/wireless/rt2x00/rt2x00.h
-@@ -1401,6 +1401,7 @@ static inline void rt2x00debug_dump_fram
-  */
- u32 rt2x00lib_get_bssidx(struct rt2x00_dev *rt2x00dev,
- 			 struct ieee80211_vif *vif);
-+const u8 *rt2x00lib_get_mac_address(struct rt2x00_dev *rt2x00dev);
- 
- /*
-  * Interrupt context handlers.
---- a/drivers/net/wireless/rt2x00/rt61pci.c
-+++ b/drivers/net/wireless/rt2x00/rt61pci.c
-@@ -2392,6 +2392,7 @@ static int rt61pci_validate_eeprom(struc
- 	u32 reg;
- 	u16 word;
- 	u8 *mac;
-+	const u8 *pdata_mac;
- 	s8 value;
- 
- 	rt2x00mmio_register_read(rt2x00dev, E2PROM_CSR, &reg);
-@@ -2412,7 +2413,11 @@ static int rt61pci_validate_eeprom(struc
- 	/*
- 	 * Start validation of the data that has been read.
- 	 */
-+	pdata_mac = rt2x00lib_get_mac_address(rt2x00dev);
- 	mac = rt2x00_eeprom_addr(rt2x00dev, EEPROM_MAC_ADDR_0);
-+	if (pdata_mac)
-+		memcpy(mac, pdata_mac, 6);
-+
- 	if (!is_valid_ether_addr(mac)) {
- 		eth_random_addr(mac);
- 		rt2x00_eeprom_dbg(rt2x00dev, "MAC: %pM\n", mac);
diff --git a/package/mac80211/patches/610-rt2x00-fix-rt3352-ext-pa.patch b/package/mac80211/patches/610-rt2x00-fix-rt3352-ext-pa.patch
deleted file mode 100644
index 83fbcd0..0000000
--- a/package/mac80211/patches/610-rt2x00-fix-rt3352-ext-pa.patch
+++ /dev/null
@@ -1,225 +0,0 @@
---- a/drivers/net/wireless/rt2x00/rt2800lib.c
-+++ b/drivers/net/wireless/rt2x00/rt2800lib.c
-@@ -3176,11 +3176,17 @@ static void rt2800_config_channel(struct
- 	/*
- 	 * Change BBP settings
- 	 */
-+	rt2800_bbp_write(rt2x00dev, 62, 0x37 - rt2x00dev->lna_gain);
-+	rt2800_bbp_write(rt2x00dev, 63, 0x37 - rt2x00dev->lna_gain);
-+	rt2800_bbp_write(rt2x00dev, 64, 0x37 - rt2x00dev->lna_gain);
-+
- 	if (rt2x00_rt(rt2x00dev, RT3352)) {
- 		rt2800_bbp_write(rt2x00dev, 27, 0x0);
- 		rt2800_bbp_write(rt2x00dev, 66, 0x26 + rt2x00dev->lna_gain);
- 		rt2800_bbp_write(rt2x00dev, 27, 0x20);
- 		rt2800_bbp_write(rt2x00dev, 66, 0x26 + rt2x00dev->lna_gain);
-+		rt2800_bbp_write(rt2x00dev, 86, 0x38);
-+		rt2800_bbp_write(rt2x00dev, 83, 0x6a);
- 	} else if (rt2x00_rt(rt2x00dev, RT3593)) {
- 		if (rf->channel > 14) {
- 			/* Disable CCK Packet detection on 5GHz */
-@@ -3194,14 +3200,8 @@ static void rt2800_config_channel(struct
- 		else
- 			rt2800_bbp_write(rt2x00dev, 105, 0x34);
- 
--		rt2800_bbp_write(rt2x00dev, 62, 0x37 - rt2x00dev->lna_gain);
--		rt2800_bbp_write(rt2x00dev, 63, 0x37 - rt2x00dev->lna_gain);
--		rt2800_bbp_write(rt2x00dev, 64, 0x37 - rt2x00dev->lna_gain);
- 		rt2800_bbp_write(rt2x00dev, 77, 0x98);
- 	} else {
--		rt2800_bbp_write(rt2x00dev, 62, 0x37 - rt2x00dev->lna_gain);
--		rt2800_bbp_write(rt2x00dev, 63, 0x37 - rt2x00dev->lna_gain);
--		rt2800_bbp_write(rt2x00dev, 64, 0x37 - rt2x00dev->lna_gain);
- 		rt2800_bbp_write(rt2x00dev, 86, 0);
- 	}
- 
-@@ -6125,6 +6125,12 @@ static void rt2800_init_rfcsr_3290(struc
- 
- static void rt2800_init_rfcsr_3352(struct rt2x00_dev *rt2x00dev)
- {
-+	int tx0_int_pa = test_bit(CAPABILITY_INTERNAL_PA_TX0,
-+				  &rt2x00dev->cap_flags);
-+	int tx1_int_pa = test_bit(CAPABILITY_INTERNAL_PA_TX1,
-+				  &rt2x00dev->cap_flags);
-+	u8 rfcsr;
-+
- 	rt2800_rf_init_calibration(rt2x00dev, 30);
- 
- 	rt2800_rfcsr_write(rt2x00dev, 0, 0xf0);
-@@ -6160,15 +6166,30 @@ static void rt2800_init_rfcsr_3352(struc
- 	rt2800_rfcsr_write(rt2x00dev, 31, 0x80);
- 	rt2800_rfcsr_write(rt2x00dev, 32, 0x80);
- 	rt2800_rfcsr_write(rt2x00dev, 33, 0x00);
--	rt2800_rfcsr_write(rt2x00dev, 34, 0x01);
-+	rfcsr = 0x01;
-+	if (!tx0_int_pa)
-+		rt2x00_set_field8(&rfcsr, RFCSR34_TX0_EXT_PA, 1);
-+	if (!tx1_int_pa)
-+		rt2x00_set_field8(&rfcsr, RFCSR34_TX1_EXT_PA, 1);
-+	rt2800_rfcsr_write(rt2x00dev, 34, rfcsr);
- 	rt2800_rfcsr_write(rt2x00dev, 35, 0x03);
- 	rt2800_rfcsr_write(rt2x00dev, 36, 0xbd);
- 	rt2800_rfcsr_write(rt2x00dev, 37, 0x3c);
- 	rt2800_rfcsr_write(rt2x00dev, 38, 0x5f);
- 	rt2800_rfcsr_write(rt2x00dev, 39, 0xc5);
- 	rt2800_rfcsr_write(rt2x00dev, 40, 0x33);
--	rt2800_rfcsr_write(rt2x00dev, 41, 0x5b);
--	rt2800_rfcsr_write(rt2x00dev, 42, 0x5b);
-+	rfcsr = 0x52;
-+	if (tx0_int_pa) {
-+		rt2x00_set_field8(&rfcsr, RFCSR41_BIT1, 1);
-+		rt2x00_set_field8(&rfcsr, RFCSR41_BIT4, 1);
-+	}
-+	rt2800_rfcsr_write(rt2x00dev, 41, rfcsr);
-+	rfcsr = 0x52;
-+	if (tx1_int_pa) {
-+		rt2x00_set_field8(&rfcsr, RFCSR42_BIT1, 1);
-+		rt2x00_set_field8(&rfcsr, RFCSR42_BIT4, 1);
-+	}
-+	rt2800_rfcsr_write(rt2x00dev, 42, rfcsr);
- 	rt2800_rfcsr_write(rt2x00dev, 43, 0xdb);
- 	rt2800_rfcsr_write(rt2x00dev, 44, 0xdb);
- 	rt2800_rfcsr_write(rt2x00dev, 45, 0xdb);
-@@ -6176,15 +6197,20 @@ static void rt2800_init_rfcsr_3352(struc
- 	rt2800_rfcsr_write(rt2x00dev, 47, 0x0d);
- 	rt2800_rfcsr_write(rt2x00dev, 48, 0x14);
- 	rt2800_rfcsr_write(rt2x00dev, 49, 0x00);
--	rt2800_rfcsr_write(rt2x00dev, 50, 0x2d);
--	rt2800_rfcsr_write(rt2x00dev, 51, 0x7f);
--	rt2800_rfcsr_write(rt2x00dev, 52, 0x00);
--	rt2800_rfcsr_write(rt2x00dev, 53, 0x52);
--	rt2800_rfcsr_write(rt2x00dev, 54, 0x1b);
--	rt2800_rfcsr_write(rt2x00dev, 55, 0x7f);
--	rt2800_rfcsr_write(rt2x00dev, 56, 0x00);
--	rt2800_rfcsr_write(rt2x00dev, 57, 0x52);
--	rt2800_rfcsr_write(rt2x00dev, 58, 0x1b);
-+	rfcsr = 0x2d;
-+	if (!tx0_int_pa)
-+		rt2x00_set_field8(&rfcsr, RFCSR50_TX0_EXT_PA, 1);
-+	if (!tx1_int_pa)
-+		rt2x00_set_field8(&rfcsr, RFCSR50_TX1_EXT_PA, 1);
-+	rt2800_rfcsr_write(rt2x00dev, 50, rfcsr);
-+	rt2800_rfcsr_write(rt2x00dev, 51, (tx0_int_pa ? 0x7f : 0x52));
-+	rt2800_rfcsr_write(rt2x00dev, 52, (tx0_int_pa ? 0x00 : 0xc0));
-+	rt2800_rfcsr_write(rt2x00dev, 53, (tx0_int_pa ? 0x52 : 0xd2));
-+	rt2800_rfcsr_write(rt2x00dev, 54, (tx0_int_pa ? 0x1b : 0xc0));
-+	rt2800_rfcsr_write(rt2x00dev, 55, (tx1_int_pa ? 0x7f : 0x52));
-+	rt2800_rfcsr_write(rt2x00dev, 56, (tx1_int_pa ? 0x00 : 0xc0));
-+	rt2800_rfcsr_write(rt2x00dev, 57, (tx0_int_pa ? 0x52 : 0x49));
-+	rt2800_rfcsr_write(rt2x00dev, 58, (tx1_int_pa ? 0x1b : 0xc0));
- 	rt2800_rfcsr_write(rt2x00dev, 59, 0x00);
- 	rt2800_rfcsr_write(rt2x00dev, 60, 0x00);
- 	rt2800_rfcsr_write(rt2x00dev, 61, 0x00);
-@@ -7051,6 +7077,7 @@ static int rt2800_init_eeprom(struct rt2
- 	 * RT53xx: defined in "EEPROM_CHIP_ID" field
- 	 */
- 	if (rt2x00_rt(rt2x00dev, RT3290) ||
-+	    rt2x00_rt(rt2x00dev, RT3352) ||
- 	    rt2x00_rt(rt2x00dev, RT5390) ||
- 	    rt2x00_rt(rt2x00dev, RT5392))
- 		rt2800_eeprom_read(rt2x00dev, EEPROM_CHIP_ID, &rf);
-@@ -7142,7 +7169,8 @@ static int rt2800_init_eeprom(struct rt2
- 	/*
- 	 * Detect if this device has Bluetooth co-existence.
- 	 */
--	if (rt2x00_get_field16(eeprom, EEPROM_NIC_CONF1_BT_COEXIST))
-+	if (!rt2x00_rt(rt2x00dev, RT3352) &&
-+	    rt2x00_get_field16(eeprom, EEPROM_NIC_CONF1_BT_COEXIST))
- 		__set_bit(CAPABILITY_BT_COEXIST, &rt2x00dev->cap_flags);
- 
- 	/*
-@@ -7171,6 +7199,22 @@ static int rt2800_init_eeprom(struct rt2
- 					EIRP_MAX_TX_POWER_LIMIT)
- 		__set_bit(CAPABILITY_POWER_LIMIT, &rt2x00dev->cap_flags);
- 
-+	/*
-+	 * Detect if device uses internal or external PA
-+	 */
-+	rt2800_eeprom_read(rt2x00dev, EEPROM_NIC_CONF1, &eeprom);
-+
-+	if (rt2x00_rt(rt2x00dev, RT3352)) {
-+		if (!rt2x00_get_field16(eeprom,
-+		    EEPROM_NIC_CONF1_EXTERNAL_TX0_PA_3352))
-+			__set_bit(CAPABILITY_INTERNAL_PA_TX0,
-+				  &rt2x00dev->cap_flags);
-+		if (!rt2x00_get_field16(eeprom,
-+		    EEPROM_NIC_CONF1_EXTERNAL_TX1_PA_3352))
-+			__set_bit(CAPABILITY_INTERNAL_PA_TX1,
-+				  &rt2x00dev->cap_flags);
-+	}
-+
- 	return 0;
- }
- 
---- a/drivers/net/wireless/rt2x00/rt2800.h
-+++ b/drivers/net/wireless/rt2x00/rt2800.h
-@@ -2299,6 +2299,12 @@ struct mac_iveiv_entry {
- #define RFCSR36_RF_BS			FIELD8(0x80)
- 
- /*
-+ * RFCSR 34:
-+ */
-+#define RFCSR34_TX0_EXT_PA		FIELD8(0x04)
-+#define RFCSR34_TX1_EXT_PA		FIELD8(0x08)
-+
-+/*
-  * RFCSR 38:
-  */
- #define RFCSR38_RX_LO1_EN		FIELD8(0x20)
-@@ -2310,6 +2316,18 @@ struct mac_iveiv_entry {
- #define RFCSR39_RX_LO2_EN		FIELD8(0x80)
- 
- /*
-+ * RFCSR 41:
-+ */
-+#define RFCSR41_BIT1			FIELD8(0x01)
-+#define RFCSR41_BIT4			FIELD8(0x08)
-+
-+/*
-+ * RFCSR 42:
-+ */
-+#define RFCSR42_BIT1			FIELD8(0x01)
-+#define RFCSR42_BIT4			FIELD8(0x08)
-+
-+/*
-  * RFCSR 49:
-  */
- #define RFCSR49_TX			FIELD8(0x3f)
-@@ -2322,6 +2340,8 @@ struct mac_iveiv_entry {
-  * RFCSR 50:
-  */
- #define RFCSR50_TX			FIELD8(0x3f)
-+#define RFCSR50_TX0_EXT_PA		FIELD8(0x02)
-+#define RFCSR50_TX1_EXT_PA		FIELD8(0x10)
- #define RFCSR50_EP			FIELD8(0xc0)
- /* bits for RT3593 */
- #define RFCSR50_TX_LO1_EN		FIELD8(0x20)
-@@ -2469,6 +2489,8 @@ enum rt2800_eeprom_word {
-  * INTERNAL_TX_ALC: 0: disable, 1: enable
-  * BT_COEXIST: 0: disable, 1: enable
-  * DAC_TEST: 0: disable, 1: enable
-+ * EXTERNAL_TX0_PA: 0: disable, 1: enable (only on RT3352)
-+ * EXTERNAL_TX1_PA: 0: disable, 1: enable (only on RT3352)
-  */
- #define EEPROM_NIC_CONF1_HW_RADIO		FIELD16(0x0001)
- #define EEPROM_NIC_CONF1_EXTERNAL_TX_ALC	FIELD16(0x0002)
-@@ -2485,6 +2507,8 @@ enum rt2800_eeprom_word {
- #define EEPROM_NIC_CONF1_INTERNAL_TX_ALC	FIELD16(0x2000)
- #define EEPROM_NIC_CONF1_BT_COEXIST		FIELD16(0x4000)
- #define EEPROM_NIC_CONF1_DAC_TEST		FIELD16(0x8000)
-+#define EEPROM_NIC_CONF1_EXTERNAL_TX0_PA_3352	FIELD16(0x4000)
-+#define EEPROM_NIC_CONF1_EXTERNAL_TX1_PA_3352	FIELD16(0x8000)
- 
- /*
-  * EEPROM frequency
---- a/drivers/net/wireless/rt2x00/rt2x00.h
-+++ b/drivers/net/wireless/rt2x00/rt2x00.h
-@@ -714,6 +714,8 @@ enum rt2x00_capability_flags {
- 	CAPABILITY_DOUBLE_ANTENNA,
- 	CAPABILITY_BT_COEXIST,
- 	CAPABILITY_VCO_RECALIBRATION,
-+	CAPABILITY_INTERNAL_PA_TX0,
-+	CAPABILITY_INTERNAL_PA_TX1,
- };
- 
- /*
diff --git a/package/mac80211/patches/611-rt2x00-rf_vals-rt3352-xtal20.patch b/package/mac80211/patches/611-rt2x00-rf_vals-rt3352-xtal20.patch
deleted file mode 100644
index 478a0f2..0000000
--- a/package/mac80211/patches/611-rt2x00-rf_vals-rt3352-xtal20.patch
+++ /dev/null
@@ -1,106 +0,0 @@
---- a/drivers/net/wireless/rt2x00/rt2800lib.c
-+++ b/drivers/net/wireless/rt2x00/rt2800lib.c
-@@ -7491,6 +7491,27 @@ static const struct rf_channel rf_vals_5
- 	{196, 83, 0, 12, 1},
- };
- 
-+/*
-+ * RF value list for rt3xxx with Xtal20MHz
-+ * Supports: 2.4 GHz (all) (RF3322)
-+ */
-+static const struct rf_channel rf_vals_xtal20mhz_3x[] = {
-+	{1,    0xE2,	 2,  0x14},
-+	{2,    0xE3,	 2,  0x14},
-+	{3,    0xE4,	 2,  0x14},
-+	{4,    0xE5,	 2,  0x14},
-+	{5,    0xE6,	 2,  0x14},
-+	{6,    0xE7,	 2,  0x14},
-+	{7,    0xE8,	 2,  0x14},
-+	{8,    0xE9,	 2,  0x14},
-+	{9,    0xEA,	 2,  0x14},
-+	{10,   0xEB,	 2,  0x14},
-+	{11,   0xEC,	 2,  0x14},
-+	{12,   0xED,	 2,  0x14},
-+	{13,   0xEE,	 2,  0x14},
-+	{14,   0xF0,	 2,  0x18},
-+};
-+
- static int rt2800_probe_hw_mode(struct rt2x00_dev *rt2x00dev)
- {
- 	struct hw_mode_spec *spec = &rt2x00dev->spec;
-@@ -7579,7 +7600,10 @@ static int rt2800_probe_hw_mode(struct r
- 	case RF5390:
- 	case RF5392:
- 		spec->num_channels = 14;
--		spec->channels = rf_vals_3x;
-+		if (spec->clk_is_20mhz)
-+			spec->channels = rf_vals_xtal20mhz_3x;
-+		else
-+			spec->channels = rf_vals_3x;
- 		break;
- 
- 	case RF3052:
-@@ -7755,6 +7779,19 @@ static int rt2800_probe_rt(struct rt2x00
- 	return 0;
- }
- 
-+int rt2800_probe_clk(struct rt2x00_dev *rt2x00dev)
-+{
-+	struct rt2x00_platform_data *pdata = rt2x00dev->dev->platform_data;
-+	struct hw_mode_spec *spec = &rt2x00dev->spec;
-+
-+	if (!pdata)
-+		return -EINVAL;
-+
-+	spec->clk_is_20mhz = pdata->clk_is_20mhz;
-+
-+	return 0;
-+}
-+
- int rt2800_probe_hw(struct rt2x00_dev *rt2x00dev)
- {
- 	int retval;
-@@ -7784,6 +7821,15 @@ int rt2800_probe_hw(struct rt2x00_dev *r
- 	rt2800_register_write(rt2x00dev, GPIO_CTRL, reg);
- 
- 	/*
-+	 * Probe SoC clock.
-+	 */
-+	if (rt2x00_is_soc(rt2x00dev)) {
-+		retval = rt2800_probe_clk(rt2x00dev);
-+		if (retval)
-+			return retval;
-+	}
-+
-+	/*
- 	 * Initialize hw specifications.
- 	 */
- 	retval = rt2800_probe_hw_mode(rt2x00dev);
---- a/drivers/net/wireless/rt2x00/rt2x00.h
-+++ b/drivers/net/wireless/rt2x00/rt2x00.h
-@@ -398,6 +398,7 @@ static inline struct rt2x00_intf* vif_to
-  * @channels: Device/chipset specific channel values (See &struct rf_channel).
-  * @channels_info: Additional information for channels (See &struct channel_info).
-  * @ht: Driver HT Capabilities (See &ieee80211_sta_ht_cap).
-+ * @clk_is_20mhz: External crystal of WiSoC is 20MHz instead of 40MHz
-  */
- struct hw_mode_spec {
- 	unsigned int supported_bands;
-@@ -414,6 +415,7 @@ struct hw_mode_spec {
- 	const struct channel_info *channels_info;
- 
- 	struct ieee80211_sta_ht_cap ht;
-+	int clk_is_20mhz;
- };
- 
- /*
---- a/include/linux/rt2x00_platform.h
-+++ b/include/linux/rt2x00_platform.h
-@@ -18,6 +18,7 @@ struct rt2x00_platform_data {
- 
- 	int disable_2ghz;
- 	int disable_5ghz;
-+	int clk_is_20mhz;
- };
- 
- #endif /* _RT2X00_PLATFORM_H */
diff --git a/package/mac80211/patches/612-rt2x00-make-wmac-loadable-via-OF-on-rt288x-305x-SoC.patch b/package/mac80211/patches/612-rt2x00-make-wmac-loadable-via-OF-on-rt288x-305x-SoC.patch
deleted file mode 100644
index f6b4808..0000000
--- a/package/mac80211/patches/612-rt2x00-make-wmac-loadable-via-OF-on-rt288x-305x-SoC.patch
+++ /dev/null
@@ -1,34 +0,0 @@
-From 04dbd87265f6ba4a373b211ba324b437d224fb2d Mon Sep 17 00:00:00 2001
-From: John Crispin <blogic@openwrt.org>
-Date: Sun, 17 Mar 2013 00:03:31 +0100
-Subject: [PATCH 21/38] rt2x00: make wmac loadable via OF on rt288x/305x SoC
-
-This patch ads the match table to allow loading the wmac support from a
-devicetree.
-
-Signed-off-by: John Crispin <blogic@openwrt.org>
----
- drivers/net/wireless/rt2x00/rt2800pci.c |    7 +++++++
- 1 file changed, 7 insertions(+)
-
---- a/drivers/net/wireless/rt2x00/rt2800soc.c
-+++ b/drivers/net/wireless/rt2x00/rt2800soc.c
-@@ -227,11 +227,18 @@ static int rt2800soc_probe(struct platfo
- 	return rt2x00soc_probe(pdev, &rt2800soc_ops);
- }
- 
-+static const struct of_device_id rt2880_wmac_match[] = {
-+	{ .compatible = "ralink,rt2880-wmac" },
-+	{},
-+};
-+MODULE_DEVICE_TABLE(of, rt2880_wmac_match);
-+
- static struct platform_driver rt2800soc_driver = {
- 	.driver		= {
- 		.name		= "rt2800_wmac",
- 		.owner		= THIS_MODULE,
- 		.mod_name	= KBUILD_MODNAME,
-+		.of_match_table	= rt2880_wmac_match,
- 	},
- 	.probe		= rt2800soc_probe,
- 	.remove		= rt2x00soc_remove,
diff --git a/package/mac80211/patches/616-rt2x00-support-rt5350.patch b/package/mac80211/patches/616-rt2x00-support-rt5350.patch
deleted file mode 100644
index 3bafa16..0000000
--- a/package/mac80211/patches/616-rt2x00-support-rt5350.patch
+++ /dev/null
@@ -1,276 +0,0 @@
---- a/drivers/net/wireless/rt2x00/rt2800.h
-+++ b/drivers/net/wireless/rt2x00/rt2800.h
-@@ -71,6 +71,7 @@
- #define RF5592				0x000f
- #define RF3070				0x3070
- #define RF3290				0x3290
-+#define RF5350				0x5350
- #define RF5360				0x5360
- #define RF5370				0x5370
- #define RF5372				0x5372
---- a/drivers/net/wireless/rt2x00/rt2800lib.c
-+++ b/drivers/net/wireless/rt2x00/rt2800lib.c
-@@ -2704,6 +2704,13 @@ static void rt2800_config_channel_rf53xx
- 
- 				rt2800_rfcsr_write(rt2x00dev, 59,
- 						   r59_non_bt[idx]);
-+			} else if (rt2x00_rt(rt2x00dev, RT5350)) {
-+				static const char r59_non_bt[] = {0x0b, 0x0b,
-+					0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0a,
-+					0x0a, 0x09, 0x08, 0x07, 0x07, 0x06};
-+
-+				rt2800_rfcsr_write(rt2x00dev, 59,
-+						   r59_non_bt[idx]);
- 			}
- 		}
- 	}
-@@ -3141,6 +3148,7 @@ static void rt2800_config_channel(struct
- 		rt2800_config_channel_rf3322(rt2x00dev, conf, rf, info);
- 		break;
- 	case RF3070:
-+	case RF5350:
- 	case RF5360:
- 	case RF5370:
- 	case RF5372:
-@@ -3158,6 +3166,7 @@ static void rt2800_config_channel(struct
- 	if (rt2x00_rf(rt2x00dev, RF3070) ||
- 	    rt2x00_rf(rt2x00dev, RF3290) ||
- 	    rt2x00_rf(rt2x00dev, RF3322) ||
-+	    rt2x00_rf(rt2x00dev, RF5350) ||
- 	    rt2x00_rf(rt2x00dev, RF5360) ||
- 	    rt2x00_rf(rt2x00dev, RF5370) ||
- 	    rt2x00_rf(rt2x00dev, RF5372) ||
-@@ -3398,7 +3407,8 @@ static void rt2800_config_channel(struct
- 	/*
- 	 * Clear update flag
- 	 */
--	if (rt2x00_rt(rt2x00dev, RT3352)) {
-+	if (rt2x00_rt(rt2x00dev, RT3352) ||
-+	    rt2x00_rt(rt2x00dev, RT5350)) {
- 		rt2800_bbp_read(rt2x00dev, 49, &bbp);
- 		rt2x00_set_field8(&bbp, BBP49_UPDATE_FLAG, 0);
- 		rt2800_bbp_write(rt2x00dev, 49, bbp);
-@@ -4272,6 +4282,7 @@ void rt2800_vco_calibration(struct rt2x0
- 	case RF3053:
- 	case RF3070:
- 	case RF3290:
-+	case RF5350:
- 	case RF5360:
- 	case RF5370:
- 	case RF5372:
-@@ -4668,6 +4679,8 @@ static int rt2800_init_registers(struct 
- 		rt2800_register_write(rt2x00dev, TX_SW_CFG0, 0x00000404);
- 		rt2800_register_write(rt2x00dev, TX_SW_CFG1, 0x00080606);
- 		rt2800_register_write(rt2x00dev, TX_SW_CFG2, 0x00000000);
-+	} else if (rt2x00_rt(rt2x00dev, RT5350)) {
-+		rt2800_register_write(rt2x00dev, TX_SW_CFG0, 0x00000404);
- 	} else {
- 		rt2800_register_write(rt2x00dev, TX_SW_CFG0, 0x00000000);
- 		rt2800_register_write(rt2x00dev, TX_SW_CFG1, 0x00080606);
-@@ -5309,9 +5322,13 @@ static void rt2800_init_bbp_3352(struct 
- 
- 	rt2800_bbp_write(rt2x00dev, 82, 0x62);
- 
--	rt2800_bbp_write(rt2x00dev, 83, 0x6a);
--
--	rt2800_bbp_write(rt2x00dev, 84, 0x99);
-+	if (rt2x00_rt(rt2x00dev, RT5350)) {
-+		rt2800_bbp_write(rt2x00dev, 83, 0x7a);
-+		rt2800_bbp_write(rt2x00dev, 84, 0x9a);
-+	} else {
-+		rt2800_bbp_write(rt2x00dev, 83, 0x6a);
-+		rt2800_bbp_write(rt2x00dev, 84, 0x99);
-+	}
- 
- 	rt2800_bbp_write(rt2x00dev, 86, 0x38);
- 
-@@ -5325,9 +5342,13 @@ static void rt2800_init_bbp_3352(struct 
- 
- 	rt2800_bbp_write(rt2x00dev, 104, 0x92);
- 
--	rt2800_bbp_write(rt2x00dev, 105, 0x34);
--
--	rt2800_bbp_write(rt2x00dev, 106, 0x05);
-+	if (rt2x00_rt(rt2x00dev, RT5350)) {
-+		rt2800_bbp_write(rt2x00dev, 105, 0x3c);
-+		rt2800_bbp_write(rt2x00dev, 106, 0x03);
-+	} else {
-+		rt2800_bbp_write(rt2x00dev, 105, 0x34);
-+		rt2800_bbp_write(rt2x00dev, 106, 0x05);
-+	}
- 
- 	rt2800_bbp_write(rt2x00dev, 120, 0x50);
- 
-@@ -5352,6 +5373,13 @@ static void rt2800_init_bbp_3352(struct 
- 	rt2800_bbp_write(rt2x00dev, 143, 0xa2);
- 
- 	rt2800_bbp_write(rt2x00dev, 148, 0xc8);
-+
-+	if (rt2x00_rt(rt2x00dev, RT5350)) {
-+		rt2800_bbp_write(rt2x00dev, 150, 0x40); /* Antenna Software OFDM */
-+		rt2800_bbp_write(rt2x00dev, 151, 0x30); /* Antenna Software CCK */
-+		rt2800_bbp_write(rt2x00dev, 152, 0xa3);
-+		rt2800_bbp_write(rt2x00dev, 154, 0); /* Clear previously selected antenna */
-+	}
- }
- 
- static void rt2800_init_bbp_3390(struct rt2x00_dev *rt2x00dev)
-@@ -5652,6 +5680,7 @@ static void rt2800_init_bbp(struct rt2x0
- 		rt2800_init_bbp_3290(rt2x00dev);
- 		break;
- 	case RT3352:
-+	case RT5350:
- 		rt2800_init_bbp_3352(rt2x00dev);
- 		break;
- 	case RT3390:
-@@ -6462,6 +6491,76 @@ static void rt2800_init_rfcsr_3593(struc
- 	/* TODO: enable stream mode support */
- }
- 
-+static void rt2800_init_rfcsr_5350(struct rt2x00_dev *rt2x00dev)
-+{
-+	rt2800_rfcsr_write(rt2x00dev, 0, 0xf0);
-+	rt2800_rfcsr_write(rt2x00dev, 1, 0x23);
-+	rt2800_rfcsr_write(rt2x00dev, 2, 0x50);
-+	rt2800_rfcsr_write(rt2x00dev, 3, 0x08);
-+	rt2800_rfcsr_write(rt2x00dev, 4, 0x49);
-+	rt2800_rfcsr_write(rt2x00dev, 5, 0x10);
-+	rt2800_rfcsr_write(rt2x00dev, 6, 0xe0);
-+	rt2800_rfcsr_write(rt2x00dev, 7, 0x00);
-+	rt2800_rfcsr_write(rt2x00dev, 8, 0xf1);
-+	rt2800_rfcsr_write(rt2x00dev, 9, 0x02);
-+	rt2800_rfcsr_write(rt2x00dev, 10, 0x53);
-+	rt2800_rfcsr_write(rt2x00dev, 11, 0x4a);
-+	rt2800_rfcsr_write(rt2x00dev, 12, 0x46);
-+	if(rt2x00dev->spec.clk_is_20mhz)
-+		rt2800_rfcsr_write(rt2x00dev, 13, 0x1f);
-+	else
-+		rt2800_rfcsr_write(rt2x00dev, 13, 0x9f);
-+	rt2800_rfcsr_write(rt2x00dev, 14, 0x00);
-+	rt2800_rfcsr_write(rt2x00dev, 15, 0x00);
-+	rt2800_rfcsr_write(rt2x00dev, 16, 0xc0);
-+	rt2800_rfcsr_write(rt2x00dev, 18, 0x03);
-+	rt2800_rfcsr_write(rt2x00dev, 19, 0x00);
-+	rt2800_rfcsr_write(rt2x00dev, 20, 0x00);
-+	rt2800_rfcsr_write(rt2x00dev, 21, 0x00);
-+	rt2800_rfcsr_write(rt2x00dev, 22, 0x20);
-+	rt2800_rfcsr_write(rt2x00dev, 23, 0x00);
-+	rt2800_rfcsr_write(rt2x00dev, 24, 0x00);
-+	rt2800_rfcsr_write(rt2x00dev, 25, 0x80);
-+	rt2800_rfcsr_write(rt2x00dev, 26, 0x00);
-+	rt2800_rfcsr_write(rt2x00dev, 27, 0x03);
-+	rt2800_rfcsr_write(rt2x00dev, 28, 0x00);
-+	rt2800_rfcsr_write(rt2x00dev, 29, 0xd0);
-+	rt2800_rfcsr_write(rt2x00dev, 30, 0x10);
-+	rt2800_rfcsr_write(rt2x00dev, 31, 0x80);
-+	rt2800_rfcsr_write(rt2x00dev, 32, 0x80);
-+	rt2800_rfcsr_write(rt2x00dev, 33, 0x00);
-+	rt2800_rfcsr_write(rt2x00dev, 34, 0x07);
-+	rt2800_rfcsr_write(rt2x00dev, 35, 0x12);
-+	rt2800_rfcsr_write(rt2x00dev, 36, 0x00);
-+	rt2800_rfcsr_write(rt2x00dev, 37, 0x08);
-+	rt2800_rfcsr_write(rt2x00dev, 38, 0x85);
-+	rt2800_rfcsr_write(rt2x00dev, 39, 0x1b);
-+	rt2800_rfcsr_write(rt2x00dev, 40, 0x0b);
-+	rt2800_rfcsr_write(rt2x00dev, 41, 0xbb);
-+	rt2800_rfcsr_write(rt2x00dev, 42, 0xd5);
-+	rt2800_rfcsr_write(rt2x00dev, 43, 0x9b);
-+	rt2800_rfcsr_write(rt2x00dev, 44, 0x0c);
-+	rt2800_rfcsr_write(rt2x00dev, 45, 0xa6);
-+	rt2800_rfcsr_write(rt2x00dev, 46, 0x73);
-+	rt2800_rfcsr_write(rt2x00dev, 47, 0x00);
-+	rt2800_rfcsr_write(rt2x00dev, 48, 0x10);
-+	rt2800_rfcsr_write(rt2x00dev, 49, 0x80);
-+	rt2800_rfcsr_write(rt2x00dev, 50, 0x00);
-+	rt2800_rfcsr_write(rt2x00dev, 51, 0x00);
-+	rt2800_rfcsr_write(rt2x00dev, 52, 0x38);
-+	rt2800_rfcsr_write(rt2x00dev, 53, 0x00);
-+	rt2800_rfcsr_write(rt2x00dev, 54, 0x38);
-+	rt2800_rfcsr_write(rt2x00dev, 55, 0x43);
-+	rt2800_rfcsr_write(rt2x00dev, 56, 0x82);
-+	rt2800_rfcsr_write(rt2x00dev, 57, 0x00);
-+	rt2800_rfcsr_write(rt2x00dev, 58, 0x39);
-+	rt2800_rfcsr_write(rt2x00dev, 59, 0x0b);
-+	rt2800_rfcsr_write(rt2x00dev, 60, 0x45);
-+	rt2800_rfcsr_write(rt2x00dev, 61, 0xd1);
-+	rt2800_rfcsr_write(rt2x00dev, 62, 0x00);
-+	rt2800_rfcsr_write(rt2x00dev, 63, 0x00);
-+}
-+
- static void rt2800_init_rfcsr_5390(struct rt2x00_dev *rt2x00dev)
- {
- 	rt2800_rf_init_calibration(rt2x00dev, 2);
-@@ -6699,6 +6798,9 @@ static void rt2800_init_rfcsr(struct rt2
- 	case RT3593:
- 		rt2800_init_rfcsr_3593(rt2x00dev);
- 		break;
-+	case RT5350:
-+		rt2800_init_rfcsr_5350(rt2x00dev);
-+		break;
- 	case RT5390:
- 		rt2800_init_rfcsr_5390(rt2x00dev);
- 		break;
-@@ -6948,6 +7050,12 @@ static int rt2800_validate_eeprom(struct
- 		rt2x00_set_field16(&word, EEPROM_NIC_CONF0_RF_TYPE, RF2820);
- 		rt2800_eeprom_write(rt2x00dev, EEPROM_NIC_CONF0, word);
- 		rt2x00_eeprom_dbg(rt2x00dev, "Antenna: 0x%04x\n", word);
-+	} else if (rt2x00_rt(rt2x00dev, RT5350)) {
-+		rt2x00_set_field16(&word, EEPROM_NIC_CONF0_RXPATH, 1);
-+		rt2x00_set_field16(&word, EEPROM_NIC_CONF0_TXPATH, 1);
-+		rt2x00_set_field16(&word, EEPROM_NIC_CONF0_RF_TYPE, RF3320);
-+		rt2x00_eeprom_write(rt2x00dev, EEPROM_NIC_CONF0, word);
-+		rt2x00_eeprom_dbg(rt2x00dev, "Antenna: 0x%04x\n", word);
- 	} else if (rt2x00_rt(rt2x00dev, RT2860) ||
- 		   rt2x00_rt(rt2x00dev, RT2872)) {
- 		/*
-@@ -7081,6 +7189,8 @@ static int rt2800_init_eeprom(struct rt2
- 	    rt2x00_rt(rt2x00dev, RT5390) ||
- 	    rt2x00_rt(rt2x00dev, RT5392))
- 		rt2800_eeprom_read(rt2x00dev, EEPROM_CHIP_ID, &rf);
-+	else if (rt2x00_rt(rt2x00dev, RT5350))
-+		rf = RF5350;
- 	else
- 		rf = rt2x00_get_field16(eeprom, EEPROM_NIC_CONF0_RF_TYPE);
- 
-@@ -7099,6 +7209,7 @@ static int rt2800_init_eeprom(struct rt2
- 	case RF3290:
- 	case RF3320:
- 	case RF3322:
-+	case RF5350:
- 	case RF5360:
- 	case RF5370:
- 	case RF5372:
-@@ -7594,6 +7705,7 @@ static int rt2800_probe_hw_mode(struct r
- 	case RF3290:
- 	case RF3320:
- 	case RF3322:
-+	case RF5350:
- 	case RF5360:
- 	case RF5370:
- 	case RF5372:
-@@ -7726,6 +7838,7 @@ static int rt2800_probe_hw_mode(struct r
- 	case RF3053:
- 	case RF3070:
- 	case RF3290:
-+	case RF5350:
- 	case RF5360:
- 	case RF5370:
- 	case RF5372:
-@@ -7764,6 +7877,7 @@ static int rt2800_probe_rt(struct rt2x00
- 	case RT3390:
- 	case RT3572:
- 	case RT3593:
-+	case RT5350:
- 	case RT5390:
- 	case RT5392:
- 	case RT5592:
---- a/drivers/net/wireless/rt2x00/rt2x00.h
-+++ b/drivers/net/wireless/rt2x00/rt2x00.h
-@@ -169,6 +169,7 @@ struct rt2x00_chip {
- #define RT3572		0x3572
- #define RT3593		0x3593
- #define RT3883		0x3883	/* WSOC */
-+#define RT5350		0x5350  /* WSOC 2.4GHz */
- #define RT5390		0x5390  /* 2.4GHz */
- #define RT5392		0x5392  /* 2.4GHz */
- #define RT5592		0x5592
diff --git a/package/mac80211/patches/619-rt2x00-change-led-polarity-from-OF.patch b/package/mac80211/patches/619-rt2x00-change-led-polarity-from-OF.patch
deleted file mode 100644
index f9186d8..0000000
--- a/package/mac80211/patches/619-rt2x00-change-led-polarity-from-OF.patch
+++ /dev/null
@@ -1,40 +0,0 @@
---- a/drivers/net/wireless/rt2x00/rt2800lib.c
-+++ b/drivers/net/wireless/rt2x00/rt2800lib.c
-@@ -36,6 +36,7 @@
- #include <linux/kernel.h>
- #include <linux/module.h>
- #include <linux/slab.h>
-+#include <linux/of.h>
- 
- #include "rt2x00.h"
- #include "rt2800lib.h"
-@@ -7298,6 +7299,17 @@ static int rt2800_init_eeprom(struct rt2
- 	rt2800_init_led(rt2x00dev, &rt2x00dev->led_assoc, LED_TYPE_ASSOC);
- 	rt2800_init_led(rt2x00dev, &rt2x00dev->led_qual, LED_TYPE_QUALITY);
- 
-+	{
-+		struct device_node *np = rt2x00dev->dev->of_node;
-+		unsigned int led_polarity;
-+
-+		/* Allow overriding polarity from OF */
-+		if (!of_property_read_u32(np, "ralink,led-polarity",
-+					  &led_polarity))
-+			rt2x00_set_field16(&eeprom, EEPROM_FREQ_LED_POLARITY,
-+					   led_polarity);
-+	}
-+
- 	rt2x00dev->led_mcu_reg = eeprom;
- #endif /* CPTCFG_RT2X00_LIB_LEDS */
- 
---- a/drivers/net/wireless/rt2x00/rt2x00leds.c
-+++ b/drivers/net/wireless/rt2x00/rt2x00leds.c
-@@ -109,6 +109,9 @@ static int rt2x00leds_register_led(struc
- 	led->led_dev.name = name;
- 	led->led_dev.brightness = LED_OFF;
- 
-+	if (rt2x00_is_soc(rt2x00dev))
-+		led->led_dev.brightness_set(&led->led_dev, LED_OFF);
-+
- 	retval = led_classdev_register(device, &led->led_dev);
- 	if (retval) {
- 		rt2x00_err(rt2x00dev, "Failed to register led handler\n");
diff --git a/package/mac80211/patches/620-rt2x00-add-AP+STA-support.patch b/package/mac80211/patches/620-rt2x00-add-AP+STA-support.patch
deleted file mode 100644
index 419cb60..0000000
--- a/package/mac80211/patches/620-rt2x00-add-AP+STA-support.patch
+++ /dev/null
@@ -1,11 +0,0 @@
---- a/drivers/net/wireless/rt2x00/rt2x00dev.c
-+++ b/drivers/net/wireless/rt2x00/rt2x00dev.c
-@@ -1262,7 +1262,7 @@ static inline void rt2x00lib_set_if_comb
- 	 */
- 	if_limit = &rt2x00dev->if_limits_ap;
- 	if_limit->max = rt2x00dev->ops->max_ap_intf;
--	if_limit->types = BIT(NL80211_IFTYPE_AP);
-+	if_limit->types = BIT(NL80211_IFTYPE_AP) | BIT(NL80211_IFTYPE_STATION);
- #ifdef CPTCFG_MAC80211_MESH
- 	if_limit->types |= BIT(NL80211_IFTYPE_MESH_POINT);
- #endif
diff --git a/package/mac80211/patches/620-rt2x00-rt3352-rf-id.patch b/package/mac80211/patches/620-rt2x00-rt3352-rf-id.patch
deleted file mode 100644
index 5e67344..0000000
--- a/package/mac80211/patches/620-rt2x00-rt3352-rf-id.patch
+++ /dev/null
@@ -1,15 +0,0 @@
---- a/drivers/net/wireless/rt2x00/rt2800lib.c
-+++ b/drivers/net/wireless/rt2x00/rt2800lib.c
-@@ -7186,10 +7186,11 @@ static int rt2800_init_eeprom(struct rt2
- 	 * RT53xx: defined in "EEPROM_CHIP_ID" field
- 	 */
- 	if (rt2x00_rt(rt2x00dev, RT3290) ||
--	    rt2x00_rt(rt2x00dev, RT3352) ||
- 	    rt2x00_rt(rt2x00dev, RT5390) ||
- 	    rt2x00_rt(rt2x00dev, RT5392))
- 		rt2800_eeprom_read(rt2x00dev, EEPROM_CHIP_ID, &rf);
-+	else if (rt2x00_rt(rt2x00dev, RT3352))
-+		rf = RF3322;
- 	else if (rt2x00_rt(rt2x00dev, RT5350))
- 		rf = RF5350;
- 	else
diff --git a/package/mac80211/patches/700-mwl8k-missing-pci-id-for-WNR854T.patch b/package/mac80211/patches/700-mwl8k-missing-pci-id-for-WNR854T.patch
deleted file mode 100644
index 484c075..0000000
--- a/package/mac80211/patches/700-mwl8k-missing-pci-id-for-WNR854T.patch
+++ /dev/null
@@ -1,10 +0,0 @@
---- a/drivers/net/wireless/mwl8k.c
-+++ b/drivers/net/wireless/mwl8k.c
-@@ -5529,6 +5529,7 @@ MODULE_FIRMWARE("mwl8k/fmimage_8366.fw")
- MODULE_FIRMWARE(MWL8K_8366_AP_FW(MWL8K_8366_AP_FW_API));
- 
- static DEFINE_PCI_DEVICE_TABLE(mwl8k_pci_id_table) = {
-+	{ PCI_VDEVICE(MARVELL, 0x2a02), .driver_data = MWL8363, },
- 	{ PCI_VDEVICE(MARVELL, 0x2a0a), .driver_data = MWL8363, },
- 	{ PCI_VDEVICE(MARVELL, 0x2a0c), .driver_data = MWL8363, },
- 	{ PCI_VDEVICE(MARVELL, 0x2a24), .driver_data = MWL8363, },
diff --git a/package/mac80211/patches/800-b43-gpio-mask-module-option.patch b/package/mac80211/patches/800-b43-gpio-mask-module-option.patch
deleted file mode 100644
index fc874ad..0000000
--- a/package/mac80211/patches/800-b43-gpio-mask-module-option.patch
+++ /dev/null
@@ -1,37 +0,0 @@
---- a/drivers/net/wireless/b43/b43.h
-+++ b/drivers/net/wireless/b43/b43.h
-@@ -820,6 +820,7 @@ struct b43_wldev {
- 	bool qos_enabled;		/* TRUE, if QoS is used. */
- 	bool hwcrypto_enabled;		/* TRUE, if HW crypto acceleration is enabled. */
- 	bool use_pio;			/* TRUE if next init should use PIO */
-+	int gpiomask;			/* GPIO LED mask as a module parameter */
- 
- 	/* PHY/Radio device. */
- 	struct b43_phy phy;
---- a/drivers/net/wireless/b43/main.c
-+++ b/drivers/net/wireless/b43/main.c
-@@ -76,6 +76,11 @@ MODULE_FIRMWARE("b43/ucode16_mimo.fw");
- MODULE_FIRMWARE("b43/ucode5.fw");
- MODULE_FIRMWARE("b43/ucode9.fw");
- 
-+static int modparam_gpiomask = 0x000F;
-+module_param_named(gpiomask, modparam_gpiomask, int, 0444);
-+MODULE_PARM_DESC(gpiomask,
-+         "GPIO mask for LED control (default 0x000F)");
-+
- static int modparam_bad_frames_preempt;
- module_param_named(bad_frames_preempt, modparam_bad_frames_preempt, int, 0444);
- MODULE_PARM_DESC(bad_frames_preempt,
-@@ -2747,10 +2752,10 @@ static int b43_gpio_init(struct b43_wlde
- 	u32 mask, set;
- 
- 	b43_maskset32(dev, B43_MMIO_MACCTL, ~B43_MACCTL_GPOUTSMSK, 0);
--	b43_maskset16(dev, B43_MMIO_GPIO_MASK, ~0, 0xF);
-+	b43_maskset16(dev, B43_MMIO_GPIO_MASK, ~0, modparam_gpiomask);
- 
- 	mask = 0x0000001F;
--	set = 0x0000000F;
-+	set = modparam_gpiomask;
- 	if (dev->dev->chip_id == 0x4301) {
- 		mask |= 0x0060;
- 		set |= 0x0060;
diff --git a/package/mac80211/patches/810-b43_no_pio.patch b/package/mac80211/patches/810-b43_no_pio.patch
deleted file mode 100644
index 5cd1b8b..0000000
--- a/package/mac80211/patches/810-b43_no_pio.patch
+++ /dev/null
@@ -1,86 +0,0 @@
---- a/drivers/net/wireless/b43/Makefile
-+++ b/drivers/net/wireless/b43/Makefile
-@@ -20,7 +20,7 @@ b43-y				+= xmit.o
- b43-y				+= lo.o
- b43-y				+= wa.o
- b43-y				+= dma.o
--b43-y				+= pio.o
-+b43-$(CPTCFG_B43_PIO)		+= pio.o
- b43-y				+= rfkill.o
- b43-$(CPTCFG_B43_LEDS)		+= leds.o
- b43-$(CPTCFG_B43_PCMCIA)	+= pcmcia.o
---- a/drivers/net/wireless/b43/main.c
-+++ b/drivers/net/wireless/b43/main.c
-@@ -1915,10 +1915,12 @@ static void b43_do_interrupt_thread(stru
- 			dma_reason[0], dma_reason[1],
- 			dma_reason[2], dma_reason[3],
- 			dma_reason[4], dma_reason[5]);
-+#ifdef CPTCFG_B43_PIO
- 		b43err(dev->wl, "This device does not support DMA "
- 			       "on your system. It will now be switched to PIO.\n");
- 		/* Fall back to PIO transfers if we get fatal DMA errors! */
- 		dev->use_pio = true;
-+#endif
- 		b43_controller_restart(dev, "DMA error");
- 		return;
- 	}
---- a/drivers/net/wireless/b43/pio.h
-+++ b/drivers/net/wireless/b43/pio.h
-@@ -150,7 +150,7 @@ static inline void b43_piorx_write32(str
- 	b43_write32(q->dev, q->mmio_base + offset, value);
- }
- 
--
-+#ifdef CPTCFG_B43_PIO
- int b43_pio_init(struct b43_wldev *dev);
- void b43_pio_free(struct b43_wldev *dev);
- 
-@@ -161,5 +161,37 @@ void b43_pio_rx(struct b43_pio_rxqueue *
- 
- void b43_pio_tx_suspend(struct b43_wldev *dev);
- void b43_pio_tx_resume(struct b43_wldev *dev);
-+#else
-+static inline int b43_pio_init(struct b43_wldev *dev)
-+{
-+	return 0;
-+}
-+
-+static inline void b43_pio_free(struct b43_wldev *dev)
-+{
-+}
-+
-+static inline int b43_pio_tx(struct b43_wldev *dev, struct sk_buff *skb)
-+{
-+	return 0;
-+}
-+
-+static inline void b43_pio_handle_txstatus(struct b43_wldev *dev,
-+					   const struct b43_txstatus *status)
-+{
-+}
-+
-+static inline void b43_pio_rx(struct b43_pio_rxqueue *q)
-+{
-+}
-+
-+static inline void b43_pio_tx_suspend(struct b43_wldev *dev)
-+{
-+}
-+
-+static inline void b43_pio_tx_resume(struct b43_wldev *dev)
-+{
-+}
-+#endif /* CPTCFG_B43_PIO */
- 
- #endif /* B43_PIO_H_ */
---- a/drivers/net/wireless/b43/Kconfig
-+++ b/drivers/net/wireless/b43/Kconfig
-@@ -98,7 +98,7 @@ config B43_BCMA_PIO
- 	default y
- 
- config B43_PIO
--	bool
-+	bool "Broadcom 43xx PIO support"
- 	depends on B43
- 	select SSB_BLOCKIO
- 	default y
diff --git a/package/mac80211/patches/820-b43-add-antenna-control.patch b/package/mac80211/patches/820-b43-add-antenna-control.patch
deleted file mode 100644
index dea9830..0000000
--- a/package/mac80211/patches/820-b43-add-antenna-control.patch
+++ /dev/null
@@ -1,131 +0,0 @@
---- a/drivers/net/wireless/b43/main.c
-+++ b/drivers/net/wireless/b43/main.c
-@@ -1562,7 +1562,7 @@ static void b43_write_beacon_template(st
- 				  len, ram_offset, shm_size_offset, rate);
- 
- 	/* Write the PHY TX control parameters. */
--	antenna = B43_ANTENNA_DEFAULT;
-+	antenna = dev->tx_antenna;
- 	antenna = b43_antenna_to_phyctl(antenna);
- 	ctl = b43_shm_read16(dev, B43_SHM_SHARED, B43_SHM_SH_BEACPHYCTL);
- 	/* We can't send beacons with short preamble. Would get PHY errors. */
-@@ -3105,8 +3105,8 @@ static int b43_chip_init(struct b43_wlde
- 
- 	/* Select the antennae */
- 	if (phy->ops->set_rx_antenna)
--		phy->ops->set_rx_antenna(dev, B43_ANTENNA_DEFAULT);
--	b43_mgmtframe_txantenna(dev, B43_ANTENNA_DEFAULT);
-+		phy->ops->set_rx_antenna(dev, dev->rx_antenna);
-+	b43_mgmtframe_txantenna(dev, dev->tx_antenna);
- 
- 	if (phy->type == B43_PHYTYPE_B) {
- 		value16 = b43_read16(dev, 0x005E);
-@@ -3850,7 +3850,6 @@ static int b43_op_config(struct ieee8021
- 	struct b43_wldev *dev;
- 	struct b43_phy *phy;
- 	struct ieee80211_conf *conf = &hw->conf;
--	int antenna;
- 	int err = 0;
- 	bool reload_bss = false;
- 
-@@ -3904,11 +3903,9 @@ static int b43_op_config(struct ieee8021
- 	}
- 
- 	/* Antennas for RX and management frame TX. */
--	antenna = B43_ANTENNA_DEFAULT;
--	b43_mgmtframe_txantenna(dev, antenna);
--	antenna = B43_ANTENNA_DEFAULT;
-+	b43_mgmtframe_txantenna(dev, dev->tx_antenna);
- 	if (phy->ops->set_rx_antenna)
--		phy->ops->set_rx_antenna(dev, antenna);
-+		phy->ops->set_rx_antenna(dev, dev->rx_antenna);
- 
- 	if (wl->radio_enabled != phy->radio_on) {
- 		if (wl->radio_enabled) {
-@@ -5041,6 +5038,47 @@ static int b43_op_get_survey(struct ieee
- 	return 0;
- }
- 
-+static int b43_op_set_antenna(struct ieee80211_hw *hw, u32 tx_ant, u32 rx_ant)
-+{
-+	struct b43_wl *wl = hw_to_b43_wl(hw);
-+	struct b43_wldev *dev = wl->current_dev;
-+
-+	if (tx_ant == 1 && rx_ant == 1) {
-+		dev->tx_antenna = B43_ANTENNA0;
-+		dev->rx_antenna = B43_ANTENNA0;
-+	}
-+	else if (tx_ant == 2 && rx_ant == 2) {
-+		dev->tx_antenna = B43_ANTENNA1;
-+		dev->rx_antenna = B43_ANTENNA1;
-+	}
-+	else if ((tx_ant & 3) == 3 && (rx_ant & 3) == 3) {
-+		dev->tx_antenna = B43_ANTENNA_DEFAULT;
-+		dev->rx_antenna = B43_ANTENNA_DEFAULT;
-+	}
-+	else {
-+		return -EINVAL;
-+	}
-+
-+	return 0;
-+}
-+
-+
-+static int b43_op_get_antenna(struct ieee80211_hw *hw, u32 *tx_ant, u32 *rx_ant)
-+{
-+	struct b43_wl *wl = hw_to_b43_wl(hw);
-+	struct b43_wldev *dev = wl->current_dev;
-+
-+	switch (dev->tx_antenna) {
-+	case B43_ANTENNA0:
-+		*tx_ant = 1; *rx_ant = 1; break;
-+	case B43_ANTENNA1:
-+		*tx_ant = 2; *rx_ant = 2; break;
-+	case B43_ANTENNA_DEFAULT:
-+		*tx_ant = 3; *rx_ant = 3; break;
-+	}
-+	return 0;
-+}
-+
- static const struct ieee80211_ops b43_hw_ops = {
- 	.tx			= b43_op_tx,
- 	.conf_tx		= b43_op_conf_tx,
-@@ -5062,6 +5100,8 @@ static const struct ieee80211_ops b43_hw
- 	.sw_scan_complete	= b43_op_sw_scan_complete_notifier,
- 	.get_survey		= b43_op_get_survey,
- 	.rfkill_poll		= b43_rfkill_poll,
-+	.set_antenna		= b43_op_set_antenna,
-+	.get_antenna		= b43_op_get_antenna,
- };
- 
- /* Hard-reset the chip. Do not call this directly.
-@@ -5308,6 +5348,8 @@ static int b43_one_core_attach(struct b4
- 	if (!wldev)
- 		goto out;
- 
-+	wldev->rx_antenna = B43_ANTENNA_DEFAULT;
-+	wldev->tx_antenna = B43_ANTENNA_DEFAULT;
- 	wldev->use_pio = b43_modparam_pio;
- 	wldev->dev = dev;
- 	wldev->wl = wl;
-@@ -5398,6 +5440,9 @@ static struct b43_wl *b43_wireless_init(
- 
- 	hw->wiphy->flags |= WIPHY_FLAG_IBSS_RSN;
- 
-+	hw->wiphy->available_antennas_rx = 0x3;
-+	hw->wiphy->available_antennas_tx = 0x3;
-+
- 	wl->hw_registred = false;
- 	hw->max_rates = 2;
- 	SET_IEEE80211_DEV(hw, dev->dev);
---- a/drivers/net/wireless/b43/b43.h
-+++ b/drivers/net/wireless/b43/b43.h
-@@ -821,6 +821,8 @@ struct b43_wldev {
- 	bool hwcrypto_enabled;		/* TRUE, if HW crypto acceleration is enabled. */
- 	bool use_pio;			/* TRUE if next init should use PIO */
- 	int gpiomask;			/* GPIO LED mask as a module parameter */
-+	int rx_antenna;			/* Used RX antenna (B43_ANTENNAxxx) */
-+	int tx_antenna;			/* Used TX antenna (B43_ANTENNAxxx) */
- 
- 	/* PHY/Radio device. */
- 	struct b43_phy phy;
diff --git a/package/mac80211/patches/830-b43-workaround-pcie-bcm4716.patch b/package/mac80211/patches/830-b43-workaround-pcie-bcm4716.patch
deleted file mode 100644
index e76758c..0000000
--- a/package/mac80211/patches/830-b43-workaround-pcie-bcm4716.patch
+++ /dev/null
@@ -1,243 +0,0 @@
-From 4f214b1ead0af7439921637645cb63f378516175 Mon Sep 17 00:00:00 2001
-From: Hauke Mehrtens <hauke@hauke-m.de>
-Date: Sat, 21 Jan 2012 18:48:38 +0100
-Subject: [PATCH 33/34] b43: add workaround for b43 on pcie bus of bcm4716.
-
-bcm4716 (which includes 4717 & 4718), plus 4706 on PCIe can reorder
-transactions. As a fix, a read after write is performed on certain
-places in the code. Older chips and the newer 5357 family don't require
-this fix.
-This code is based on the brcmsmac driver.
-
-Signed-off-by: Hauke Mehrtens <hauke@hauke-m.de>
----
- drivers/net/wireless/b43/b43.h        |   26 ++++++++++++++++++++++++++
- drivers/net/wireless/b43/bus.h        |   10 ++++++++++
- drivers/net/wireless/b43/phy_common.c |    6 ++++++
- drivers/net/wireless/b43/phy_n.c      |   10 +++++-----
- 4 files changed, 47 insertions(+), 5 deletions(-)
-
---- a/drivers/net/wireless/b43/b43.h
-+++ b/drivers/net/wireless/b43/b43.h
-@@ -1061,6 +1061,31 @@ static inline bool b43_using_pio_transfe
- 	return dev->__using_pio_transfers;
- }
- 
-+/*
-+ * bcm4716 (which includes 4717 & 4718), plus 4706 on PCIe can reorder
-+ * transactions. As a fix, a read after write is performed on certain places
-+ * in the code. Older chips and the newer 5357 family don't require this fix.
-+ */
-+#ifdef CONFIG_BCM47XX_BCMA
-+#include <asm/mach-bcm47xx/bcm47xx.h>
-+static inline void b43_wflush16(struct b43_wldev *dev, u16 offset, u16 value)
-+{
-+	if (b43_bus_host_is_pci(dev->dev) &&
-+	    bcm47xx_bus_type == BCM47XX_BUS_TYPE_BCMA &&
-+	    bcm47xx_bus.bcma.bus.chipinfo.id == BCMA_CHIP_ID_BCM4716) {
-+		b43_write16(dev, offset, value);
-+		b43_read16(dev, offset);
-+	} else {
-+		b43_write16(dev, offset, value);
-+	}
-+}
-+#else
-+static inline void b43_wflush16(struct b43_wldev *dev, u16 offset, u16 value)
-+{
-+	b43_write16(dev, offset, value);
-+}
-+#endif
-+
- /* Message printing */
- __printf(2, 3) void b43info(struct b43_wl *wl, const char *fmt, ...);
- __printf(2, 3) void b43err(struct b43_wl *wl, const char *fmt, ...);
---- a/drivers/net/wireless/b43/bus.h
-+++ b/drivers/net/wireless/b43/bus.h
-@@ -60,6 +60,16 @@ static inline bool b43_bus_host_is_sdio(
- 	return (dev->bus_type == B43_BUS_SSB &&
- 		dev->sdev->bus->bustype == SSB_BUSTYPE_SDIO);
- }
-+static inline bool b43_bus_host_is_pci(struct b43_bus_dev *dev)
-+{
-+	if (dev->bus_type == B43_BUS_SSB)
-+		return (dev->sdev->bus->bustype == SSB_BUSTYPE_PCI);
-+#ifdef CPTCFG_B43_BCMA
-+	if (dev->bus_type == B43_BUS_BCMA)
-+		return (dev->bdev->bus->hosttype == BCMA_HOSTTYPE_PCI);
-+#endif
-+	return false;
-+}
- 
- struct b43_bus_dev *b43_bus_dev_bcma_init(struct bcma_device *core);
- struct b43_bus_dev *b43_bus_dev_ssb_init(struct ssb_device *sdev);
---- a/drivers/net/wireless/b43/main.c
-+++ b/drivers/net/wireless/b43/main.c
-@@ -4437,7 +4437,7 @@ static int b43_phy_versioning(struct b43
- 		u16 radio24[3];
- 
- 		for (tmp = 0; tmp < 3; tmp++) {
--			b43_write16(dev, B43_MMIO_RADIO24_CONTROL, tmp);
-+			b43_wflush16(dev, B43_MMIO_RADIO24_CONTROL, tmp);
- 			radio24[tmp] = b43_read16(dev, B43_MMIO_RADIO24_DATA);
- 		}
- 
-@@ -4456,10 +4456,10 @@ static int b43_phy_versioning(struct b43
- 			else
- 				tmp = 0x5205017F;
- 		} else {
--			b43_write16(dev, B43_MMIO_RADIO_CONTROL,
-+			b43_wflush16(dev, B43_MMIO_RADIO_CONTROL,
- 				    B43_RADIOCTL_ID);
- 			tmp = b43_read16(dev, B43_MMIO_RADIO_DATA_LOW);
--			b43_write16(dev, B43_MMIO_RADIO_CONTROL,
-+			b43_wflush16(dev, B43_MMIO_RADIO_CONTROL,
- 				    B43_RADIOCTL_ID);
- 			tmp |= (u32)b43_read16(dev, B43_MMIO_RADIO_DATA_HIGH)
- 				<< 16;
---- a/drivers/net/wireless/b43/phy_common.c
-+++ b/drivers/net/wireless/b43/phy_common.c
-@@ -266,6 +266,12 @@ void b43_phy_write(struct b43_wldev *dev
- {
- 	assert_mac_suspended(dev);
- 	dev->phy.ops->phy_write(dev, reg, value);
-+#ifdef CONFIG_BCM47XX
-+	if (b43_bus_host_is_pci(dev->dev) && reg == 0x72) {
-+		b43_read16(dev, B43_MMIO_PHY_VER);
-+		return;
-+	}
-+#endif
- 	if (++dev->phy.writes_counter == B43_MAX_WRITES_IN_ROW) {
- 		b43_read16(dev, B43_MMIO_PHY_VER);
- 		dev->phy.writes_counter = 0;
---- a/drivers/net/wireless/b43/phy_ht.c
-+++ b/drivers/net/wireless/b43/phy_ht.c
-@@ -1073,20 +1073,20 @@ static unsigned int b43_phy_ht_op_get_de
- 
- static u16 b43_phy_ht_op_read(struct b43_wldev *dev, u16 reg)
- {
--	b43_write16(dev, B43_MMIO_PHY_CONTROL, reg);
-+	b43_wflush16(dev, B43_MMIO_PHY_CONTROL, reg);
- 	return b43_read16(dev, B43_MMIO_PHY_DATA);
- }
- 
- static void b43_phy_ht_op_write(struct b43_wldev *dev, u16 reg, u16 value)
- {
--	b43_write16(dev, B43_MMIO_PHY_CONTROL, reg);
-+	b43_wflush16(dev, B43_MMIO_PHY_CONTROL, reg);
- 	b43_write16(dev, B43_MMIO_PHY_DATA, value);
- }
- 
- static void b43_phy_ht_op_maskset(struct b43_wldev *dev, u16 reg, u16 mask,
- 				 u16 set)
- {
--	b43_write16(dev, B43_MMIO_PHY_CONTROL, reg);
-+	b43_wflush16(dev, B43_MMIO_PHY_CONTROL, reg);
- 	b43_write16(dev, B43_MMIO_PHY_DATA,
- 		    (b43_read16(dev, B43_MMIO_PHY_DATA) & mask) | set);
- }
-@@ -1096,14 +1096,14 @@ static u16 b43_phy_ht_op_radio_read(stru
- 	/* HT-PHY needs 0x200 for read access */
- 	reg |= 0x200;
- 
--	b43_write16(dev, B43_MMIO_RADIO24_CONTROL, reg);
-+	b43_wflush16(dev, B43_MMIO_RADIO24_CONTROL, reg);
- 	return b43_read16(dev, B43_MMIO_RADIO24_DATA);
- }
- 
- static void b43_phy_ht_op_radio_write(struct b43_wldev *dev, u16 reg,
- 				      u16 value)
- {
--	b43_write16(dev, B43_MMIO_RADIO24_CONTROL, reg);
-+	b43_wflush16(dev, B43_MMIO_RADIO24_CONTROL, reg);
- 	b43_write16(dev, B43_MMIO_RADIO24_DATA, value);
- }
- 
---- a/drivers/net/wireless/b43/phy_lcn.c
-+++ b/drivers/net/wireless/b43/phy_lcn.c
-@@ -845,20 +845,20 @@ static void b43_phy_lcn_op_adjust_txpowe
- 
- static u16 b43_phy_lcn_op_read(struct b43_wldev *dev, u16 reg)
- {
--	b43_write16(dev, B43_MMIO_PHY_CONTROL, reg);
-+	b43_wflush16(dev, B43_MMIO_PHY_CONTROL, reg);
- 	return b43_read16(dev, B43_MMIO_PHY_DATA);
- }
- 
- static void b43_phy_lcn_op_write(struct b43_wldev *dev, u16 reg, u16 value)
- {
--	b43_write16(dev, B43_MMIO_PHY_CONTROL, reg);
-+	b43_wflush16(dev, B43_MMIO_PHY_CONTROL, reg);
- 	b43_write16(dev, B43_MMIO_PHY_DATA, value);
- }
- 
- static void b43_phy_lcn_op_maskset(struct b43_wldev *dev, u16 reg, u16 mask,
- 				   u16 set)
- {
--	b43_write16(dev, B43_MMIO_PHY_CONTROL, reg);
-+	b43_wflush16(dev, B43_MMIO_PHY_CONTROL, reg);
- 	b43_write16(dev, B43_MMIO_PHY_DATA,
- 		    (b43_read16(dev, B43_MMIO_PHY_DATA) & mask) | set);
- }
-@@ -868,14 +868,14 @@ static u16 b43_phy_lcn_op_radio_read(str
- 	/* LCN-PHY needs 0x200 for read access */
- 	reg |= 0x200;
- 
--	b43_write16(dev, B43_MMIO_RADIO24_CONTROL, reg);
-+	b43_wflush16(dev, B43_MMIO_RADIO24_CONTROL, reg);
- 	return b43_read16(dev, B43_MMIO_RADIO24_DATA);
- }
- 
- static void b43_phy_lcn_op_radio_write(struct b43_wldev *dev, u16 reg,
- 				       u16 value)
- {
--	b43_write16(dev, B43_MMIO_RADIO24_CONTROL, reg);
-+	b43_wflush16(dev, B43_MMIO_RADIO24_CONTROL, reg);
- 	b43_write16(dev, B43_MMIO_RADIO24_DATA, value);
- }
- 
---- a/drivers/net/wireless/b43/phy_n.c
-+++ b/drivers/net/wireless/b43/phy_n.c
-@@ -5418,14 +5418,14 @@ static inline void check_phyreg(struct b
- static u16 b43_nphy_op_read(struct b43_wldev *dev, u16 reg)
- {
- 	check_phyreg(dev, reg);
--	b43_write16(dev, B43_MMIO_PHY_CONTROL, reg);
-+	b43_wflush16(dev, B43_MMIO_PHY_CONTROL, reg);
- 	return b43_read16(dev, B43_MMIO_PHY_DATA);
- }
- 
- static void b43_nphy_op_write(struct b43_wldev *dev, u16 reg, u16 value)
- {
- 	check_phyreg(dev, reg);
--	b43_write16(dev, B43_MMIO_PHY_CONTROL, reg);
-+	b43_wflush16(dev, B43_MMIO_PHY_CONTROL, reg);
- 	b43_write16(dev, B43_MMIO_PHY_DATA, value);
- }
- 
-@@ -5433,7 +5433,7 @@ static void b43_nphy_op_maskset(struct b
- 				 u16 set)
- {
- 	check_phyreg(dev, reg);
--	b43_write16(dev, B43_MMIO_PHY_CONTROL, reg);
-+	b43_wflush16(dev, B43_MMIO_PHY_CONTROL, reg);
- 	b43_maskset16(dev, B43_MMIO_PHY_DATA, mask, set);
- }
- 
-@@ -5444,7 +5444,7 @@ static u16 b43_nphy_op_radio_read(struct
- 	/* N-PHY needs 0x100 for read access */
- 	reg |= 0x100;
- 
--	b43_write16(dev, B43_MMIO_RADIO_CONTROL, reg);
-+	b43_wflush16(dev, B43_MMIO_RADIO_CONTROL, reg);
- 	return b43_read16(dev, B43_MMIO_RADIO_DATA_LOW);
- }
- 
-@@ -5453,7 +5453,7 @@ static void b43_nphy_op_radio_write(stru
- 	/* Register 1 is a 32-bit register. */
- 	B43_WARN_ON(reg == 1);
- 
--	b43_write16(dev, B43_MMIO_RADIO_CONTROL, reg);
-+	b43_wflush16(dev, B43_MMIO_RADIO_CONTROL, reg);
- 	b43_write16(dev, B43_MMIO_RADIO_DATA_LOW, value);
- }
- 
diff --git a/package/mac80211/patches/841-b43-reduce-number-of-RX-slots.patch b/package/mac80211/patches/841-b43-reduce-number-of-RX-slots.patch
deleted file mode 100644
index 9c51ac6..0000000
--- a/package/mac80211/patches/841-b43-reduce-number-of-RX-slots.patch
+++ /dev/null
@@ -1,11 +0,0 @@
---- a/drivers/net/wireless/b43/dma.h
-+++ b/drivers/net/wireless/b43/dma.h
-@@ -169,7 +169,7 @@ struct b43_dmadesc_generic {
- 
- /* DMA engine tuning knobs */
- #define B43_TXRING_SLOTS		256
--#define B43_RXRING_SLOTS		256
-+#define B43_RXRING_SLOTS		32
- #define B43_DMA0_RX_FW598_BUFSIZE	(B43_DMA0_RX_FW598_FO + IEEE80211_MAX_FRAME_LEN)
- #define B43_DMA0_RX_FW351_BUFSIZE	(B43_DMA0_RX_FW351_FO + IEEE80211_MAX_FRAME_LEN)
- 
diff --git a/package/mac80211/patches/845-b43-only-use-gpio-0-1-for-led.patch b/package/mac80211/patches/845-b43-only-use-gpio-0-1-for-led.patch
deleted file mode 100644
index 50347cd..0000000
--- a/package/mac80211/patches/845-b43-only-use-gpio-0-1-for-led.patch
+++ /dev/null
@@ -1,17 +0,0 @@
---- a/drivers/net/wireless/b43/main.c
-+++ b/drivers/net/wireless/b43/main.c
-@@ -2764,6 +2764,14 @@ static int b43_gpio_init(struct b43_wlde
- 	} else if (dev->dev->chip_id == 0x5354) {
- 		/* Don't allow overtaking buttons GPIOs */
- 		set &= 0x2; /* 0x2 is LED GPIO on BCM5354 */
-+	} else if (dev->dev->chip_id == BCMA_CHIP_ID_BCM4716 || 
-+		   dev->dev->chip_id == BCMA_CHIP_ID_BCM47162 ||
-+		   dev->dev->chip_id == BCMA_CHIP_ID_BCM5356 ||
-+		   dev->dev->chip_id == BCMA_CHIP_ID_BCM5357 ||
-+		   dev->dev->chip_id == BCMA_CHIP_ID_BCM53572) {
-+		/* just use gpio 0 and 1 for 2.4 GHz wifi led */
-+		set &= 0x3;
-+		mask &= 0x3;
- 	}
- 
- 	if (0 /* FIXME: conditional unknown */ ) {
diff --git a/package/mac80211/patches/847-b43-always-take-overlapping-devs.patch b/package/mac80211/patches/847-b43-always-take-overlapping-devs.patch
deleted file mode 100644
index 9d1d419..0000000
--- a/package/mac80211/patches/847-b43-always-take-overlapping-devs.patch
+++ /dev/null
@@ -1,11 +0,0 @@
---- a/drivers/net/wireless/b43/main.c
-+++ b/drivers/net/wireless/b43/main.c
-@@ -118,7 +118,7 @@ static int b43_modparam_pio = 0;
- module_param_named(pio, b43_modparam_pio, int, 0644);
- MODULE_PARM_DESC(pio, "Use PIO accesses by default: 0=DMA, 1=PIO");
- 
--static int modparam_allhwsupport = !IS_ENABLED(CPTCFG_BRCMSMAC);
-+static int modparam_allhwsupport = 1;
- module_param_named(allhwsupport, modparam_allhwsupport, int, 0444);
- MODULE_PARM_DESC(allhwsupport, "Enable support for all hardware (even it if overlaps with the brcmsmac driver)");
- 
diff --git a/package/mac80211/patches/850-brcmsmac-remove-extra-regulation-restriction.patch b/package/mac80211/patches/850-brcmsmac-remove-extra-regulation-restriction.patch
deleted file mode 100644
index 185c427..0000000
--- a/package/mac80211/patches/850-brcmsmac-remove-extra-regulation-restriction.patch
+++ /dev/null
@@ -1,27 +0,0 @@
---- a/drivers/net/wireless/brcm80211/brcmsmac/channel.c
-+++ b/drivers/net/wireless/brcm80211/brcmsmac/channel.c
-@@ -58,19 +58,12 @@
- 				 (((c) < 149) ? 3 : 4))))
- 
- #define BRCM_2GHZ_2412_2462	REG_RULE(2412-10, 2462+10, 40, 0, 19, 0)
--#define BRCM_2GHZ_2467_2472	REG_RULE(2467-10, 2472+10, 20, 0, 19, \
--					 NL80211_RRF_NO_IR)
-+#define BRCM_2GHZ_2467_2472	REG_RULE(2467-10, 2472+10, 20, 0, 19, 0)
- 
--#define BRCM_5GHZ_5180_5240	REG_RULE(5180-10, 5240+10, 40, 0, 21, \
--					 NL80211_RRF_NO_IR)
--#define BRCM_5GHZ_5260_5320	REG_RULE(5260-10, 5320+10, 40, 0, 21, \
--					 NL80211_RRF_DFS | \
--					 NL80211_RRF_NO_IR)
--#define BRCM_5GHZ_5500_5700	REG_RULE(5500-10, 5700+10, 40, 0, 21, \
--					 NL80211_RRF_DFS | \
--					 NL80211_RRF_NO_IR)
--#define BRCM_5GHZ_5745_5825	REG_RULE(5745-10, 5825+10, 40, 0, 21, \
--					 NL80211_RRF_NO_IR)
-+#define BRCM_5GHZ_5180_5240	REG_RULE(5180-10, 5240+10, 40, 0, 21, 0)
-+#define BRCM_5GHZ_5260_5320	REG_RULE(5260-10, 5320+10, 40, 0, 21, 0)
-+#define BRCM_5GHZ_5500_5700	REG_RULE(5500-10, 5700+10, 40, 0, 21, 0)
-+#define BRCM_5GHZ_5745_5825	REG_RULE(5745-10, 5825+10, 40, 0, 21, 0)
- 
- static const struct ieee80211_regdomain brcms_regdom_x2 = {
- 	.n_reg_rules = 6,
diff --git a/package/mac80211/patches/900-wl1251-split-wl251-platform-data-to-a-separate-structure.patch b/package/mac80211/patches/900-wl1251-split-wl251-platform-data-to-a-separate-structure.patch
deleted file mode 100644
index a8af257..0000000
--- a/package/mac80211/patches/900-wl1251-split-wl251-platform-data-to-a-separate-structure.patch
+++ /dev/null
@@ -1,109 +0,0 @@
-Move the wl1251 part of the wl12xx platform data structure into a new
-structure specifically for wl1251.  Change the platform data built-in
-block and board files accordingly.
-
-Cc: Tony Lindgren <tony@atomide.com>
-Signed-off-by: Luciano Coelho <coelho@ti.com>
-Acked-by: Tony Lindgren <tony@atomide.com>
-Reviewed-by: Felipe Balbi <balbi@ti.com>
-
---- a/drivers/net/wireless/ti/wilink_platform_data.c
-+++ b/drivers/net/wireless/ti/wilink_platform_data.c
-@@ -23,17 +23,17 @@
- #include <linux/err.h>
- #include <linux/wl12xx.h>
- 
--static struct wl12xx_platform_data *platform_data;
-+static struct wl12xx_platform_data *wl12xx_platform_data;
- 
- int __init wl12xx_set_platform_data(const struct wl12xx_platform_data *data)
- {
--	if (platform_data)
-+	if (wl12xx_platform_data)
- 		return -EBUSY;
- 	if (!data)
- 		return -EINVAL;
- 
--	platform_data = kmemdup(data, sizeof(*data), GFP_KERNEL);
--	if (!platform_data)
-+	wl12xx_platform_data = kmemdup(data, sizeof(*data), GFP_KERNEL);
-+	if (!wl12xx_platform_data)
- 		return -ENOMEM;
- 
- 	return 0;
-@@ -41,9 +41,34 @@ int __init wl12xx_set_platform_data(cons
- 
- struct wl12xx_platform_data *wl12xx_get_platform_data(void)
- {
--	if (!platform_data)
-+	if (!wl12xx_platform_data)
- 		return ERR_PTR(-ENODEV);
- 
--	return platform_data;
-+	return wl12xx_platform_data;
- }
- EXPORT_SYMBOL(wl12xx_get_platform_data);
-+
-+static struct wl1251_platform_data *wl1251_platform_data;
-+
-+int __init wl1251_set_platform_data(const struct wl1251_platform_data *data)
-+{
-+	if (wl1251_platform_data)
-+		return -EBUSY;
-+	if (!data)
-+		return -EINVAL;
-+
-+	wl1251_platform_data = kmemdup(data, sizeof(*data), GFP_KERNEL);
-+	if (!wl1251_platform_data)
-+		return -ENOMEM;
-+
-+	return 0;
-+}
-+
-+struct wl1251_platform_data *wl1251_get_platform_data(void)
-+{
-+	if (!wl1251_platform_data)
-+		return ERR_PTR(-ENODEV);
-+
-+	return wl1251_platform_data;
-+}
-+EXPORT_SYMBOL(wl1251_get_platform_data);
---- a/drivers/net/wireless/ti/wl1251/sdio.c
-+++ b/drivers/net/wireless/ti/wl1251/sdio.c
-@@ -227,7 +227,7 @@ static int wl1251_sdio_probe(struct sdio
- 	struct wl1251 *wl;
- 	struct ieee80211_hw *hw;
- 	struct wl1251_sdio *wl_sdio;
--	const struct wl12xx_platform_data *wl12xx_board_data;
-+	const struct wl1251_platform_data *wl1251_board_data;
- 
- 	hw = wl1251_alloc_hw();
- 	if (IS_ERR(hw))
-@@ -254,11 +254,11 @@ static int wl1251_sdio_probe(struct sdio
- 	wl->if_priv = wl_sdio;
- 	wl->if_ops = &wl1251_sdio_ops;
- 
--	wl12xx_board_data = wl12xx_get_platform_data();
--	if (!IS_ERR(wl12xx_board_data)) {
--		wl->set_power = wl12xx_board_data->set_power;
--		wl->irq = wl12xx_board_data->irq;
--		wl->use_eeprom = wl12xx_board_data->use_eeprom;
-+	wl1251_board_data = wl1251_get_platform_data();
-+	if (!IS_ERR(wl1251_board_data)) {
-+		wl->set_power = wl1251_board_data->set_power;
-+		wl->irq = wl1251_board_data->irq;
-+		wl->use_eeprom = wl1251_board_data->use_eeprom;
- 	}
- 
- 	if (wl->irq) {
---- a/drivers/net/wireless/ti/wl1251/spi.c
-+++ b/drivers/net/wireless/ti/wl1251/spi.c
-@@ -241,7 +241,7 @@ static const struct wl1251_if_operations
- 
- static int wl1251_spi_probe(struct spi_device *spi)
- {
--	struct wl12xx_platform_data *pdata;
-+	struct wl1251_platform_data *pdata;
- 	struct ieee80211_hw *hw;
- 	struct wl1251 *wl;
- 	int ret;
diff --git a/package/mac80211/patches/901-wlcore-set-irq_flags-in-the-board-files.patch b/package/mac80211/patches/901-wlcore-set-irq_flags-in-the-board-files.patch
deleted file mode 100644
index f2789a9..0000000
--- a/package/mac80211/patches/901-wlcore-set-irq_flags-in-the-board-files.patch
+++ /dev/null
@@ -1,118 +0,0 @@
-The platform_quirk element in the platform data was used to change the
-way the IRQ is triggered.  When set, the EDGE_IRQ quirk would change
-the irqflags used and treat edge trigger differently from the rest.
-
-Instead of hiding this irq flag setting behind the quirk, have the
-board files set the flags during initialization.  This will be more
-meaningful than driver-specific quirks when we switch to DT.
-
-Additionally, fix missing gpio_request() calls in the boarding files
-(so that setting the flags actually works).
-
-Cc: Tony Lindgren <tony@atomide.com>
-Cc: Sekhar Nori <nsekhar@ti.com>
-Signed-off-by: Luciano Coelho <coelho@ti.com>
-Reviewed-by: Felipe Balbi <balbi@ti.com>
-Acked-by: Sekhar Nori <nsekhar@ti.com>
-
---- a/drivers/net/wireless/ti/wlcore/debugfs.c
-+++ b/drivers/net/wireless/ti/wlcore/debugfs.c
-@@ -502,7 +502,7 @@ static ssize_t driver_state_read(struct 
- 	DRIVER_STATE_PRINT_HEX(irq);
- 	/* TODO: ref_clock and tcxo_clock were moved to wl12xx priv */
- 	DRIVER_STATE_PRINT_HEX(hw_pg_ver);
--	DRIVER_STATE_PRINT_HEX(platform_quirks);
-+	DRIVER_STATE_PRINT_HEX(irq_flags);
- 	DRIVER_STATE_PRINT_HEX(chip.id);
- 	DRIVER_STATE_PRINT_STR(chip.fw_ver_str);
- 	DRIVER_STATE_PRINT_STR(chip.phy_fw_ver_str);
---- a/drivers/net/wireless/ti/wlcore/main.c
-+++ b/drivers/net/wireless/ti/wlcore/main.c
-@@ -27,6 +27,7 @@
- #include <linux/vmalloc.h>
- #include <linux/wl12xx.h>
- #include <linux/interrupt.h>
-+#include <linux/irq.h>
- 
- #include "wlcore.h"
- #include "debug.h"
-@@ -528,7 +529,7 @@ static int wlcore_irq_locked(struct wl12
- 	 * In case edge triggered interrupt must be used, we cannot iterate
- 	 * more than once without introducing race conditions with the hardirq.
- 	 */
--	if (wl->platform_quirks & WL12XX_PLATFORM_QUIRK_EDGE_IRQ)
-+	if (wl->irq_flags & IRQF_TRIGGER_RISING)
- 		loopcount = 1;
- 
- 	wl1271_debug(DEBUG_IRQ, "IRQ work");
-@@ -5934,7 +5935,6 @@ struct ieee80211_hw *wlcore_alloc_hw(siz
- 	wl->ap_ps_map = 0;
- 	wl->ap_fw_ps_map = 0;
- 	wl->quirks = 0;
--	wl->platform_quirks = 0;
- 	wl->system_hlid = WL12XX_SYSTEM_HLID;
- 	wl->active_sta_count = 0;
- 	wl->active_link_count = 0;
-@@ -6075,7 +6075,7 @@ static void wlcore_nvs_cb(const struct f
- 	struct platform_device *pdev = wl->pdev;
- 	struct wlcore_platdev_data *pdev_data = dev_get_platdata(&pdev->dev);
- 	struct wl12xx_platform_data *pdata = pdev_data->pdata;
--	unsigned long irqflags;
-+
- 	int ret;
- 	irq_handler_t hardirq_fn = NULL;
- 
-@@ -6103,29 +6103,19 @@ static void wlcore_nvs_cb(const struct f
- 	wlcore_adjust_conf(wl);
- 
- 	wl->irq = platform_get_irq(pdev, 0);
--	wl->platform_quirks = pdata->platform_quirks;
- 	wl->if_ops = pdev_data->if_ops;
- 
--#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,32)
--	irqflags = IRQF_TRIGGER_RISING;
-+	wl->irq_flags = irq_get_trigger_type(wl->irq) | IRQF_ONESHOT;
- 	hardirq_fn = wlcore_hardirq;
--#else
--	if (wl->platform_quirks & WL12XX_PLATFORM_QUIRK_EDGE_IRQ) {
--		irqflags = IRQF_TRIGGER_RISING;
--		hardirq_fn = wlcore_hardirq;
--	} else {
--		irqflags = IRQF_TRIGGER_HIGH | IRQF_ONESHOT;
--	}
--#endif
- 
- #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,31)
- 	ret = compat_request_threaded_irq(&wl->irq_compat, wl->irq,
- 					  hardirq_fn, wlcore_irq,
--					  irqflags,
-+					  wl->irqflags,
- 					  pdev->name, wl);
- #else
- 	ret = request_threaded_irq(wl->irq, hardirq_fn, wlcore_irq,
--				   irqflags, pdev->name, wl);
-+				   wl->irq_flags, pdev->name, wl);
- #endif
- 	if (ret < 0) {
- 		wl1271_error("request_irq() failed: %d", ret);
---- a/drivers/net/wireless/ti/wlcore/wlcore.h
-+++ b/drivers/net/wireless/ti/wlcore/wlcore.h
-@@ -188,6 +188,8 @@ struct wl1271 {
- 
- 	int irq;
- 
-+	int irq_flags;
-+
- 	spinlock_t wl_lock;
- 
- 	enum wlcore_state state;
-@@ -395,9 +397,6 @@ struct wl1271 {
- 	/* Quirks of specific hardware revisions */
- 	unsigned int quirks;
- 
--	/* Platform limitations */
--	unsigned int platform_quirks;
--
- 	/* number of currently active RX BA sessions */
- 	int ba_rx_session_count;
- 
diff --git a/package/mac80211/patches/902-wlcore-remove-pwr_in_suspend-from-platform-data.patch b/package/mac80211/patches/902-wlcore-remove-pwr_in_suspend-from-platform-data.patch
deleted file mode 100644
index 6394377..0000000
--- a/package/mac80211/patches/902-wlcore-remove-pwr_in_suspend-from-platform-data.patch
+++ /dev/null
@@ -1,48 +0,0 @@
-The pwr_in_suspend flag depends on the MMC settings which can be
-retrieved from the SDIO subsystem, so it doesn't need to be part of
-the platform data structure.  Move it to the platform device data that
-is passed from SDIO to wlcore.
-
-Signed-off-by: Luciano Coelho <coelho@ti.com>
-Reviewed-by: Felipe Balbi <balbi@ti.com>
-
---- a/drivers/net/wireless/ti/wlcore/main.c
-+++ b/drivers/net/wireless/ti/wlcore/main.c
-@@ -6074,7 +6074,6 @@ static void wlcore_nvs_cb(const struct f
- 	struct wl1271 *wl = context;
- 	struct platform_device *pdev = wl->pdev;
- 	struct wlcore_platdev_data *pdev_data = dev_get_platdata(&pdev->dev);
--	struct wl12xx_platform_data *pdata = pdev_data->pdata;
- 
- 	int ret;
- 	irq_handler_t hardirq_fn = NULL;
-@@ -6127,7 +6126,7 @@ static void wlcore_nvs_cb(const struct f
- 	if (!ret) {
- 		wl->irq_wake_enabled = true;
- 		device_init_wakeup(wl->dev, 1);
--		if (pdata->pwr_in_suspend)
-+		if (pdev_data->pwr_in_suspend)
- 			wl->hw->wiphy->wowlan = &wlcore_wowlan_support;
- 	}
- #endif
---- a/drivers/net/wireless/ti/wlcore/sdio.c
-+++ b/drivers/net/wireless/ti/wlcore/sdio.c
-@@ -260,7 +260,7 @@ static int wl1271_probe(struct sdio_func
- 	dev_dbg(glue->dev, "sdio PM caps = 0x%x\n", mmcflags);
- 
- 	if (mmcflags & MMC_PM_KEEP_POWER)
--		pdev_data->pdata->pwr_in_suspend = true;
-+		pdev_data->pwr_in_suspend = true;
- 
- 	sdio_set_drvdata(func, glue);
- 
---- a/drivers/net/wireless/ti/wlcore/wlcore_i.h
-+++ b/drivers/net/wireless/ti/wlcore/wlcore_i.h
-@@ -209,6 +209,7 @@ struct wl1271_if_operations {
- struct wlcore_platdev_data {
- 	struct wl12xx_platform_data *pdata;
- 	struct wl1271_if_operations *if_ops;
-+	bool pwr_in_suspend;
- };
- 
- #define MAX_NUM_KEYS 14
diff --git a/package/mac80211/patches/903-wl12xx-use-frequency-instead-of-enumerations-for-pdata-clocks.patch b/package/mac80211/patches/903-wl12xx-use-frequency-instead-of-enumerations-for-pdata-clocks.patch
deleted file mode 100644
index 4b20932..0000000
--- a/package/mac80211/patches/903-wl12xx-use-frequency-instead-of-enumerations-for-pdata-clocks.patch
+++ /dev/null
@@ -1,131 +0,0 @@
-Instead of defining an enumeration with the FW specific values for the
-different clock rates, use the actual frequency instead.  Also add a
-boolean to specify whether the clock is XTAL or not.
-
-Change all board files to reflect this.
-
-Additionally, this reverts commit 26f45c (ARM: OMAP2+: Legacy support
-for wl12xx when booted with devicetree), since this is not be needed
-anymore, now that DT support for WiLink is implemented.
-
-Cc: Tony Lindgren <tony@atomide.com>
-Cc: Sekhar Nori <nsekhar@ti.com>
-Signed-off-by: Luciano Coelho <coelho@ti.com>
-Reviewed-by: Felipe Balbi <balbi@ti.com>
-
---- a/drivers/net/wireless/ti/wl12xx/main.c
-+++ b/drivers/net/wireless/ti/wl12xx/main.c
-@@ -1711,6 +1711,43 @@ static struct ieee80211_sta_ht_cap wl12x
- 		},
- };
- 
-+static const struct wl12xx_clock wl12xx_refclock_table[] = {
-+	{ 19200000,	false,	WL12XX_REFCLOCK_19	},
-+	{ 26000000,	false,	WL12XX_REFCLOCK_26	},
-+	{ 26000000,	true,	WL12XX_REFCLOCK_26_XTAL	},
-+	{ 38400000,	false,	WL12XX_REFCLOCK_38	},
-+	{ 38400000,	true,	WL12XX_REFCLOCK_38_XTAL	},
-+	{ 52000000,	false,	WL12XX_REFCLOCK_52	},
-+	{ 0,		false,	0 }
-+};
-+
-+static const struct wl12xx_clock wl12xx_tcxoclock_table[] = {
-+	{ 16368000,	true,	WL12XX_TCXOCLOCK_16_368	},
-+	{ 16800000,	true,	WL12XX_TCXOCLOCK_16_8	},
-+	{ 19200000,	true,	WL12XX_TCXOCLOCK_19_2	},
-+	{ 26000000,	true,	WL12XX_TCXOCLOCK_26	},
-+	{ 32736000,	true,	WL12XX_TCXOCLOCK_32_736	},
-+	{ 33600000,	true,	WL12XX_TCXOCLOCK_33_6	},
-+	{ 38400000,	true,	WL12XX_TCXOCLOCK_38_4	},
-+	{ 52000000,	true,	WL12XX_TCXOCLOCK_52	},
-+	{ 0,		false,	0 }
-+};
-+
-+static int wl12xx_get_clock_idx(const struct wl12xx_clock *table,
-+				u32 freq, bool xtal)
-+{
-+	int i = 0;
-+
-+	while(table[i].freq != 0) {
-+		if ((table[i].freq == freq) &&
-+		    (table[i].xtal == xtal))
-+			return table[i].hw_idx;
-+		i++;
-+	};
-+
-+	return -EINVAL;
-+}
-+
- static int wl12xx_setup(struct wl1271 *wl)
- {
- 	struct wl12xx_priv *priv = wl->priv;
-@@ -1732,7 +1769,16 @@ static int wl12xx_setup(struct wl1271 *w
- 	wl12xx_conf_init(wl);
- 
- 	if (!fref_param) {
--		priv->ref_clock = pdata->board_ref_clock;
-+		priv->ref_clock = wl12xx_get_clock_idx(wl12xx_refclock_table,
-+						       pdata->ref_clock_freq,
-+						       pdata->ref_clock_xtal);
-+		if (priv->ref_clock < 0) {
-+			wl1271_error("Invalid ref_clock frequency (%d Hz, %s)",
-+				pdata->ref_clock_freq,
-+				pdata->ref_clock_xtal ? "XTAL" : "not XTAL");
-+
-+			return priv->ref_clock;
-+		}
- 	} else {
- 		if (!strcmp(fref_param, "19.2"))
- 			priv->ref_clock = WL12XX_REFCLOCK_19;
-@@ -1751,7 +1797,15 @@ static int wl12xx_setup(struct wl1271 *w
- 	}
- 
- 	if (!tcxo_param) {
--		priv->tcxo_clock = pdata->board_tcxo_clock;
-+		priv->tcxo_clock = wl12xx_get_clock_idx(wl12xx_tcxoclock_table,
-+							pdata->tcxo_clock_freq,
-+							true);
-+		if (priv->tcxo_clock < 0) {
-+			wl1271_error("Invalid tcxo_clock frequency (%d Hz)",
-+				pdata->tcxo_clock_freq);
-+
-+			return priv->tcxo_clock;
-+		}
- 	} else {
- 		if (!strcmp(tcxo_param, "19.2"))
- 			priv->tcxo_clock = WL12XX_TCXOCLOCK_19_2;
---- a/drivers/net/wireless/ti/wl12xx/wl12xx.h
-+++ b/drivers/net/wireless/ti/wl12xx/wl12xx.h
-@@ -79,4 +79,32 @@ struct wl12xx_priv {
- 	struct wl127x_rx_mem_pool_addr *rx_mem_addr;
- };
- 
-+/* Reference clock values */
-+enum {
-+	WL12XX_REFCLOCK_19	= 0, /* 19.2 MHz */
-+	WL12XX_REFCLOCK_26	= 1, /* 26 MHz */
-+	WL12XX_REFCLOCK_38	= 2, /* 38.4 MHz */
-+	WL12XX_REFCLOCK_52	= 3, /* 52 MHz */
-+	WL12XX_REFCLOCK_38_XTAL = 4, /* 38.4 MHz, XTAL */
-+	WL12XX_REFCLOCK_26_XTAL = 5, /* 26 MHz, XTAL */
-+};
-+
-+/* TCXO clock values */
-+enum {
-+	WL12XX_TCXOCLOCK_19_2	= 0, /* 19.2MHz */
-+	WL12XX_TCXOCLOCK_26	= 1, /* 26 MHz */
-+	WL12XX_TCXOCLOCK_38_4	= 2, /* 38.4MHz */
-+	WL12XX_TCXOCLOCK_52	= 3, /* 52 MHz */
-+	WL12XX_TCXOCLOCK_16_368	= 4, /* 16.368 MHz */
-+	WL12XX_TCXOCLOCK_32_736	= 5, /* 32.736 MHz */
-+	WL12XX_TCXOCLOCK_16_8	= 6, /* 16.8 MHz */
-+	WL12XX_TCXOCLOCK_33_6	= 7, /* 33.6 MHz */
-+};
-+
-+struct wl12xx_clock {
-+	u32	freq;
-+	bool	xtal;
-+	u8	hw_idx;
-+};
-+
- #endif /* __WL12XX_PRIV_H__ */
diff --git a/package/mac80211/patches/904-wlcore-add-initial-device-tree-support-to-the-sdio-module.patch b/package/mac80211/patches/904-wlcore-add-initial-device-tree-support-to-the-sdio-module.patch
deleted file mode 100644
index 9e1d190..0000000
--- a/package/mac80211/patches/904-wlcore-add-initial-device-tree-support-to-the-sdio-module.patch
+++ /dev/null
@@ -1,118 +0,0 @@
-If platform data is not available, try to get the required information
-from the device tree.  Register an OF match table and parse the
-appropriate device tree nodes.
-
-Parse interrupt property only, for now.
-
-Signed-off-by: Luciano Coelho <coelho@ti.com>
-Reviewed-by: Felipe Balbi <balbi@ti.com>
-
---- a/drivers/net/wireless/ti/wlcore/sdio.c
-+++ b/drivers/net/wireless/ti/wlcore/sdio.c
-@@ -30,7 +30,7 @@
- #include <linux/mmc/sdio_ids.h>
- #include <linux/mmc/card.h>
- #include <linux/mmc/host.h>
--#include <linux/gpio.h>
-+#include <linux/of_irq.h>
- #include <linux/wl12xx.h>
- #include <linux/pm_runtime.h>
- #include <linux/printk.h>
-@@ -214,6 +214,43 @@ static struct wl1271_if_operations sdio_
- 	.set_block_size = wl1271_sdio_set_block_size,
- };
- 
-+static struct wl12xx_platform_data *wlcore_get_pdata_from_of(struct device *dev)
-+{
-+	struct wl12xx_platform_data *pdata;
-+	struct device_node *np = dev->of_node;
-+
-+	if (!np) {
-+		np = of_find_matching_node(NULL, dev->driver->of_match_table);
-+		if (!np) {
-+			dev_notice(dev, "device tree node not available\n");
-+			pdata = ERR_PTR(-ENODEV);
-+			goto out;
-+		}
-+	}
-+
-+	pdata = kzalloc(sizeof(*pdata), GFP_KERNEL);
-+	if (!pdata) {
-+		dev_err(dev, "can't allocate platform data\n");
-+		pdata = ERR_PTR(-ENODEV);
-+		goto out;
-+	}
-+
-+	pdata->irq = irq_of_parse_and_map(np, 0);
-+	if (pdata->irq < 0) {
-+		dev_err(dev, "can't get interrupt gpio from the device tree\n");
-+		goto out_free;
-+	}
-+
-+	goto out;
-+
-+out_free:
-+	kfree(pdata);
-+	pdata = ERR_PTR(-ENODEV);
-+
-+out:
-+	return pdata;
-+}
-+
- static int wl1271_probe(struct sdio_func *func,
- 				  const struct sdio_device_id *id)
- {
-@@ -248,11 +285,22 @@ static int wl1271_probe(struct sdio_func
- 	/* Use block mode for transferring over one block size of data */
- 	func->card->quirks |= MMC_QUIRK_BLKSZ_FOR_BYTE_MODE;
- 
-+	/* The pdata allocated here is freed when the device is freed,
-+	 * so we don't need an additional out label to free it in case
-+	 * of error further on.
-+	 */
-+
-+	/* Try to get legacy platform data from the board file */
- 	pdev_data->pdata = wl12xx_get_platform_data();
- 	if (IS_ERR(pdev_data->pdata)) {
--		ret = PTR_ERR(pdev_data->pdata);
--		dev_err(glue->dev, "missing wlan platform data: %d\n", ret);
--		goto out_free_glue;
-+		dev_info(&func->dev,
-+			 "legacy platform data not found, trying device tree\n");
-+
-+		pdev_data->pdata = wlcore_get_pdata_from_of(&func->dev);
-+		if (IS_ERR(pdev_data->pdata)) {
-+			dev_err(&func->dev, "can't get platform data\n");
-+			goto out_free_glue;
-+		}
- 	}
- 
- 	/* if sdio can keep power while host is suspended, enable wow */
-@@ -386,16 +434,25 @@ static const struct dev_pm_ops wl1271_sd
- };
- #endif
- 
-+static const struct of_device_id wlcore_sdio_of_match_table[] = {
-+	{ .compatible = "ti,wilink6" },
-+	{ .compatible = "ti,wilink7" },
-+	{ .compatible = "ti,wilink8" },
-+	{ }
-+};
-+MODULE_DEVICE_TABLE(of, wlcore_sdio_of_match_table);
-+
- static struct sdio_driver wl1271_sdio_driver = {
- 	.name		= "wl1271_sdio",
- 	.id_table	= wl1271_devices,
- 	.probe		= wl1271_probe,
- 	.remove		= wl1271_remove,
--#ifdef CONFIG_PM
- 	.drv = {
-+#ifdef CONFIG_PM
- 		.pm = &wl1271_sdio_pm_ops,
--	},
- #endif
-+		.of_match_table = of_match_ptr(wlcore_sdio_of_match_table),
-+	},
- };
- 
- static int __init wl1271_init(void)
diff --git a/package/mac80211/patches/905-wlcore-sdio-add-wilink-clock-providers.patch b/package/mac80211/patches/905-wlcore-sdio-add-wilink-clock-providers.patch
deleted file mode 100644
index be1f9ad..0000000
--- a/package/mac80211/patches/905-wlcore-sdio-add-wilink-clock-providers.patch
+++ /dev/null
@@ -1,50 +0,0 @@
-Add refclock and tcxoclock as clock providers in WiLink.  These clocks
-are not accesible outside the WiLink module, but they are registered
-in the clock framework anyway.  Only the WiLink chip consumes these
-clocks.
-
-In theory, the WiLink chip could be connected to external clocks
-instead of using these internal clocks, so make the clock consumer
-code generic enough.  If external clocks are used, then the internal
-clock device tree nodes are not necessary, but the external ones must
-be specified.
-
-Signed-off-by: Luciano Coelho <coelho@ti.com>
-Reviewed-by: Felipe Balbi <balbi@ti.com>
-
---- a/drivers/net/wireless/ti/wlcore/sdio.c
-+++ b/drivers/net/wireless/ti/wlcore/sdio.c
-@@ -34,6 +34,7 @@
- #include <linux/wl12xx.h>
- #include <linux/pm_runtime.h>
- #include <linux/printk.h>
-+#include <linux/clk-provider.h>
- 
- #include "wlcore.h"
- #include "wl12xx_80211.h"
-@@ -214,10 +215,15 @@ static struct wl1271_if_operations sdio_
- 	.set_block_size = wl1271_sdio_set_block_size,
- };
- 
-+static const struct of_device_id wlcore_sdio_of_clk_match_table[] = {
-+	{ .compatible = "ti,wilink-clock" },
-+};
-+
- static struct wl12xx_platform_data *wlcore_get_pdata_from_of(struct device *dev)
- {
- 	struct wl12xx_platform_data *pdata;
- 	struct device_node *np = dev->of_node;
-+	struct device_node *clock_node;
- 
- 	if (!np) {
- 		np = of_find_matching_node(NULL, dev->driver->of_match_table);
-@@ -241,6 +247,9 @@ static struct wl12xx_platform_data *wlco
- 		goto out_free;
- 	}
- 
-+	for_each_matching_node(clock_node, wlcore_sdio_of_clk_match_table)
-+		of_fixed_clk_setup(clock_node);
-+
- 	goto out;
- 
- out_free:
diff --git a/package/mac80211/patches/906-wlcore-sdio-get-clocks-from-device-tree.patch b/package/mac80211/patches/906-wlcore-sdio-get-clocks-from-device-tree.patch
deleted file mode 100644
index 09ff4af..0000000
--- a/package/mac80211/patches/906-wlcore-sdio-get-clocks-from-device-tree.patch
+++ /dev/null
@@ -1,90 +0,0 @@
-Read the clock nodes from the device tree and use them to set the
-frequency for the refclock and the tcxo clock.
-
-Also, call sdio_set_drvdata() earlier, so the glue is already set in
-the driver data when we call wlcore_get_pdata_from_of() and we don't
-need to pass it as a parameter.
-
-Signed-off-by: Luciano Coelho <coelho@ti.com>
-Reviewed-by: Felipe Balbi <balbi@ti.com>
-
---- a/drivers/net/wireless/ti/wlcore/sdio.c
-+++ b/drivers/net/wireless/ti/wlcore/sdio.c
-@@ -53,6 +53,7 @@ static bool dump = false;
- struct wl12xx_sdio_glue {
- 	struct device *dev;
- 	struct platform_device *core;
-+	struct clk *refclock, *tcxoclock;
- };
- 
- static const struct sdio_device_id wl1271_devices[] = {
-@@ -224,6 +225,7 @@ static struct wl12xx_platform_data *wlco
- 	struct wl12xx_platform_data *pdata;
- 	struct device_node *np = dev->of_node;
- 	struct device_node *clock_node;
-+	struct wl12xx_sdio_glue *glue = sdio_get_drvdata(dev_to_sdio_func(dev));
- 
- 	if (!np) {
- 		np = of_find_matching_node(NULL, dev->driver->of_match_table);
-@@ -250,6 +252,26 @@ static struct wl12xx_platform_data *wlco
- 	for_each_matching_node(clock_node, wlcore_sdio_of_clk_match_table)
- 		of_fixed_clk_setup(clock_node);
- 
-+	/* TODO: make sure we have this when needed (ie. for WL6 and WL7) */
-+	glue->refclock = of_clk_get_by_name(np, "refclock");
-+	if (IS_ERR(glue->refclock)) {
-+		dev_err(dev, "couldn't find refclock on the device tree\n");
-+		glue->refclock = NULL;
-+	} else {
-+		clk_prepare_enable(glue->refclock);
-+		pdata->ref_clock_freq = clk_get_rate(glue->refclock);
-+	}
-+
-+	/* TODO: make sure we have this when needed (ie. for WL7) */
-+	glue->tcxoclock = of_clk_get_by_name(np, "tcxoclock");
-+	if (IS_ERR(glue->tcxoclock)) {
-+		dev_err(dev, "couldn't find tcxoclock on the device tree\n");
-+		glue->tcxoclock = NULL;
-+	} else {
-+		clk_prepare_enable(glue->tcxoclock);
-+		pdata->ref_clock_freq = clk_get_rate(glue->tcxoclock);
-+	}
-+
- 	goto out;
- 
- out_free:
-@@ -294,6 +316,8 @@ static int wl1271_probe(struct sdio_func
- 	/* Use block mode for transferring over one block size of data */
- 	func->card->quirks |= MMC_QUIRK_BLKSZ_FOR_BYTE_MODE;
- 
-+	sdio_set_drvdata(func, glue);
-+
- 	/* The pdata allocated here is freed when the device is freed,
- 	 * so we don't need an additional out label to free it in case
- 	 * of error further on.
-@@ -319,8 +343,6 @@ static int wl1271_probe(struct sdio_func
- 	if (mmcflags & MMC_PM_KEEP_POWER)
- 		pdev_data->pwr_in_suspend = true;
- 
--	sdio_set_drvdata(func, glue);
--
- 	/* Tell PM core that we don't need the card to be powered now */
- 	pm_runtime_put_noidle(&func->dev);
- 
-@@ -387,6 +409,16 @@ static void wl1271_remove(struct sdio_fu
- {
- 	struct wl12xx_sdio_glue *glue = sdio_get_drvdata(func);
- 
-+	if (glue->refclock) {
-+		clk_disable_unprepare(glue->refclock);
-+		clk_put(glue->refclock);
-+	}
-+
-+	if (glue->tcxoclock) {
-+		clk_disable_unprepare(glue->tcxoclock);
-+		clk_put(glue->tcxoclock);
-+	}
-+
- 	/* Undo decrement done above in wl1271_probe */
- 	pm_runtime_get_noresume(&func->dev);
- 
diff --git a/package/mac80211/patches/907-wlcore-wl12xx-check-if-we-got-correct-clock-data-from-DT.patch b/package/mac80211/patches/907-wlcore-wl12xx-check-if-we-got-correct-clock-data-from-DT.patch
deleted file mode 100644
index 6b09177..0000000
--- a/package/mac80211/patches/907-wlcore-wl12xx-check-if-we-got-correct-clock-data-from-DT.patch
+++ /dev/null
@@ -1,96 +0,0 @@
-The fref and the tcxo clocks settings are optional in some platforms.
-WiLink8 doesn't need either, so we don't check the values.  WiLink 6
-only needs the fref clock, so we check that it is valid or return with
-an error.  WiLink7 needs both clocks, if either is not available we
-return with an error.
-
-Signed-off-by: Luciano Coelho <coelho@ti.com>
-Reviewed-by: Felipe Balbi <balbi@ti.com>
-
---- a/drivers/net/wireless/ti/wl12xx/main.c
-+++ b/drivers/net/wireless/ti/wl12xx/main.c
-@@ -930,6 +930,11 @@ static int wl128x_boot_clk(struct wl1271
- 	u16 sys_clk_cfg;
- 	int ret;
- 
-+	if ((priv->ref_clock < 0) || (priv->tcxo_clock < 0)) {
-+		wl1271_error("Missing fref and/or tcxo clock settings\n");
-+		return -EINVAL;
-+	}
-+
- 	/* For XTAL-only modes, FREF will be used after switching from TCXO */
- 	if (priv->ref_clock == WL12XX_REFCLOCK_26_XTAL ||
- 	    priv->ref_clock == WL12XX_REFCLOCK_38_XTAL) {
-@@ -979,6 +984,11 @@ static int wl127x_boot_clk(struct wl1271
- 	u32 clk;
- 	int ret;
- 
-+	if (priv->ref_clock < 0) {
-+		wl1271_error("Missing fref clock settings\n");
-+		return -EINVAL;
-+	}
-+
- 	if (WL127X_PG_GET_MAJOR(wl->hw_pg_ver) < 3)
- 		wl->quirks |= WLCORE_QUIRK_END_OF_TRANSACTION;
- 
-@@ -1768,7 +1778,7 @@ static int wl12xx_setup(struct wl1271 *w
- 	wlcore_set_ht_cap(wl, IEEE80211_BAND_5GHZ, &wl12xx_ht_cap);
- 	wl12xx_conf_init(wl);
- 
--	if (!fref_param) {
-+	if (!fref_param && (pdata->ref_clock_freq > 0)) {
- 		priv->ref_clock = wl12xx_get_clock_idx(wl12xx_refclock_table,
- 						       pdata->ref_clock_freq,
- 						       pdata->ref_clock_xtal);
-@@ -1779,6 +1789,8 @@ static int wl12xx_setup(struct wl1271 *w
- 
- 			return priv->ref_clock;
- 		}
-+	} else if (!fref_param) {
-+		priv->ref_clock = -EINVAL;
- 	} else {
- 		if (!strcmp(fref_param, "19.2"))
- 			priv->ref_clock = WL12XX_REFCLOCK_19;
-@@ -1796,7 +1808,7 @@ static int wl12xx_setup(struct wl1271 *w
- 			wl1271_error("Invalid fref parameter %s", fref_param);
- 	}
- 
--	if (!tcxo_param) {
-+	if (!fref_param && (pdata->tcxo_clock_freq > 0)) {
- 		priv->tcxo_clock = wl12xx_get_clock_idx(wl12xx_tcxoclock_table,
- 							pdata->tcxo_clock_freq,
- 							true);
-@@ -1806,7 +1818,9 @@ static int wl12xx_setup(struct wl1271 *w
- 
- 			return priv->tcxo_clock;
- 		}
--	} else {
-+	} else if (!fref_param) {
-+		priv->tcxo_clock = -EINVAL;
-+	}else {
- 		if (!strcmp(tcxo_param, "19.2"))
- 			priv->tcxo_clock = WL12XX_TCXOCLOCK_19_2;
- 		else if (!strcmp(tcxo_param, "26"))
---- a/drivers/net/wireless/ti/wlcore/sdio.c
-+++ b/drivers/net/wireless/ti/wlcore/sdio.c
-@@ -252,20 +252,16 @@ static struct wl12xx_platform_data *wlco
- 	for_each_matching_node(clock_node, wlcore_sdio_of_clk_match_table)
- 		of_fixed_clk_setup(clock_node);
- 
--	/* TODO: make sure we have this when needed (ie. for WL6 and WL7) */
- 	glue->refclock = of_clk_get_by_name(np, "refclock");
- 	if (IS_ERR(glue->refclock)) {
--		dev_err(dev, "couldn't find refclock on the device tree\n");
- 		glue->refclock = NULL;
- 	} else {
- 		clk_prepare_enable(glue->refclock);
- 		pdata->ref_clock_freq = clk_get_rate(glue->refclock);
- 	}
- 
--	/* TODO: make sure we have this when needed (ie. for WL7) */
- 	glue->tcxoclock = of_clk_get_by_name(np, "tcxoclock");
- 	if (IS_ERR(glue->tcxoclock)) {
--		dev_err(dev, "couldn't find tcxoclock on the device tree\n");
- 		glue->tcxoclock = NULL;
- 	} else {
- 		clk_prepare_enable(glue->tcxoclock);
diff --git a/package/mac80211/patches/a00-ath9k_platform_h_backup.patch b/package/mac80211/patches/a00-ath9k_platform_h_backup.patch
deleted file mode 100644
index cff3dae..0000000
--- a/package/mac80211/patches/a00-ath9k_platform_h_backup.patch
+++ /dev/null
@@ -1,22 +0,0 @@
---- a/drivers/net/wireless/ath/ath9k/init.c
-+++ b/drivers/net/wireless/ath/ath9k/init.c
-@@ -678,8 +678,7 @@ static int ath9k_init_soc_platform(struc
- 			return ret;
- 	}
- 
--	if (pdata->tx_gain_buffalo)
--		ah->config.tx_gain_buffalo = true;
-+	ah->config.tx_gain_buffalo = true;
- 
- 	return ret;
- }
---- a/include/linux/ath9k_platform.h
-+++ b/include/linux/ath9k_platform.h
-@@ -33,7 +33,6 @@ struct ath9k_platform_data {
- 
- 	bool endian_check;
- 	bool is_clk_25mhz;
--	bool tx_gain_buffalo;
- 	bool disable_2ghz;
- 	bool disable_5ghz;
- 
